// Code generated from StarRocks.g4 by ANTLR 4.13.2. DO NOT EDIT.

package parser // StarRocks
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type StarRocksParser struct {
	*antlr.BaseParser
}

var StarRocksParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func starrocksParserInit() {
	staticData := &StarRocksParserStaticData
	staticData.LiteralNames = []string{
		"", "'.'", "'('", "','", "')'", "'=>'", "'['", "']'", "':'", "'{'",
		"'}'", "'ACCESS'", "'ACTIVE'", "'ADD'", "'ADMIN'", "'ADVISOR'", "'AFTER'",
		"'AGGREGATE'", "'ALL'", "'ALTER'", "'ANALYZE'", "'AND'", "'ANTI'", "'APPLY'",
		"'ARRAY'", "'ARRAY_AGG'", "'ARRAY_AGG_DISTINCT'", "'AS'", "'ASC'", "'ASYNC'",
		"'AUTHORS'", "'AUTHENTICATION'", "'AUTOMATED'", "'AUTO_INCREMENT'",
		"'AVG'", "'BACKEND'", "'BACKENDS'", "'BACKUP'", "'BASE'", "'BASELINE'",
		"'BEGIN'", "'BETWEEN'", "'BIGINT'", "'BINARY'", "'BITMAP'", "'BITMAP_UNION'",
		"'BLACKHOLE'", "'BLACKLIST'", "'BODY'", "'BOOLEAN'", "'BOTH'", "'BRANCH'",
		"'BROKER'", "'BUCKETS'", "'BUILTIN'", "'BY'", "'CACHE'", "'CANCEL'",
		"'CASE'", "'CAST'", "'CATALOG'", "'CATALOGS'", "'CEIL'", "'CHAIN'",
		"'CHAR'", "'CHARACTER'", "'CHARSET'", "'CHECK'", "'CLEAN'", "'CLEAR'",
		"'CLUSTER'", "'CLUSTERS'", "'COLLATE'", "'COLLATION'", "'COLUMN'", "'COLUMNS'",
		"'COMMENT'", "'COMMIT'", "'COMMITTED'", "'COMPACT'", "'COMPACTION'",
		"'COMPUTE'", "'CONFIG'", "'CONNECTION'", "'CONSISTENT'", "'CONVERT'",
		"'COSTS'", "'COUNT'", "'CREATE'", "'CROSS'", "'CUBE'", "'CUME_DIST'",
		"'CUMULATIVE'", "'CURRENT'", "'CURRENT_DATE'", "'CURRENT_GROUP'", "'CURRENT_ROLE'",
		"'CURRENT_TIME'", "'CURRENT_TIMESTAMP'", "'CURRENT_USER'", "'DATA'",
		"'DATACACHE'", "'DATABASE'", "'DATABASES'", "'DATE'", "'DATETIME'",
		"'DAY'", "'DAYS'", "'DEALLOCATE'", "'DECIMAL'", "'DECIMALV2'", "'DECIMAL32'",
		"'DECIMAL64'", "'DECIMAL128'", "'DECOMMISSION'", "'DEFAULT'", "'DELETE'",
		"'DENSE_RANK'", "'DEFERRED'", "'DIALECT'", "'DICTIONARY'", "'DICTIONARY_GET'",
		"'NTILE'", "'DESC'", "'DESCRIBE'", "'DISABLE'", "'DISTINCT'", "'DISTRIBUTED'",
		"'DISTRIBUTION'", "'DOUBLE'", "'DROP'", "'DUAL'", "'DUPLICATE'", "'DYNAMIC'",
		"'ELSE'", "'ENABLE'", "'ENCLOSE'", "'END'", "'ENGINE'", "'ENGINES'",
		"'ERRORS'", "'ESCAPE'", "'EVENTS'", "'EXCEPT'", "'EXECUTE'", "'EXISTS'",
		"'EXPLAIN'", "'EXPORT'", "'EXTERNAL'", "'EXTRACT'", "'EVERY'", "'FAILPOINT'",
		"'FAILPOINTS'", "'FALSE'", "'FIELDS'", "'FILE'", "'FILES'", "'FILTER'",
		"'FIRST'", "'FIRST_VALUE'", "'FLOAT'", "'FLOOR'", "'FN'", "'FOLLOWING'",
		"'FOLLOWER'", "'FOR'", "'FORCE'", "'FORMAT'", "'FREE'", "'FROM'", "'FRONTEND'",
		"'FRONTENDS'", "'FULL'", "'FUNCTION'", "'FUNCTIONS'", "'GLOBAL'", "'GRANT'",
		"'GRANTS'", "'GROUP'", "'GROUPS'", "'GROUPING'", "'GROUPING_ID'", "'GROUP_CONCAT'",
		"'HASH'", "'HAVING'", "'HELP'", "'HISTOGRAM'", "'HLL'", "'HLL_UNION'",
		"'HOST'", "'HOUR'", "'HOURS'", "'HUB'", "'IDENTIFIED'", "'IF'", "'IMPERSONATE'",
		"'IMMEDIATE'", "'IGNORE'", "'IMAGE'", "'IN'", "'INACTIVE'", "'INCREMENTAL'",
		"'INDEX'", "'INDEXES'", "'INFILE'", "'INNER'", "'INSTALL'", "'INSERT'",
		"'INT'", "'INTEGER'", "'INTEGRATION'", "'INTEGRATIONS'", "'INTERMEDIATE'",
		"'INTERSECT'", "'INTERVAL'", "'INTO'", "'INVOKER'", "'GIN'", "'OVERWRITE'",
		"'IS'", "'ISOLATION'", "'JOB'", "'JOIN'", "'JSON'", "'KEY'", "'KEYS'",
		"'KILL'", "'LABEL'", "'LAG'", "'LARGEINT'", "'LAST'", "'LAST_VALUE'",
		"'LATERAL'", "'LEAD'", "'LEFT'", "'LESS'", "'LEVEL'", "'LIKE'", "'LIMIT'",
		"'LIST'", "'LOAD'", "'LOCAL'", "'LOCALTIME'", "'LOCALTIMESTAMP'", "'LOCATION'",
		"'LOCATIONS'", "'LOGS'", "'LOGICAL'", "'MANUAL'", "'MAP'", "'MAPPING'",
		"'MAPPINGS'", "'MASKING'", "'MATCH'", "'MATERIALIZED'", "'MAX'", "'MAXVALUE'",
		"'MERGE'", "'MICROSECOND'", "'MILLISECOND'", "'MIN'", "'MINUTE'", "'MINUTES'",
		"'MINUS'", "'META'", "'MOD'", "'MODE'", "'MODIFY'", "'MONTH'", "'MULTIPLE'",
		"'NAME'", "'NAMES'", "'NEGATIVE'", "'NGRAMBF'", "'NO'", "'NODE'", "'NODES'",
		"'NONE'", "'NOT'", "'NULL'", "'NULLS'", "'NUMBER'", "'NUMERIC'", "'OBSERVER'",
		"'OF'", "'OFF'", "'OFFSET'", "'ON'", "'ONLY'", "'OPEN'", "'OPERATE'",
		"'OPTIMIZE'", "'OPTIMIZER'", "'OPTION'", "'OR'", "'ORDER'", "'OUTER'",
		"'OUTFILE'", "'OVER'", "'?'", "'PARTITION'", "'PARTITIONS'", "'PASSWORD'",
		"'PATH'", "'PAUSE'", "'PENDING'", "'PERCENT_RANK'", "'PERCENTILE'",
		"'PERCENTILE_UNION'", "'PLAN'", "'PLUGIN'", "'PLUGINS'", "'PIPE'", "'PIPES'",
		"'PIVOT'", "'POLICY'", "'POLICIES'", "'PRECEDING'", "'PREDICATE'", "'PREPARE'",
		"'PRIMARY'", "'PRIORITY'", "'PRIVILEGES'", "'PROBABILITY'", "'PROC'",
		"'PROCEDURE'", "'PROCESSLIST'", "'PROFILE'", "'PROFILELIST'", "'PROPERTIES'",
		"'PROPERTY'", "'PROVIDER'", "'PROVIDERS'", "'QUALIFY'", "'QUARTER'",
		"'QUERY'", "'QUERIES'", "'QUEUE'", "'QUOTA'", "'RANDOM'", "'RANGE'",
		"'RANK'", "'READ'", "'REASON'", "'RECOVER'", "'REFRESH'", "'REWRITE'",
		"'REGEXP'", "'RELEASE'", "'REMOVE'", "'RENAME'", "'REPAIR'", "'REPEATABLE'",
		"'REPLACE'", "'REPLACE_IF_NOT_NULL'", "'REPLICA'", "'REPOSITORY'", "'REPOSITORIES'",
		"'RESOURCE'", "'RESOURCES'", "'RESTORE'", "'RESUME'", "'RETAIN'", "'RETENTION'",
		"'RETURNS'", "'RETRY'", "'REVOKE'", "'REVERT'", "'RIGHT'", "'RLIKE'",
		"'ROLE'", "'ROLES'", "'ROLLBACK'", "'ROLLUP'", "'ROUTINE'", "'ROW'",
		"'ROWS'", "'ROW_NUMBER'", "'RULE'", "'RULES'", "'RUNNING'", "'SAMPLE'",
		"'SCHEDULE'", "'SCHEDULER'", "'SCHEMA'", "'SCHEMAS'", "'SECOND'", "'SECURITY'",
		"'SELECT'", "'SEMI'", "'SEPARATOR'", "'SERIALIZABLE'", "'SESSION'",
		"'SET'", "'SETS'", "'SET_VAR'", "'SIGNED'", "'SKIP_HEADER'", "'SHOW'",
		"'SMALLINT'", "'SNAPSHOT'", "'SNAPSHOTS'", "'SQLBLACKLIST'", "'STARROCKS'",
		"'START'", "'STATS'", "'STATUS'", "'STOP'", "'STORAGE'", "'STREAM'",
		"'STRING'", "'TEXT'", "'SUBMIT'", "'SUM'", "'SUSPEND'", "'SYNC'", "'SYSTEM'",
		"'SYSTEM_TIME'", "'SWAP'", "'STRUCT'", "'TABLE'", "'TABLES'", "'TABLET'",
		"'TABLETS'", "'TAG'", "'TASK'", "'TEMPORARY'", "'TERMINATED'", "'THAN'",
		"'THEN'", "'TIME'", "'TIMES'", "'TIMESTAMP'", "'TIMESTAMPADD'", "'TIMESTAMPDIFF'",
		"'TINYINT'", "'TRANSACTION'", "'TRANSLATE'", "'TO'", "'TRACE'", "'TRIGGERS'",
		"'TRIM_SPACE'", "'TRUE'", "'TRUNCATE'", "'TYPE'", "'TYPES'", "'UNBOUNDED'",
		"'UNCOMMITTED'", "'UNION'", "'UNIQUE'", "'UNINSTALL'", "'UNSET'", "'UNSIGNED'",
		"'UPDATE'", "'USAGE'", "'USE'", "'USER'", "'USERS'", "'USING'", "'VALUE'",
		"'VALUES'", "'VARBINARY'", "'VARCHAR'", "'VARIABLES'", "'VECTOR'", "'VERBOSE'",
		"'VERSION'", "'VIEW'", "'VIEWS'", "'VOLUME'", "'VOLUMES'", "'WAREHOUSE'",
		"'WAREHOUSES'", "'WARNINGS'", "'WEEK'", "'WHEN'", "'WHERE'", "'WHITELIST'",
		"'WITH'", "'WORK'", "'WRITE'", "'YEAR'", "'LOCK'", "'UNLOCK'", "'LOW_PRIORITY'",
		"'DISK'", "'BEFORE'", "'$$'", "'FIELD'", "'PERSISTENT'", "'='", "",
		"'<'", "'<='", "'>'", "'>='", "'<=>'", "'[*]'", "'+'", "'-'", "'*'",
		"'/'", "'%'", "'||'", "'&&'", "'!'", "'DIV'", "'&'", "'|'", "'^'", "'~'",
		"'BITSHIFTLEFT'", "'BITSHIFTRIGHT'", "'BITSHIFTRIGHTLOGICAL'", "'->'",
		"'@'", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "';'",
		"'...'",
	}
	staticData.SymbolicNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "ACCESS", "ACTIVE", "ADD",
		"ADMIN", "ADVISOR", "AFTER", "AGGREGATE", "ALL", "ALTER", "ANALYZE",
		"AND", "ANTI", "APPLY", "ARRAY", "ARRAY_AGG", "ARRAY_AGG_DISTINCT",
		"AS", "ASC", "ASYNC", "AUTHORS", "AUTHENTICATION", "AUTOMATED", "AUTO_INCREMENT",
		"AVG", "BACKEND", "BACKENDS", "BACKUP", "BASE", "BASELINE", "BEGIN",
		"BETWEEN", "BIGINT", "BINARY", "BITMAP", "BITMAP_UNION", "BLACKHOLE",
		"BLACKLIST", "BODY", "BOOLEAN", "BOTH", "BRANCH", "BROKER", "BUCKETS",
		"BUILTIN", "BY", "CACHE", "CANCEL", "CASE", "CAST", "CATALOG", "CATALOGS",
		"CEIL", "CHAIN", "CHAR", "CHARACTER", "CHARSET", "CHECK", "CLEAN", "CLEAR",
		"CLUSTER", "CLUSTERS", "COLLATE", "COLLATION", "COLUMN", "COLUMNS",
		"COMMENT", "COMMIT", "COMMITTED", "COMPACT", "COMPACTION", "COMPUTE",
		"CONFIG", "CONNECTION", "CONSISTENT", "CONVERT", "COSTS", "COUNT", "CREATE",
		"CROSS", "CUBE", "CUME_DIST", "CUMULATIVE", "CURRENT", "CURRENT_DATE",
		"CURRENT_GROUP", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP",
		"CURRENT_USER", "DATA", "DATACACHE", "DATABASE", "DATABASES", "DATE",
		"DATETIME", "DAY", "DAYS", "DEALLOCATE", "DECIMAL", "DECIMALV2", "DECIMAL32",
		"DECIMAL64", "DECIMAL128", "DECOMMISSION", "DEFAULT", "DELETE", "DENSE_RANK",
		"DEFERRED", "DIALECT", "DICTIONARY", "DICTIONARY_GET", "NTILE", "DESC",
		"DESCRIBE", "DISABLE", "DISTINCT", "DISTRIBUTED", "DISTRIBUTION", "DOUBLE",
		"DROP", "DUAL", "DUPLICATE", "DYNAMIC", "ELSE", "ENABLE", "ENCLOSE",
		"END", "ENGINE", "ENGINES", "ERRORS", "ESCAPE", "EVENTS", "EXCEPT",
		"EXECUTE", "EXISTS", "EXPLAIN", "EXPORT", "EXTERNAL", "EXTRACT", "EVERY",
		"FAILPOINT", "FAILPOINTS", "FALSE", "FIELDS", "FILE", "FILES", "FILTER",
		"FIRST", "FIRST_VALUE", "FLOAT", "FLOOR", "FN", "FOLLOWING", "FOLLOWER",
		"FOR", "FORCE", "FORMAT", "FREE", "FROM", "FRONTEND", "FRONTENDS", "FULL",
		"FUNCTION", "FUNCTIONS", "GLOBAL", "GRANT", "GRANTS", "GROUP", "GROUPS",
		"GROUPING", "GROUPING_ID", "GROUP_CONCAT", "HASH", "HAVING", "HELP",
		"HISTOGRAM", "HLL", "HLL_UNION", "HOST", "HOUR", "HOURS", "HUB", "IDENTIFIED",
		"IF", "IMPERSONATE", "IMMEDIATE", "IGNORE", "IMAGE", "IN", "INACTIVE",
		"INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INNER", "INSTALL", "INSERT",
		"INT", "INTEGER", "INTEGRATION", "INTEGRATIONS", "INTERMEDIATE", "INTERSECT",
		"INTERVAL", "INTO", "INVOKER", "GIN", "OVERWRITE", "IS", "ISOLATION",
		"JOB", "JOIN", "JSON", "KEY", "KEYS", "KILL", "LABEL", "LAG", "LARGEINT",
		"LAST", "LAST_VALUE", "LATERAL", "LEAD", "LEFT", "LESS", "LEVEL", "LIKE",
		"LIMIT", "LIST", "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP", "LOCATION",
		"LOCATIONS", "LOGS", "LOGICAL", "MANUAL", "MAP", "MAPPING", "MAPPINGS",
		"MASKING", "MATCH", "MATERIALIZED", "MAX", "MAXVALUE", "MERGE", "MICROSECOND",
		"MILLISECOND", "MIN", "MINUTE", "MINUTES", "MINUS", "META", "MOD", "MODE",
		"MODIFY", "MONTH", "MULTIPLE", "NAME", "NAMES", "NEGATIVE", "NGRAMBF",
		"NO", "NODE", "NODES", "NONE", "NOT", "NULL", "NULLS", "NUMBER", "NUMERIC",
		"OBSERVER", "OF", "OFF", "OFFSET", "ON", "ONLY", "OPEN", "OPERATE",
		"OPTIMIZE", "OPTIMIZER", "OPTION", "OR", "ORDER", "OUTER", "OUTFILE",
		"OVER", "PARAMETER", "PARTITION", "PARTITIONS", "PASSWORD", "PATH",
		"PAUSE", "PENDING", "PERCENT_RANK", "PERCENTILE", "PERCENTILE_UNION",
		"PLAN", "PLUGIN", "PLUGINS", "PIPE", "PIPES", "PIVOT", "POLICY", "POLICIES",
		"PRECEDING", "PREDICATE", "PREPARE", "PRIMARY", "PRIORITY", "PRIVILEGES",
		"PROBABILITY", "PROC", "PROCEDURE", "PROCESSLIST", "PROFILE", "PROFILELIST",
		"PROPERTIES", "PROPERTY", "PROVIDER", "PROVIDERS", "QUALIFY", "QUARTER",
		"QUERY", "QUERIES", "QUEUE", "QUOTA", "RANDOM", "RANGE", "RANK", "READ",
		"REASON", "RECOVER", "REFRESH", "REWRITE", "REGEXP", "RELEASE", "REMOVE",
		"RENAME", "REPAIR", "REPEATABLE", "REPLACE", "REPLACE_IF_NOT_NULL",
		"REPLICA", "REPOSITORY", "REPOSITORIES", "RESOURCE", "RESOURCES", "RESTORE",
		"RESUME", "RETAIN", "RETENTION", "RETURNS", "RETRY", "REVOKE", "REVERT",
		"RIGHT", "RLIKE", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROUTINE",
		"ROW", "ROWS", "ROW_NUMBER", "RULE", "RULES", "RUNNING", "SAMPLE", "SCHEDULE",
		"SCHEDULER", "SCHEMA", "SCHEMAS", "SECOND", "SECURITY", "SELECT", "SEMI",
		"SEPARATOR", "SERIALIZABLE", "SESSION", "SET", "SETS", "SET_VAR", "SIGNED",
		"SKIP_HEADER", "SHOW", "SMALLINT", "SNAPSHOT", "SNAPSHOTS", "SQLBLACKLIST",
		"STARROCKS", "START", "STATS", "STATUS", "STOP", "STORAGE", "STREAM",
		"STRING", "TEXT", "SUBMIT", "SUM", "SUSPEND", "SYNC", "SYSTEM", "SYSTEM_TIME",
		"SWAP", "STRUCT", "TABLE", "TABLES", "TABLET", "TABLETS", "TAG", "TASK",
		"TEMPORARY", "TERMINATED", "THAN", "THEN", "TIME", "TIMES", "TIMESTAMP",
		"TIMESTAMPADD", "TIMESTAMPDIFF", "TINYINT", "TRANSACTION", "TRANSLATE",
		"TO", "TRACE", "TRIGGERS", "TRIM_SPACE", "TRUE", "TRUNCATE", "TYPE",
		"TYPES", "UNBOUNDED", "UNCOMMITTED", "UNION", "UNIQUE", "UNINSTALL",
		"UNSET", "UNSIGNED", "UPDATE", "USAGE", "USE", "USER", "USERS", "USING",
		"VALUE", "VALUES", "VARBINARY", "VARCHAR", "VARIABLES", "VECTOR", "VERBOSE",
		"VERSION", "VIEW", "VIEWS", "VOLUME", "VOLUMES", "WAREHOUSE", "WAREHOUSES",
		"WARNINGS", "WEEK", "WHEN", "WHERE", "WHITELIST", "WITH", "WORK", "WRITE",
		"YEAR", "LOCK", "UNLOCK", "LOW_PRIORITY", "DISK", "BEFORE", "DOUBLE_DOLLAR",
		"FIELD", "PERSISTENT", "EQ", "NEQ", "LT", "LTE", "GT", "GTE", "EQ_FOR_NULL",
		"ARRAY_ELEMENT", "PLUS_SYMBOL", "MINUS_SYMBOL", "ASTERISK_SYMBOL", "SLASH_SYMBOL",
		"PERCENT_SYMBOL", "LOGICAL_OR", "LOGICAL_AND", "LOGICAL_NOT", "INT_DIV",
		"BITAND", "BITOR", "BITXOR", "BITNOT", "BIT_SHIFT_LEFT", "BIT_SHIFT_RIGHT",
		"BIT_SHIFT_RIGHT_LOGICAL", "ARROW", "AT", "INTEGER_VALUE", "DECIMAL_VALUE",
		"DOUBLE_VALUE", "SINGLE_QUOTED_TEXT", "DOUBLE_QUOTED_TEXT", "BINARY_SINGLE_QUOTED_TEXT",
		"BINARY_DOUBLE_QUOTED_TEXT", "LETTER_IDENTIFIER", "DIGIT_IDENTIFIER",
		"BACKQUOTED_IDENTIFIER", "DOT_IDENTIFIER", "SIMPLE_COMMENT", "BRACKETED_COMMENT",
		"OPTIMIZER_HINT", "SEMICOLON", "DOTDOTDOT", "WS", "ATTACHMENT", "CONCAT",
	}
	staticData.RuleNames = []string{
		"sqlStatements", "singleStatement", "emptyStatement", "statement", "useDatabaseStatement",
		"useCatalogStatement", "setCatalogStatement", "showDatabasesStatement",
		"alterDbQuotaStatement", "createDbStatement", "dropDbStatement", "showCreateDbStatement",
		"alterDatabaseRenameStatement", "recoverDbStmt", "showDataStmt", "showDataDistributionStmt",
		"createTableStatement", "columnDesc", "charsetName", "defaultDesc",
		"generatedColumnDesc", "indexDesc", "engineDesc", "charsetDesc", "collateDesc",
		"keyDesc", "orderByDesc", "columnNullable", "typeWithNullable", "aggStateDesc",
		"aggDesc", "rollupDesc", "rollupItem", "dupKeys", "fromRollup", "orReplace",
		"ifNotExists", "createTableAsSelectStatement", "dropTableStatement",
		"cleanTemporaryTableStatement", "alterTableStatement", "createIndexStatement",
		"dropIndexStatement", "indexType", "showTableStatement", "showTemporaryTablesStatement",
		"showCreateTableStatement", "showColumnStatement", "showTableStatusStatement",
		"refreshTableStatement", "showAlterStatement", "descTableStatement",
		"createTableLikeStatement", "showIndexStatement", "recoverTableStatement",
		"truncateTableStatement", "cancelAlterTableStatement", "showPartitionsStatement",
		"recoverPartitionStatement", "createViewStatement", "alterViewStatement",
		"dropViewStatement", "columnNameWithComment", "submitTaskStatement",
		"taskClause", "dropTaskStatement", "taskScheduleDesc", "createMaterializedViewStatement",
		"mvPartitionExprs", "materializedViewDesc", "showMaterializedViewsStatement",
		"dropMaterializedViewStatement", "alterMaterializedViewStatement", "refreshMaterializedViewStatement",
		"cancelRefreshMaterializedViewStatement", "adminSetConfigStatement",
		"adminSetReplicaStatusStatement", "adminShowConfigStatement", "adminShowReplicaDistributionStatement",
		"adminShowReplicaStatusStatement", "adminRepairTableStatement", "adminCancelRepairTableStatement",
		"adminCheckTabletsStatement", "adminSetPartitionVersion", "killStatement",
		"syncStatement", "adminSetAutomatedSnapshotOnStatement", "adminSetAutomatedSnapshotOffStatement",
		"alterSystemStatement", "cancelAlterSystemStatement", "showComputeNodesStatement",
		"createExternalCatalogStatement", "showCreateExternalCatalogStatement",
		"dropExternalCatalogStatement", "showCatalogsStatement", "alterCatalogStatement",
		"createStorageVolumeStatement", "typeDesc", "locationsDesc", "showStorageVolumesStatement",
		"dropStorageVolumeStatement", "alterStorageVolumeStatement", "alterStorageVolumeClause",
		"modifyStorageVolumePropertiesClause", "modifyStorageVolumeCommentClause",
		"descStorageVolumeStatement", "setDefaultStorageVolumeStatement", "updateFailPointStatusStatement",
		"showFailPointStatement", "createDictionaryStatement", "dropDictionaryStatement",
		"refreshDictionaryStatement", "showDictionaryStatement", "cancelRefreshDictionaryStatement",
		"dictionaryColumnDesc", "dictionaryName", "alterClause", "addFrontendClause",
		"dropFrontendClause", "modifyFrontendHostClause", "addBackendClause",
		"dropBackendClause", "decommissionBackendClause", "modifyBackendClause",
		"addComputeNodeClause", "dropComputeNodeClause", "modifyBrokerClause",
		"alterLoadErrorUrlClause", "createImageClause", "cleanTabletSchedQClause",
		"decommissionDiskClause", "cancelDecommissionDiskClause", "disableDiskClause",
		"cancelDisableDiskClause", "createIndexClause", "dropIndexClause", "tableRenameClause",
		"swapTableClause", "modifyPropertiesClause", "modifyCommentClause",
		"optimizeRange", "optimizeClause", "addColumnClause", "addColumnsClause",
		"dropColumnClause", "modifyColumnClause", "modifyColumnCommentClause",
		"columnRenameClause", "reorderColumnsClause", "rollupRenameClause",
		"compactionClause", "subfieldName", "nestedFieldName", "addFieldClause",
		"dropFieldClause", "createOrReplaceTagClause", "createOrReplaceBranchClause",
		"dropBranchClause", "dropTagClause", "tableOperationClause", "tagOptions",
		"branchOptions", "snapshotRetention", "refRetain", "maxSnapshotAge",
		"minSnapshotsToKeep", "snapshotId", "timeUnit", "integer_list", "dropPersistentIndexClause",
		"alterTableAutoIncrementClause", "addPartitionClause", "dropPartitionClause",
		"truncatePartitionClause", "modifyPartitionClause", "replacePartitionClause",
		"partitionRenameClause", "insertStatement", "insertLabelOrColumnAliases",
		"columnAliasesOrByName", "updateStatement", "deleteStatement", "createRoutineLoadStatement",
		"alterRoutineLoadStatement", "dataSource", "loadProperties", "colSeparatorProperty",
		"rowDelimiterProperty", "importColumns", "columnProperties", "jobProperties",
		"dataSourceProperties", "stopRoutineLoadStatement", "resumeRoutineLoadStatement",
		"pauseRoutineLoadStatement", "showRoutineLoadStatement", "showRoutineLoadTaskStatement",
		"showCreateRoutineLoadStatement", "showStreamLoadStatement", "analyzeStatement",
		"analyzeColumnClause", "dropStatsStatement", "histogramStatement", "analyzeHistogramStatement",
		"dropHistogramStatement", "createAnalyzeStatement", "dropAnalyzeJobStatement",
		"showAnalyzeStatement", "showStatsMetaStatement", "showHistogramMetaStatement",
		"killAnalyzeStatement", "analyzeProfileStatement", "createBaselinePlanStatement",
		"dropBaselinePlanStatement", "showBaselinePlanStatement", "createResourceGroupStatement",
		"dropResourceGroupStatement", "alterResourceGroupStatement", "showResourceGroupStatement",
		"showResourceGroupUsageStatement", "createResourceStatement", "alterResourceStatement",
		"dropResourceStatement", "showResourceStatement", "classifier", "showFunctionsStatement",
		"dropFunctionStatement", "createFunctionStatement", "inlineFunction",
		"typeList", "loadStatement", "labelName", "dataDescList", "dataDesc",
		"formatProps", "brokerDesc", "resourceDesc", "showLoadStatement", "showLoadWarningsStatement",
		"cancelLoadStatement", "alterLoadStatement", "cancelCompactionStatement",
		"showAuthorStatement", "showBackendsStatement", "showBrokerStatement",
		"showCharsetStatement", "showCollationStatement", "showDeleteStatement",
		"showDynamicPartitionStatement", "showEventsStatement", "showEnginesStatement",
		"showFrontendsStatement", "showPluginsStatement", "showRepositoriesStatement",
		"showOpenTableStatement", "showPrivilegesStatement", "showProcedureStatement",
		"showProcStatement", "showProcesslistStatement", "showProfilelistStatement",
		"showRunningQueriesStatement", "showStatusStatement", "showTabletStatement",
		"showTransactionStatement", "showTriggersStatement", "showUserPropertyStatement",
		"showVariablesStatement", "showWarningStatement", "helpStatement", "createUserStatement",
		"dropUserStatement", "alterUserStatement", "showUserStatement", "showAuthenticationStatement",
		"executeAsStatement", "createRoleStatement", "alterRoleStatement", "dropRoleStatement",
		"showRolesStatement", "grantRoleStatement", "revokeRoleStatement", "setRoleStatement",
		"setDefaultRoleStatement", "grantRevokeClause", "grantPrivilegeStatement",
		"revokePrivilegeStatement", "showGrantsStatement", "authOption", "privObjectName",
		"privObjectNameList", "privFunctionObjectNameList", "privilegeTypeList",
		"privilegeType", "privObjectType", "privObjectTypePlural", "createSecurityIntegrationStatement",
		"alterSecurityIntegrationStatement", "dropSecurityIntegrationStatement",
		"showSecurityIntegrationStatement", "showCreateSecurityIntegrationStatement",
		"createGroupProviderStatement", "dropGroupProviderStatement", "showGroupProvidersStatement",
		"showCreateGroupProviderStatement", "backupStatement", "cancelBackupStatement",
		"showBackupStatement", "restoreStatement", "cancelRestoreStatement",
		"showRestoreStatement", "showSnapshotStatement", "createRepositoryStatement",
		"dropRepositoryStatement", "addSqlBlackListStatement", "delSqlBlackListStatement",
		"showSqlBlackListStatement", "showWhiteListStatement", "addBackendBlackListStatement",
		"delBackendBlackListStatement", "showBackendBlackListStatement", "dataCacheTarget",
		"createDataCacheRuleStatement", "showDataCacheRulesStatement", "dropDataCacheRuleStatement",
		"clearDataCacheRulesStatement", "dataCacheSelectStatement", "exportStatement",
		"cancelExportStatement", "showExportStatement", "installPluginStatement",
		"uninstallPluginStatement", "createFileStatement", "dropFileStatement",
		"showSmallFilesStatement", "createPipeStatement", "dropPipeStatement",
		"alterPipeClause", "alterPipeStatement", "descPipeStatement", "showPipeStatement",
		"setStatement", "setVar", "transaction_characteristics", "transaction_access_mode",
		"isolation_level", "isolation_types", "setExprOrDefault", "setUserPropertyStatement",
		"roleList", "executeScriptStatement", "unsupportedStatement", "lock_item",
		"lock_type", "alterPlanAdvisorAddStatement", "truncatePlanAdvisorStatement",
		"alterPlanAdvisorDropStatement", "showPlanAdvisorStatement", "createWarehouseStatement",
		"dropWarehouseStatement", "suspendWarehouseStatement", "resumeWarehouseStatement",
		"setWarehouseStatement", "showWarehousesStatement", "showClustersStatement",
		"showNodesStatement", "alterWarehouseStatement", "beginStatement", "commitStatement",
		"rollbackStatement", "translateStatement", "dialect", "translateSQL",
		"queryStatement", "queryRelation", "withClause", "queryNoWith", "queryPeriod",
		"periodType", "queryPrimary", "subquery", "rowConstructor", "sortItem",
		"limitConstExpr", "limitElement", "querySpecification", "fromClause",
		"groupingElement", "groupingSet", "commonTableExpression", "setQuantifier",
		"selectItem", "relations", "relation", "relationPrimary", "pivotClause",
		"pivotAggregationExpression", "pivotValue", "sampleClause", "argumentList",
		"namedArgumentList", "namedArgument", "joinRelation", "crossOrInnerJoinType",
		"outerAndSemiJoinType", "bracketHint", "hintMap", "joinCriteria", "columnAliases",
		"partitionNames", "keyPartitions", "tabletList", "prepareStatement",
		"prepareSql", "executeStatement", "deallocateStatement", "replicaList",
		"expressionsWithDefault", "expressionOrDefault", "mapExpressionList",
		"mapExpression", "expressionSingleton", "expression", "expressionList",
		"booleanExpression", "predicate", "tupleInSubquery", "predicateOperations",
		"valueExpression", "primaryExpression", "literalExpression", "functionCall",
		"aggregationFunction", "userVariable", "systemVariable", "columnReference",
		"informationFunctionExpression", "specialDateTimeExpression", "specialFunctionExpression",
		"windowFunction", "whenClause", "over", "ignoreNulls", "windowFrame",
		"frameBound", "backupRestoreObjectDesc", "tableDesc", "backupRestoreTableDesc",
		"explainDesc", "optimizerTrace", "partitionExpr", "partitionDesc", "listPartitionDesc",
		"singleItemListPartitionDesc", "multiItemListPartitionDesc", "multiListPartitionValues",
		"singleListPartitionValues", "listPartitionValues", "listPartitionValue",
		"stringList", "integerList", "literalExpressionList", "rangePartitionDesc",
		"singleRangePartition", "multiRangePartition", "partitionRangeDesc",
		"partitionKeyDesc", "partitionValueList", "keyPartition", "partitionValue",
		"distributionClause", "distributionDesc", "alterModifyDefaultBuckets",
		"refreshSchemeDesc", "statusDesc", "properties", "extProperties", "propertyList",
		"userPropertyList", "property", "inlineProperties", "inlineProperty",
		"varType", "comment", "outfile", "fileFormat", "string", "binary", "comparisonOperator",
		"booleanValue", "interval", "taskInterval", "taskUnitIdentifier", "unitIdentifier",
		"unitBoundary", "type", "arrayType", "mapType", "subfieldDesc", "subfieldDescs",
		"structType", "typeParameter", "baseType", "decimalType", "qualifiedName",
		"tableName", "writeBranch", "identifier", "identifierWithAlias", "identifierWithAliasList",
		"identifierList", "identifierOrString", "identifierOrStringList", "identifierOrStringOrStar",
		"user", "assignment", "assignmentList", "number", "nonReserved",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 534, 8188, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2,
		419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7,
		423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2,
		428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7,
		432, 2, 433, 7, 433, 2, 434, 7, 434, 2, 435, 7, 435, 2, 436, 7, 436, 2,
		437, 7, 437, 2, 438, 7, 438, 2, 439, 7, 439, 2, 440, 7, 440, 2, 441, 7,
		441, 2, 442, 7, 442, 2, 443, 7, 443, 2, 444, 7, 444, 2, 445, 7, 445, 2,
		446, 7, 446, 2, 447, 7, 447, 2, 448, 7, 448, 2, 449, 7, 449, 2, 450, 7,
		450, 2, 451, 7, 451, 2, 452, 7, 452, 2, 453, 7, 453, 2, 454, 7, 454, 2,
		455, 7, 455, 2, 456, 7, 456, 2, 457, 7, 457, 2, 458, 7, 458, 2, 459, 7,
		459, 2, 460, 7, 460, 2, 461, 7, 461, 2, 462, 7, 462, 2, 463, 7, 463, 2,
		464, 7, 464, 2, 465, 7, 465, 2, 466, 7, 466, 2, 467, 7, 467, 2, 468, 7,
		468, 2, 469, 7, 469, 2, 470, 7, 470, 2, 471, 7, 471, 2, 472, 7, 472, 2,
		473, 7, 473, 2, 474, 7, 474, 2, 475, 7, 475, 2, 476, 7, 476, 2, 477, 7,
		477, 2, 478, 7, 478, 2, 479, 7, 479, 2, 480, 7, 480, 2, 481, 7, 481, 2,
		482, 7, 482, 2, 483, 7, 483, 2, 484, 7, 484, 2, 485, 7, 485, 2, 486, 7,
		486, 2, 487, 7, 487, 2, 488, 7, 488, 2, 489, 7, 489, 2, 490, 7, 490, 2,
		491, 7, 491, 2, 492, 7, 492, 2, 493, 7, 493, 2, 494, 7, 494, 2, 495, 7,
		495, 2, 496, 7, 496, 2, 497, 7, 497, 2, 498, 7, 498, 2, 499, 7, 499, 2,
		500, 7, 500, 2, 501, 7, 501, 2, 502, 7, 502, 2, 503, 7, 503, 2, 504, 7,
		504, 2, 505, 7, 505, 2, 506, 7, 506, 2, 507, 7, 507, 2, 508, 7, 508, 2,
		509, 7, 509, 2, 510, 7, 510, 2, 511, 7, 511, 2, 512, 7, 512, 2, 513, 7,
		513, 2, 514, 7, 514, 2, 515, 7, 515, 2, 516, 7, 516, 2, 517, 7, 517, 1,
		0, 4, 0, 1038, 8, 0, 11, 0, 12, 0, 1039, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1,
		1, 1, 3, 1, 1048, 8, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 3, 3, 1287, 8, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5, 1, 6, 1, 6,
		1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 1303, 8, 7, 1, 7, 1, 7, 1, 7,
		1, 7, 3, 7, 1309, 8, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3, 7, 1317,
		8, 7, 3, 7, 1319, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8,
		1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 1337, 8, 8, 1, 9,
		1, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1344, 8, 9, 1, 9, 1, 9, 1, 9, 3, 9, 1349,
		8, 9, 1, 9, 1, 9, 3, 9, 1353, 8, 9, 1, 9, 3, 9, 1356, 8, 9, 1, 9, 3, 9,
		1359, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10, 1365, 8, 10, 1, 10, 1, 10,
		1, 10, 3, 10, 1370, 8, 10, 1, 10, 1, 10, 3, 10, 1374, 8, 10, 1, 11, 1,
		11, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13,
		1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 3, 14, 1397,
		8, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 3, 15, 1405, 8, 15, 1,
		16, 1, 16, 3, 16, 1409, 8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 3, 16, 1415,
		8, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 5, 16, 1422, 8, 16, 10, 16, 12,
		16, 1425, 9, 16, 1, 16, 1, 16, 5, 16, 1429, 8, 16, 10, 16, 12, 16, 1432,
		9, 16, 1, 16, 1, 16, 3, 16, 1436, 8, 16, 1, 16, 3, 16, 1439, 8, 16, 1,
		16, 3, 16, 1442, 8, 16, 1, 16, 3, 16, 1445, 8, 16, 1, 16, 3, 16, 1448,
		8, 16, 1, 16, 3, 16, 1451, 8, 16, 1, 16, 3, 16, 1454, 8, 16, 1, 16, 3,
		16, 1457, 8, 16, 1, 16, 3, 16, 1460, 8, 16, 1, 16, 3, 16, 1463, 8, 16,
		1, 17, 1, 17, 3, 17, 1467, 8, 17, 1, 17, 3, 17, 1470, 8, 17, 1, 17, 3,
		17, 1473, 8, 17, 1, 17, 3, 17, 1476, 8, 17, 1, 17, 3, 17, 1479, 8, 17,
		1, 17, 1, 17, 1, 17, 3, 17, 1484, 8, 17, 1, 17, 3, 17, 1487, 8, 17, 1,
		18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 3, 18, 1497, 8, 18,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 1505, 8, 19, 1, 19, 3,
		19, 1508, 8, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 1516,
		8, 19, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 3, 21, 1526,
		8, 21, 3, 21, 1528, 8, 21, 1, 21, 3, 21, 1531, 8, 21, 1, 22, 1, 22, 1,
		22, 1, 22, 1, 23, 3, 23, 1538, 8, 23, 1, 23, 1, 23, 1, 23, 1, 23, 1, 23,
		3, 23, 1545, 8, 23, 1, 23, 3, 23, 1548, 8, 23, 1, 23, 1, 23, 1, 24, 3,
		24, 1553, 8, 24, 1, 24, 1, 24, 3, 24, 1557, 8, 24, 1, 24, 1, 24, 1, 25,
		1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 3,
		27, 1572, 8, 27, 1, 28, 1, 28, 3, 28, 1576, 8, 28, 1, 29, 1, 29, 1, 29,
		1, 29, 1, 29, 5, 29, 1583, 8, 29, 10, 29, 12, 29, 1586, 9, 29, 1, 29, 1,
		29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30,
		1599, 8, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 1606, 8, 31, 10,
		31, 12, 31, 1609, 9, 31, 1, 31, 1, 31, 1, 32, 1, 32, 1, 32, 3, 32, 1616,
		8, 32, 1, 32, 3, 32, 1619, 8, 32, 1, 32, 3, 32, 1622, 8, 32, 1, 33, 1,
		33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 3, 35, 1633, 8, 35,
		1, 36, 1, 36, 1, 36, 3, 36, 1638, 8, 36, 1, 37, 1, 37, 3, 37, 1642, 8,
		37, 1, 37, 1, 37, 1, 37, 1, 37, 3, 37, 1648, 8, 37, 1, 37, 1, 37, 1, 37,
		1, 37, 1, 37, 5, 37, 1655, 8, 37, 10, 37, 12, 37, 1658, 9, 37, 1, 37, 1,
		37, 5, 37, 1662, 8, 37, 10, 37, 12, 37, 1665, 9, 37, 1, 37, 1, 37, 1, 37,
		5, 37, 1670, 8, 37, 10, 37, 12, 37, 1673, 9, 37, 3, 37, 1675, 8, 37, 1,
		37, 1, 37, 3, 37, 1679, 8, 37, 1, 37, 3, 37, 1682, 8, 37, 1, 37, 3, 37,
		1685, 8, 37, 1, 37, 3, 37, 1688, 8, 37, 1, 37, 3, 37, 1691, 8, 37, 1, 37,
		3, 37, 1694, 8, 37, 1, 37, 3, 37, 1697, 8, 37, 1, 37, 1, 37, 1, 37, 1,
		38, 1, 38, 3, 38, 1704, 8, 38, 1, 38, 1, 38, 1, 38, 3, 38, 1709, 8, 38,
		1, 38, 1, 38, 3, 38, 1713, 8, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1,
		39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 1728, 8, 40,
		10, 40, 12, 40, 1731, 9, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40,
		1, 40, 1, 40, 5, 40, 1741, 8, 40, 10, 40, 12, 40, 1744, 9, 40, 1, 40, 1,
		40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 5, 40, 1754, 8, 40, 10, 40,
		12, 40, 1757, 9, 40, 3, 40, 1759, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 1,
		41, 1, 41, 1, 41, 1, 41, 3, 41, 1769, 8, 41, 3, 41, 1771, 8, 41, 1, 41,
		3, 41, 1774, 8, 41, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 42, 1, 43, 1,
		43, 1, 43, 1, 44, 1, 44, 3, 44, 1787, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44,
		1792, 8, 44, 1, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1798, 8, 44, 1, 45, 1,
		45, 1, 45, 1, 45, 1, 45, 3, 45, 1805, 8, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 1811, 8, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 1, 46, 3, 46, 1819,
		8, 46, 1, 46, 1, 46, 1, 47, 1, 47, 3, 47, 1825, 8, 47, 1, 47, 1, 47, 1,
		47, 1, 47, 1, 47, 1, 47, 3, 47, 1833, 8, 47, 1, 47, 1, 47, 1, 47, 1, 47,
		3, 47, 1839, 8, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1846, 8,
		48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 1852, 8, 48, 1, 49, 1, 49, 1, 49,
		1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 5, 49, 1863, 8, 49, 10, 49, 12,
		49, 1866, 9, 49, 1, 49, 1, 49, 3, 49, 1870, 8, 49, 1, 50, 1, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 3, 50, 1878, 8, 50, 1, 50, 1, 50, 3, 50, 1882, 8,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 1889, 8, 50, 10, 50, 12,
		50, 1892, 9, 50, 3, 50, 1894, 8, 50, 1, 50, 3, 50, 1897, 8, 50, 1, 50,
		1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 1905, 8, 50, 1, 50, 1, 50, 3,
		50, 1909, 8, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 5, 50, 1916, 8, 50,
		10, 50, 12, 50, 1919, 9, 50, 3, 50, 1921, 8, 50, 1, 50, 3, 50, 1924, 8,
		50, 3, 50, 1926, 8, 50, 1, 51, 1, 51, 1, 51, 3, 51, 1931, 8, 51, 1, 51,
		1, 51, 3, 51, 1935, 8, 51, 1, 52, 1, 52, 3, 52, 1939, 8, 52, 1, 52, 1,
		52, 1, 52, 1, 52, 3, 52, 1945, 8, 52, 1, 52, 1, 52, 3, 52, 1949, 8, 52,
		1, 52, 3, 52, 1952, 8, 52, 1, 52, 3, 52, 1955, 8, 52, 1, 52, 1, 52, 1,
		52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 3, 53, 1967, 8, 53,
		1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 3, 55, 1977, 8,
		55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1983, 8, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 56, 5, 56, 1991, 8, 56, 10, 56, 12, 56, 1994, 9, 56, 1,
		56, 3, 56, 1997, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56,
		2005, 8, 56, 1, 57, 1, 57, 3, 57, 2009, 8, 57, 1, 57, 1, 57, 1, 57, 1,
		57, 1, 57, 3, 57, 2016, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 5, 57,
		2023, 8, 57, 10, 57, 12, 57, 2026, 9, 57, 3, 57, 2028, 8, 57, 1, 57, 3,
		57, 2031, 8, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59,
		1, 59, 3, 59, 2042, 8, 59, 1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 2048, 8,
		59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 5, 59, 2055, 8, 59, 10, 59, 12,
		59, 2058, 9, 59, 1, 59, 1, 59, 3, 59, 2062, 8, 59, 1, 59, 3, 59, 2065,
		8, 59, 1, 59, 1, 59, 3, 59, 2069, 8, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 5, 60, 2081, 8, 60, 10, 60, 12,
		60, 2084, 9, 60, 1, 60, 1, 60, 3, 60, 2088, 8, 60, 1, 60, 1, 60, 1, 60,
		1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 2112,
		8, 60, 1, 60, 1, 60, 3, 60, 2116, 8, 60, 1, 61, 1, 61, 1, 61, 1, 61, 3,
		61, 2122, 8, 61, 1, 61, 1, 61, 1, 62, 1, 62, 3, 62, 2128, 8, 62, 1, 63,
		1, 63, 1, 63, 3, 63, 2133, 8, 63, 1, 63, 5, 63, 2136, 8, 63, 10, 63, 12,
		63, 2139, 9, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 2145, 8, 63, 1, 64,
		1, 64, 3, 64, 2149, 8, 64, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65, 2155, 8,
		65, 1, 65, 1, 65, 3, 65, 2159, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66,
		1, 66, 3, 66, 2167, 8, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 2180, 8, 67, 1, 67, 1, 67, 1, 67,
		1, 67, 1, 67, 5, 67, 2187, 8, 67, 10, 67, 12, 67, 2190, 9, 67, 1, 67, 1,
		67, 5, 67, 2194, 8, 67, 10, 67, 12, 67, 2197, 9, 67, 1, 67, 1, 67, 3, 67,
		2201, 8, 67, 1, 67, 3, 67, 2204, 8, 67, 1, 67, 5, 67, 2207, 8, 67, 10,
		67, 12, 67, 2210, 9, 67, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68,
		1, 68, 5, 68, 2220, 8, 68, 10, 68, 12, 68, 2223, 9, 68, 1, 68, 1, 68, 3,
		68, 2227, 8, 68, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 1, 69, 3, 69,
		2236, 8, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 2243, 8, 70, 1,
		70, 1, 70, 1, 70, 1, 70, 3, 70, 2249, 8, 70, 1, 71, 1, 71, 1, 71, 1, 71,
		1, 71, 3, 71, 2256, 8, 71, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 72, 1,
		72, 1, 72, 1, 72, 1, 72, 3, 72, 2268, 8, 72, 1, 72, 1, 72, 1, 72, 1, 72,
		1, 72, 1, 72, 3, 72, 2276, 8, 72, 1, 73, 1, 73, 1, 73, 1, 73, 1, 73, 1,
		73, 1, 73, 3, 73, 2285, 8, 73, 3, 73, 2287, 8, 73, 1, 73, 3, 73, 2290,
		8, 73, 1, 73, 1, 73, 1, 73, 3, 73, 2295, 8, 73, 1, 73, 1, 73, 1, 73, 3,
		73, 2300, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 1, 74, 3, 74, 2308,
		8, 74, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 1, 75, 3,
		75, 2319, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77,
		1, 77, 1, 77, 1, 77, 1, 77, 3, 77, 2333, 8, 77, 1, 78, 1, 78, 1, 78, 1,
		78, 1, 78, 1, 78, 1, 78, 3, 78, 2342, 8, 78, 1, 79, 1, 79, 1, 79, 1, 79,
		1, 79, 1, 79, 1, 79, 3, 79, 2351, 8, 79, 1, 79, 1, 79, 3, 79, 2355, 8,
		79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 2362, 8, 80, 1, 81, 1, 81,
		1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 2370, 8, 81, 1, 82, 1, 82, 1, 82, 1,
		82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		1, 83, 1, 83, 3, 83, 2388, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1,
		84, 1, 84, 3, 84, 2397, 8, 84, 1, 84, 3, 84, 2400, 8, 84, 1, 84, 1, 84,
		3, 84, 2404, 8, 84, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1,
		86, 1, 86, 1, 86, 1, 86, 3, 86, 2417, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87,
		1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1,
		89, 1, 89, 1, 89, 5, 89, 2436, 8, 89, 10, 89, 12, 89, 2439, 9, 89, 1, 90,
		1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 3, 91, 2451,
		8, 91, 1, 91, 1, 91, 3, 91, 2455, 8, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1,
		92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 3, 93, 2468, 8, 93, 1, 93,
		1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 2476, 8, 94, 1, 95, 1, 95, 1,
		95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 2489,
		8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 2495, 8, 96, 1, 96, 3, 96, 2498,
		8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 99, 1,
		99, 1, 99, 1, 99, 1, 99, 3, 99, 2513, 8, 99, 1, 100, 1, 100, 1, 100, 1,
		100, 1, 100, 3, 100, 2520, 8, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101,
		1, 101, 1, 101, 1, 101, 1, 101, 5, 101, 2531, 8, 101, 10, 101, 12, 101,
		2534, 9, 101, 1, 102, 1, 102, 3, 102, 2538, 8, 102, 1, 103, 1, 103, 1,
		103, 1, 104, 1, 104, 1, 104, 1, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1,
		105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 106, 1, 107, 1,
		107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 3, 107, 2566, 8, 107, 1, 107,
		1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 3, 107, 2575, 8, 107, 1,
		107, 1, 107, 1, 107, 3, 107, 2580, 8, 107, 1, 107, 1, 107, 1, 107, 1, 107,
		1, 107, 1, 107, 1, 107, 3, 107, 2589, 8, 107, 1, 107, 1, 107, 1, 107, 3,
		107, 2594, 8, 107, 3, 107, 2596, 8, 107, 1, 108, 1, 108, 1, 108, 1, 108,
		3, 108, 2602, 8, 108, 1, 108, 1, 108, 1, 108, 3, 108, 2607, 8, 108, 1,
		109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 5,
		109, 2618, 8, 109, 10, 109, 12, 109, 2621, 9, 109, 1, 109, 1, 109, 3, 109,
		2625, 8, 109, 1, 110, 1, 110, 1, 110, 1, 110, 3, 110, 2631, 8, 110, 1,
		111, 1, 111, 1, 111, 1, 111, 1, 112, 1, 112, 1, 112, 3, 112, 2640, 8, 112,
		1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 114,
		1, 114, 1, 114, 3, 114, 2653, 8, 114, 1, 115, 1, 115, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1,
		116, 1, 116, 1, 116, 3, 116, 2707, 8, 116, 1, 117, 1, 117, 1, 117, 1, 117,
		1, 118, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119,
		1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 5, 120, 2729, 8,
		120, 10, 120, 12, 120, 2732, 9, 120, 1, 120, 1, 120, 1, 120, 3, 120, 2737,
		8, 120, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 5, 121, 2744, 8, 121, 10,
		121, 12, 121, 2747, 9, 121, 1, 121, 1, 121, 1, 121, 3, 121, 2752, 8, 121,
		1, 121, 3, 121, 2755, 8, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 5,
		122, 2762, 8, 122, 10, 122, 12, 122, 2765, 9, 122, 1, 123, 1, 123, 1, 123,
		1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123,
		1, 123, 3, 123, 2780, 8, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1,
		124, 5, 124, 2788, 8, 124, 10, 124, 12, 124, 2791, 9, 124, 1, 124, 1, 124,
		1, 124, 3, 124, 2796, 8, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1,
		125, 5, 125, 2804, 8, 125, 10, 125, 12, 125, 2807, 9, 125, 1, 125, 1, 125,
		1, 125, 3, 125, 2812, 8, 125, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1,
		126, 5, 126, 2820, 8, 126, 10, 126, 12, 126, 2823, 9, 126, 1, 126, 1, 126,
		1, 126, 1, 126, 1, 126, 1, 126, 5, 126, 2831, 8, 126, 10, 126, 12, 126,
		2834, 9, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 2840, 8, 126, 1,
		127, 1, 127, 1, 127, 1, 127, 1, 127, 3, 127, 2847, 8, 127, 1, 128, 1, 128,
		1, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130,
		1, 130, 1, 130, 5, 130, 2862, 8, 130, 10, 130, 12, 130, 2865, 9, 130, 1,
		130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1,
		131, 5, 131, 2877, 8, 131, 10, 131, 12, 131, 2880, 9, 131, 1, 131, 1, 131,
		1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 5, 132, 2891, 8,
		132, 10, 132, 12, 132, 2894, 9, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1,
		133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 133, 5, 133, 2906, 8, 133, 10,
		133, 12, 133, 2909, 9, 133, 1, 133, 1, 133, 1, 133, 1, 133, 1, 134, 1,
		134, 1, 134, 1, 134, 1, 134, 1, 134, 3, 134, 2921, 8, 134, 3, 134, 2923,
		8, 134, 1, 134, 3, 134, 2926, 8, 134, 1, 135, 1, 135, 1, 135, 1, 135, 1,
		136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 138, 1, 138, 1,
		138, 1, 139, 1, 139, 1, 139, 1, 139, 1, 140, 1, 140, 1, 140, 1, 140, 1,
		140, 1, 141, 3, 141, 2952, 8, 141, 1, 141, 3, 141, 2955, 8, 141, 1, 141,
		3, 141, 2958, 8, 141, 1, 141, 3, 141, 2961, 8, 141, 1, 141, 3, 141, 2964,
		8, 141, 1, 141, 3, 141, 2967, 8, 141, 1, 142, 1, 142, 1, 142, 1, 142, 1,
		142, 1, 142, 3, 142, 2975, 8, 142, 1, 142, 1, 142, 3, 142, 2979, 8, 142,
		1, 142, 3, 142, 2982, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 1, 143, 1,
		143, 5, 143, 2990, 8, 143, 10, 143, 12, 143, 2993, 9, 143, 1, 143, 1, 143,
		1, 143, 3, 143, 2998, 8, 143, 1, 143, 3, 143, 3001, 8, 143, 1, 144, 1,
		144, 1, 144, 1, 144, 1, 144, 3, 144, 3008, 8, 144, 1, 144, 3, 144, 3011,
		8, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 3019, 8,
		145, 1, 145, 1, 145, 3, 145, 3023, 8, 145, 1, 145, 3, 145, 3026, 8, 145,
		1, 146, 1, 146, 1, 146, 1, 146, 1, 146, 1, 147, 1, 147, 1, 147, 1, 147,
		1, 147, 1, 147, 1, 148, 1, 148, 1, 148, 1, 148, 1, 148, 3, 148, 3044, 8,
		148, 1, 148, 3, 148, 3047, 8, 148, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149,
		1, 150, 3, 150, 3055, 8, 150, 1, 150, 1, 150, 1, 150, 3, 150, 3060, 8,
		150, 1, 151, 1, 151, 3, 151, 3064, 8, 151, 1, 152, 1, 152, 1, 152, 1, 152,
		5, 152, 3070, 8, 152, 10, 152, 12, 152, 3073, 9, 152, 1, 153, 1, 153, 1,
		153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 3, 153, 3084, 8, 153,
		1, 153, 3, 153, 3087, 8, 153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1,
		154, 1, 154, 3, 154, 3096, 8, 154, 1, 155, 1, 155, 3, 155, 3100, 8, 155,
		1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155,
		1, 155, 3, 155, 3112, 8, 155, 1, 155, 1, 155, 1, 155, 3, 155, 3117, 8,
		155, 1, 156, 1, 156, 3, 156, 3121, 8, 156, 1, 156, 1, 156, 1, 156, 1, 156,
		1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 3, 156, 3133, 8, 156, 1,
		156, 1, 156, 1, 156, 3, 156, 3138, 8, 156, 1, 157, 1, 157, 1, 157, 1, 157,
		3, 157, 3144, 8, 157, 1, 157, 1, 157, 1, 158, 1, 158, 1, 158, 1, 158, 3,
		158, 3152, 8, 158, 1, 158, 1, 158, 1, 159, 1, 159, 1, 159, 1, 160, 1, 160,
		1, 160, 1, 160, 3, 160, 3163, 8, 160, 1, 160, 3, 160, 3166, 8, 160, 1,
		161, 1, 161, 1, 161, 1, 161, 3, 161, 3172, 8, 161, 1, 161, 3, 161, 3175,
		8, 161, 1, 161, 3, 161, 3178, 8, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1,
		162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 1,
		162, 3, 162, 3194, 8, 162, 1, 163, 1, 163, 1, 163, 1, 163, 1, 164, 1, 164,
		1, 164, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 167, 1, 167, 1, 168,
		1, 168, 1, 168, 1, 168, 5, 168, 3214, 8, 168, 10, 168, 12, 168, 3217, 9,
		168, 1, 168, 1, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1,
		169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 171, 1, 171, 3, 171, 3234, 8, 171,
		1, 171, 1, 171, 1, 171, 3, 171, 3239, 8, 171, 1, 171, 3, 171, 3242, 8,
		171, 1, 171, 3, 171, 3245, 8, 171, 1, 171, 1, 171, 3, 171, 3249, 8, 171,
		1, 171, 1, 171, 3, 171, 3253, 8, 171, 1, 171, 3, 171, 3256, 8, 171, 1,
		171, 3, 171, 3259, 8, 171, 3, 171, 3261, 8, 171, 1, 172, 1, 172, 3, 172,
		3265, 8, 172, 1, 172, 1, 172, 1, 172, 3, 172, 3270, 8, 172, 1, 172, 1,
		172, 1, 172, 1, 172, 3, 172, 3276, 8, 172, 1, 172, 3, 172, 3279, 8, 172,
		1, 172, 3, 172, 3282, 8, 172, 1, 172, 1, 172, 3, 172, 3286, 8, 172, 1,
		172, 1, 172, 1, 172, 3, 172, 3291, 8, 172, 1, 172, 1, 172, 3, 172, 3295,
		8, 172, 1, 172, 1, 172, 3, 172, 3299, 8, 172, 1, 172, 1, 172, 1, 172, 3,
		172, 3304, 8, 172, 1, 172, 1, 172, 1, 172, 3, 172, 3309, 8, 172, 1, 172,
		1, 172, 1, 172, 1, 172, 1, 172, 3, 172, 3316, 8, 172, 3, 172, 3318, 8,
		172, 1, 173, 1, 173, 1, 173, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 3, 174, 3330, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		3, 174, 3337, 8, 174, 1, 175, 1, 175, 1, 175, 1, 175, 1, 175, 3, 175, 3344,
		8, 175, 1, 176, 1, 176, 1, 176, 1, 176, 1, 176, 1, 177, 3, 177, 3352, 8,
		177, 1, 177, 1, 177, 1, 177, 1, 177, 3, 177, 3358, 8, 177, 1, 177, 3, 177,
		3361, 8, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 3, 177, 3368, 8,
		177, 1, 177, 5, 177, 3371, 8, 177, 10, 177, 12, 177, 3374, 9, 177, 1, 177,
		3, 177, 3377, 8, 177, 1, 177, 1, 177, 1, 177, 1, 177, 1, 177, 5, 177, 3384,
		8, 177, 10, 177, 12, 177, 3387, 9, 177, 3, 177, 3389, 8, 177, 1, 178, 1,
		178, 1, 178, 1, 178, 3, 178, 3395, 8, 178, 1, 179, 1, 179, 1, 179, 3, 179,
		3400, 8, 179, 1, 180, 3, 180, 3403, 8, 180, 1, 180, 3, 180, 3406, 8, 180,
		1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 1, 180, 3, 180, 3415, 8,
		180, 1, 181, 3, 181, 3418, 8, 181, 1, 181, 3, 181, 3421, 8, 181, 1, 181,
		1, 181, 1, 181, 1, 181, 3, 181, 3427, 8, 181, 1, 181, 1, 181, 3, 181, 3431,
		8, 181, 1, 181, 1, 181, 3, 181, 3435, 8, 181, 1, 182, 1, 182, 1, 182, 1,
		182, 1, 182, 1, 182, 3, 182, 3443, 8, 182, 1, 182, 1, 182, 1, 182, 1, 182,
		1, 182, 1, 182, 5, 182, 3451, 8, 182, 10, 182, 12, 182, 3454, 9, 182, 3,
		182, 3456, 8, 182, 1, 182, 3, 182, 3459, 8, 182, 1, 182, 1, 182, 1, 182,
		3, 182, 3464, 8, 182, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1,
		183, 3, 183, 3473, 8, 183, 1, 183, 1, 183, 1, 183, 1, 183, 5, 183, 3479,
		8, 183, 10, 183, 12, 183, 3482, 9, 183, 3, 183, 3484, 8, 183, 1, 183, 3,
		183, 3487, 8, 183, 1, 183, 3, 183, 3490, 8, 183, 1, 184, 1, 184, 1, 184,
		1, 184, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 1, 185, 3, 185, 3502, 8,
		185, 1, 186, 1, 186, 1, 186, 1, 186, 1, 186, 1, 187, 1, 187, 1, 187, 1,
		187, 1, 187, 1, 188, 1, 188, 1, 188, 1, 189, 1, 189, 1, 189, 3, 189, 3520,
		8, 189, 1, 189, 1, 189, 1, 189, 3, 189, 3525, 8, 189, 5, 189, 3527, 8,
		189, 10, 189, 12, 189, 3530, 9, 189, 1, 189, 1, 189, 1, 190, 1, 190, 1,
		191, 1, 191, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 1, 192, 3,
		192, 3545, 8, 192, 1, 192, 1, 192, 1, 193, 1, 193, 1, 193, 1, 193, 1, 193,
		1, 193, 1, 193, 3, 193, 3556, 8, 193, 1, 193, 1, 193, 1, 194, 1, 194, 1,
		194, 1, 194, 1, 194, 1, 194, 1, 194, 3, 194, 3567, 8, 194, 1, 194, 1, 194,
		1, 195, 1, 195, 3, 195, 3573, 8, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1,
		195, 1, 195, 3, 195, 3581, 8, 195, 1, 195, 3, 195, 3584, 8, 195, 1, 195,
		1, 195, 3, 195, 3588, 8, 195, 1, 195, 1, 195, 3, 195, 3592, 8, 195, 1,
		195, 1, 195, 1, 195, 1, 195, 1, 195, 5, 195, 3599, 8, 195, 10, 195, 12,
		195, 3602, 9, 195, 3, 195, 3604, 8, 195, 1, 195, 3, 195, 3607, 8, 195,
		1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 3615, 8, 196, 1,
		196, 1, 196, 1, 196, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1, 197, 1,
		197, 3, 197, 3627, 8, 197, 1, 197, 1, 197, 1, 198, 1, 198, 3, 198, 3633,
		8, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1, 198, 3, 198, 3641, 8,
		198, 1, 198, 3, 198, 3644, 8, 198, 1, 198, 1, 198, 3, 198, 3648, 8, 198,
		1, 198, 1, 198, 3, 198, 3652, 8, 198, 1, 198, 1, 198, 1, 198, 1, 198, 1,
		198, 5, 198, 3659, 8, 198, 10, 198, 12, 198, 3662, 9, 198, 3, 198, 3664,
		8, 198, 1, 198, 3, 198, 3667, 8, 198, 1, 199, 1, 199, 3, 199, 3671, 8,
		199, 1, 199, 1, 199, 1, 199, 3, 199, 3676, 8, 199, 1, 199, 3, 199, 3679,
		8, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3684, 8, 199, 1, 199, 3, 199, 3687,
		8, 199, 1, 200, 1, 200, 1, 200, 1, 200, 5, 200, 3693, 8, 200, 10, 200,
		12, 200, 3696, 9, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 5, 200,
		3703, 8, 200, 10, 200, 12, 200, 3706, 9, 200, 1, 200, 1, 200, 1, 200, 1,
		200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 1, 200, 5, 200, 3718, 8, 200,
		10, 200, 12, 200, 3721, 9, 200, 1, 200, 1, 200, 3, 200, 3725, 8, 200, 1,
		201, 1, 201, 1, 201, 3, 201, 3730, 8, 201, 1, 201, 1, 201, 1, 201, 1, 202,
		1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202, 1, 202,
		3, 202, 3745, 8, 202, 1, 202, 3, 202, 3748, 8, 202, 1, 203, 1, 203, 1,
		203, 1, 203, 3, 203, 3754, 8, 203, 1, 204, 1, 204, 1, 204, 1, 204, 1, 204,
		1, 204, 1, 204, 1, 204, 1, 204, 5, 204, 3765, 8, 204, 10, 204, 12, 204,
		3768, 9, 204, 1, 205, 1, 205, 1, 205, 3, 205, 3773, 8, 205, 1, 205, 1,
		205, 3, 205, 3777, 8, 205, 1, 205, 1, 205, 1, 205, 3, 205, 3782, 8, 205,
		1, 205, 1, 205, 1, 205, 3, 205, 3787, 8, 205, 1, 205, 1, 205, 1, 205, 3,
		205, 3792, 8, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 1, 205, 5, 205,
		3800, 8, 205, 10, 205, 12, 205, 3803, 9, 205, 1, 205, 1, 205, 3, 205, 3807,
		8, 205, 1, 205, 3, 205, 3810, 8, 205, 1, 205, 1, 205, 3, 205, 3814, 8,
		205, 1, 206, 1, 206, 1, 206, 1, 206, 1, 206, 1, 206, 1, 206, 3, 206, 3823,
		8, 206, 1, 207, 1, 207, 1, 207, 3, 207, 3828, 8, 207, 1, 207, 1, 207, 3,
		207, 3832, 8, 207, 1, 207, 1, 207, 1, 207, 1, 207, 1, 207, 5, 207, 3839,
		8, 207, 10, 207, 12, 207, 3842, 9, 207, 3, 207, 3844, 8, 207, 1, 207, 3,
		207, 3847, 8, 207, 1, 208, 1, 208, 1, 208, 3, 208, 3852, 8, 208, 1, 208,
		1, 208, 1, 208, 1, 208, 3, 208, 3858, 8, 208, 1, 208, 1, 208, 1, 208, 1,
		208, 1, 208, 5, 208, 3865, 8, 208, 10, 208, 12, 208, 3868, 9, 208, 3, 208,
		3870, 8, 208, 1, 208, 3, 208, 3873, 8, 208, 1, 209, 1, 209, 1, 209, 1,
		209, 1, 209, 3, 209, 3880, 8, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209,
		5, 209, 3887, 8, 209, 10, 209, 12, 209, 3890, 9, 209, 3, 209, 3892, 8,
		209, 1, 209, 3, 209, 3895, 8, 209, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 3, 210, 3904, 8, 210, 1, 211, 1, 211, 1, 211, 1, 211, 1,
		211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 5, 211, 3918,
		8, 211, 10, 211, 12, 211, 3921, 9, 211, 3, 211, 3923, 8, 211, 1, 212, 1,
		212, 3, 212, 3927, 8, 212, 1, 212, 1, 212, 1, 212, 3, 212, 3932, 8, 212,
		1, 212, 1, 212, 1, 212, 3, 212, 3937, 8, 212, 1, 213, 1, 213, 1, 213, 1,
		213, 1, 214, 1, 214, 1, 214, 1, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1,
		215, 3, 215, 3952, 8, 215, 1, 215, 1, 215, 3, 215, 3956, 8, 215, 1, 215,
		1, 215, 1, 215, 1, 215, 1, 215, 5, 215, 3963, 8, 215, 10, 215, 12, 215,
		3966, 9, 215, 3, 215, 3968, 8, 215, 1, 215, 1, 215, 1, 215, 1, 215, 1,
		215, 5, 215, 3975, 8, 215, 10, 215, 12, 215, 3978, 9, 215, 1, 215, 1, 215,
		1, 216, 1, 216, 1, 216, 1, 216, 1, 216, 1, 217, 1, 217, 1, 217, 1, 217,
		1, 217, 1, 217, 1, 217, 1, 217, 5, 217, 3995, 8, 217, 10, 217, 12, 217,
		3998, 9, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1,
		217, 1, 217, 5, 217, 4009, 8, 217, 10, 217, 12, 217, 4012, 9, 217, 1, 217,
		1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217,
		1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 5, 217,
		4032, 8, 217, 10, 217, 12, 217, 4035, 9, 217, 1, 217, 1, 217, 3, 217, 4039,
		8, 217, 1, 218, 1, 218, 3, 218, 4043, 8, 218, 1, 218, 1, 218, 1, 218, 1,
		218, 1, 218, 3, 218, 4050, 8, 218, 1, 218, 1, 218, 1, 218, 3, 218, 4055,
		8, 218, 3, 218, 4057, 8, 218, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1,
		219, 1, 219, 1, 219, 1, 219, 3, 219, 4068, 8, 219, 1, 220, 1, 220, 3, 220,
		4072, 8, 220, 1, 220, 1, 220, 1, 220, 3, 220, 4077, 8, 220, 1, 221, 1,
		221, 1, 221, 1, 221, 1, 221, 1, 221, 1, 222, 1, 222, 1, 222, 1, 222, 1,
		223, 1, 223, 1, 223, 1, 224, 1, 224, 1, 224, 1, 224, 1, 225, 1, 225, 3,
		225, 4098, 8, 225, 1, 225, 3, 225, 4101, 8, 225, 1, 225, 1, 225, 1, 225,
		3, 225, 4106, 8, 225, 1, 225, 1, 225, 1, 225, 1, 225, 3, 225, 4112, 8,
		225, 1, 226, 1, 226, 3, 226, 4116, 8, 226, 1, 226, 1, 226, 1, 226, 3, 226,
		4121, 8, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 226, 1, 227, 1, 227, 1,
		227, 3, 227, 4131, 8, 227, 1, 227, 3, 227, 4134, 8, 227, 1, 227, 1, 227,
		1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 1, 227, 3, 227,
		4146, 8, 227, 1, 227, 3, 227, 4149, 8, 227, 1, 228, 1, 228, 1, 228, 1,
		229, 3, 229, 4155, 8, 229, 1, 229, 1, 229, 5, 229, 4159, 8, 229, 10, 229,
		12, 229, 4162, 9, 229, 1, 229, 1, 229, 3, 229, 4166, 8, 229, 1, 230, 1,
		230, 1, 230, 1, 230, 3, 230, 4172, 8, 230, 1, 230, 3, 230, 4175, 8, 230,
		1, 230, 1, 230, 3, 230, 4179, 8, 230, 1, 230, 1, 230, 3, 230, 4183, 8,
		230, 1, 230, 1, 230, 1, 230, 1, 230, 3, 230, 4189, 8, 230, 1, 230, 1, 230,
		1, 230, 3, 230, 4194, 8, 230, 3, 230, 4196, 8, 230, 1, 231, 1, 231, 1,
		231, 3, 231, 4201, 8, 231, 1, 231, 1, 231, 1, 232, 1, 232, 1, 232, 1, 232,
		5, 232, 4209, 8, 232, 10, 232, 12, 232, 4212, 9, 232, 1, 232, 1, 232, 1,
		233, 1, 233, 1, 233, 1, 233, 3, 233, 4220, 8, 233, 1, 233, 1, 233, 1, 233,
		1, 233, 3, 233, 4226, 8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4232,
		8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4238, 8, 233, 1, 233, 3,
		233, 4241, 8, 233, 1, 233, 3, 233, 4244, 8, 233, 1, 233, 3, 233, 4247,
		8, 233, 1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4254, 8, 233, 1,
		233, 1, 233, 3, 233, 4258, 8, 233, 1, 233, 1, 233, 3, 233, 4262, 8, 233,
		1, 233, 1, 233, 1, 233, 1, 233, 1, 233, 3, 233, 4269, 8, 233, 1, 233, 1,
		233, 1, 233, 1, 233, 3, 233, 4275, 8, 233, 1, 233, 1, 233, 3, 233, 4279,
		8, 233, 1, 233, 1, 233, 3, 233, 4283, 8, 233, 3, 233, 4285, 8, 233, 1,
		234, 1, 234, 1, 234, 1, 234, 3, 234, 4291, 8, 234, 1, 234, 1, 234, 1, 234,
		3, 234, 4296, 8, 234, 1, 234, 1, 234, 1, 234, 3, 234, 4301, 8, 234, 1,
		234, 1, 234, 1, 234, 3, 234, 4306, 8, 234, 1, 234, 1, 234, 1, 235, 1, 235,
		1, 235, 3, 235, 4313, 8, 235, 1, 235, 1, 235, 1, 235, 1, 235, 3, 235, 4319,
		8, 235, 3, 235, 4321, 8, 235, 1, 236, 1, 236, 1, 236, 1, 236, 3, 236, 4327,
		8, 236, 1, 237, 1, 237, 1, 237, 3, 237, 4332, 8, 237, 1, 237, 1, 237, 3,
		237, 4336, 8, 237, 1, 237, 1, 237, 3, 237, 4340, 8, 237, 1, 237, 1, 237,
		1, 237, 1, 237, 1, 237, 5, 237, 4347, 8, 237, 10, 237, 12, 237, 4350, 9,
		237, 3, 237, 4352, 8, 237, 1, 237, 3, 237, 4355, 8, 237, 1, 238, 1, 238,
		1, 238, 1, 238, 1, 238, 3, 238, 4362, 8, 238, 1, 238, 1, 238, 3, 238, 4366,
		8, 238, 1, 238, 3, 238, 4369, 8, 238, 1, 238, 1, 238, 1, 238, 1, 238, 1,
		238, 3, 238, 4376, 8, 238, 1, 239, 1, 239, 1, 239, 1, 239, 3, 239, 4382,
		8, 239, 1, 239, 1, 239, 3, 239, 4386, 8, 239, 1, 240, 1, 240, 1, 240, 1,
		240, 1, 240, 1, 240, 3, 240, 4394, 8, 240, 1, 240, 1, 240, 3, 240, 4398,
		8, 240, 1, 241, 1, 241, 1, 241, 1, 241, 1, 241, 1, 242, 1, 242, 1, 242,
		1, 243, 1, 243, 1, 243, 1, 244, 1, 244, 1, 244, 1, 245, 1, 245, 1, 245,
		1, 245, 1, 245, 1, 245, 3, 245, 4420, 8, 245, 1, 245, 1, 245, 1, 245, 1,
		245, 3, 245, 4426, 8, 245, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246, 1, 246,
		3, 246, 4434, 8, 246, 1, 247, 1, 247, 1, 247, 1, 247, 3, 247, 4440, 8,
		247, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 1, 248, 3, 248, 4448, 8, 248,
		1, 249, 1, 249, 1, 249, 1, 249, 3, 249, 4454, 8, 249, 1, 249, 1, 249, 1,
		249, 1, 249, 3, 249, 4460, 8, 249, 1, 250, 1, 250, 1, 250, 1, 251, 1, 251,
		1, 251, 1, 252, 1, 252, 1, 252, 1, 253, 1, 253, 1, 253, 1, 254, 1, 254,
		1, 254, 1, 254, 1, 255, 1, 255, 1, 255, 1, 256, 1, 256, 1, 256, 1, 256,
		1, 256, 1, 256, 1, 256, 3, 256, 4488, 8, 256, 1, 257, 1, 257, 1, 257, 1,
		257, 1, 258, 1, 258, 3, 258, 4496, 8, 258, 1, 258, 1, 258, 1, 258, 3, 258,
		4501, 8, 258, 1, 259, 1, 259, 1, 259, 1, 259, 3, 259, 4507, 8, 259, 1,
		260, 1, 260, 1, 260, 1, 260, 1, 260, 3, 260, 4514, 8, 260, 1, 261, 1, 261,
		3, 261, 4518, 8, 261, 1, 261, 1, 261, 1, 261, 1, 261, 1, 261, 3, 261, 4525,
		8, 261, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262, 1, 262,
		3, 262, 4535, 8, 262, 1, 262, 1, 262, 3, 262, 4539, 8, 262, 1, 262, 1,
		262, 1, 262, 1, 262, 1, 262, 5, 262, 4546, 8, 262, 10, 262, 12, 262, 4549,
		9, 262, 3, 262, 4551, 8, 262, 1, 262, 3, 262, 4554, 8, 262, 3, 262, 4556,
		8, 262, 1, 263, 1, 263, 1, 263, 1, 263, 3, 263, 4562, 8, 263, 1, 263, 1,
		263, 3, 263, 4566, 8, 263, 1, 264, 1, 264, 3, 264, 4570, 8, 264, 1, 264,
		1, 264, 1, 264, 3, 264, 4575, 8, 264, 1, 264, 1, 264, 1, 264, 1, 264, 3,
		264, 4581, 8, 264, 1, 265, 1, 265, 1, 265, 1, 265, 3, 265, 4587, 8, 265,
		1, 265, 1, 265, 3, 265, 4591, 8, 265, 1, 265, 1, 265, 1, 265, 1, 265, 3,
		265, 4597, 8, 265, 1, 265, 1, 265, 3, 265, 4601, 8, 265, 3, 265, 4603,
		8, 265, 1, 266, 1, 266, 3, 266, 4607, 8, 266, 1, 266, 1, 266, 1, 266, 1,
		266, 1, 266, 3, 266, 4614, 8, 266, 1, 267, 1, 267, 1, 267, 3, 267, 4619,
		8, 267, 1, 268, 1, 268, 1, 268, 1, 269, 1, 269, 1, 269, 1, 269, 1, 269,
		3, 269, 4629, 8, 269, 1, 269, 1, 269, 3, 269, 4633, 8, 269, 1, 269, 1,
		269, 1, 269, 3, 269, 4638, 8, 269, 1, 269, 3, 269, 4641, 8, 269, 1, 270,
		1, 270, 1, 270, 1, 270, 3, 270, 4647, 8, 270, 1, 270, 1, 270, 1, 271, 1,
		271, 1, 271, 1, 271, 3, 271, 4655, 8, 271, 1, 271, 1, 271, 1, 271, 1, 271,
		1, 271, 1, 271, 1, 271, 3, 271, 4664, 8, 271, 1, 271, 1, 271, 1, 271, 1,
		271, 1, 271, 1, 271, 3, 271, 4672, 8, 271, 1, 271, 1, 271, 1, 271, 1, 271,
		3, 271, 4678, 8, 271, 1, 271, 1, 271, 1, 271, 1, 271, 3, 271, 4684, 8,
		271, 1, 272, 1, 272, 1, 272, 1, 273, 1, 273, 1, 273, 1, 273, 1, 273, 1,
		273, 1, 273, 3, 273, 4696, 8, 273, 3, 273, 4698, 8, 273, 1, 274, 1, 274,
		1, 274, 1, 274, 1, 274, 1, 274, 3, 274, 4706, 8, 274, 1, 275, 1, 275, 1,
		275, 1, 275, 1, 275, 3, 275, 4713, 8, 275, 1, 275, 1, 275, 3, 275, 4717,
		8, 275, 1, 276, 1, 276, 1, 276, 1, 276, 3, 276, 4723, 8, 276, 1, 276, 1,
		276, 1, 276, 1, 276, 1, 276, 1, 276, 1, 277, 1, 277, 1, 277, 1, 277, 3,
		277, 4735, 8, 277, 1, 277, 1, 277, 1, 278, 1, 278, 1, 278, 1, 279, 1, 279,
		1, 279, 1, 279, 3, 279, 4746, 8, 279, 1, 279, 1, 279, 1, 279, 1, 279, 1,
		279, 1, 279, 1, 279, 1, 279, 3, 279, 4756, 8, 279, 1, 280, 1, 280, 1, 280,
		1, 280, 3, 280, 4762, 8, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1,
		280, 1, 280, 1, 280, 3, 280, 4772, 8, 280, 1, 281, 1, 281, 1, 281, 1, 281,
		1, 281, 1, 281, 1, 281, 1, 281, 1, 281, 1, 281, 1, 281, 3, 281, 4785, 8,
		281, 1, 281, 1, 281, 1, 281, 3, 281, 4790, 8, 281, 1, 282, 1, 282, 1, 282,
		1, 282, 1, 282, 1, 282, 3, 282, 4798, 8, 282, 1, 282, 1, 282, 1, 282, 1,
		283, 3, 283, 4804, 8, 283, 1, 283, 1, 283, 1, 283, 3, 283, 4809, 8, 283,
		1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 5, 284, 4818, 8,
		284, 10, 284, 12, 284, 4821, 9, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1,
		284, 3, 284, 4828, 8, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 1, 284, 1, 284, 3, 284, 4839, 8, 284, 1, 284, 1, 284, 1, 284, 1,
		284, 3, 284, 4845, 8, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 3, 284, 4854, 8, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1,
		284, 1, 284, 1, 284, 1, 284, 3, 284, 4865, 8, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 3, 284, 4877, 8,
		284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1, 284, 1,
		284, 1, 284, 1, 284, 3, 284, 4890, 8, 284, 1, 284, 1, 284, 1, 284, 1, 284,
		1, 284, 3, 284, 4897, 8, 284, 3, 284, 4899, 8, 284, 1, 285, 1, 285, 1,
		285, 1, 285, 1, 285, 1, 285, 1, 285, 5, 285, 4908, 8, 285, 10, 285, 12,
		285, 4911, 9, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285,
		1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 4927, 8,
		285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1,
		285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1,
		285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1, 285, 1,
		285, 1, 285, 1, 285, 1, 285, 1, 285, 3, 285, 4960, 8, 285, 1, 285, 1, 285,
		1, 285, 3, 285, 4965, 8, 285, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1,
		286, 3, 286, 4973, 8, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286,
		3, 286, 4981, 8, 286, 1, 287, 1, 287, 1, 287, 3, 287, 4986, 8, 287, 1,
		287, 1, 287, 1, 287, 1, 287, 1, 287, 1, 287, 3, 287, 4994, 8, 287, 3, 287,
		4996, 8, 287, 1, 288, 1, 288, 1, 288, 3, 288, 5001, 8, 288, 1, 289, 1,
		289, 1, 289, 5, 289, 5006, 8, 289, 10, 289, 12, 289, 5009, 9, 289, 1, 290,
		1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290,
		5, 290, 5021, 8, 290, 10, 290, 12, 290, 5024, 9, 290, 1, 291, 1, 291, 1,
		291, 5, 291, 5029, 8, 291, 10, 291, 12, 291, 5032, 9, 291, 1, 292, 1, 292,
		3, 292, 5036, 8, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1,
		292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1,
		292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 3, 292, 5059, 8, 292, 1, 292,
		1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292,
		1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 1, 292, 3, 292, 5077, 8, 292, 1,
		293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1, 293, 1,
		293, 1, 293, 1, 293, 1, 293, 1, 293, 3, 293, 5093, 8, 293, 1, 294, 1, 294,
		1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294,
		1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 3, 294, 5113, 8,
		294, 1, 295, 1, 295, 1, 295, 1, 295, 1, 295, 1, 295, 1, 296, 1, 296, 1,
		296, 1, 296, 1, 296, 1, 296, 1, 296, 1, 297, 1, 297, 1, 297, 1, 297, 1,
		297, 1, 298, 1, 298, 1, 298, 1, 298, 1, 299, 1, 299, 1, 299, 1, 299, 1,
		299, 1, 299, 1, 300, 1, 300, 1, 300, 1, 300, 1, 300, 1, 300, 3, 300, 5149,
		8, 300, 1, 300, 1, 300, 1, 300, 1, 301, 1, 301, 1, 301, 1, 301, 1, 301,
		3, 301, 5159, 8, 301, 1, 301, 1, 301, 1, 302, 1, 302, 1, 302, 1, 302, 1,
		303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 304, 1, 304, 1, 304, 1,
		304, 1, 304, 1, 304, 1, 304, 3, 304, 5180, 8, 304, 1, 304, 1, 304, 3, 304,
		5184, 8, 304, 1, 304, 1, 304, 1, 304, 1, 304, 1, 304, 1, 304, 1, 304, 1,
		304, 1, 304, 5, 304, 5195, 8, 304, 10, 304, 12, 304, 5198, 9, 304, 1, 304,
		1, 304, 3, 304, 5202, 8, 304, 1, 304, 1, 304, 3, 304, 5206, 8, 304, 1,
		305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 1, 305, 3, 305, 5215, 8, 305,
		1, 306, 1, 306, 1, 306, 1, 306, 3, 306, 5221, 8, 306, 1, 307, 1, 307, 1,
		307, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 3,
		307, 5234, 8, 307, 1, 307, 1, 307, 1, 307, 1, 307, 3, 307, 5240, 8, 307,
		3, 307, 5242, 8, 307, 1, 307, 1, 307, 1, 307, 1, 307, 1, 307, 5, 307, 5249,
		8, 307, 10, 307, 12, 307, 5252, 9, 307, 1, 307, 1, 307, 3, 307, 5256, 8,
		307, 1, 307, 1, 307, 3, 307, 5260, 8, 307, 1, 308, 1, 308, 1, 308, 1, 308,
		1, 308, 1, 308, 1, 308, 3, 308, 5269, 8, 308, 1, 309, 1, 309, 1, 309, 1,
		309, 3, 309, 5275, 8, 309, 1, 309, 1, 309, 3, 309, 5279, 8, 309, 1, 310,
		1, 310, 1, 310, 1, 310, 1, 310, 1, 310, 3, 310, 5287, 8, 310, 1, 311, 1,
		311, 1, 311, 3, 311, 5292, 8, 311, 1, 311, 1, 311, 1, 311, 1, 311, 1, 311,
		3, 311, 5299, 8, 311, 1, 311, 1, 311, 1, 311, 1, 311, 1, 311, 3, 311, 5306,
		8, 311, 1, 312, 1, 312, 1, 312, 1, 312, 1, 313, 1, 313, 1, 313, 1, 313,
		1, 314, 1, 314, 1, 314, 1, 314, 1, 314, 5, 314, 5321, 8, 314, 10, 314,
		12, 314, 5324, 9, 314, 1, 315, 1, 315, 1, 315, 1, 316, 1, 316, 1, 316,
		1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 1, 317, 5, 317, 5338, 8, 317, 10,
		317, 12, 317, 5341, 9, 317, 1, 318, 1, 318, 1, 318, 1, 318, 1, 318, 1,
		318, 5, 318, 5349, 8, 318, 10, 318, 12, 318, 5352, 9, 318, 1, 319, 1, 319,
		1, 319, 1, 319, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 320, 1, 321,
		1, 321, 1, 321, 1, 321, 1, 321, 1, 321, 3, 321, 5370, 8, 321, 1, 321, 1,
		321, 1, 321, 3, 321, 5375, 8, 321, 1, 321, 1, 321, 3, 321, 5379, 8, 321,
		1, 322, 1, 322, 1, 322, 1, 322, 1, 323, 1, 323, 1, 323, 1, 323, 1, 323,
		1, 324, 1, 324, 1, 324, 1, 324, 1, 325, 1, 325, 1, 325, 1, 325, 1, 325,
		5, 325, 5399, 8, 325, 10, 325, 12, 325, 5402, 9, 325, 1, 325, 1, 325, 1,
		325, 1, 325, 3, 325, 5408, 8, 325, 1, 325, 3, 325, 5411, 8, 325, 1, 326,
		1, 326, 1, 326, 1, 326, 3, 326, 5417, 8, 326, 1, 326, 1, 326, 1, 326, 1,
		326, 1, 326, 3, 326, 5424, 8, 326, 1, 326, 3, 326, 5427, 8, 326, 1, 326,
		3, 326, 5430, 8, 326, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 5436, 8,
		327, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 5442, 8, 327, 1, 328, 1, 328,
		1, 328, 1, 328, 3, 328, 5448, 8, 328, 1, 328, 1, 328, 1, 328, 1, 328, 3,
		328, 5454, 8, 328, 1, 328, 1, 328, 1, 328, 1, 328, 1, 328, 5, 328, 5461,
		8, 328, 10, 328, 12, 328, 5464, 9, 328, 3, 328, 5466, 8, 328, 1, 328, 3,
		328, 5469, 8, 328, 1, 329, 1, 329, 1, 329, 1, 329, 1, 329, 3, 329, 5476,
		8, 329, 1, 330, 1, 330, 1, 330, 1, 330, 1, 331, 1, 331, 1, 331, 1, 331,
		1, 331, 3, 331, 5487, 8, 331, 1, 331, 1, 331, 1, 332, 1, 332, 1, 332, 1,
		332, 1, 332, 3, 332, 5496, 8, 332, 1, 332, 1, 332, 1, 333, 1, 333, 1, 333,
		1, 333, 3, 333, 5504, 8, 333, 1, 334, 1, 334, 1, 334, 1, 334, 1, 334, 1,
		334, 3, 334, 5512, 8, 334, 1, 334, 1, 334, 1, 334, 1, 335, 1, 335, 1, 335,
		1, 335, 3, 335, 5521, 8, 335, 1, 335, 1, 335, 1, 336, 1, 336, 1, 336, 1,
		336, 1, 336, 1, 336, 1, 336, 1, 336, 1, 336, 3, 336, 5534, 8, 336, 1, 337,
		1, 337, 1, 337, 1, 337, 1, 337, 1, 338, 1, 338, 1, 338, 1, 338, 1, 339,
		1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 3, 339, 5553, 8,
		339, 1, 339, 1, 339, 1, 339, 1, 339, 1, 339, 5, 339, 5560, 8, 339, 10,
		339, 12, 339, 5563, 9, 339, 3, 339, 5565, 8, 339, 1, 339, 3, 339, 5568,
		8, 339, 1, 340, 1, 340, 1, 340, 1, 340, 5, 340, 5574, 8, 340, 10, 340,
		12, 340, 5577, 9, 340, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 3, 341,
		5584, 8, 341, 1, 341, 1, 341, 3, 341, 5588, 8, 341, 1, 341, 1, 341, 1,
		341, 3, 341, 5593, 8, 341, 1, 341, 1, 341, 1, 341, 3, 341, 5598, 8, 341,
		3, 341, 5600, 8, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1,
		341, 1, 341, 3, 341, 5610, 8, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341,
		1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 3, 341, 5622, 8, 341, 1, 341, 1,
		341, 1, 341, 1, 341, 1, 341, 3, 341, 5629, 8, 341, 1, 341, 1, 341, 1, 341,
		1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 1, 341, 3, 341, 5640, 8, 341, 1,
		341, 1, 341, 3, 341, 5644, 8, 341, 1, 342, 1, 342, 1, 342, 1, 342, 1, 342,
		1, 342, 1, 342, 1, 342, 1, 342, 1, 342, 3, 342, 5656, 8, 342, 1, 343, 1,
		343, 1, 343, 1, 343, 3, 343, 5662, 8, 343, 1, 344, 1, 344, 1, 344, 1, 344,
		1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 1, 345, 3, 345, 5675, 8,
		345, 1, 346, 1, 346, 1, 346, 1, 346, 3, 346, 5681, 8, 346, 1, 347, 1, 347,
		1, 347, 1, 347, 3, 347, 5687, 8, 347, 1, 347, 1, 347, 1, 348, 1, 348, 1,
		348, 5, 348, 5694, 8, 348, 10, 348, 12, 348, 5697, 9, 348, 1, 349, 1, 349,
		1, 349, 1, 349, 1, 349, 1, 349, 1, 350, 1, 350, 1, 350, 1, 350, 1, 350,
		5, 350, 5710, 8, 350, 10, 350, 12, 350, 5713, 9, 350, 1, 350, 1, 350, 3,
		350, 5717, 8, 350, 1, 351, 1, 351, 3, 351, 5721, 8, 351, 1, 351, 3, 351,
		5724, 8, 351, 1, 351, 1, 351, 1, 352, 1, 352, 3, 352, 5730, 8, 352, 1,
		352, 3, 352, 5733, 8, 352, 1, 352, 3, 352, 5736, 8, 352, 1, 353, 1, 353,
		1, 353, 1, 353, 1, 353, 1, 353, 1, 354, 1, 354, 1, 354, 1, 354, 1, 355,
		1, 355, 1, 355, 1, 355, 1, 355, 1, 355, 1, 356, 1, 356, 1, 356, 1, 356,
		1, 357, 1, 357, 1, 357, 1, 357, 1, 357, 3, 357, 5763, 8, 357, 1, 357, 1,
		357, 3, 357, 5767, 8, 357, 1, 357, 3, 357, 5770, 8, 357, 1, 358, 1, 358,
		1, 358, 1, 358, 3, 358, 5776, 8, 358, 1, 358, 1, 358, 1, 359, 1, 359, 1,
		359, 1, 359, 3, 359, 5784, 8, 359, 1, 359, 1, 359, 1, 360, 1, 360, 1, 360,
		1, 360, 3, 360, 5792, 8, 360, 1, 360, 1, 360, 1, 361, 1, 361, 3, 361, 5798,
		8, 361, 1, 361, 1, 361, 3, 361, 5802, 8, 361, 1, 361, 1, 361, 1, 362, 1,
		362, 1, 362, 1, 362, 3, 362, 5810, 8, 362, 1, 363, 1, 363, 1, 363, 1, 363,
		1, 363, 1, 363, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 3, 364,
		5824, 8, 364, 1, 364, 1, 364, 1, 364, 1, 364, 1, 364, 3, 364, 5831, 8,
		364, 1, 365, 1, 365, 1, 365, 1, 365, 1, 365, 1, 366, 1, 366, 1, 366, 1,
		366, 1, 366, 3, 366, 5843, 8, 366, 1, 366, 1, 366, 3, 366, 5847, 8, 366,
		3, 366, 5849, 8, 366, 1, 367, 1, 367, 3, 367, 5853, 8, 367, 1, 367, 1,
		367, 3, 367, 5857, 8, 367, 1, 367, 3, 367, 5860, 8, 367, 1, 367, 3, 367,
		5863, 8, 367, 1, 367, 3, 367, 5866, 8, 367, 1, 368, 1, 368, 3, 368, 5870,
		8, 368, 1, 368, 1, 368, 3, 368, 5874, 8, 368, 1, 368, 3, 368, 5877, 8,
		368, 1, 368, 3, 368, 5880, 8, 368, 1, 368, 3, 368, 5883, 8, 368, 1, 369,
		1, 369, 1, 369, 1, 369, 1, 370, 1, 370, 1, 371, 4, 371, 5892, 8, 371, 11,
		371, 12, 371, 5893, 1, 372, 1, 372, 3, 372, 5898, 8, 372, 1, 372, 1, 372,
		3, 372, 5902, 8, 372, 1, 373, 3, 373, 5905, 8, 373, 1, 373, 1, 373, 1,
		374, 1, 374, 1, 374, 1, 374, 5, 374, 5913, 8, 374, 10, 374, 12, 374, 5916,
		9, 374, 1, 375, 1, 375, 1, 375, 1, 375, 1, 375, 1, 375, 5, 375, 5924, 8,
		375, 10, 375, 12, 375, 5927, 9, 375, 3, 375, 5929, 8, 375, 1, 375, 3, 375,
		5932, 8, 375, 1, 376, 3, 376, 5935, 8, 376, 1, 376, 1, 376, 1, 376, 1,
		376, 1, 376, 1, 376, 1, 376, 3, 376, 5944, 8, 376, 1, 376, 1, 376, 1, 376,
		1, 376, 1, 376, 1, 376, 1, 376, 3, 376, 5953, 8, 376, 1, 376, 1, 376, 1,
		376, 1, 376, 3, 376, 5959, 8, 376, 1, 376, 1, 376, 1, 376, 1, 376, 1, 376,
		3, 376, 5966, 8, 376, 1, 377, 1, 377, 1, 378, 1, 378, 1, 378, 3, 378, 5973,
		8, 378, 1, 378, 1, 378, 1, 378, 3, 378, 5978, 8, 378, 1, 378, 1, 378, 1,
		378, 1, 378, 3, 378, 5984, 8, 378, 1, 378, 5, 378, 5987, 8, 378, 10, 378,
		12, 378, 5990, 9, 378, 1, 379, 1, 379, 1, 379, 1, 379, 1, 380, 1, 380,
		1, 380, 1, 380, 1, 381, 1, 381, 3, 381, 6002, 8, 381, 1, 381, 1, 381, 3,
		381, 6006, 8, 381, 1, 382, 1, 382, 1, 382, 3, 382, 6011, 8, 382, 1, 383,
		1, 383, 1, 383, 1, 383, 3, 383, 6017, 8, 383, 1, 383, 1, 383, 1, 383, 1,
		383, 1, 383, 3, 383, 6024, 8, 383, 1, 384, 1, 384, 3, 384, 6028, 8, 384,
		1, 384, 1, 384, 1, 384, 5, 384, 6033, 8, 384, 10, 384, 12, 384, 6036, 9,
		384, 1, 384, 1, 384, 1, 384, 3, 384, 6041, 8, 384, 1, 384, 1, 384, 1, 384,
		3, 384, 6046, 8, 384, 1, 384, 1, 384, 3, 384, 6050, 8, 384, 1, 384, 1,
		384, 1, 384, 1, 384, 1, 384, 3, 384, 6057, 8, 384, 1, 385, 1, 385, 1, 385,
		3, 385, 6062, 8, 385, 3, 385, 6064, 8, 385, 1, 385, 1, 385, 3, 385, 6068,
		8, 385, 1, 386, 1, 386, 1, 386, 3, 386, 6073, 8, 386, 1, 386, 1, 386, 1,
		386, 1, 386, 3, 386, 6079, 8, 386, 1, 386, 1, 386, 1, 386, 1, 386, 1, 386,
		1, 386, 1, 386, 5, 386, 6088, 8, 386, 10, 386, 12, 386, 6091, 9, 386, 1,
		386, 1, 386, 1, 386, 3, 386, 6096, 8, 386, 1, 387, 1, 387, 3, 387, 6100,
		8, 387, 1, 387, 1, 387, 5, 387, 6104, 8, 387, 10, 387, 12, 387, 6107, 9,
		387, 1, 387, 1, 387, 1, 388, 1, 388, 3, 388, 6113, 8, 388, 1, 388, 1, 388,
		1, 388, 1, 388, 1, 388, 1, 389, 1, 389, 1, 390, 1, 390, 3, 390, 6124, 8,
		390, 1, 390, 1, 390, 3, 390, 6128, 8, 390, 3, 390, 6130, 8, 390, 1, 390,
		1, 390, 1, 390, 1, 390, 1, 390, 3, 390, 6137, 8, 390, 1, 391, 1, 391, 1,
		391, 3, 391, 6142, 8, 391, 1, 391, 5, 391, 6145, 8, 391, 10, 391, 12, 391,
		6148, 9, 391, 1, 392, 1, 392, 5, 392, 6152, 8, 392, 10, 392, 12, 392, 6155,
		9, 392, 1, 392, 1, 392, 1, 392, 5, 392, 6160, 8, 392, 10, 392, 12, 392,
		6163, 9, 392, 1, 392, 1, 392, 3, 392, 6167, 8, 392, 1, 393, 1, 393, 3,
		393, 6171, 8, 393, 1, 393, 3, 393, 6174, 8, 393, 1, 393, 3, 393, 6177,
		8, 393, 1, 393, 3, 393, 6180, 8, 393, 1, 393, 3, 393, 6183, 8, 393, 1,
		393, 3, 393, 6186, 8, 393, 1, 393, 3, 393, 6189, 8, 393, 1, 393, 3, 393,
		6192, 8, 393, 1, 393, 1, 393, 3, 393, 6196, 8, 393, 1, 393, 1, 393, 1,
		393, 1, 393, 1, 393, 5, 393, 6203, 8, 393, 10, 393, 12, 393, 6206, 9, 393,
		1, 393, 1, 393, 3, 393, 6210, 8, 393, 1, 393, 1, 393, 3, 393, 6214, 8,
		393, 3, 393, 6216, 8, 393, 1, 393, 1, 393, 3, 393, 6220, 8, 393, 1, 393,
		1, 393, 3, 393, 6224, 8, 393, 3, 393, 6226, 8, 393, 1, 393, 1, 393, 1,
		393, 1, 393, 1, 393, 3, 393, 6233, 8, 393, 1, 393, 1, 393, 3, 393, 6237,
		8, 393, 3, 393, 6239, 8, 393, 1, 393, 1, 393, 1, 393, 1, 393, 1, 393, 1,
		393, 1, 393, 1, 393, 3, 393, 6249, 8, 393, 1, 393, 1, 393, 3, 393, 6253,
		8, 393, 3, 393, 6255, 8, 393, 1, 393, 1, 393, 1, 393, 3, 393, 6260, 8,
		393, 1, 393, 1, 393, 3, 393, 6264, 8, 393, 3, 393, 6266, 8, 393, 1, 393,
		1, 393, 1, 393, 1, 393, 3, 393, 6272, 8, 393, 1, 394, 1, 394, 1, 394, 1,
		394, 1, 394, 5, 394, 6279, 8, 394, 10, 394, 12, 394, 6282, 9, 394, 1, 394,
		1, 394, 1, 394, 3, 394, 6287, 8, 394, 1, 394, 1, 394, 1, 394, 1, 394, 1,
		394, 5, 394, 6294, 8, 394, 10, 394, 12, 394, 6297, 9, 394, 1, 394, 1, 394,
		1, 394, 1, 395, 1, 395, 3, 395, 6304, 8, 395, 1, 395, 1, 395, 3, 395, 6308,
		8, 395, 3, 395, 6310, 8, 395, 1, 396, 1, 396, 3, 396, 6314, 8, 396, 1,
		396, 3, 396, 6317, 8, 396, 1, 396, 1, 396, 3, 396, 6321, 8, 396, 3, 396,
		6323, 8, 396, 1, 397, 1, 397, 3, 397, 6327, 8, 397, 1, 398, 1, 398, 3,
		398, 6331, 8, 398, 1, 399, 1, 399, 1, 399, 5, 399, 6336, 8, 399, 10, 399,
		12, 399, 6339, 9, 399, 1, 400, 1, 400, 1, 400, 1, 400, 1, 401, 1, 401,
		3, 401, 6347, 8, 401, 1, 401, 3, 401, 6350, 8, 401, 1, 401, 1, 401, 3,
		401, 6354, 8, 401, 1, 401, 1, 401, 3, 401, 6358, 8, 401, 1, 401, 3, 401,
		6361, 8, 401, 1, 401, 1, 401, 1, 401, 3, 401, 6366, 8, 401, 1, 402, 1,
		402, 1, 402, 1, 402, 1, 402, 1, 402, 3, 402, 6374, 8, 402, 1, 403, 1, 403,
		1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403,
		1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403,
		1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403, 3, 403, 6403, 8,
		403, 1, 404, 1, 404, 1, 404, 1, 404, 5, 404, 6409, 8, 404, 10, 404, 12,
		404, 6412, 9, 404, 1, 404, 1, 404, 1, 404, 1, 404, 1, 404, 1, 404, 1, 404,
		1, 404, 1, 404, 3, 404, 6423, 8, 404, 1, 405, 1, 405, 1, 405, 1, 405, 1,
		406, 1, 406, 1, 406, 1, 406, 1, 406, 1, 406, 1, 406, 5, 406, 6436, 8, 406,
		10, 406, 12, 406, 6439, 9, 406, 1, 406, 1, 406, 3, 406, 6443, 8, 406, 1,
		407, 1, 407, 1, 407, 1, 407, 5, 407, 6449, 8, 407, 10, 407, 12, 407, 6452,
		9, 407, 1, 407, 1, 407, 1, 408, 3, 408, 6457, 8, 408, 1, 408, 1, 408, 1,
		408, 1, 408, 1, 408, 5, 408, 6464, 8, 408, 10, 408, 12, 408, 6467, 9, 408,
		1, 408, 1, 408, 1, 408, 3, 408, 6472, 8, 408, 1, 408, 1, 408, 1, 408, 3,
		408, 6477, 8, 408, 1, 409, 1, 409, 1, 409, 1, 409, 1, 409, 5, 409, 6484,
		8, 409, 10, 409, 12, 409, 6487, 9, 409, 1, 409, 1, 409, 1, 410, 1, 410,
		1, 410, 1, 410, 1, 410, 5, 410, 6496, 8, 410, 10, 410, 12, 410, 6499, 9,
		410, 1, 410, 1, 410, 1, 411, 1, 411, 1, 411, 1, 411, 1, 411, 1, 412, 1,
		412, 3, 412, 6510, 8, 412, 1, 413, 1, 413, 1, 413, 1, 413, 1, 413, 1, 413,
		1, 413, 1, 413, 5, 413, 6520, 8, 413, 10, 413, 12, 413, 6523, 9, 413, 3,
		413, 6525, 8, 413, 1, 414, 1, 414, 1, 414, 1, 414, 1, 415, 1, 415, 1, 415,
		1, 415, 1, 415, 5, 415, 6536, 8, 415, 10, 415, 12, 415, 6539, 9, 415, 1,
		415, 1, 415, 1, 416, 1, 416, 1, 416, 1, 416, 5, 416, 6547, 8, 416, 10,
		416, 12, 416, 6550, 9, 416, 1, 416, 1, 416, 1, 417, 1, 417, 3, 417, 6556,
		8, 417, 1, 418, 1, 418, 1, 418, 5, 418, 6561, 8, 418, 10, 418, 12, 418,
		6564, 9, 418, 1, 419, 1, 419, 1, 419, 1, 419, 1, 420, 1, 420, 1, 420, 1,
		421, 1, 421, 3, 421, 6575, 8, 421, 1, 421, 1, 421, 1, 421, 3, 421, 6580,
		8, 421, 1, 421, 1, 421, 1, 421, 1, 421, 1, 421, 1, 421, 5, 421, 6588, 8,
		421, 10, 421, 12, 421, 6591, 9, 421, 1, 422, 1, 422, 1, 422, 5, 422, 6596,
		8, 422, 10, 422, 12, 422, 6599, 9, 422, 1, 423, 1, 423, 1, 423, 1, 423,
		1, 423, 1, 423, 3, 423, 6607, 8, 423, 1, 423, 1, 423, 1, 423, 1, 423, 1,
		423, 1, 423, 1, 423, 1, 423, 1, 423, 1, 423, 1, 423, 5, 423, 6620, 8, 423,
		10, 423, 12, 423, 6623, 9, 423, 1, 424, 1, 424, 3, 424, 6627, 8, 424, 1,
		424, 3, 424, 6630, 8, 424, 1, 425, 1, 425, 1, 425, 1, 425, 4, 425, 6636,
		8, 425, 11, 425, 12, 425, 6637, 1, 425, 1, 425, 3, 425, 6642, 8, 425, 1,
		425, 1, 425, 1, 425, 1, 425, 1, 425, 1, 426, 3, 426, 6650, 8, 426, 1, 426,
		1, 426, 1, 426, 3, 426, 6655, 8, 426, 1, 426, 1, 426, 1, 426, 3, 426, 6660,
		8, 426, 1, 426, 1, 426, 1, 426, 1, 426, 1, 426, 1, 426, 3, 426, 6668, 8,
		426, 1, 426, 1, 426, 1, 426, 1, 426, 1, 426, 1, 426, 3, 426, 6676, 8, 426,
		1, 426, 1, 426, 1, 426, 1, 426, 1, 426, 1, 426, 3, 426, 6684, 8, 426, 1,
		426, 1, 426, 3, 426, 6688, 8, 426, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427,
		1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427,
		1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427, 1, 427,
		1, 427, 1, 427, 1, 427, 1, 427, 5, 427, 6717, 8, 427, 10, 427, 12, 427,
		6720, 9, 427, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1,
		428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1,
		428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1,
		428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1,
		428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1,
		428, 1, 428, 1, 428, 1, 428, 4, 428, 6769, 8, 428, 11, 428, 12, 428, 6770,
		1, 428, 1, 428, 3, 428, 6775, 8, 428, 1, 428, 1, 428, 1, 428, 1, 428, 4,
		428, 6781, 8, 428, 11, 428, 12, 428, 6782, 1, 428, 1, 428, 3, 428, 6787,
		8, 428, 1, 428, 1, 428, 1, 428, 3, 428, 6792, 8, 428, 1, 428, 1, 428, 3,
		428, 6796, 8, 428, 1, 428, 1, 428, 1, 428, 1, 428, 3, 428, 6802, 8, 428,
		1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 3, 428, 6809, 8, 428, 1, 428, 1,
		428, 1, 428, 3, 428, 6814, 8, 428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428,
		1, 428, 1, 428, 3, 428, 6823, 8, 428, 1, 428, 1, 428, 3, 428, 6827, 8,
		428, 1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 3, 428, 6834, 8, 428, 1, 428,
		1, 428, 1, 428, 1, 428, 1, 428, 1, 428, 3, 428, 6842, 8, 428, 1, 428, 1,
		428, 1, 428, 1, 428, 3, 428, 6848, 8, 428, 1, 428, 1, 428, 1, 428, 1, 428,
		1, 428, 1, 428, 1, 428, 1, 428, 3, 428, 6858, 8, 428, 1, 428, 1, 428, 3,
		428, 6862, 8, 428, 1, 428, 1, 428, 1, 428, 1, 428, 5, 428, 6868, 8, 428,
		10, 428, 12, 428, 6871, 9, 428, 1, 429, 1, 429, 1, 429, 1, 429, 1, 429,
		1, 429, 1, 429, 1, 429, 1, 429, 1, 429, 3, 429, 6883, 8, 429, 1, 430, 1,
		430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1,
		430, 1, 430, 5, 430, 6897, 8, 430, 10, 430, 12, 430, 6900, 9, 430, 3, 430,
		6902, 8, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 5, 430, 6910,
		8, 430, 10, 430, 12, 430, 6913, 9, 430, 3, 430, 6915, 8, 430, 1, 430, 1,
		430, 1, 430, 1, 430, 1, 430, 1, 430, 3, 430, 6923, 8, 430, 1, 430, 1, 430,
		1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 1, 430, 5, 430, 6933, 8, 430, 10,
		430, 12, 430, 6936, 9, 430, 3, 430, 6938, 8, 430, 1, 430, 1, 430, 1, 430,
		1, 430, 1, 430, 1, 430, 5, 430, 6946, 8, 430, 10, 430, 12, 430, 6949, 9,
		430, 3, 430, 6951, 8, 430, 1, 430, 1, 430, 3, 430, 6955, 8, 430, 3, 430,
		6957, 8, 430, 1, 431, 1, 431, 1, 431, 3, 431, 6962, 8, 431, 1, 431, 1,
		431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431, 6970, 8, 431, 1, 431, 1, 431,
		1, 431, 1, 431, 1, 431, 3, 431, 6977, 8, 431, 3, 431, 6979, 8, 431, 1,
		431, 1, 431, 1, 431, 5, 431, 6984, 8, 431, 10, 431, 12, 431, 6987, 9, 431,
		3, 431, 6989, 8, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431, 6995, 8,
		431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431, 7003, 8, 431,
		1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431, 7011, 8, 431, 1,
		431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 3, 431, 7019, 8, 431, 1, 431,
		1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 5, 431, 7027, 8, 431, 10, 431,
		12, 431, 7030, 9, 431, 3, 431, 7032, 8, 431, 1, 431, 1, 431, 1, 431, 1,
		431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 1, 431, 5, 431, 7044, 8, 431,
		10, 431, 12, 431, 7047, 9, 431, 3, 431, 7049, 8, 431, 1, 431, 1, 431, 1,
		431, 1, 431, 1, 431, 3, 431, 7056, 8, 431, 1, 431, 1, 431, 1, 431, 5, 431,
		7061, 8, 431, 10, 431, 12, 431, 7064, 9, 431, 1, 431, 1, 431, 1, 431, 1,
		431, 1, 431, 5, 431, 7071, 8, 431, 10, 431, 12, 431, 7074, 9, 431, 3, 431,
		7076, 8, 431, 1, 431, 1, 431, 3, 431, 7080, 8, 431, 1, 431, 1, 431, 3,
		431, 7084, 8, 431, 1, 432, 1, 432, 1, 432, 1, 433, 1, 433, 1, 433, 1, 433,
		1, 433, 3, 433, 7094, 8, 433, 1, 433, 1, 433, 1, 434, 1, 434, 1, 435, 1,
		435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1, 435, 1,
		435, 1, 435, 1, 435, 1, 435, 1, 435, 3, 435, 7115, 8, 435, 1, 435, 1, 435,
		1, 435, 3, 435, 7120, 8, 435, 1, 435, 1, 435, 1, 435, 3, 435, 7125, 8,
		435, 3, 435, 7127, 8, 435, 1, 436, 1, 436, 1, 436, 3, 436, 7132, 8, 436,
		1, 436, 1, 436, 1, 436, 3, 436, 7137, 8, 436, 1, 436, 1, 436, 1, 436, 3,
		436, 7142, 8, 436, 1, 436, 3, 436, 7145, 8, 436, 1, 436, 1, 436, 1, 436,
		3, 436, 7150, 8, 436, 1, 436, 1, 436, 1, 436, 3, 436, 7155, 8, 436, 3,
		436, 7157, 8, 436, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437,
		1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437,
		1, 437, 1, 437, 1, 437, 1, 437, 5, 437, 7179, 8, 437, 10, 437, 12, 437,
		7182, 9, 437, 3, 437, 7184, 8, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1,
		437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1,
		437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1,
		437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1,
		437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1,
		437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 5,
		437, 7235, 8, 437, 10, 437, 12, 437, 7238, 9, 437, 3, 437, 7240, 8, 437,
		1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437,
		1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437,
		1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437,
		1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437,
		1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437,
		1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437, 1, 437,
		1, 437, 1, 437, 1, 437, 1, 437, 3, 437, 7300, 8, 437, 1, 438, 1, 438, 1,
		438, 1, 438, 1, 438, 1, 438, 1, 438, 1, 438, 1, 438, 1, 438, 1, 438, 1,
		438, 1, 438, 1, 438, 1, 438, 1, 438, 1, 438, 1, 438, 3, 438, 7320, 8, 438,
		1, 438, 1, 438, 1, 438, 1, 438, 1, 438, 3, 438, 7327, 8, 438, 1, 438, 1,
		438, 5, 438, 7331, 8, 438, 10, 438, 12, 438, 7334, 9, 438, 3, 438, 7336,
		8, 438, 1, 438, 1, 438, 3, 438, 7340, 8, 438, 1, 438, 1, 438, 1, 438, 1,
		438, 3, 438, 7346, 8, 438, 1, 438, 1, 438, 5, 438, 7350, 8, 438, 10, 438,
		12, 438, 7353, 9, 438, 3, 438, 7355, 8, 438, 1, 438, 1, 438, 3, 438, 7359,
		8, 438, 1, 438, 1, 438, 1, 438, 1, 438, 3, 438, 7365, 8, 438, 1, 438, 1,
		438, 5, 438, 7369, 8, 438, 10, 438, 12, 438, 7372, 9, 438, 3, 438, 7374,
		8, 438, 1, 438, 1, 438, 3, 438, 7378, 8, 438, 1, 438, 1, 438, 1, 438, 1,
		438, 3, 438, 7384, 8, 438, 1, 438, 1, 438, 5, 438, 7388, 8, 438, 10, 438,
		12, 438, 7391, 9, 438, 3, 438, 7393, 8, 438, 1, 438, 1, 438, 3, 438, 7397,
		8, 438, 3, 438, 7399, 8, 438, 1, 439, 1, 439, 1, 439, 1, 439, 1, 439, 1,
		440, 1, 440, 1, 440, 3, 440, 7409, 8, 440, 1, 440, 1, 440, 1, 440, 1, 440,
		1, 440, 5, 440, 7416, 8, 440, 10, 440, 12, 440, 7419, 9, 440, 3, 440, 7421,
		8, 440, 1, 440, 1, 440, 1, 440, 1, 440, 1, 440, 5, 440, 7428, 8, 440, 10,
		440, 12, 440, 7431, 9, 440, 3, 440, 7433, 8, 440, 1, 440, 3, 440, 7436,
		8, 440, 1, 440, 1, 440, 1, 441, 1, 441, 1, 441, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442, 1, 442,
		1, 442, 1, 442, 1, 442, 1, 442, 3, 442, 7459, 8, 442, 1, 443, 1, 443, 1,
		443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 1, 443, 3, 443, 7470, 8, 443,
		1, 444, 1, 444, 1, 444, 1, 444, 1, 444, 1, 444, 1, 444, 3, 444, 7479, 8,
		444, 3, 444, 7481, 8, 444, 1, 444, 1, 444, 1, 444, 1, 444, 3, 444, 7487,
		8, 444, 1, 444, 1, 444, 1, 444, 1, 444, 1, 444, 1, 444, 1, 444, 1, 444,
		3, 444, 7497, 8, 444, 3, 444, 7499, 8, 444, 1, 444, 1, 444, 1, 444, 1,
		444, 1, 444, 1, 444, 3, 444, 7507, 8, 444, 3, 444, 7509, 8, 444, 3, 444,
		7511, 8, 444, 1, 445, 1, 445, 3, 445, 7515, 8, 445, 1, 446, 1, 446, 3,
		446, 7519, 8, 446, 1, 446, 1, 446, 3, 446, 7523, 8, 446, 1, 447, 1, 447,
		3, 447, 7527, 8, 447, 1, 448, 1, 448, 1, 448, 3, 448, 7532, 8, 448, 1,
		449, 1, 449, 3, 449, 7536, 8, 449, 1, 450, 1, 450, 1, 450, 1, 450, 1, 450,
		1, 450, 1, 450, 1, 450, 5, 450, 7546, 8, 450, 10, 450, 12, 450, 7549, 9,
		450, 3, 450, 7551, 8, 450, 1, 450, 1, 450, 1, 450, 1, 450, 1, 450, 1, 450,
		1, 450, 1, 450, 1, 450, 1, 450, 5, 450, 7563, 8, 450, 10, 450, 12, 450,
		7566, 9, 450, 3, 450, 7568, 8, 450, 1, 450, 1, 450, 1, 450, 1, 450, 1,
		450, 3, 450, 7575, 8, 450, 1, 450, 1, 450, 1, 450, 1, 450, 1, 450, 5, 450,
		7582, 8, 450, 10, 450, 12, 450, 7585, 9, 450, 3, 450, 7587, 8, 450, 1,
		450, 1, 450, 1, 450, 1, 450, 1, 450, 3, 450, 7594, 8, 450, 1, 450, 1, 450,
		1, 450, 1, 450, 1, 450, 1, 450, 1, 450, 1, 450, 5, 450, 7604, 8, 450, 10,
		450, 12, 450, 7607, 9, 450, 3, 450, 7609, 8, 450, 1, 450, 1, 450, 1, 450,
		1, 450, 1, 450, 1, 450, 1, 450, 1, 450, 1, 450, 1, 450, 5, 450, 7621, 8,
		450, 10, 450, 12, 450, 7624, 9, 450, 3, 450, 7626, 8, 450, 1, 451, 1, 451,
		3, 451, 7630, 8, 451, 1, 452, 1, 452, 1, 452, 1, 452, 3, 452, 7636, 8,
		452, 1, 452, 1, 452, 1, 452, 1, 452, 1, 452, 3, 452, 7643, 8, 452, 1, 453,
		1, 453, 1, 453, 1, 453, 3, 453, 7649, 8, 453, 1, 453, 1, 453, 1, 453, 1,
		453, 1, 453, 3, 453, 7656, 8, 453, 1, 454, 1, 454, 1, 454, 1, 454, 5, 454,
		7662, 8, 454, 10, 454, 12, 454, 7665, 9, 454, 1, 454, 1, 454, 1, 455, 1,
		455, 1, 455, 1, 455, 5, 455, 7673, 8, 455, 10, 455, 12, 455, 7676, 9, 455,
		1, 455, 1, 455, 1, 456, 1, 456, 3, 456, 7682, 8, 456, 1, 457, 1, 457, 3,
		457, 7686, 8, 457, 1, 458, 1, 458, 1, 458, 1, 458, 5, 458, 7692, 8, 458,
		10, 458, 12, 458, 7695, 9, 458, 1, 458, 1, 458, 1, 459, 1, 459, 1, 459,
		1, 459, 5, 459, 7703, 8, 459, 10, 459, 12, 459, 7706, 9, 459, 1, 459, 1,
		459, 1, 460, 1, 460, 1, 460, 1, 460, 5, 460, 7714, 8, 460, 10, 460, 12,
		460, 7717, 9, 460, 1, 460, 1, 460, 1, 461, 1, 461, 3, 461, 7723, 8, 461,
		1, 462, 1, 462, 1, 462, 1, 462, 3, 462, 7729, 8, 462, 1, 462, 1, 462, 1,
		462, 1, 462, 3, 462, 7735, 8, 462, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463,
		1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463,
		1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463, 1, 463,
		1, 463, 1, 463, 1, 463, 3, 463, 7763, 8, 463, 1, 464, 1, 464, 1, 464, 1,
		464, 1, 464, 1, 464, 1, 464, 1, 464, 1, 464, 1, 465, 1, 465, 1, 465, 1,
		465, 3, 465, 7778, 8, 465, 1, 465, 1, 465, 1, 465, 1, 465, 1, 465, 1, 465,
		3, 465, 7786, 8, 465, 1, 466, 1, 466, 1, 466, 1, 466, 5, 466, 7792, 8,
		466, 10, 466, 12, 466, 7795, 9, 466, 1, 466, 1, 466, 1, 467, 1, 467, 1,
		467, 1, 467, 1, 468, 1, 468, 3, 468, 7805, 8, 468, 1, 469, 1, 469, 1, 469,
		1, 469, 1, 469, 1, 469, 3, 469, 7813, 8, 469, 1, 469, 1, 469, 1, 469, 1,
		469, 3, 469, 7819, 8, 469, 1, 470, 1, 470, 1, 470, 1, 470, 1, 470, 1, 470,
		3, 470, 7827, 8, 470, 1, 470, 1, 470, 1, 470, 1, 470, 1, 470, 1, 470, 1,
		470, 1, 470, 1, 470, 3, 470, 7838, 8, 470, 3, 470, 7840, 8, 470, 1, 471,
		1, 471, 1, 471, 1, 471, 1, 471, 1, 471, 1, 471, 1, 471, 1, 472, 1, 472,
		3, 472, 7852, 8, 472, 1, 472, 1, 472, 1, 472, 1, 472, 1, 472, 1, 472, 1,
		472, 3, 472, 7861, 8, 472, 1, 472, 1, 472, 1, 472, 1, 472, 1, 472, 1, 472,
		1, 472, 3, 472, 7870, 8, 472, 1, 473, 1, 473, 1, 474, 1, 474, 1, 474, 1,
		474, 1, 474, 5, 474, 7879, 8, 474, 10, 474, 12, 474, 7882, 9, 474, 1, 474,
		1, 474, 1, 475, 1, 475, 1, 475, 1, 476, 1, 476, 1, 476, 1, 476, 5, 476,
		7893, 8, 476, 10, 476, 12, 476, 7896, 9, 476, 1, 476, 1, 476, 1, 477, 1,
		477, 1, 477, 5, 477, 7903, 8, 477, 10, 477, 12, 477, 7906, 9, 477, 1, 478,
		1, 478, 1, 478, 1, 478, 1, 479, 1, 479, 5, 479, 7914, 8, 479, 10, 479,
		12, 479, 7917, 9, 479, 1, 480, 1, 480, 1, 480, 1, 480, 1, 481, 1, 481,
		1, 482, 1, 482, 1, 482, 1, 483, 1, 483, 1, 483, 1, 483, 3, 483, 7932, 8,
		483, 1, 483, 3, 483, 7935, 8, 483, 1, 484, 1, 484, 1, 484, 1, 484, 3, 484,
		7941, 8, 484, 1, 485, 1, 485, 1, 486, 1, 486, 1, 487, 1, 487, 1, 488, 1,
		488, 1, 489, 1, 489, 1, 489, 1, 489, 1, 490, 1, 490, 1, 490, 1, 490, 1,
		491, 1, 491, 1, 492, 1, 492, 1, 493, 1, 493, 1, 494, 1, 494, 1, 494, 1,
		494, 1, 494, 3, 494, 7970, 8, 494, 1, 495, 1, 495, 1, 495, 1, 495, 1, 495,
		1, 496, 1, 496, 1, 496, 1, 496, 1, 496, 1, 496, 1, 496, 1, 497, 1, 497,
		3, 497, 7986, 8, 497, 1, 497, 1, 497, 1, 498, 1, 498, 1, 498, 5, 498, 7993,
		8, 498, 10, 498, 12, 498, 7996, 9, 498, 1, 499, 1, 499, 1, 499, 1, 499,
		1, 499, 1, 500, 1, 500, 1, 500, 1, 500, 1, 501, 1, 501, 1, 501, 3, 501,
		8010, 8, 501, 1, 501, 1, 501, 3, 501, 8014, 8, 501, 1, 501, 1, 501, 3,
		501, 8018, 8, 501, 1, 501, 1, 501, 3, 501, 8022, 8, 501, 1, 501, 1, 501,
		3, 501, 8026, 8, 501, 1, 501, 1, 501, 3, 501, 8030, 8, 501, 1, 501, 1,
		501, 3, 501, 8034, 8, 501, 1, 501, 1, 501, 3, 501, 8038, 8, 501, 1, 501,
		1, 501, 3, 501, 8042, 8, 501, 1, 501, 1, 501, 3, 501, 8046, 8, 501, 1,
		501, 1, 501, 1, 501, 1, 501, 1, 501, 1, 501, 1, 501, 3, 501, 8055, 8, 501,
		1, 501, 1, 501, 3, 501, 8059, 8, 501, 1, 501, 1, 501, 1, 501, 1, 501, 1,
		501, 1, 501, 1, 501, 1, 501, 3, 501, 8069, 8, 501, 1, 501, 1, 501, 3, 501,
		8073, 8, 501, 3, 501, 8075, 8, 501, 1, 502, 1, 502, 1, 502, 1, 502, 1,
		502, 3, 502, 8082, 8, 502, 1, 502, 3, 502, 8085, 8, 502, 1, 503, 1, 503,
		1, 503, 1, 503, 5, 503, 8091, 8, 503, 10, 503, 12, 503, 8094, 9, 503, 1,
		504, 1, 504, 1, 505, 3, 505, 8099, 8, 505, 1, 505, 1, 505, 1, 505, 1, 505,
		1, 505, 1, 506, 1, 506, 1, 506, 1, 506, 3, 506, 8110, 8, 506, 1, 507, 1,
		507, 1, 507, 3, 507, 8115, 8, 507, 1, 508, 1, 508, 1, 508, 1, 508, 5, 508,
		8121, 8, 508, 10, 508, 12, 508, 8124, 9, 508, 1, 508, 1, 508, 1, 509, 1,
		509, 1, 509, 1, 509, 5, 509, 8132, 8, 509, 10, 509, 12, 509, 8135, 9, 509,
		1, 509, 1, 509, 1, 510, 1, 510, 3, 510, 8141, 8, 510, 1, 511, 1, 511, 1,
		511, 5, 511, 8146, 8, 511, 10, 511, 12, 511, 8149, 9, 511, 1, 512, 1, 512,
		1, 512, 3, 512, 8154, 8, 512, 1, 513, 1, 513, 1, 513, 1, 513, 1, 513, 1,
		513, 1, 513, 1, 513, 1, 513, 1, 513, 1, 513, 3, 513, 8167, 8, 513, 1, 514,
		1, 514, 1, 514, 1, 514, 1, 515, 1, 515, 1, 515, 5, 515, 8176, 8, 515, 10,
		515, 12, 515, 8179, 9, 515, 1, 516, 1, 516, 1, 516, 3, 516, 8184, 8, 516,
		1, 517, 1, 517, 1, 517, 1, 4145, 5, 756, 842, 846, 854, 856, 518, 0, 2,
		4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40,
		42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76,
		78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110,
		112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140,
		142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170,
		172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200,
		202, 204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230,
		232, 234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260,
		262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290,
		292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 312, 314, 316, 318, 320,
		322, 324, 326, 328, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350,
		352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, 376, 378, 380,
		382, 384, 386, 388, 390, 392, 394, 396, 398, 400, 402, 404, 406, 408, 410,
		412, 414, 416, 418, 420, 422, 424, 426, 428, 430, 432, 434, 436, 438, 440,
		442, 444, 446, 448, 450, 452, 454, 456, 458, 460, 462, 464, 466, 468, 470,
		472, 474, 476, 478, 480, 482, 484, 486, 488, 490, 492, 494, 496, 498, 500,
		502, 504, 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530,
		532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560,
		562, 564, 566, 568, 570, 572, 574, 576, 578, 580, 582, 584, 586, 588, 590,
		592, 594, 596, 598, 600, 602, 604, 606, 608, 610, 612, 614, 616, 618, 620,
		622, 624, 626, 628, 630, 632, 634, 636, 638, 640, 642, 644, 646, 648, 650,
		652, 654, 656, 658, 660, 662, 664, 666, 668, 670, 672, 674, 676, 678, 680,
		682, 684, 686, 688, 690, 692, 694, 696, 698, 700, 702, 704, 706, 708, 710,
		712, 714, 716, 718, 720, 722, 724, 726, 728, 730, 732, 734, 736, 738, 740,
		742, 744, 746, 748, 750, 752, 754, 756, 758, 760, 762, 764, 766, 768, 770,
		772, 774, 776, 778, 780, 782, 784, 786, 788, 790, 792, 794, 796, 798, 800,
		802, 804, 806, 808, 810, 812, 814, 816, 818, 820, 822, 824, 826, 828, 830,
		832, 834, 836, 838, 840, 842, 844, 846, 848, 850, 852, 854, 856, 858, 860,
		862, 864, 866, 868, 870, 872, 874, 876, 878, 880, 882, 884, 886, 888, 890,
		892, 894, 896, 898, 900, 902, 904, 906, 908, 910, 912, 914, 916, 918, 920,
		922, 924, 926, 928, 930, 932, 934, 936, 938, 940, 942, 944, 946, 948, 950,
		952, 954, 956, 958, 960, 962, 964, 966, 968, 970, 972, 974, 976, 978, 980,
		982, 984, 986, 988, 990, 992, 994, 996, 998, 1000, 1002, 1004, 1006, 1008,
		1010, 1012, 1014, 1016, 1018, 1020, 1022, 1024, 1026, 1028, 1030, 1032,
		1034, 0, 62, 1, 1, 530, 530, 2, 0, 169, 169, 199, 199, 2, 0, 102, 102,
		384, 384, 2, 0, 148, 148, 426, 426, 4, 0, 17, 17, 132, 132, 320, 320, 449,
		449, 4, 0, 44, 44, 217, 217, 273, 273, 464, 464, 2, 0, 75, 75, 154, 154,
		3, 0, 74, 74, 291, 291, 373, 373, 1, 0, 123, 124, 2, 0, 202, 203, 224,
		225, 2, 0, 216, 216, 277, 277, 2, 0, 13, 13, 267, 267, 2, 0, 29, 29, 415,
		415, 2, 0, 164, 164, 283, 283, 2, 0, 199, 199, 438, 438, 2, 0, 38, 38,
		92, 92, 3, 0, 107, 107, 191, 191, 262, 262, 2, 0, 215, 215, 218, 218, 2,
		0, 172, 172, 381, 381, 2, 0, 221, 221, 406, 406, 2, 0, 54, 54, 175, 175,
		2, 0, 17, 17, 420, 420, 2, 0, 173, 173, 325, 325, 1, 0, 422, 423, 2, 0,
		140, 140, 473, 473, 1, 0, 456, 457, 2, 0, 27, 27, 55, 55, 1, 0, 60, 61,
		2, 0, 170, 170, 516, 516, 3, 0, 417, 417, 432, 432, 466, 466, 3, 0, 143,
		143, 263, 263, 448, 448, 2, 0, 28, 28, 123, 123, 2, 0, 158, 158, 230, 230,
		2, 0, 18, 18, 126, 126, 1, 0, 300, 301, 2, 0, 108, 108, 130, 130, 2, 0,
		21, 21, 504, 504, 2, 0, 294, 294, 503, 503, 3, 0, 237, 237, 347, 347, 369,
		369, 3, 0, 265, 265, 500, 502, 506, 506, 1, 0, 498, 499, 2, 0, 498, 499,
		510, 510, 1, 0, 104, 105, 2, 0, 163, 163, 317, 317, 1, 0, 173, 174, 1,
		0, 420, 421, 1, 0, 467, 468, 2, 0, 123, 124, 146, 146, 5, 0, 20, 20, 86,
		86, 247, 247, 383, 383, 465, 465, 5, 0, 18, 18, 246, 246, 343, 343, 431,
		431, 460, 460, 2, 0, 118, 118, 196, 196, 2, 0, 12, 12, 200, 200, 4, 0,
		175, 175, 241, 241, 392, 392, 465, 465, 1, 0, 519, 520, 1, 0, 521, 522,
		1, 0, 490, 496, 2, 0, 153, 153, 442, 442, 4, 0, 106, 106, 190, 190, 261,
		261, 386, 386, 9, 0, 106, 106, 190, 190, 258, 259, 261, 261, 268, 268,
		334, 334, 386, 386, 474, 474, 481, 481, 2, 0, 62, 62, 161, 161, 2, 0, 109,
		113, 281, 282, 94, 0, 11, 12, 14, 17, 22, 23, 25, 26, 29, 40, 43, 43, 45,
		49, 51, 54, 56, 57, 59, 63, 66, 66, 68, 71, 73, 73, 75, 79, 81, 84, 86,
		87, 91, 93, 100, 101, 104, 108, 114, 114, 119, 121, 125, 125, 127, 128,
		132, 133, 135, 142, 144, 144, 147, 152, 154, 155, 157, 158, 161, 164, 167,
		168, 170, 171, 174, 175, 177, 177, 182, 183, 185, 186, 188, 193, 195, 195,
		198, 198, 200, 201, 203, 203, 206, 206, 210, 212, 214, 214, 218, 218, 220,
		221, 227, 227, 230, 230, 235, 236, 239, 239, 241, 241, 244, 255, 257, 257,
		260, 264, 266, 277, 280, 286, 288, 290, 292, 293, 301, 306, 308, 318, 321,
		324, 326, 339, 341, 341, 343, 346, 349, 349, 351, 352, 354, 365, 367, 367,
		370, 375, 378, 383, 386, 387, 389, 392, 394, 394, 396, 397, 400, 410, 412,
		415, 417, 419, 421, 426, 428, 428, 430, 434, 436, 437, 439, 441, 443, 447,
		450, 451, 454, 454, 456, 457, 459, 459, 461, 461, 463, 474, 477, 477, 479,
		486, 488, 489, 497, 497, 531, 531, 9236, 0, 1037, 1, 0, 0, 0, 2, 1047,
		1, 0, 0, 0, 4, 1049, 1, 0, 0, 0, 6, 1286, 1, 0, 0, 0, 8, 1288, 1, 0, 0,
		0, 10, 1291, 1, 0, 0, 0, 12, 1294, 1, 0, 0, 0, 14, 1318, 1, 0, 0, 0, 16,
		1336, 1, 0, 0, 0, 18, 1338, 1, 0, 0, 0, 20, 1360, 1, 0, 0, 0, 22, 1375,
		1, 0, 0, 0, 24, 1380, 1, 0, 0, 0, 26, 1386, 1, 0, 0, 0, 28, 1396, 1, 0,
		0, 0, 30, 1398, 1, 0, 0, 0, 32, 1406, 1, 0, 0, 0, 34, 1464, 1, 0, 0, 0,
		36, 1496, 1, 0, 0, 0, 38, 1498, 1, 0, 0, 0, 40, 1517, 1, 0, 0, 0, 42, 1520,
		1, 0, 0, 0, 44, 1532, 1, 0, 0, 0, 46, 1537, 1, 0, 0, 0, 48, 1552, 1, 0,
		0, 0, 50, 1560, 1, 0, 0, 0, 52, 1564, 1, 0, 0, 0, 54, 1571, 1, 0, 0, 0,
		56, 1573, 1, 0, 0, 0, 58, 1577, 1, 0, 0, 0, 60, 1598, 1, 0, 0, 0, 62, 1600,
		1, 0, 0, 0, 64, 1612, 1, 0, 0, 0, 66, 1623, 1, 0, 0, 0, 68, 1627, 1, 0,
		0, 0, 70, 1632, 1, 0, 0, 0, 72, 1637, 1, 0, 0, 0, 74, 1639, 1, 0, 0, 0,
		76, 1701, 1, 0, 0, 0, 78, 1714, 1, 0, 0, 0, 80, 1758, 1, 0, 0, 0, 82, 1760,
		1, 0, 0, 0, 84, 1775, 1, 0, 0, 0, 86, 1781, 1, 0, 0, 0, 88, 1784, 1, 0,
		0, 0, 90, 1799, 1, 0, 0, 0, 92, 1812, 1, 0, 0, 0, 94, 1822, 1, 0, 0, 0,
		96, 1840, 1, 0, 0, 0, 98, 1853, 1, 0, 0, 0, 100, 1925, 1, 0, 0, 0, 102,
		1927, 1, 0, 0, 0, 104, 1936, 1, 0, 0, 0, 106, 1959, 1, 0, 0, 0, 108, 1968,
		1, 0, 0, 0, 110, 1972, 1, 0, 0, 0, 112, 2004, 1, 0, 0, 0, 114, 2006, 1,
		0, 0, 0, 116, 2032, 1, 0, 0, 0, 118, 2038, 1, 0, 0, 0, 120, 2115, 1, 0,
		0, 0, 122, 2117, 1, 0, 0, 0, 124, 2125, 1, 0, 0, 0, 126, 2129, 1, 0, 0,
		0, 128, 2148, 1, 0, 0, 0, 130, 2150, 1, 0, 0, 0, 132, 2160, 1, 0, 0, 0,
		134, 2173, 1, 0, 0, 0, 136, 2226, 1, 0, 0, 0, 138, 2235, 1, 0, 0, 0, 140,
		2237, 1, 0, 0, 0, 142, 2250, 1, 0, 0, 0, 144, 2275, 1, 0, 0, 0, 146, 2277,
		1, 0, 0, 0, 148, 2301, 1, 0, 0, 0, 150, 2309, 1, 0, 0, 0, 152, 2320, 1,
		0, 0, 0, 154, 2326, 1, 0, 0, 0, 156, 2334, 1, 0, 0, 0, 158, 2343, 1, 0,
		0, 0, 160, 2356, 1, 0, 0, 0, 162, 2363, 1, 0, 0, 0, 164, 2371, 1, 0, 0,
		0, 166, 2379, 1, 0, 0, 0, 168, 2394, 1, 0, 0, 0, 170, 2405, 1, 0, 0, 0,
		172, 2407, 1, 0, 0, 0, 174, 2418, 1, 0, 0, 0, 176, 2425, 1, 0, 0, 0, 178,
		2429, 1, 0, 0, 0, 180, 2440, 1, 0, 0, 0, 182, 2444, 1, 0, 0, 0, 184, 2458,
		1, 0, 0, 0, 186, 2463, 1, 0, 0, 0, 188, 2471, 1, 0, 0, 0, 190, 2477, 1,
		0, 0, 0, 192, 2482, 1, 0, 0, 0, 194, 2499, 1, 0, 0, 0, 196, 2503, 1, 0,
		0, 0, 198, 2507, 1, 0, 0, 0, 200, 2514, 1, 0, 0, 0, 202, 2523, 1, 0, 0,
		0, 204, 2537, 1, 0, 0, 0, 206, 2539, 1, 0, 0, 0, 208, 2542, 1, 0, 0, 0,
		210, 2546, 1, 0, 0, 0, 212, 2551, 1, 0, 0, 0, 214, 2595, 1, 0, 0, 0, 216,
		2597, 1, 0, 0, 0, 218, 2608, 1, 0, 0, 0, 220, 2626, 1, 0, 0, 0, 222, 2632,
		1, 0, 0, 0, 224, 2636, 1, 0, 0, 0, 226, 2641, 1, 0, 0, 0, 228, 2652, 1,
		0, 0, 0, 230, 2654, 1, 0, 0, 0, 232, 2706, 1, 0, 0, 0, 234, 2708, 1, 0,
		0, 0, 236, 2712, 1, 0, 0, 0, 238, 2716, 1, 0, 0, 0, 240, 2723, 1, 0, 0,
		0, 242, 2738, 1, 0, 0, 0, 244, 2756, 1, 0, 0, 0, 246, 2779, 1, 0, 0, 0,
		248, 2781, 1, 0, 0, 0, 250, 2797, 1, 0, 0, 0, 252, 2839, 1, 0, 0, 0, 254,
		2841, 1, 0, 0, 0, 256, 2848, 1, 0, 0, 0, 258, 2851, 1, 0, 0, 0, 260, 2856,
		1, 0, 0, 0, 262, 2870, 1, 0, 0, 0, 264, 2885, 1, 0, 0, 0, 266, 2899, 1,
		0, 0, 0, 268, 2914, 1, 0, 0, 0, 270, 2927, 1, 0, 0, 0, 272, 2931, 1, 0,
		0, 0, 274, 2934, 1, 0, 0, 0, 276, 2938, 1, 0, 0, 0, 278, 2941, 1, 0, 0,
		0, 280, 2945, 1, 0, 0, 0, 282, 2951, 1, 0, 0, 0, 284, 2968, 1, 0, 0, 0,
		286, 2983, 1, 0, 0, 0, 288, 3002, 1, 0, 0, 0, 290, 3012, 1, 0, 0, 0, 292,
		3027, 1, 0, 0, 0, 294, 3032, 1, 0, 0, 0, 296, 3038, 1, 0, 0, 0, 298, 3048,
		1, 0, 0, 0, 300, 3054, 1, 0, 0, 0, 302, 3063, 1, 0, 0, 0, 304, 3065, 1,
		0, 0, 0, 306, 3074, 1, 0, 0, 0, 308, 3088, 1, 0, 0, 0, 310, 3116, 1, 0,
		0, 0, 312, 3137, 1, 0, 0, 0, 314, 3139, 1, 0, 0, 0, 316, 3147, 1, 0, 0,
		0, 318, 3155, 1, 0, 0, 0, 320, 3162, 1, 0, 0, 0, 322, 3171, 1, 0, 0, 0,
		324, 3193, 1, 0, 0, 0, 326, 3195, 1, 0, 0, 0, 328, 3199, 1, 0, 0, 0, 330,
		3202, 1, 0, 0, 0, 332, 3205, 1, 0, 0, 0, 334, 3207, 1, 0, 0, 0, 336, 3209,
		1, 0, 0, 0, 338, 3220, 1, 0, 0, 0, 340, 3227, 1, 0, 0, 0, 342, 3260, 1,
		0, 0, 0, 344, 3317, 1, 0, 0, 0, 346, 3319, 1, 0, 0, 0, 348, 3336, 1, 0,
		0, 0, 350, 3338, 1, 0, 0, 0, 352, 3345, 1, 0, 0, 0, 354, 3351, 1, 0, 0,
		0, 356, 3394, 1, 0, 0, 0, 358, 3399, 1, 0, 0, 0, 360, 3402, 1, 0, 0, 0,
		362, 3417, 1, 0, 0, 0, 364, 3436, 1, 0, 0, 0, 366, 3465, 1, 0, 0, 0, 368,
		3491, 1, 0, 0, 0, 370, 3501, 1, 0, 0, 0, 372, 3503, 1, 0, 0, 0, 374, 3508,
		1, 0, 0, 0, 376, 3513, 1, 0, 0, 0, 378, 3516, 1, 0, 0, 0, 380, 3533, 1,
		0, 0, 0, 382, 3535, 1, 0, 0, 0, 384, 3537, 1, 0, 0, 0, 386, 3548, 1, 0,
		0, 0, 388, 3559, 1, 0, 0, 0, 390, 3570, 1, 0, 0, 0, 392, 3608, 1, 0, 0,
		0, 394, 3619, 1, 0, 0, 0, 396, 3630, 1, 0, 0, 0, 398, 3668, 1, 0, 0, 0,
		400, 3724, 1, 0, 0, 0, 402, 3726, 1, 0, 0, 0, 404, 3734, 1, 0, 0, 0, 406,
		3749, 1, 0, 0, 0, 408, 3755, 1, 0, 0, 0, 410, 3813, 1, 0, 0, 0, 412, 3822,
		1, 0, 0, 0, 414, 3824, 1, 0, 0, 0, 416, 3848, 1, 0, 0, 0, 418, 3874, 1,
		0, 0, 0, 420, 3903, 1, 0, 0, 0, 422, 3922, 1, 0, 0, 0, 424, 3924, 1, 0,
		0, 0, 426, 3938, 1, 0, 0, 0, 428, 3942, 1, 0, 0, 0, 430, 3945, 1, 0, 0,
		0, 432, 3981, 1, 0, 0, 0, 434, 4038, 1, 0, 0, 0, 436, 4056, 1, 0, 0, 0,
		438, 4067, 1, 0, 0, 0, 440, 4069, 1, 0, 0, 0, 442, 4078, 1, 0, 0, 0, 444,
		4084, 1, 0, 0, 0, 446, 4088, 1, 0, 0, 0, 448, 4091, 1, 0, 0, 0, 450, 4095,
		1, 0, 0, 0, 452, 4113, 1, 0, 0, 0, 454, 4127, 1, 0, 0, 0, 456, 4150, 1,
		0, 0, 0, 458, 4154, 1, 0, 0, 0, 460, 4195, 1, 0, 0, 0, 462, 4200, 1, 0,
		0, 0, 464, 4204, 1, 0, 0, 0, 466, 4284, 1, 0, 0, 0, 468, 4286, 1, 0, 0,
		0, 470, 4320, 1, 0, 0, 0, 472, 4322, 1, 0, 0, 0, 474, 4328, 1, 0, 0, 0,
		476, 4375, 1, 0, 0, 0, 478, 4377, 1, 0, 0, 0, 480, 4387, 1, 0, 0, 0, 482,
		4399, 1, 0, 0, 0, 484, 4404, 1, 0, 0, 0, 486, 4407, 1, 0, 0, 0, 488, 4410,
		1, 0, 0, 0, 490, 4413, 1, 0, 0, 0, 492, 4427, 1, 0, 0, 0, 494, 4435, 1,
		0, 0, 0, 496, 4441, 1, 0, 0, 0, 498, 4449, 1, 0, 0, 0, 500, 4461, 1, 0,
		0, 0, 502, 4464, 1, 0, 0, 0, 504, 4467, 1, 0, 0, 0, 506, 4470, 1, 0, 0,
		0, 508, 4473, 1, 0, 0, 0, 510, 4477, 1, 0, 0, 0, 512, 4480, 1, 0, 0, 0,
		514, 4489, 1, 0, 0, 0, 516, 4493, 1, 0, 0, 0, 518, 4502, 1, 0, 0, 0, 520,
		4508, 1, 0, 0, 0, 522, 4515, 1, 0, 0, 0, 524, 4555, 1, 0, 0, 0, 526, 4557,
		1, 0, 0, 0, 528, 4567, 1, 0, 0, 0, 530, 4602, 1, 0, 0, 0, 532, 4604, 1,
		0, 0, 0, 534, 4615, 1, 0, 0, 0, 536, 4620, 1, 0, 0, 0, 538, 4623, 1, 0,
		0, 0, 540, 4642, 1, 0, 0, 0, 542, 4683, 1, 0, 0, 0, 544, 4685, 1, 0, 0,
		0, 546, 4697, 1, 0, 0, 0, 548, 4699, 1, 0, 0, 0, 550, 4707, 1, 0, 0, 0,
		552, 4718, 1, 0, 0, 0, 554, 4730, 1, 0, 0, 0, 556, 4738, 1, 0, 0, 0, 558,
		4755, 1, 0, 0, 0, 560, 4771, 1, 0, 0, 0, 562, 4789, 1, 0, 0, 0, 564, 4791,
		1, 0, 0, 0, 566, 4808, 1, 0, 0, 0, 568, 4898, 1, 0, 0, 0, 570, 4964, 1,
		0, 0, 0, 572, 4980, 1, 0, 0, 0, 574, 4995, 1, 0, 0, 0, 576, 4997, 1, 0,
		0, 0, 578, 5002, 1, 0, 0, 0, 580, 5010, 1, 0, 0, 0, 582, 5025, 1, 0, 0,
		0, 584, 5076, 1, 0, 0, 0, 586, 5092, 1, 0, 0, 0, 588, 5112, 1, 0, 0, 0,
		590, 5114, 1, 0, 0, 0, 592, 5120, 1, 0, 0, 0, 594, 5127, 1, 0, 0, 0, 596,
		5132, 1, 0, 0, 0, 598, 5136, 1, 0, 0, 0, 600, 5142, 1, 0, 0, 0, 602, 5153,
		1, 0, 0, 0, 604, 5162, 1, 0, 0, 0, 606, 5166, 1, 0, 0, 0, 608, 5172, 1,
		0, 0, 0, 610, 5207, 1, 0, 0, 0, 612, 5216, 1, 0, 0, 0, 614, 5222, 1, 0,
		0, 0, 616, 5261, 1, 0, 0, 0, 618, 5270, 1, 0, 0, 0, 620, 5280, 1, 0, 0,
		0, 622, 5288, 1, 0, 0, 0, 624, 5307, 1, 0, 0, 0, 626, 5311, 1, 0, 0, 0,
		628, 5315, 1, 0, 0, 0, 630, 5325, 1, 0, 0, 0, 632, 5328, 1, 0, 0, 0, 634,
		5331, 1, 0, 0, 0, 636, 5342, 1, 0, 0, 0, 638, 5353, 1, 0, 0, 0, 640, 5357,
		1, 0, 0, 0, 642, 5363, 1, 0, 0, 0, 644, 5380, 1, 0, 0, 0, 646, 5384, 1,
		0, 0, 0, 648, 5389, 1, 0, 0, 0, 650, 5393, 1, 0, 0, 0, 652, 5412, 1, 0,
		0, 0, 654, 5431, 1, 0, 0, 0, 656, 5443, 1, 0, 0, 0, 658, 5470, 1, 0, 0,
		0, 660, 5477, 1, 0, 0, 0, 662, 5481, 1, 0, 0, 0, 664, 5490, 1, 0, 0, 0,
		666, 5499, 1, 0, 0, 0, 668, 5505, 1, 0, 0, 0, 670, 5516, 1, 0, 0, 0, 672,
		5533, 1, 0, 0, 0, 674, 5535, 1, 0, 0, 0, 676, 5540, 1, 0, 0, 0, 678, 5544,
		1, 0, 0, 0, 680, 5569, 1, 0, 0, 0, 682, 5643, 1, 0, 0, 0, 684, 5655, 1,
		0, 0, 0, 686, 5661, 1, 0, 0, 0, 688, 5663, 1, 0, 0, 0, 690, 5674, 1, 0,
		0, 0, 692, 5680, 1, 0, 0, 0, 694, 5682, 1, 0, 0, 0, 696, 5690, 1, 0, 0,
		0, 698, 5698, 1, 0, 0, 0, 700, 5716, 1, 0, 0, 0, 702, 5718, 1, 0, 0, 0,
		704, 5735, 1, 0, 0, 0, 706, 5737, 1, 0, 0, 0, 708, 5743, 1, 0, 0, 0, 710,
		5747, 1, 0, 0, 0, 712, 5753, 1, 0, 0, 0, 714, 5757, 1, 0, 0, 0, 716, 5771,
		1, 0, 0, 0, 718, 5779, 1, 0, 0, 0, 720, 5787, 1, 0, 0, 0, 722, 5795, 1,
		0, 0, 0, 724, 5805, 1, 0, 0, 0, 726, 5811, 1, 0, 0, 0, 728, 5830, 1, 0,
		0, 0, 730, 5832, 1, 0, 0, 0, 732, 5848, 1, 0, 0, 0, 734, 5850, 1, 0, 0,
		0, 736, 5867, 1, 0, 0, 0, 738, 5884, 1, 0, 0, 0, 740, 5888, 1, 0, 0, 0,
		742, 5891, 1, 0, 0, 0, 744, 5897, 1, 0, 0, 0, 746, 5904, 1, 0, 0, 0, 748,
		5908, 1, 0, 0, 0, 750, 5917, 1, 0, 0, 0, 752, 5965, 1, 0, 0, 0, 754, 5967,
		1, 0, 0, 0, 756, 5972, 1, 0, 0, 0, 758, 5991, 1, 0, 0, 0, 760, 5995, 1,
		0, 0, 0, 762, 5999, 1, 0, 0, 0, 764, 6010, 1, 0, 0, 0, 766, 6023, 1, 0,
		0, 0, 768, 6025, 1, 0, 0, 0, 770, 6067, 1, 0, 0, 0, 772, 6095, 1, 0, 0,
		0, 774, 6097, 1, 0, 0, 0, 776, 6110, 1, 0, 0, 0, 778, 6119, 1, 0, 0, 0,
		780, 6136, 1, 0, 0, 0, 782, 6138, 1, 0, 0, 0, 784, 6166, 1, 0, 0, 0, 786,
		6271, 1, 0, 0, 0, 788, 6273, 1, 0, 0, 0, 790, 6301, 1, 0, 0, 0, 792, 6313,
		1, 0, 0, 0, 794, 6324, 1, 0, 0, 0, 796, 6330, 1, 0, 0, 0, 798, 6332, 1,
		0, 0, 0, 800, 6340, 1, 0, 0, 0, 802, 6365, 1, 0, 0, 0, 804, 6373, 1, 0,
		0, 0, 806, 6402, 1, 0, 0, 0, 808, 6422, 1, 0, 0, 0, 810, 6424, 1, 0, 0,
		0, 812, 6442, 1, 0, 0, 0, 814, 6444, 1, 0, 0, 0, 816, 6476, 1, 0, 0, 0,
		818, 6478, 1, 0, 0, 0, 820, 6490, 1, 0, 0, 0, 822, 6502, 1, 0, 0, 0, 824,
		6509, 1, 0, 0, 0, 826, 6511, 1, 0, 0, 0, 828, 6526, 1, 0, 0, 0, 830, 6530,
		1, 0, 0, 0, 832, 6542, 1, 0, 0, 0, 834, 6555, 1, 0, 0, 0, 836, 6557, 1,
		0, 0, 0, 838, 6565, 1, 0, 0, 0, 840, 6569, 1, 0, 0, 0, 842, 6579, 1, 0,
		0, 0, 844, 6592, 1, 0, 0, 0, 846, 6600, 1, 0, 0, 0, 848, 6629, 1, 0, 0,
		0, 850, 6631, 1, 0, 0, 0, 852, 6687, 1, 0, 0, 0, 854, 6689, 1, 0, 0, 0,
		856, 6826, 1, 0, 0, 0, 858, 6882, 1, 0, 0, 0, 860, 6956, 1, 0, 0, 0, 862,
		7083, 1, 0, 0, 0, 864, 7085, 1, 0, 0, 0, 866, 7088, 1, 0, 0, 0, 868, 7097,
		1, 0, 0, 0, 870, 7126, 1, 0, 0, 0, 872, 7156, 1, 0, 0, 0, 874, 7299, 1,
		0, 0, 0, 876, 7398, 1, 0, 0, 0, 878, 7400, 1, 0, 0, 0, 880, 7405, 1, 0,
		0, 0, 882, 7439, 1, 0, 0, 0, 884, 7458, 1, 0, 0, 0, 886, 7469, 1, 0, 0,
		0, 888, 7510, 1, 0, 0, 0, 890, 7512, 1, 0, 0, 0, 892, 7516, 1, 0, 0, 0,
		894, 7524, 1, 0, 0, 0, 896, 7528, 1, 0, 0, 0, 898, 7535, 1, 0, 0, 0, 900,
		7625, 1, 0, 0, 0, 902, 7629, 1, 0, 0, 0, 904, 7631, 1, 0, 0, 0, 906, 7644,
		1, 0, 0, 0, 908, 7657, 1, 0, 0, 0, 910, 7668, 1, 0, 0, 0, 912, 7681, 1,
		0, 0, 0, 914, 7685, 1, 0, 0, 0, 916, 7687, 1, 0, 0, 0, 918, 7698, 1, 0,
		0, 0, 920, 7709, 1, 0, 0, 0, 922, 7722, 1, 0, 0, 0, 924, 7724, 1, 0, 0,
		0, 926, 7762, 1, 0, 0, 0, 928, 7764, 1, 0, 0, 0, 930, 7785, 1, 0, 0, 0,
		932, 7787, 1, 0, 0, 0, 934, 7798, 1, 0, 0, 0, 936, 7804, 1, 0, 0, 0, 938,
		7818, 1, 0, 0, 0, 940, 7839, 1, 0, 0, 0, 942, 7841, 1, 0, 0, 0, 944, 7849,
		1, 0, 0, 0, 946, 7871, 1, 0, 0, 0, 948, 7873, 1, 0, 0, 0, 950, 7885, 1,
		0, 0, 0, 952, 7888, 1, 0, 0, 0, 954, 7899, 1, 0, 0, 0, 956, 7907, 1, 0,
		0, 0, 958, 7911, 1, 0, 0, 0, 960, 7918, 1, 0, 0, 0, 962, 7922, 1, 0, 0,
		0, 964, 7924, 1, 0, 0, 0, 966, 7927, 1, 0, 0, 0, 968, 7936, 1, 0, 0, 0,
		970, 7942, 1, 0, 0, 0, 972, 7944, 1, 0, 0, 0, 974, 7946, 1, 0, 0, 0, 976,
		7948, 1, 0, 0, 0, 978, 7950, 1, 0, 0, 0, 980, 7954, 1, 0, 0, 0, 982, 7958,
		1, 0, 0, 0, 984, 7960, 1, 0, 0, 0, 986, 7962, 1, 0, 0, 0, 988, 7969, 1,
		0, 0, 0, 990, 7971, 1, 0, 0, 0, 992, 7976, 1, 0, 0, 0, 994, 7985, 1, 0,
		0, 0, 996, 7989, 1, 0, 0, 0, 998, 7997, 1, 0, 0, 0, 1000, 8002, 1, 0, 0,
		0, 1002, 8074, 1, 0, 0, 0, 1004, 8076, 1, 0, 0, 0, 1006, 8086, 1, 0, 0,
		0, 1008, 8095, 1, 0, 0, 0, 1010, 8098, 1, 0, 0, 0, 1012, 8109, 1, 0, 0,
		0, 1014, 8111, 1, 0, 0, 0, 1016, 8116, 1, 0, 0, 0, 1018, 8127, 1, 0, 0,
		0, 1020, 8140, 1, 0, 0, 0, 1022, 8142, 1, 0, 0, 0, 1024, 8153, 1, 0, 0,
		0, 1026, 8166, 1, 0, 0, 0, 1028, 8168, 1, 0, 0, 0, 1030, 8172, 1, 0, 0,
		0, 1032, 8183, 1, 0, 0, 0, 1034, 8185, 1, 0, 0, 0, 1036, 1038, 3, 2, 1,
		0, 1037, 1036, 1, 0, 0, 0, 1038, 1039, 1, 0, 0, 0, 1039, 1037, 1, 0, 0,
		0, 1039, 1040, 1, 0, 0, 0, 1040, 1041, 1, 0, 0, 0, 1041, 1042, 5, 0, 0,
		1, 1042, 1, 1, 0, 0, 0, 1043, 1044, 3, 6, 3, 0, 1044, 1045, 7, 0, 0, 0,
		1045, 1048, 1, 0, 0, 0, 1046, 1048, 3, 4, 2, 0, 1047, 1043, 1, 0, 0, 0,
		1047, 1046, 1, 0, 0, 0, 1048, 3, 1, 0, 0, 0, 1049, 1050, 5, 530, 0, 0,
		1050, 5, 1, 0, 0, 0, 1051, 1287, 3, 744, 372, 0, 1052, 1287, 3, 8, 4, 0,
		1053, 1287, 3, 10, 5, 0, 1054, 1287, 3, 12, 6, 0, 1055, 1287, 3, 14, 7,
		0, 1056, 1287, 3, 16, 8, 0, 1057, 1287, 3, 18, 9, 0, 1058, 1287, 3, 20,
		10, 0, 1059, 1287, 3, 22, 11, 0, 1060, 1287, 3, 24, 12, 0, 1061, 1287,
		3, 26, 13, 0, 1062, 1287, 3, 28, 14, 0, 1063, 1287, 3, 30, 15, 0, 1064,
		1287, 3, 32, 16, 0, 1065, 1287, 3, 74, 37, 0, 1066, 1287, 3, 104, 52, 0,
		1067, 1287, 3, 92, 46, 0, 1068, 1287, 3, 76, 38, 0, 1069, 1287, 3, 78,
		39, 0, 1070, 1287, 3, 108, 54, 0, 1071, 1287, 3, 110, 55, 0, 1072, 1287,
		3, 88, 44, 0, 1073, 1287, 3, 102, 51, 0, 1074, 1287, 3, 96, 48, 0, 1075,
		1287, 3, 94, 47, 0, 1076, 1287, 3, 98, 49, 0, 1077, 1287, 3, 80, 40, 0,
		1078, 1287, 3, 112, 56, 0, 1079, 1287, 3, 100, 50, 0, 1080, 1287, 3, 90,
		45, 0, 1081, 1287, 3, 118, 59, 0, 1082, 1287, 3, 120, 60, 0, 1083, 1287,
		3, 122, 61, 0, 1084, 1287, 3, 114, 57, 0, 1085, 1287, 3, 116, 58, 0, 1086,
		1287, 3, 82, 41, 0, 1087, 1287, 3, 84, 42, 0, 1088, 1287, 3, 106, 53, 0,
		1089, 1287, 3, 126, 63, 0, 1090, 1287, 3, 130, 65, 0, 1091, 1287, 3, 134,
		67, 0, 1092, 1287, 3, 140, 70, 0, 1093, 1287, 3, 142, 71, 0, 1094, 1287,
		3, 144, 72, 0, 1095, 1287, 3, 146, 73, 0, 1096, 1287, 3, 148, 74, 0, 1097,
		1287, 3, 182, 91, 0, 1098, 1287, 3, 186, 93, 0, 1099, 1287, 3, 188, 94,
		0, 1100, 1287, 3, 184, 92, 0, 1101, 1287, 3, 190, 95, 0, 1102, 1287, 3,
		354, 177, 0, 1103, 1287, 3, 360, 180, 0, 1104, 1287, 3, 362, 181, 0, 1105,
		1287, 3, 364, 182, 0, 1106, 1287, 3, 366, 183, 0, 1107, 1287, 3, 384, 192,
		0, 1108, 1287, 3, 386, 193, 0, 1109, 1287, 3, 388, 194, 0, 1110, 1287,
		3, 390, 195, 0, 1111, 1287, 3, 392, 196, 0, 1112, 1287, 3, 394, 197, 0,
		1113, 1287, 3, 396, 198, 0, 1114, 1287, 3, 150, 75, 0, 1115, 1287, 3, 152,
		76, 0, 1116, 1287, 3, 154, 77, 0, 1117, 1287, 3, 156, 78, 0, 1118, 1287,
		3, 158, 79, 0, 1119, 1287, 3, 160, 80, 0, 1120, 1287, 3, 162, 81, 0, 1121,
		1287, 3, 164, 82, 0, 1122, 1287, 3, 166, 83, 0, 1123, 1287, 3, 168, 84,
		0, 1124, 1287, 3, 170, 85, 0, 1125, 1287, 3, 698, 349, 0, 1126, 1287, 3,
		172, 86, 0, 1127, 1287, 3, 174, 87, 0, 1128, 1287, 3, 176, 88, 0, 1129,
		1287, 3, 178, 89, 0, 1130, 1287, 3, 180, 90, 0, 1131, 1287, 3, 398, 199,
		0, 1132, 1287, 3, 402, 201, 0, 1133, 1287, 3, 410, 205, 0, 1134, 1287,
		3, 412, 206, 0, 1135, 1287, 3, 406, 203, 0, 1136, 1287, 3, 408, 204, 0,
		1137, 1287, 3, 414, 207, 0, 1138, 1287, 3, 416, 208, 0, 1139, 1287, 3,
		418, 209, 0, 1140, 1287, 3, 420, 210, 0, 1141, 1287, 3, 422, 211, 0, 1142,
		1287, 3, 430, 215, 0, 1143, 1287, 3, 432, 216, 0, 1144, 1287, 3, 434, 217,
		0, 1145, 1287, 3, 436, 218, 0, 1146, 1287, 3, 438, 219, 0, 1147, 1287,
		3, 440, 220, 0, 1148, 1287, 3, 442, 221, 0, 1149, 1287, 3, 444, 222, 0,
		1150, 1287, 3, 446, 223, 0, 1151, 1287, 3, 450, 225, 0, 1152, 1287, 3,
		452, 226, 0, 1153, 1287, 3, 454, 227, 0, 1154, 1287, 3, 460, 230, 0, 1155,
		1287, 3, 474, 237, 0, 1156, 1287, 3, 476, 238, 0, 1157, 1287, 3, 478, 239,
		0, 1158, 1287, 3, 480, 240, 0, 1159, 1287, 3, 484, 242, 0, 1160, 1287,
		3, 486, 243, 0, 1161, 1287, 3, 488, 244, 0, 1162, 1287, 3, 490, 245, 0,
		1163, 1287, 3, 492, 246, 0, 1164, 1287, 3, 494, 247, 0, 1165, 1287, 3,
		496, 248, 0, 1166, 1287, 3, 498, 249, 0, 1167, 1287, 3, 500, 250, 0, 1168,
		1287, 3, 502, 251, 0, 1169, 1287, 3, 504, 252, 0, 1170, 1287, 3, 506, 253,
		0, 1171, 1287, 3, 508, 254, 0, 1172, 1287, 3, 510, 255, 0, 1173, 1287,
		3, 512, 256, 0, 1174, 1287, 3, 514, 257, 0, 1175, 1287, 3, 516, 258, 0,
		1176, 1287, 3, 518, 259, 0, 1177, 1287, 3, 520, 260, 0, 1178, 1287, 3,
		522, 261, 0, 1179, 1287, 3, 524, 262, 0, 1180, 1287, 3, 526, 263, 0, 1181,
		1287, 3, 528, 264, 0, 1182, 1287, 3, 530, 265, 0, 1183, 1287, 3, 532, 266,
		0, 1184, 1287, 3, 534, 267, 0, 1185, 1287, 3, 536, 268, 0, 1186, 1287,
		3, 538, 269, 0, 1187, 1287, 3, 540, 270, 0, 1188, 1287, 3, 542, 271, 0,
		1189, 1287, 3, 544, 272, 0, 1190, 1287, 3, 546, 273, 0, 1191, 1287, 3,
		548, 274, 0, 1192, 1287, 3, 550, 275, 0, 1193, 1287, 3, 552, 276, 0, 1194,
		1287, 3, 554, 277, 0, 1195, 1287, 3, 556, 278, 0, 1196, 1287, 3, 558, 279,
		0, 1197, 1287, 3, 560, 280, 0, 1198, 1287, 3, 562, 281, 0, 1199, 1287,
		3, 564, 282, 0, 1200, 1287, 3, 568, 284, 0, 1201, 1287, 3, 570, 285, 0,
		1202, 1287, 3, 572, 286, 0, 1203, 1287, 3, 590, 295, 0, 1204, 1287, 3,
		592, 296, 0, 1205, 1287, 3, 594, 297, 0, 1206, 1287, 3, 596, 298, 0, 1207,
		1287, 3, 598, 299, 0, 1208, 1287, 3, 600, 300, 0, 1209, 1287, 3, 602, 301,
		0, 1210, 1287, 3, 604, 302, 0, 1211, 1287, 3, 606, 303, 0, 1212, 1287,
		3, 608, 304, 0, 1213, 1287, 3, 610, 305, 0, 1214, 1287, 3, 612, 306, 0,
		1215, 1287, 3, 614, 307, 0, 1216, 1287, 3, 616, 308, 0, 1217, 1287, 3,
		618, 309, 0, 1218, 1287, 3, 620, 310, 0, 1219, 1287, 3, 622, 311, 0, 1220,
		1287, 3, 624, 312, 0, 1221, 1287, 3, 626, 313, 0, 1222, 1287, 3, 628, 314,
		0, 1223, 1287, 3, 630, 315, 0, 1224, 1287, 3, 632, 316, 0, 1225, 1287,
		3, 634, 317, 0, 1226, 1287, 3, 636, 318, 0, 1227, 1287, 3, 638, 319, 0,
		1228, 1287, 3, 642, 321, 0, 1229, 1287, 3, 644, 322, 0, 1230, 1287, 3,
		646, 323, 0, 1231, 1287, 3, 648, 324, 0, 1232, 1287, 3, 650, 325, 0, 1233,
		1287, 3, 652, 326, 0, 1234, 1287, 3, 654, 327, 0, 1235, 1287, 3, 656, 328,
		0, 1236, 1287, 3, 658, 329, 0, 1237, 1287, 3, 660, 330, 0, 1238, 1287,
		3, 662, 331, 0, 1239, 1287, 3, 664, 332, 0, 1240, 1287, 3, 666, 333, 0,
		1241, 1287, 3, 680, 340, 0, 1242, 1287, 3, 694, 347, 0, 1243, 1287, 3,
		192, 96, 0, 1244, 1287, 3, 202, 101, 0, 1245, 1287, 3, 200, 100, 0, 1246,
		1287, 3, 198, 99, 0, 1247, 1287, 3, 210, 105, 0, 1248, 1287, 3, 212, 106,
		0, 1249, 1287, 3, 668, 334, 0, 1250, 1287, 3, 670, 335, 0, 1251, 1287,
		3, 674, 337, 0, 1252, 1287, 3, 678, 339, 0, 1253, 1287, 3, 676, 338, 0,
		1254, 1287, 3, 482, 241, 0, 1255, 1287, 3, 214, 107, 0, 1256, 1287, 3,
		216, 108, 0, 1257, 1287, 3, 822, 411, 0, 1258, 1287, 3, 826, 413, 0, 1259,
		1287, 3, 828, 414, 0, 1260, 1287, 3, 218, 109, 0, 1261, 1287, 3, 220, 110,
		0, 1262, 1287, 3, 222, 111, 0, 1263, 1287, 3, 224, 112, 0, 1264, 1287,
		3, 226, 113, 0, 1265, 1287, 3, 706, 353, 0, 1266, 1287, 3, 708, 354, 0,
		1267, 1287, 3, 710, 355, 0, 1268, 1287, 3, 712, 356, 0, 1269, 1287, 3,
		714, 357, 0, 1270, 1287, 3, 716, 358, 0, 1271, 1287, 3, 718, 359, 0, 1272,
		1287, 3, 720, 360, 0, 1273, 1287, 3, 722, 361, 0, 1274, 1287, 3, 724, 362,
		0, 1275, 1287, 3, 726, 363, 0, 1276, 1287, 3, 728, 364, 0, 1277, 1287,
		3, 730, 365, 0, 1278, 1287, 3, 732, 366, 0, 1279, 1287, 3, 734, 367, 0,
		1280, 1287, 3, 736, 368, 0, 1281, 1287, 3, 738, 369, 0, 1282, 1287, 3,
		424, 212, 0, 1283, 1287, 3, 426, 213, 0, 1284, 1287, 3, 428, 214, 0, 1285,
		1287, 3, 700, 350, 0, 1286, 1051, 1, 0, 0, 0, 1286, 1052, 1, 0, 0, 0, 1286,
		1053, 1, 0, 0, 0, 1286, 1054, 1, 0, 0, 0, 1286, 1055, 1, 0, 0, 0, 1286,
		1056, 1, 0, 0, 0, 1286, 1057, 1, 0, 0, 0, 1286, 1058, 1, 0, 0, 0, 1286,
		1059, 1, 0, 0, 0, 1286, 1060, 1, 0, 0, 0, 1286, 1061, 1, 0, 0, 0, 1286,
		1062, 1, 0, 0, 0, 1286, 1063, 1, 0, 0, 0, 1286, 1064, 1, 0, 0, 0, 1286,
		1065, 1, 0, 0, 0, 1286, 1066, 1, 0, 0, 0, 1286, 1067, 1, 0, 0, 0, 1286,
		1068, 1, 0, 0, 0, 1286, 1069, 1, 0, 0, 0, 1286, 1070, 1, 0, 0, 0, 1286,
		1071, 1, 0, 0, 0, 1286, 1072, 1, 0, 0, 0, 1286, 1073, 1, 0, 0, 0, 1286,
		1074, 1, 0, 0, 0, 1286, 1075, 1, 0, 0, 0, 1286, 1076, 1, 0, 0, 0, 1286,
		1077, 1, 0, 0, 0, 1286, 1078, 1, 0, 0, 0, 1286, 1079, 1, 0, 0, 0, 1286,
		1080, 1, 0, 0, 0, 1286, 1081, 1, 0, 0, 0, 1286, 1082, 1, 0, 0, 0, 1286,
		1083, 1, 0, 0, 0, 1286, 1084, 1, 0, 0, 0, 1286, 1085, 1, 0, 0, 0, 1286,
		1086, 1, 0, 0, 0, 1286, 1087, 1, 0, 0, 0, 1286, 1088, 1, 0, 0, 0, 1286,
		1089, 1, 0, 0, 0, 1286, 1090, 1, 0, 0, 0, 1286, 1091, 1, 0, 0, 0, 1286,
		1092, 1, 0, 0, 0, 1286, 1093, 1, 0, 0, 0, 1286, 1094, 1, 0, 0, 0, 1286,
		1095, 1, 0, 0, 0, 1286, 1096, 1, 0, 0, 0, 1286, 1097, 1, 0, 0, 0, 1286,
		1098, 1, 0, 0, 0, 1286, 1099, 1, 0, 0, 0, 1286, 1100, 1, 0, 0, 0, 1286,
		1101, 1, 0, 0, 0, 1286, 1102, 1, 0, 0, 0, 1286, 1103, 1, 0, 0, 0, 1286,
		1104, 1, 0, 0, 0, 1286, 1105, 1, 0, 0, 0, 1286, 1106, 1, 0, 0, 0, 1286,
		1107, 1, 0, 0, 0, 1286, 1108, 1, 0, 0, 0, 1286, 1109, 1, 0, 0, 0, 1286,
		1110, 1, 0, 0, 0, 1286, 1111, 1, 0, 0, 0, 1286, 1112, 1, 0, 0, 0, 1286,
		1113, 1, 0, 0, 0, 1286, 1114, 1, 0, 0, 0, 1286, 1115, 1, 0, 0, 0, 1286,
		1116, 1, 0, 0, 0, 1286, 1117, 1, 0, 0, 0, 1286, 1118, 1, 0, 0, 0, 1286,
		1119, 1, 0, 0, 0, 1286, 1120, 1, 0, 0, 0, 1286, 1121, 1, 0, 0, 0, 1286,
		1122, 1, 0, 0, 0, 1286, 1123, 1, 0, 0, 0, 1286, 1124, 1, 0, 0, 0, 1286,
		1125, 1, 0, 0, 0, 1286, 1126, 1, 0, 0, 0, 1286, 1127, 1, 0, 0, 0, 1286,
		1128, 1, 0, 0, 0, 1286, 1129, 1, 0, 0, 0, 1286, 1130, 1, 0, 0, 0, 1286,
		1131, 1, 0, 0, 0, 1286, 1132, 1, 0, 0, 0, 1286, 1133, 1, 0, 0, 0, 1286,
		1134, 1, 0, 0, 0, 1286, 1135, 1, 0, 0, 0, 1286, 1136, 1, 0, 0, 0, 1286,
		1137, 1, 0, 0, 0, 1286, 1138, 1, 0, 0, 0, 1286, 1139, 1, 0, 0, 0, 1286,
		1140, 1, 0, 0, 0, 1286, 1141, 1, 0, 0, 0, 1286, 1142, 1, 0, 0, 0, 1286,
		1143, 1, 0, 0, 0, 1286, 1144, 1, 0, 0, 0, 1286, 1145, 1, 0, 0, 0, 1286,
		1146, 1, 0, 0, 0, 1286, 1147, 1, 0, 0, 0, 1286, 1148, 1, 0, 0, 0, 1286,
		1149, 1, 0, 0, 0, 1286, 1150, 1, 0, 0, 0, 1286, 1151, 1, 0, 0, 0, 1286,
		1152, 1, 0, 0, 0, 1286, 1153, 1, 0, 0, 0, 1286, 1154, 1, 0, 0, 0, 1286,
		1155, 1, 0, 0, 0, 1286, 1156, 1, 0, 0, 0, 1286, 1157, 1, 0, 0, 0, 1286,
		1158, 1, 0, 0, 0, 1286, 1159, 1, 0, 0, 0, 1286, 1160, 1, 0, 0, 0, 1286,
		1161, 1, 0, 0, 0, 1286, 1162, 1, 0, 0, 0, 1286, 1163, 1, 0, 0, 0, 1286,
		1164, 1, 0, 0, 0, 1286, 1165, 1, 0, 0, 0, 1286, 1166, 1, 0, 0, 0, 1286,
		1167, 1, 0, 0, 0, 1286, 1168, 1, 0, 0, 0, 1286, 1169, 1, 0, 0, 0, 1286,
		1170, 1, 0, 0, 0, 1286, 1171, 1, 0, 0, 0, 1286, 1172, 1, 0, 0, 0, 1286,
		1173, 1, 0, 0, 0, 1286, 1174, 1, 0, 0, 0, 1286, 1175, 1, 0, 0, 0, 1286,
		1176, 1, 0, 0, 0, 1286, 1177, 1, 0, 0, 0, 1286, 1178, 1, 0, 0, 0, 1286,
		1179, 1, 0, 0, 0, 1286, 1180, 1, 0, 0, 0, 1286, 1181, 1, 0, 0, 0, 1286,
		1182, 1, 0, 0, 0, 1286, 1183, 1, 0, 0, 0, 1286, 1184, 1, 0, 0, 0, 1286,
		1185, 1, 0, 0, 0, 1286, 1186, 1, 0, 0, 0, 1286, 1187, 1, 0, 0, 0, 1286,
		1188, 1, 0, 0, 0, 1286, 1189, 1, 0, 0, 0, 1286, 1190, 1, 0, 0, 0, 1286,
		1191, 1, 0, 0, 0, 1286, 1192, 1, 0, 0, 0, 1286, 1193, 1, 0, 0, 0, 1286,
		1194, 1, 0, 0, 0, 1286, 1195, 1, 0, 0, 0, 1286, 1196, 1, 0, 0, 0, 1286,
		1197, 1, 0, 0, 0, 1286, 1198, 1, 0, 0, 0, 1286, 1199, 1, 0, 0, 0, 1286,
		1200, 1, 0, 0, 0, 1286, 1201, 1, 0, 0, 0, 1286, 1202, 1, 0, 0, 0, 1286,
		1203, 1, 0, 0, 0, 1286, 1204, 1, 0, 0, 0, 1286, 1205, 1, 0, 0, 0, 1286,
		1206, 1, 0, 0, 0, 1286, 1207, 1, 0, 0, 0, 1286, 1208, 1, 0, 0, 0, 1286,
		1209, 1, 0, 0, 0, 1286, 1210, 1, 0, 0, 0, 1286, 1211, 1, 0, 0, 0, 1286,
		1212, 1, 0, 0, 0, 1286, 1213, 1, 0, 0, 0, 1286, 1214, 1, 0, 0, 0, 1286,
		1215, 1, 0, 0, 0, 1286, 1216, 1, 0, 0, 0, 1286, 1217, 1, 0, 0, 0, 1286,
		1218, 1, 0, 0, 0, 1286, 1219, 1, 0, 0, 0, 1286, 1220, 1, 0, 0, 0, 1286,
		1221, 1, 0, 0, 0, 1286, 1222, 1, 0, 0, 0, 1286, 1223, 1, 0, 0, 0, 1286,
		1224, 1, 0, 0, 0, 1286, 1225, 1, 0, 0, 0, 1286, 1226, 1, 0, 0, 0, 1286,
		1227, 1, 0, 0, 0, 1286, 1228, 1, 0, 0, 0, 1286, 1229, 1, 0, 0, 0, 1286,
		1230, 1, 0, 0, 0, 1286, 1231, 1, 0, 0, 0, 1286, 1232, 1, 0, 0, 0, 1286,
		1233, 1, 0, 0, 0, 1286, 1234, 1, 0, 0, 0, 1286, 1235, 1, 0, 0, 0, 1286,
		1236, 1, 0, 0, 0, 1286, 1237, 1, 0, 0, 0, 1286, 1238, 1, 0, 0, 0, 1286,
		1239, 1, 0, 0, 0, 1286, 1240, 1, 0, 0, 0, 1286, 1241, 1, 0, 0, 0, 1286,
		1242, 1, 0, 0, 0, 1286, 1243, 1, 0, 0, 0, 1286, 1244, 1, 0, 0, 0, 1286,
		1245, 1, 0, 0, 0, 1286, 1246, 1, 0, 0, 0, 1286, 1247, 1, 0, 0, 0, 1286,
		1248, 1, 0, 0, 0, 1286, 1249, 1, 0, 0, 0, 1286, 1250, 1, 0, 0, 0, 1286,
		1251, 1, 0, 0, 0, 1286, 1252, 1, 0, 0, 0, 1286, 1253, 1, 0, 0, 0, 1286,
		1254, 1, 0, 0, 0, 1286, 1255, 1, 0, 0, 0, 1286, 1256, 1, 0, 0, 0, 1286,
		1257, 1, 0, 0, 0, 1286, 1258, 1, 0, 0, 0, 1286, 1259, 1, 0, 0, 0, 1286,
		1260, 1, 0, 0, 0, 1286, 1261, 1, 0, 0, 0, 1286, 1262, 1, 0, 0, 0, 1286,
		1263, 1, 0, 0, 0, 1286, 1264, 1, 0, 0, 0, 1286, 1265, 1, 0, 0, 0, 1286,
		1266, 1, 0, 0, 0, 1286, 1267, 1, 0, 0, 0, 1286, 1268, 1, 0, 0, 0, 1286,
		1269, 1, 0, 0, 0, 1286, 1270, 1, 0, 0, 0, 1286, 1271, 1, 0, 0, 0, 1286,
		1272, 1, 0, 0, 0, 1286, 1273, 1, 0, 0, 0, 1286, 1274, 1, 0, 0, 0, 1286,
		1275, 1, 0, 0, 0, 1286, 1276, 1, 0, 0, 0, 1286, 1277, 1, 0, 0, 0, 1286,
		1278, 1, 0, 0, 0, 1286, 1279, 1, 0, 0, 0, 1286, 1280, 1, 0, 0, 0, 1286,
		1281, 1, 0, 0, 0, 1286, 1282, 1, 0, 0, 0, 1286, 1283, 1, 0, 0, 0, 1286,
		1284, 1, 0, 0, 0, 1286, 1285, 1, 0, 0, 0, 1287, 7, 1, 0, 0, 0, 1288, 1289,
		5, 455, 0, 0, 1289, 1290, 3, 1006, 503, 0, 1290, 9, 1, 0, 0, 0, 1291, 1292,
		5, 455, 0, 0, 1292, 1293, 3, 970, 485, 0, 1293, 11, 1, 0, 0, 0, 1294, 1295,
		5, 393, 0, 0, 1295, 1296, 5, 60, 0, 0, 1296, 1297, 3, 1020, 510, 0, 1297,
		13, 1, 0, 0, 0, 1298, 1299, 5, 398, 0, 0, 1299, 1302, 5, 103, 0, 0, 1300,
		1301, 7, 1, 0, 0, 1301, 1303, 3, 1006, 503, 0, 1302, 1300, 1, 0, 0, 0,
		1302, 1303, 1, 0, 0, 0, 1303, 1308, 1, 0, 0, 0, 1304, 1305, 5, 237, 0,
		0, 1305, 1309, 3, 970, 485, 0, 1306, 1307, 5, 476, 0, 0, 1307, 1309, 3,
		842, 421, 0, 1308, 1304, 1, 0, 0, 0, 1308, 1306, 1, 0, 0, 0, 1308, 1309,
		1, 0, 0, 0, 1309, 1319, 1, 0, 0, 0, 1310, 1311, 5, 398, 0, 0, 1311, 1316,
		5, 385, 0, 0, 1312, 1313, 5, 237, 0, 0, 1313, 1317, 3, 970, 485, 0, 1314,
		1315, 5, 476, 0, 0, 1315, 1317, 3, 842, 421, 0, 1316, 1312, 1, 0, 0, 0,
		1316, 1314, 1, 0, 0, 0, 1316, 1317, 1, 0, 0, 0, 1317, 1319, 1, 0, 0, 0,
		1318, 1298, 1, 0, 0, 0, 1318, 1310, 1, 0, 0, 0, 1319, 15, 1, 0, 0, 0, 1320,
		1321, 5, 19, 0, 0, 1321, 1322, 5, 102, 0, 0, 1322, 1323, 3, 1012, 506,
		0, 1323, 1324, 5, 393, 0, 0, 1324, 1325, 5, 100, 0, 0, 1325, 1326, 5, 338,
		0, 0, 1326, 1327, 3, 1012, 506, 0, 1327, 1337, 1, 0, 0, 0, 1328, 1329,
		5, 19, 0, 0, 1329, 1330, 5, 102, 0, 0, 1330, 1331, 3, 1012, 506, 0, 1331,
		1332, 5, 393, 0, 0, 1332, 1333, 5, 355, 0, 0, 1333, 1334, 5, 338, 0, 0,
		1334, 1335, 5, 516, 0, 0, 1335, 1337, 1, 0, 0, 0, 1336, 1320, 1, 0, 0,
		0, 1336, 1328, 1, 0, 0, 0, 1337, 17, 1, 0, 0, 0, 1338, 1339, 5, 88, 0,
		0, 1339, 1343, 7, 2, 0, 0, 1340, 1341, 5, 194, 0, 0, 1341, 1342, 5, 278,
		0, 0, 1342, 1344, 5, 145, 0, 0, 1343, 1340, 1, 0, 0, 0, 1343, 1344, 1,
		0, 0, 0, 1344, 1348, 1, 0, 0, 0, 1345, 1346, 3, 1012, 506, 0, 1346, 1347,
		5, 1, 0, 0, 1347, 1349, 1, 0, 0, 0, 1348, 1345, 1, 0, 0, 0, 1348, 1349,
		1, 0, 0, 0, 1349, 1350, 1, 0, 0, 0, 1350, 1352, 3, 1006, 503, 0, 1351,
		1353, 3, 46, 23, 0, 1352, 1351, 1, 0, 0, 0, 1352, 1353, 1, 0, 0, 0, 1353,
		1355, 1, 0, 0, 0, 1354, 1356, 3, 48, 24, 0, 1355, 1354, 1, 0, 0, 0, 1355,
		1356, 1, 0, 0, 0, 1356, 1358, 1, 0, 0, 0, 1357, 1359, 3, 948, 474, 0, 1358,
		1357, 1, 0, 0, 0, 1358, 1359, 1, 0, 0, 0, 1359, 19, 1, 0, 0, 0, 1360, 1361,
		5, 130, 0, 0, 1361, 1364, 7, 2, 0, 0, 1362, 1363, 5, 194, 0, 0, 1363, 1365,
		5, 145, 0, 0, 1364, 1362, 1, 0, 0, 0, 1364, 1365, 1, 0, 0, 0, 1365, 1369,
		1, 0, 0, 0, 1366, 1367, 3, 1012, 506, 0, 1367, 1368, 5, 1, 0, 0, 1368,
		1370, 1, 0, 0, 0, 1369, 1366, 1, 0, 0, 0, 1369, 1370, 1, 0, 0, 0, 1370,
		1371, 1, 0, 0, 0, 1371, 1373, 3, 1006, 503, 0, 1372, 1374, 5, 166, 0, 0,
		1373, 1372, 1, 0, 0, 0, 1373, 1374, 1, 0, 0, 0, 1374, 21, 1, 0, 0, 0, 1375,
		1376, 5, 398, 0, 0, 1376, 1377, 5, 88, 0, 0, 1377, 1378, 7, 2, 0, 0, 1378,
		1379, 3, 1012, 506, 0, 1379, 23, 1, 0, 0, 0, 1380, 1381, 5, 19, 0, 0, 1381,
		1382, 5, 102, 0, 0, 1382, 1383, 3, 1012, 506, 0, 1383, 1384, 5, 350, 0,
		0, 1384, 1385, 3, 1012, 506, 0, 1385, 25, 1, 0, 0, 0, 1386, 1387, 5, 344,
		0, 0, 1387, 1388, 7, 2, 0, 0, 1388, 1389, 3, 1012, 506, 0, 1389, 27, 1,
		0, 0, 0, 1390, 1391, 5, 398, 0, 0, 1391, 1397, 5, 100, 0, 0, 1392, 1393,
		5, 398, 0, 0, 1393, 1394, 5, 100, 0, 0, 1394, 1395, 5, 169, 0, 0, 1395,
		1397, 3, 1006, 503, 0, 1396, 1390, 1, 0, 0, 0, 1396, 1392, 1, 0, 0, 0,
		1397, 29, 1, 0, 0, 0, 1398, 1399, 5, 398, 0, 0, 1399, 1400, 5, 100, 0,
		0, 1400, 1401, 5, 128, 0, 0, 1401, 1402, 5, 169, 0, 0, 1402, 1404, 3, 1006,
		503, 0, 1403, 1405, 3, 816, 408, 0, 1404, 1403, 1, 0, 0, 0, 1404, 1405,
		1, 0, 0, 0, 1405, 31, 1, 0, 0, 0, 1406, 1408, 5, 88, 0, 0, 1407, 1409,
		7, 3, 0, 0, 1408, 1407, 1, 0, 0, 0, 1408, 1409, 1, 0, 0, 0, 1409, 1410,
		1, 0, 0, 0, 1410, 1414, 5, 420, 0, 0, 1411, 1412, 5, 194, 0, 0, 1412, 1413,
		5, 278, 0, 0, 1413, 1415, 5, 145, 0, 0, 1414, 1411, 1, 0, 0, 0, 1414, 1415,
		1, 0, 0, 0, 1415, 1416, 1, 0, 0, 0, 1416, 1417, 3, 1006, 503, 0, 1417,
		1418, 5, 2, 0, 0, 1418, 1423, 3, 34, 17, 0, 1419, 1420, 5, 3, 0, 0, 1420,
		1422, 3, 34, 17, 0, 1421, 1419, 1, 0, 0, 0, 1422, 1425, 1, 0, 0, 0, 1423,
		1421, 1, 0, 0, 0, 1423, 1424, 1, 0, 0, 0, 1424, 1430, 1, 0, 0, 0, 1425,
		1423, 1, 0, 0, 0, 1426, 1427, 5, 3, 0, 0, 1427, 1429, 3, 42, 21, 0, 1428,
		1426, 1, 0, 0, 0, 1429, 1432, 1, 0, 0, 0, 1430, 1428, 1, 0, 0, 0, 1430,
		1431, 1, 0, 0, 0, 1431, 1433, 1, 0, 0, 0, 1432, 1430, 1, 0, 0, 0, 1433,
		1435, 5, 4, 0, 0, 1434, 1436, 3, 44, 22, 0, 1435, 1434, 1, 0, 0, 0, 1435,
		1436, 1, 0, 0, 0, 1436, 1438, 1, 0, 0, 0, 1437, 1439, 3, 46, 23, 0, 1438,
		1437, 1, 0, 0, 0, 1438, 1439, 1, 0, 0, 0, 1439, 1441, 1, 0, 0, 0, 1440,
		1442, 3, 50, 25, 0, 1441, 1440, 1, 0, 0, 0, 1441, 1442, 1, 0, 0, 0, 1442,
		1444, 1, 0, 0, 0, 1443, 1445, 3, 964, 482, 0, 1444, 1443, 1, 0, 0, 0, 1444,
		1445, 1, 0, 0, 0, 1445, 1447, 1, 0, 0, 0, 1446, 1448, 3, 900, 450, 0, 1447,
		1446, 1, 0, 0, 0, 1447, 1448, 1, 0, 0, 0, 1448, 1450, 1, 0, 0, 0, 1449,
		1451, 3, 940, 470, 0, 1450, 1449, 1, 0, 0, 0, 1450, 1451, 1, 0, 0, 0, 1451,
		1453, 1, 0, 0, 0, 1452, 1454, 3, 52, 26, 0, 1453, 1452, 1, 0, 0, 0, 1453,
		1454, 1, 0, 0, 0, 1454, 1456, 1, 0, 0, 0, 1455, 1457, 3, 62, 31, 0, 1456,
		1455, 1, 0, 0, 0, 1456, 1457, 1, 0, 0, 0, 1457, 1459, 1, 0, 0, 0, 1458,
		1460, 3, 948, 474, 0, 1459, 1458, 1, 0, 0, 0, 1459, 1460, 1, 0, 0, 0, 1460,
		1462, 1, 0, 0, 0, 1461, 1463, 3, 950, 475, 0, 1462, 1461, 1, 0, 0, 0, 1462,
		1463, 1, 0, 0, 0, 1463, 33, 1, 0, 0, 0, 1464, 1466, 3, 1012, 506, 0, 1465,
		1467, 3, 988, 494, 0, 1466, 1465, 1, 0, 0, 0, 1466, 1467, 1, 0, 0, 0, 1467,
		1469, 1, 0, 0, 0, 1468, 1470, 3, 36, 18, 0, 1469, 1468, 1, 0, 0, 0, 1469,
		1470, 1, 0, 0, 0, 1470, 1472, 1, 0, 0, 0, 1471, 1473, 5, 224, 0, 0, 1472,
		1471, 1, 0, 0, 0, 1472, 1473, 1, 0, 0, 0, 1473, 1475, 1, 0, 0, 0, 1474,
		1476, 3, 60, 30, 0, 1475, 1474, 1, 0, 0, 0, 1475, 1476, 1, 0, 0, 0, 1476,
		1478, 1, 0, 0, 0, 1477, 1479, 3, 54, 27, 0, 1478, 1477, 1, 0, 0, 0, 1478,
		1479, 1, 0, 0, 0, 1479, 1483, 1, 0, 0, 0, 1480, 1484, 3, 38, 19, 0, 1481,
		1484, 5, 33, 0, 0, 1482, 1484, 3, 40, 20, 0, 1483, 1480, 1, 0, 0, 0, 1483,
		1481, 1, 0, 0, 0, 1483, 1482, 1, 0, 0, 0, 1483, 1484, 1, 0, 0, 0, 1484,
		1486, 1, 0, 0, 0, 1485, 1487, 3, 964, 482, 0, 1486, 1485, 1, 0, 0, 0, 1486,
		1487, 1, 0, 0, 0, 1487, 35, 1, 0, 0, 0, 1488, 1489, 5, 64, 0, 0, 1489,
		1490, 5, 393, 0, 0, 1490, 1497, 3, 1012, 506, 0, 1491, 1492, 5, 66, 0,
		0, 1492, 1497, 3, 1012, 506, 0, 1493, 1494, 5, 65, 0, 0, 1494, 1495, 5,
		393, 0, 0, 1495, 1497, 3, 1012, 506, 0, 1496, 1488, 1, 0, 0, 0, 1496, 1491,
		1, 0, 0, 0, 1496, 1493, 1, 0, 0, 0, 1497, 37, 1, 0, 0, 0, 1498, 1515, 5,
		115, 0, 0, 1499, 1516, 3, 970, 485, 0, 1500, 1516, 5, 279, 0, 0, 1501,
		1507, 5, 98, 0, 0, 1502, 1504, 5, 2, 0, 0, 1503, 1505, 5, 516, 0, 0, 1504,
		1503, 1, 0, 0, 0, 1504, 1505, 1, 0, 0, 0, 1505, 1506, 1, 0, 0, 0, 1506,
		1508, 5, 4, 0, 0, 1507, 1502, 1, 0, 0, 0, 1507, 1508, 1, 0, 0, 0, 1508,
		1516, 1, 0, 0, 0, 1509, 1510, 5, 2, 0, 0, 1510, 1511, 3, 1006, 503, 0,
		1511, 1512, 5, 2, 0, 0, 1512, 1513, 5, 4, 0, 0, 1513, 1514, 5, 4, 0, 0,
		1514, 1516, 1, 0, 0, 0, 1515, 1499, 1, 0, 0, 0, 1515, 1500, 1, 0, 0, 0,
		1515, 1501, 1, 0, 0, 0, 1515, 1509, 1, 0, 0, 0, 1516, 39, 1, 0, 0, 0, 1517,
		1518, 5, 27, 0, 0, 1518, 1519, 3, 842, 421, 0, 1519, 41, 1, 0, 0, 0, 1520,
		1521, 5, 202, 0, 0, 1521, 1522, 3, 1012, 506, 0, 1522, 1527, 3, 1018, 509,
		0, 1523, 1525, 3, 86, 43, 0, 1524, 1526, 3, 952, 476, 0, 1525, 1524, 1,
		0, 0, 0, 1525, 1526, 1, 0, 0, 0, 1526, 1528, 1, 0, 0, 0, 1527, 1523, 1,
		0, 0, 0, 1527, 1528, 1, 0, 0, 0, 1528, 1530, 1, 0, 0, 0, 1529, 1531, 3,
		964, 482, 0, 1530, 1529, 1, 0, 0, 0, 1530, 1531, 1, 0, 0, 0, 1531, 43,
		1, 0, 0, 0, 1532, 1533, 5, 138, 0, 0, 1533, 1534, 5, 490, 0, 0, 1534, 1535,
		3, 1012, 506, 0, 1535, 45, 1, 0, 0, 0, 1536, 1538, 5, 115, 0, 0, 1537,
		1536, 1, 0, 0, 0, 1537, 1538, 1, 0, 0, 0, 1538, 1544, 1, 0, 0, 0, 1539,
		1540, 5, 64, 0, 0, 1540, 1545, 5, 393, 0, 0, 1541, 1545, 5, 66, 0, 0, 1542,
		1543, 5, 65, 0, 0, 1543, 1545, 5, 393, 0, 0, 1544, 1539, 1, 0, 0, 0, 1544,
		1541, 1, 0, 0, 0, 1544, 1542, 1, 0, 0, 0, 1545, 1547, 1, 0, 0, 0, 1546,
		1548, 5, 490, 0, 0, 1547, 1546, 1, 0, 0, 0, 1547, 1548, 1, 0, 0, 0, 1548,
		1549, 1, 0, 0, 0, 1549, 1550, 3, 1020, 510, 0, 1550, 47, 1, 0, 0, 0, 1551,
		1553, 5, 115, 0, 0, 1552, 1551, 1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553,
		1554, 1, 0, 0, 0, 1554, 1556, 5, 72, 0, 0, 1555, 1557, 5, 490, 0, 0, 1556,
		1555, 1, 0, 0, 0, 1556, 1557, 1, 0, 0, 0, 1557, 1558, 1, 0, 0, 0, 1558,
		1559, 3, 1020, 510, 0, 1559, 49, 1, 0, 0, 0, 1560, 1561, 7, 4, 0, 0, 1561,
		1562, 5, 224, 0, 0, 1562, 1563, 3, 1018, 509, 0, 1563, 51, 1, 0, 0, 0,
		1564, 1565, 5, 295, 0, 0, 1565, 1566, 5, 55, 0, 0, 1566, 1567, 3, 1018,
		509, 0, 1567, 53, 1, 0, 0, 0, 1568, 1572, 5, 279, 0, 0, 1569, 1570, 5,
		278, 0, 0, 1570, 1572, 5, 279, 0, 0, 1571, 1568, 1, 0, 0, 0, 1571, 1569,
		1, 0, 0, 0, 1572, 55, 1, 0, 0, 0, 1573, 1575, 3, 988, 494, 0, 1574, 1576,
		3, 54, 27, 0, 1575, 1574, 1, 0, 0, 0, 1575, 1576, 1, 0, 0, 0, 1576, 57,
		1, 0, 0, 0, 1577, 1578, 3, 1012, 506, 0, 1578, 1579, 5, 2, 0, 0, 1579,
		1584, 3, 56, 28, 0, 1580, 1581, 5, 3, 0, 0, 1581, 1583, 3, 56, 28, 0, 1582,
		1580, 1, 0, 0, 0, 1583, 1586, 1, 0, 0, 0, 1584, 1582, 1, 0, 0, 0, 1584,
		1585, 1, 0, 0, 0, 1585, 1587, 1, 0, 0, 0, 1586, 1584, 1, 0, 0, 0, 1587,
		1588, 5, 4, 0, 0, 1588, 59, 1, 0, 0, 0, 1589, 1599, 5, 413, 0, 0, 1590,
		1599, 5, 255, 0, 0, 1591, 1599, 5, 260, 0, 0, 1592, 1599, 5, 353, 0, 0,
		1593, 1599, 5, 188, 0, 0, 1594, 1599, 5, 45, 0, 0, 1595, 1599, 5, 308,
		0, 0, 1596, 1599, 5, 354, 0, 0, 1597, 1599, 3, 58, 29, 0, 1598, 1589, 1,
		0, 0, 0, 1598, 1590, 1, 0, 0, 0, 1598, 1591, 1, 0, 0, 0, 1598, 1592, 1,
		0, 0, 0, 1598, 1593, 1, 0, 0, 0, 1598, 1594, 1, 0, 0, 0, 1598, 1595, 1,
		0, 0, 0, 1598, 1596, 1, 0, 0, 0, 1598, 1597, 1, 0, 0, 0, 1599, 61, 1, 0,
		0, 0, 1600, 1601, 5, 373, 0, 0, 1601, 1602, 5, 2, 0, 0, 1602, 1607, 3,
		64, 32, 0, 1603, 1604, 5, 3, 0, 0, 1604, 1606, 3, 64, 32, 0, 1605, 1603,
		1, 0, 0, 0, 1606, 1609, 1, 0, 0, 0, 1607, 1605, 1, 0, 0, 0, 1607, 1608,
		1, 0, 0, 0, 1608, 1610, 1, 0, 0, 0, 1609, 1607, 1, 0, 0, 0, 1610, 1611,
		5, 4, 0, 0, 1611, 63, 1, 0, 0, 0, 1612, 1613, 3, 1012, 506, 0, 1613, 1615,
		3, 1018, 509, 0, 1614, 1616, 3, 66, 33, 0, 1615, 1614, 1, 0, 0, 0, 1615,
		1616, 1, 0, 0, 0, 1616, 1618, 1, 0, 0, 0, 1617, 1619, 3, 68, 34, 0, 1618,
		1617, 1, 0, 0, 0, 1618, 1619, 1, 0, 0, 0, 1619, 1621, 1, 0, 0, 0, 1620,
		1622, 3, 948, 474, 0, 1621, 1620, 1, 0, 0, 0, 1621, 1622, 1, 0, 0, 0, 1622,
		65, 1, 0, 0, 0, 1623, 1624, 5, 132, 0, 0, 1624, 1625, 5, 224, 0, 0, 1625,
		1626, 3, 1018, 509, 0, 1626, 67, 1, 0, 0, 0, 1627, 1628, 5, 169, 0, 0,
		1628, 1629, 3, 1012, 506, 0, 1629, 69, 1, 0, 0, 0, 1630, 1631, 5, 294,
		0, 0, 1631, 1633, 5, 353, 0, 0, 1632, 1630, 1, 0, 0, 0, 1632, 1633, 1,
		0, 0, 0, 1633, 71, 1, 0, 0, 0, 1634, 1635, 5, 194, 0, 0, 1635, 1636, 5,
		278, 0, 0, 1636, 1638, 5, 145, 0, 0, 1637, 1634, 1, 0, 0, 0, 1637, 1638,
		1, 0, 0, 0, 1638, 73, 1, 0, 0, 0, 1639, 1641, 5, 88, 0, 0, 1640, 1642,
		5, 426, 0, 0, 1641, 1640, 1, 0, 0, 0, 1641, 1642, 1, 0, 0, 0, 1642, 1643,
		1, 0, 0, 0, 1643, 1647, 5, 420, 0, 0, 1644, 1645, 5, 194, 0, 0, 1645, 1646,
		5, 278, 0, 0, 1646, 1648, 5, 145, 0, 0, 1647, 1644, 1, 0, 0, 0, 1647, 1648,
		1, 0, 0, 0, 1648, 1649, 1, 0, 0, 0, 1649, 1678, 3, 1006, 503, 0, 1650,
		1674, 5, 2, 0, 0, 1651, 1656, 3, 1012, 506, 0, 1652, 1653, 5, 3, 0, 0,
		1653, 1655, 3, 1012, 506, 0, 1654, 1652, 1, 0, 0, 0, 1655, 1658, 1, 0,
		0, 0, 1656, 1654, 1, 0, 0, 0, 1656, 1657, 1, 0, 0, 0, 1657, 1663, 1, 0,
		0, 0, 1658, 1656, 1, 0, 0, 0, 1659, 1660, 5, 3, 0, 0, 1660, 1662, 3, 42,
		21, 0, 1661, 1659, 1, 0, 0, 0, 1662, 1665, 1, 0, 0, 0, 1663, 1661, 1, 0,
		0, 0, 1663, 1664, 1, 0, 0, 0, 1664, 1675, 1, 0, 0, 0, 1665, 1663, 1, 0,
		0, 0, 1666, 1671, 3, 42, 21, 0, 1667, 1668, 5, 3, 0, 0, 1668, 1670, 3,
		42, 21, 0, 1669, 1667, 1, 0, 0, 0, 1670, 1673, 1, 0, 0, 0, 1671, 1669,
		1, 0, 0, 0, 1671, 1672, 1, 0, 0, 0, 1672, 1675, 1, 0, 0, 0, 1673, 1671,
		1, 0, 0, 0, 1674, 1651, 1, 0, 0, 0, 1674, 1666, 1, 0, 0, 0, 1675, 1676,
		1, 0, 0, 0, 1676, 1677, 5, 4, 0, 0, 1677, 1679, 1, 0, 0, 0, 1678, 1650,
		1, 0, 0, 0, 1678, 1679, 1, 0, 0, 0, 1679, 1681, 1, 0, 0, 0, 1680, 1682,
		3, 50, 25, 0, 1681, 1680, 1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 1682, 1684,
		1, 0, 0, 0, 1683, 1685, 3, 964, 482, 0, 1684, 1683, 1, 0, 0, 0, 1684, 1685,
		1, 0, 0, 0, 1685, 1687, 1, 0, 0, 0, 1686, 1688, 3, 900, 450, 0, 1687, 1686,
		1, 0, 0, 0, 1687, 1688, 1, 0, 0, 0, 1688, 1690, 1, 0, 0, 0, 1689, 1691,
		3, 940, 470, 0, 1690, 1689, 1, 0, 0, 0, 1690, 1691, 1, 0, 0, 0, 1691, 1693,
		1, 0, 0, 0, 1692, 1694, 3, 52, 26, 0, 1693, 1692, 1, 0, 0, 0, 1693, 1694,
		1, 0, 0, 0, 1694, 1696, 1, 0, 0, 0, 1695, 1697, 3, 948, 474, 0, 1696, 1695,
		1, 0, 0, 0, 1696, 1697, 1, 0, 0, 0, 1697, 1698, 1, 0, 0, 0, 1698, 1699,
		5, 27, 0, 0, 1699, 1700, 3, 744, 372, 0, 1700, 75, 1, 0, 0, 0, 1701, 1703,
		5, 130, 0, 0, 1702, 1704, 5, 426, 0, 0, 1703, 1702, 1, 0, 0, 0, 1703, 1704,
		1, 0, 0, 0, 1704, 1705, 1, 0, 0, 0, 1705, 1708, 5, 420, 0, 0, 1706, 1707,
		5, 194, 0, 0, 1707, 1709, 5, 145, 0, 0, 1708, 1706, 1, 0, 0, 0, 1708, 1709,
		1, 0, 0, 0, 1709, 1710, 1, 0, 0, 0, 1710, 1712, 3, 1006, 503, 0, 1711,
		1713, 5, 166, 0, 0, 1712, 1711, 1, 0, 0, 0, 1712, 1713, 1, 0, 0, 0, 1713,
		77, 1, 0, 0, 0, 1714, 1715, 5, 68, 0, 0, 1715, 1716, 5, 426, 0, 0, 1716,
		1717, 5, 420, 0, 0, 1717, 1718, 5, 287, 0, 0, 1718, 1719, 5, 392, 0, 0,
		1719, 1720, 3, 970, 485, 0, 1720, 79, 1, 0, 0, 0, 1721, 1722, 5, 19, 0,
		0, 1722, 1723, 5, 420, 0, 0, 1723, 1724, 3, 1006, 503, 0, 1724, 1729, 3,
		232, 116, 0, 1725, 1726, 5, 3, 0, 0, 1726, 1728, 3, 232, 116, 0, 1727,
		1725, 1, 0, 0, 0, 1728, 1731, 1, 0, 0, 0, 1729, 1727, 1, 0, 0, 0, 1729,
		1730, 1, 0, 0, 0, 1730, 1759, 1, 0, 0, 0, 1731, 1729, 1, 0, 0, 0, 1732,
		1733, 5, 19, 0, 0, 1733, 1734, 5, 420, 0, 0, 1734, 1735, 3, 1006, 503,
		0, 1735, 1736, 5, 13, 0, 0, 1736, 1737, 5, 373, 0, 0, 1737, 1742, 3, 64,
		32, 0, 1738, 1739, 5, 3, 0, 0, 1739, 1741, 3, 64, 32, 0, 1740, 1738, 1,
		0, 0, 0, 1741, 1744, 1, 0, 0, 0, 1742, 1740, 1, 0, 0, 0, 1742, 1743, 1,
		0, 0, 0, 1743, 1759, 1, 0, 0, 0, 1744, 1742, 1, 0, 0, 0, 1745, 1746, 5,
		19, 0, 0, 1746, 1747, 5, 420, 0, 0, 1747, 1748, 3, 1006, 503, 0, 1748,
		1749, 5, 130, 0, 0, 1749, 1750, 5, 373, 0, 0, 1750, 1755, 3, 1012, 506,
		0, 1751, 1752, 5, 3, 0, 0, 1752, 1754, 3, 1012, 506, 0, 1753, 1751, 1,
		0, 0, 0, 1754, 1757, 1, 0, 0, 0, 1755, 1753, 1, 0, 0, 0, 1755, 1756, 1,
		0, 0, 0, 1756, 1759, 1, 0, 0, 0, 1757, 1755, 1, 0, 0, 0, 1758, 1721, 1,
		0, 0, 0, 1758, 1732, 1, 0, 0, 0, 1758, 1745, 1, 0, 0, 0, 1759, 81, 1, 0,
		0, 0, 1760, 1761, 5, 88, 0, 0, 1761, 1762, 5, 202, 0, 0, 1762, 1763, 3,
		1012, 506, 0, 1763, 1764, 5, 287, 0, 0, 1764, 1765, 3, 1006, 503, 0, 1765,
		1770, 3, 1018, 509, 0, 1766, 1768, 3, 86, 43, 0, 1767, 1769, 3, 952, 476,
		0, 1768, 1767, 1, 0, 0, 0, 1768, 1769, 1, 0, 0, 0, 1769, 1771, 1, 0, 0,
		0, 1770, 1766, 1, 0, 0, 0, 1770, 1771, 1, 0, 0, 0, 1771, 1773, 1, 0, 0,
		0, 1772, 1774, 3, 964, 482, 0, 1773, 1772, 1, 0, 0, 0, 1773, 1774, 1, 0,
		0, 0, 1774, 83, 1, 0, 0, 0, 1775, 1776, 5, 130, 0, 0, 1776, 1777, 5, 202,
		0, 0, 1777, 1778, 3, 1012, 506, 0, 1778, 1779, 5, 287, 0, 0, 1779, 1780,
		3, 1006, 503, 0, 1780, 85, 1, 0, 0, 0, 1781, 1782, 5, 458, 0, 0, 1782,
		1783, 7, 5, 0, 0, 1783, 87, 1, 0, 0, 0, 1784, 1786, 5, 398, 0, 0, 1785,
		1787, 5, 172, 0, 0, 1786, 1785, 1, 0, 0, 0, 1786, 1787, 1, 0, 0, 0, 1787,
		1788, 1, 0, 0, 0, 1788, 1791, 5, 421, 0, 0, 1789, 1790, 7, 1, 0, 0, 1790,
		1792, 3, 1006, 503, 0, 1791, 1789, 1, 0, 0, 0, 1791, 1792, 1, 0, 0, 0,
		1792, 1797, 1, 0, 0, 0, 1793, 1794, 5, 237, 0, 0, 1794, 1798, 3, 970, 485,
		0, 1795, 1796, 5, 476, 0, 0, 1796, 1798, 3, 842, 421, 0, 1797, 1793, 1,
		0, 0, 0, 1797, 1795, 1, 0, 0, 0, 1797, 1798, 1, 0, 0, 0, 1798, 89, 1, 0,
		0, 0, 1799, 1800, 5, 398, 0, 0, 1800, 1801, 5, 426, 0, 0, 1801, 1804, 5,
		421, 0, 0, 1802, 1803, 7, 1, 0, 0, 1803, 1805, 3, 1006, 503, 0, 1804, 1802,
		1, 0, 0, 0, 1804, 1805, 1, 0, 0, 0, 1805, 1810, 1, 0, 0, 0, 1806, 1807,
		5, 237, 0, 0, 1807, 1811, 3, 970, 485, 0, 1808, 1809, 5, 476, 0, 0, 1809,
		1811, 3, 842, 421, 0, 1810, 1806, 1, 0, 0, 0, 1810, 1808, 1, 0, 0, 0, 1810,
		1811, 1, 0, 0, 0, 1811, 91, 1, 0, 0, 0, 1812, 1813, 5, 398, 0, 0, 1813,
		1818, 5, 88, 0, 0, 1814, 1819, 5, 420, 0, 0, 1815, 1819, 5, 467, 0, 0,
		1816, 1817, 5, 254, 0, 0, 1817, 1819, 5, 467, 0, 0, 1818, 1814, 1, 0, 0,
		0, 1818, 1815, 1, 0, 0, 0, 1818, 1816, 1, 0, 0, 0, 1819, 1820, 1, 0, 0,
		0, 1820, 1821, 3, 1006, 503, 0, 1821, 93, 1, 0, 0, 0, 1822, 1824, 5, 398,
		0, 0, 1823, 1825, 5, 172, 0, 0, 1824, 1823, 1, 0, 0, 0, 1824, 1825, 1,
		0, 0, 0, 1825, 1826, 1, 0, 0, 0, 1826, 1827, 7, 6, 0, 0, 1827, 1828, 7,
		1, 0, 0, 1828, 1829, 3, 1006, 503, 0, 1829, 1832, 1, 0, 0, 0, 1830, 1831,
		7, 1, 0, 0, 1831, 1833, 3, 1006, 503, 0, 1832, 1830, 1, 0, 0, 0, 1832,
		1833, 1, 0, 0, 0, 1833, 1838, 1, 0, 0, 0, 1834, 1835, 5, 237, 0, 0, 1835,
		1839, 3, 970, 485, 0, 1836, 1837, 5, 476, 0, 0, 1837, 1839, 3, 842, 421,
		0, 1838, 1834, 1, 0, 0, 0, 1838, 1836, 1, 0, 0, 0, 1838, 1839, 1, 0, 0,
		0, 1839, 95, 1, 0, 0, 0, 1840, 1841, 5, 398, 0, 0, 1841, 1842, 5, 420,
		0, 0, 1842, 1845, 5, 406, 0, 0, 1843, 1844, 7, 1, 0, 0, 1844, 1846, 3,
		1006, 503, 0, 1845, 1843, 1, 0, 0, 0, 1845, 1846, 1, 0, 0, 0, 1846, 1851,
		1, 0, 0, 0, 1847, 1848, 5, 237, 0, 0, 1848, 1852, 3, 970, 485, 0, 1849,
		1850, 5, 476, 0, 0, 1850, 1852, 3, 842, 421, 0, 1851, 1847, 1, 0, 0, 0,
		1851, 1849, 1, 0, 0, 0, 1851, 1852, 1, 0, 0, 0, 1852, 97, 1, 0, 0, 0, 1853,
		1854, 5, 345, 0, 0, 1854, 1855, 5, 148, 0, 0, 1855, 1856, 5, 420, 0, 0,
		1856, 1869, 3, 1006, 503, 0, 1857, 1858, 5, 300, 0, 0, 1858, 1859, 5, 2,
		0, 0, 1859, 1864, 3, 970, 485, 0, 1860, 1861, 5, 3, 0, 0, 1861, 1863, 3,
		970, 485, 0, 1862, 1860, 1, 0, 0, 0, 1863, 1866, 1, 0, 0, 0, 1864, 1862,
		1, 0, 0, 0, 1864, 1865, 1, 0, 0, 0, 1865, 1867, 1, 0, 0, 0, 1866, 1864,
		1, 0, 0, 0, 1867, 1868, 5, 4, 0, 0, 1868, 1870, 1, 0, 0, 0, 1869, 1857,
		1, 0, 0, 0, 1869, 1870, 1, 0, 0, 0, 1870, 99, 1, 0, 0, 0, 1871, 1872, 5,
		398, 0, 0, 1872, 1873, 5, 19, 0, 0, 1873, 1874, 5, 420, 0, 0, 1874, 1877,
		7, 7, 0, 0, 1875, 1876, 7, 1, 0, 0, 1876, 1878, 3, 1006, 503, 0, 1877,
		1875, 1, 0, 0, 0, 1877, 1878, 1, 0, 0, 0, 1878, 1881, 1, 0, 0, 0, 1879,
		1880, 5, 476, 0, 0, 1880, 1882, 3, 842, 421, 0, 1881, 1879, 1, 0, 0, 0,
		1881, 1882, 1, 0, 0, 0, 1882, 1893, 1, 0, 0, 0, 1883, 1884, 5, 295, 0,
		0, 1884, 1885, 5, 55, 0, 0, 1885, 1890, 3, 762, 381, 0, 1886, 1887, 5,
		3, 0, 0, 1887, 1889, 3, 762, 381, 0, 1888, 1886, 1, 0, 0, 0, 1889, 1892,
		1, 0, 0, 0, 1890, 1888, 1, 0, 0, 0, 1890, 1891, 1, 0, 0, 0, 1891, 1894,
		1, 0, 0, 0, 1892, 1890, 1, 0, 0, 0, 1893, 1883, 1, 0, 0, 0, 1893, 1894,
		1, 0, 0, 0, 1894, 1896, 1, 0, 0, 0, 1895, 1897, 3, 766, 383, 0, 1896, 1895,
		1, 0, 0, 0, 1896, 1897, 1, 0, 0, 0, 1897, 1926, 1, 0, 0, 0, 1898, 1899,
		5, 398, 0, 0, 1899, 1900, 5, 19, 0, 0, 1900, 1901, 5, 254, 0, 0, 1901,
		1904, 5, 467, 0, 0, 1902, 1903, 7, 1, 0, 0, 1903, 1905, 3, 1006, 503, 0,
		1904, 1902, 1, 0, 0, 0, 1904, 1905, 1, 0, 0, 0, 1905, 1908, 1, 0, 0, 0,
		1906, 1907, 5, 476, 0, 0, 1907, 1909, 3, 842, 421, 0, 1908, 1906, 1, 0,
		0, 0, 1908, 1909, 1, 0, 0, 0, 1909, 1920, 1, 0, 0, 0, 1910, 1911, 5, 295,
		0, 0, 1911, 1912, 5, 55, 0, 0, 1912, 1917, 3, 762, 381, 0, 1913, 1914,
		5, 3, 0, 0, 1914, 1916, 3, 762, 381, 0, 1915, 1913, 1, 0, 0, 0, 1916, 1919,
		1, 0, 0, 0, 1917, 1915, 1, 0, 0, 0, 1917, 1918, 1, 0, 0, 0, 1918, 1921,
		1, 0, 0, 0, 1919, 1917, 1, 0, 0, 0, 1920, 1910, 1, 0, 0, 0, 1920, 1921,
		1, 0, 0, 0, 1921, 1923, 1, 0, 0, 0, 1922, 1924, 3, 766, 383, 0, 1923, 1922,
		1, 0, 0, 0, 1923, 1924, 1, 0, 0, 0, 1924, 1926, 1, 0, 0, 0, 1925, 1871,
		1, 0, 0, 0, 1925, 1898, 1, 0, 0, 0, 1926, 101, 1, 0, 0, 0, 1927, 1934,
		7, 8, 0, 0, 1928, 1930, 3, 1006, 503, 0, 1929, 1931, 5, 18, 0, 0, 1930,
		1929, 1, 0, 0, 0, 1930, 1931, 1, 0, 0, 0, 1931, 1935, 1, 0, 0, 0, 1932,
		1933, 5, 156, 0, 0, 1933, 1935, 3, 952, 476, 0, 1934, 1928, 1, 0, 0, 0,
		1934, 1932, 1, 0, 0, 0, 1935, 103, 1, 0, 0, 0, 1936, 1938, 5, 88, 0, 0,
		1937, 1939, 7, 3, 0, 0, 1938, 1937, 1, 0, 0, 0, 1938, 1939, 1, 0, 0, 0,
		1939, 1940, 1, 0, 0, 0, 1940, 1944, 5, 420, 0, 0, 1941, 1942, 5, 194, 0,
		0, 1942, 1943, 5, 278, 0, 0, 1943, 1945, 5, 145, 0, 0, 1944, 1941, 1, 0,
		0, 0, 1944, 1945, 1, 0, 0, 0, 1945, 1946, 1, 0, 0, 0, 1946, 1948, 3, 1006,
		503, 0, 1947, 1949, 3, 900, 450, 0, 1948, 1947, 1, 0, 0, 0, 1948, 1949,
		1, 0, 0, 0, 1949, 1951, 1, 0, 0, 0, 1950, 1952, 3, 940, 470, 0, 1951, 1950,
		1, 0, 0, 0, 1951, 1952, 1, 0, 0, 0, 1952, 1954, 1, 0, 0, 0, 1953, 1955,
		3, 948, 474, 0, 1954, 1953, 1, 0, 0, 0, 1954, 1955, 1, 0, 0, 0, 1955, 1956,
		1, 0, 0, 0, 1956, 1957, 5, 237, 0, 0, 1957, 1958, 3, 1006, 503, 0, 1958,
		105, 1, 0, 0, 0, 1959, 1960, 5, 398, 0, 0, 1960, 1961, 7, 9, 0, 0, 1961,
		1962, 7, 1, 0, 0, 1962, 1963, 3, 1006, 503, 0, 1963, 1966, 1, 0, 0, 0,
		1964, 1965, 7, 1, 0, 0, 1965, 1967, 3, 1006, 503, 0, 1966, 1964, 1, 0,
		0, 0, 1966, 1967, 1, 0, 0, 0, 1967, 107, 1, 0, 0, 0, 1968, 1969, 5, 344,
		0, 0, 1969, 1970, 5, 420, 0, 0, 1970, 1971, 3, 1006, 503, 0, 1971, 109,
		1, 0, 0, 0, 1972, 1973, 5, 443, 0, 0, 1973, 1974, 5, 420, 0, 0, 1974, 1976,
		3, 1006, 503, 0, 1975, 1977, 3, 816, 408, 0, 1976, 1975, 1, 0, 0, 0, 1976,
		1977, 1, 0, 0, 0, 1977, 111, 1, 0, 0, 0, 1978, 1979, 5, 57, 0, 0, 1979,
		1980, 5, 19, 0, 0, 1980, 1982, 5, 420, 0, 0, 1981, 1983, 7, 7, 0, 0, 1982,
		1981, 1, 0, 0, 0, 1982, 1983, 1, 0, 0, 0, 1983, 1984, 1, 0, 0, 0, 1984,
		1985, 5, 169, 0, 0, 1985, 1996, 3, 1006, 503, 0, 1986, 1987, 5, 2, 0, 0,
		1987, 1992, 5, 516, 0, 0, 1988, 1989, 5, 3, 0, 0, 1989, 1991, 5, 516, 0,
		0, 1990, 1988, 1, 0, 0, 0, 1991, 1994, 1, 0, 0, 0, 1992, 1990, 1, 0, 0,
		0, 1992, 1993, 1, 0, 0, 0, 1993, 1995, 1, 0, 0, 0, 1994, 1992, 1, 0, 0,
		0, 1995, 1997, 5, 4, 0, 0, 1996, 1986, 1, 0, 0, 0, 1996, 1997, 1, 0, 0,
		0, 1997, 2005, 1, 0, 0, 0, 1998, 1999, 5, 57, 0, 0, 1999, 2000, 5, 19,
		0, 0, 2000, 2001, 5, 254, 0, 0, 2001, 2002, 5, 467, 0, 0, 2002, 2003, 5,
		169, 0, 0, 2003, 2005, 3, 1006, 503, 0, 2004, 1978, 1, 0, 0, 0, 2004, 1998,
		1, 0, 0, 0, 2005, 113, 1, 0, 0, 0, 2006, 2008, 5, 398, 0, 0, 2007, 2009,
		5, 426, 0, 0, 2008, 2007, 1, 0, 0, 0, 2008, 2009, 1, 0, 0, 0, 2009, 2010,
		1, 0, 0, 0, 2010, 2011, 5, 301, 0, 0, 2011, 2012, 5, 169, 0, 0, 2012, 2015,
		3, 1006, 503, 0, 2013, 2014, 5, 476, 0, 0, 2014, 2016, 3, 842, 421, 0,
		2015, 2013, 1, 0, 0, 0, 2015, 2016, 1, 0, 0, 0, 2016, 2027, 1, 0, 0, 0,
		2017, 2018, 5, 295, 0, 0, 2018, 2019, 5, 55, 0, 0, 2019, 2024, 3, 762,
		381, 0, 2020, 2021, 5, 3, 0, 0, 2021, 2023, 3, 762, 381, 0, 2022, 2020,
		1, 0, 0, 0, 2023, 2026, 1, 0, 0, 0, 2024, 2022, 1, 0, 0, 0, 2024, 2025,
		1, 0, 0, 0, 2025, 2028, 1, 0, 0, 0, 2026, 2024, 1, 0, 0, 0, 2027, 2017,
		1, 0, 0, 0, 2027, 2028, 1, 0, 0, 0, 2028, 2030, 1, 0, 0, 0, 2029, 2031,
		3, 766, 383, 0, 2030, 2029, 1, 0, 0, 0, 2030, 2031, 1, 0, 0, 0, 2031, 115,
		1, 0, 0, 0, 2032, 2033, 5, 344, 0, 0, 2033, 2034, 5, 300, 0, 0, 2034, 2035,
		3, 1012, 506, 0, 2035, 2036, 5, 169, 0, 0, 2036, 2037, 3, 1006, 503, 0,
		2037, 117, 1, 0, 0, 0, 2038, 2041, 5, 88, 0, 0, 2039, 2040, 5, 294, 0,
		0, 2040, 2042, 5, 353, 0, 0, 2041, 2039, 1, 0, 0, 0, 2041, 2042, 1, 0,
		0, 0, 2042, 2043, 1, 0, 0, 0, 2043, 2047, 5, 467, 0, 0, 2044, 2045, 5,
		194, 0, 0, 2045, 2046, 5, 278, 0, 0, 2046, 2048, 5, 145, 0, 0, 2047, 2044,
		1, 0, 0, 0, 2047, 2048, 1, 0, 0, 0, 2048, 2049, 1, 0, 0, 0, 2049, 2061,
		3, 1006, 503, 0, 2050, 2051, 5, 2, 0, 0, 2051, 2056, 3, 124, 62, 0, 2052,
		2053, 5, 3, 0, 0, 2053, 2055, 3, 124, 62, 0, 2054, 2052, 1, 0, 0, 0, 2055,
		2058, 1, 0, 0, 0, 2056, 2054, 1, 0, 0, 0, 2056, 2057, 1, 0, 0, 0, 2057,
		2059, 1, 0, 0, 0, 2058, 2056, 1, 0, 0, 0, 2059, 2060, 5, 4, 0, 0, 2060,
		2062, 1, 0, 0, 0, 2061, 2050, 1, 0, 0, 0, 2061, 2062, 1, 0, 0, 0, 2062,
		2064, 1, 0, 0, 0, 2063, 2065, 3, 964, 482, 0, 2064, 2063, 1, 0, 0, 0, 2064,
		2065, 1, 0, 0, 0, 2065, 2068, 1, 0, 0, 0, 2066, 2067, 5, 387, 0, 0, 2067,
		2069, 7, 10, 0, 0, 2068, 2066, 1, 0, 0, 0, 2068, 2069, 1, 0, 0, 0, 2069,
		2070, 1, 0, 0, 0, 2070, 2071, 5, 27, 0, 0, 2071, 2072, 3, 744, 372, 0,
		2072, 119, 1, 0, 0, 0, 2073, 2074, 5, 19, 0, 0, 2074, 2075, 5, 467, 0,
		0, 2075, 2087, 3, 1006, 503, 0, 2076, 2077, 5, 2, 0, 0, 2077, 2082, 3,
		124, 62, 0, 2078, 2079, 5, 3, 0, 0, 2079, 2081, 3, 124, 62, 0, 2080, 2078,
		1, 0, 0, 0, 2081, 2084, 1, 0, 0, 0, 2082, 2080, 1, 0, 0, 0, 2082, 2083,
		1, 0, 0, 0, 2083, 2085, 1, 0, 0, 0, 2084, 2082, 1, 0, 0, 0, 2085, 2086,
		5, 4, 0, 0, 2086, 2088, 1, 0, 0, 0, 2087, 2076, 1, 0, 0, 0, 2087, 2088,
		1, 0, 0, 0, 2088, 2089, 1, 0, 0, 0, 2089, 2090, 5, 27, 0, 0, 2090, 2091,
		3, 744, 372, 0, 2091, 2116, 1, 0, 0, 0, 2092, 2093, 5, 19, 0, 0, 2093,
		2094, 5, 467, 0, 0, 2094, 2095, 3, 1006, 503, 0, 2095, 2096, 5, 393, 0,
		0, 2096, 2097, 5, 387, 0, 0, 2097, 2098, 7, 10, 0, 0, 2098, 2116, 1, 0,
		0, 0, 2099, 2100, 5, 19, 0, 0, 2100, 2101, 5, 467, 0, 0, 2101, 2102, 3,
		1006, 503, 0, 2102, 2103, 5, 393, 0, 0, 2103, 2104, 3, 948, 474, 0, 2104,
		2116, 1, 0, 0, 0, 2105, 2106, 5, 19, 0, 0, 2106, 2107, 5, 467, 0, 0, 2107,
		2108, 3, 1006, 503, 0, 2108, 2109, 7, 11, 0, 0, 2109, 2111, 5, 119, 0,
		0, 2110, 2112, 5, 403, 0, 0, 2111, 2110, 1, 0, 0, 0, 2111, 2112, 1, 0,
		0, 0, 2112, 2113, 1, 0, 0, 0, 2113, 2114, 3, 744, 372, 0, 2114, 2116, 1,
		0, 0, 0, 2115, 2073, 1, 0, 0, 0, 2115, 2092, 1, 0, 0, 0, 2115, 2099, 1,
		0, 0, 0, 2115, 2105, 1, 0, 0, 0, 2116, 121, 1, 0, 0, 0, 2117, 2118, 5,
		130, 0, 0, 2118, 2121, 5, 467, 0, 0, 2119, 2120, 5, 194, 0, 0, 2120, 2122,
		5, 145, 0, 0, 2121, 2119, 1, 0, 0, 0, 2121, 2122, 1, 0, 0, 0, 2122, 2123,
		1, 0, 0, 0, 2123, 2124, 3, 1006, 503, 0, 2124, 123, 1, 0, 0, 0, 2125, 2127,
		3, 1012, 506, 0, 2126, 2128, 3, 964, 482, 0, 2127, 2126, 1, 0, 0, 0, 2127,
		2128, 1, 0, 0, 0, 2128, 125, 1, 0, 0, 0, 2129, 2130, 5, 412, 0, 0, 2130,
		2132, 5, 425, 0, 0, 2131, 2133, 3, 1006, 503, 0, 2132, 2131, 1, 0, 0, 0,
		2132, 2133, 1, 0, 0, 0, 2133, 2137, 1, 0, 0, 0, 2134, 2136, 3, 128, 64,
		0, 2135, 2134, 1, 0, 0, 0, 2136, 2139, 1, 0, 0, 0, 2137, 2135, 1, 0, 0,
		0, 2137, 2138, 1, 0, 0, 0, 2138, 2140, 1, 0, 0, 0, 2139, 2137, 1, 0, 0,
		0, 2140, 2144, 5, 27, 0, 0, 2141, 2145, 3, 74, 37, 0, 2142, 2145, 3, 354,
		177, 0, 2143, 2145, 3, 650, 325, 0, 2144, 2141, 1, 0, 0, 0, 2144, 2142,
		1, 0, 0, 0, 2144, 2143, 1, 0, 0, 0, 2145, 127, 1, 0, 0, 0, 2146, 2149,
		3, 948, 474, 0, 2147, 2149, 3, 132, 66, 0, 2148, 2146, 1, 0, 0, 0, 2148,
		2147, 1, 0, 0, 0, 2149, 129, 1, 0, 0, 0, 2150, 2151, 5, 130, 0, 0, 2151,
		2154, 5, 425, 0, 0, 2152, 2153, 5, 194, 0, 0, 2153, 2155, 5, 145, 0, 0,
		2154, 2152, 1, 0, 0, 0, 2154, 2155, 1, 0, 0, 0, 2155, 2156, 1, 0, 0, 0,
		2156, 2158, 3, 1006, 503, 0, 2157, 2159, 5, 166, 0, 0, 2158, 2157, 1, 0,
		0, 0, 2158, 2159, 1, 0, 0, 0, 2159, 131, 1, 0, 0, 0, 2160, 2166, 5, 382,
		0, 0, 2161, 2162, 5, 404, 0, 0, 2162, 2163, 5, 2, 0, 0, 2163, 2164, 3,
		970, 485, 0, 2164, 2165, 5, 4, 0, 0, 2165, 2167, 1, 0, 0, 0, 2166, 2161,
		1, 0, 0, 0, 2166, 2167, 1, 0, 0, 0, 2167, 2168, 1, 0, 0, 0, 2168, 2169,
		5, 150, 0, 0, 2169, 2170, 5, 2, 0, 0, 2170, 2171, 3, 980, 490, 0, 2171,
		2172, 5, 4, 0, 0, 2172, 133, 1, 0, 0, 0, 2173, 2174, 5, 88, 0, 0, 2174,
		2175, 5, 254, 0, 0, 2175, 2179, 5, 467, 0, 0, 2176, 2177, 5, 194, 0, 0,
		2177, 2178, 5, 278, 0, 0, 2178, 2180, 5, 145, 0, 0, 2179, 2176, 1, 0, 0,
		0, 2179, 2180, 1, 0, 0, 0, 2180, 2181, 1, 0, 0, 0, 2181, 2200, 3, 1006,
		503, 0, 2182, 2183, 5, 2, 0, 0, 2183, 2188, 3, 124, 62, 0, 2184, 2185,
		5, 3, 0, 0, 2185, 2187, 3, 124, 62, 0, 2186, 2184, 1, 0, 0, 0, 2187, 2190,
		1, 0, 0, 0, 2188, 2186, 1, 0, 0, 0, 2188, 2189, 1, 0, 0, 0, 2189, 2195,
		1, 0, 0, 0, 2190, 2188, 1, 0, 0, 0, 2191, 2192, 5, 3, 0, 0, 2192, 2194,
		3, 42, 21, 0, 2193, 2191, 1, 0, 0, 0, 2194, 2197, 1, 0, 0, 0, 2195, 2193,
		1, 0, 0, 0, 2195, 2196, 1, 0, 0, 0, 2196, 2198, 1, 0, 0, 0, 2197, 2195,
		1, 0, 0, 0, 2198, 2199, 5, 4, 0, 0, 2199, 2201, 1, 0, 0, 0, 2200, 2182,
		1, 0, 0, 0, 2200, 2201, 1, 0, 0, 0, 2201, 2203, 1, 0, 0, 0, 2202, 2204,
		3, 964, 482, 0, 2203, 2202, 1, 0, 0, 0, 2203, 2204, 1, 0, 0, 0, 2204, 2208,
		1, 0, 0, 0, 2205, 2207, 3, 138, 69, 0, 2206, 2205, 1, 0, 0, 0, 2207, 2210,
		1, 0, 0, 0, 2208, 2206, 1, 0, 0, 0, 2208, 2209, 1, 0, 0, 0, 2209, 2211,
		1, 0, 0, 0, 2210, 2208, 1, 0, 0, 0, 2211, 2212, 5, 27, 0, 0, 2212, 2213,
		3, 744, 372, 0, 2213, 135, 1, 0, 0, 0, 2214, 2227, 3, 856, 428, 0, 2215,
		2216, 5, 2, 0, 0, 2216, 2221, 3, 856, 428, 0, 2217, 2218, 5, 3, 0, 0, 2218,
		2220, 3, 856, 428, 0, 2219, 2217, 1, 0, 0, 0, 2220, 2223, 1, 0, 0, 0, 2221,
		2219, 1, 0, 0, 0, 2221, 2222, 1, 0, 0, 0, 2222, 2224, 1, 0, 0, 0, 2223,
		2221, 1, 0, 0, 0, 2224, 2225, 5, 4, 0, 0, 2225, 2227, 1, 0, 0, 0, 2226,
		2214, 1, 0, 0, 0, 2226, 2215, 1, 0, 0, 0, 2227, 137, 1, 0, 0, 0, 2228,
		2229, 5, 300, 0, 0, 2229, 2230, 5, 55, 0, 0, 2230, 2236, 3, 136, 68, 0,
		2231, 2236, 3, 940, 470, 0, 2232, 2236, 3, 52, 26, 0, 2233, 2236, 3, 944,
		472, 0, 2234, 2236, 3, 948, 474, 0, 2235, 2228, 1, 0, 0, 0, 2235, 2231,
		1, 0, 0, 0, 2235, 2232, 1, 0, 0, 0, 2235, 2233, 1, 0, 0, 0, 2235, 2234,
		1, 0, 0, 0, 2236, 139, 1, 0, 0, 0, 2237, 2238, 5, 398, 0, 0, 2238, 2239,
		5, 254, 0, 0, 2239, 2242, 5, 468, 0, 0, 2240, 2241, 7, 1, 0, 0, 2241, 2243,
		3, 1006, 503, 0, 2242, 2240, 1, 0, 0, 0, 2242, 2243, 1, 0, 0, 0, 2243,
		2248, 1, 0, 0, 0, 2244, 2245, 5, 237, 0, 0, 2245, 2249, 3, 970, 485, 0,
		2246, 2247, 5, 476, 0, 0, 2247, 2249, 3, 842, 421, 0, 2248, 2244, 1, 0,
		0, 0, 2248, 2246, 1, 0, 0, 0, 2248, 2249, 1, 0, 0, 0, 2249, 141, 1, 0,
		0, 0, 2250, 2251, 5, 130, 0, 0, 2251, 2252, 5, 254, 0, 0, 2252, 2255, 5,
		467, 0, 0, 2253, 2254, 5, 194, 0, 0, 2254, 2256, 5, 145, 0, 0, 2255, 2253,
		1, 0, 0, 0, 2255, 2256, 1, 0, 0, 0, 2256, 2257, 1, 0, 0, 0, 2257, 2258,
		3, 1006, 503, 0, 2258, 143, 1, 0, 0, 0, 2259, 2260, 5, 19, 0, 0, 2260,
		2261, 5, 254, 0, 0, 2261, 2262, 5, 467, 0, 0, 2262, 2267, 3, 1006, 503,
		0, 2263, 2268, 3, 944, 472, 0, 2264, 2268, 3, 272, 136, 0, 2265, 2268,
		3, 276, 138, 0, 2266, 2268, 3, 274, 137, 0, 2267, 2263, 1, 0, 0, 0, 2267,
		2264, 1, 0, 0, 0, 2267, 2265, 1, 0, 0, 0, 2267, 2266, 1, 0, 0, 0, 2268,
		2276, 1, 0, 0, 0, 2269, 2270, 5, 19, 0, 0, 2270, 2271, 5, 254, 0, 0, 2271,
		2272, 5, 467, 0, 0, 2272, 2273, 3, 1006, 503, 0, 2273, 2274, 3, 946, 473,
		0, 2274, 2276, 1, 0, 0, 0, 2275, 2259, 1, 0, 0, 0, 2275, 2269, 1, 0, 0,
		0, 2276, 145, 1, 0, 0, 0, 2277, 2278, 5, 345, 0, 0, 2278, 2279, 5, 254,
		0, 0, 2279, 2280, 5, 467, 0, 0, 2280, 2286, 3, 1006, 503, 0, 2281, 2284,
		5, 300, 0, 0, 2282, 2285, 3, 928, 464, 0, 2283, 2285, 3, 912, 456, 0, 2284,
		2282, 1, 0, 0, 0, 2284, 2283, 1, 0, 0, 0, 2285, 2287, 1, 0, 0, 0, 2286,
		2281, 1, 0, 0, 0, 2286, 2287, 1, 0, 0, 0, 2287, 2289, 1, 0, 0, 0, 2288,
		2290, 5, 166, 0, 0, 2289, 2288, 1, 0, 0, 0, 2289, 2290, 1, 0, 0, 0, 2290,
		2294, 1, 0, 0, 0, 2291, 2292, 5, 478, 0, 0, 2292, 2293, 7, 12, 0, 0, 2293,
		2295, 5, 266, 0, 0, 2294, 2291, 1, 0, 0, 0, 2294, 2295, 1, 0, 0, 0, 2295,
		2299, 1, 0, 0, 0, 2296, 2297, 5, 478, 0, 0, 2297, 2298, 5, 321, 0, 0, 2298,
		2300, 5, 516, 0, 0, 2299, 2296, 1, 0, 0, 0, 2299, 2300, 1, 0, 0, 0, 2300,
		147, 1, 0, 0, 0, 2301, 2302, 5, 57, 0, 0, 2302, 2303, 5, 345, 0, 0, 2303,
		2304, 5, 254, 0, 0, 2304, 2305, 5, 467, 0, 0, 2305, 2307, 3, 1006, 503,
		0, 2306, 2308, 5, 166, 0, 0, 2307, 2306, 1, 0, 0, 0, 2307, 2308, 1, 0,
		0, 0, 2308, 149, 1, 0, 0, 0, 2309, 2310, 5, 14, 0, 0, 2310, 2311, 5, 393,
		0, 0, 2311, 2312, 5, 170, 0, 0, 2312, 2313, 5, 82, 0, 0, 2313, 2314, 5,
		2, 0, 0, 2314, 2315, 3, 956, 478, 0, 2315, 2318, 5, 4, 0, 0, 2316, 2317,
		5, 478, 0, 0, 2317, 2319, 5, 489, 0, 0, 2318, 2316, 1, 0, 0, 0, 2318, 2319,
		1, 0, 0, 0, 2319, 151, 1, 0, 0, 0, 2320, 2321, 5, 14, 0, 0, 2321, 2322,
		5, 393, 0, 0, 2322, 2323, 5, 355, 0, 0, 2323, 2324, 5, 406, 0, 0, 2324,
		2325, 3, 948, 474, 0, 2325, 153, 1, 0, 0, 0, 2326, 2327, 5, 14, 0, 0, 2327,
		2328, 5, 398, 0, 0, 2328, 2329, 5, 170, 0, 0, 2329, 2332, 5, 82, 0, 0,
		2330, 2331, 5, 237, 0, 0, 2331, 2333, 3, 970, 485, 0, 2332, 2330, 1, 0,
		0, 0, 2332, 2333, 1, 0, 0, 0, 2333, 155, 1, 0, 0, 0, 2334, 2335, 5, 14,
		0, 0, 2335, 2336, 5, 398, 0, 0, 2336, 2337, 5, 355, 0, 0, 2337, 2338, 5,
		128, 0, 0, 2338, 2339, 5, 169, 0, 0, 2339, 2341, 3, 1006, 503, 0, 2340,
		2342, 3, 816, 408, 0, 2341, 2340, 1, 0, 0, 0, 2341, 2342, 1, 0, 0, 0, 2342,
		157, 1, 0, 0, 0, 2343, 2344, 5, 14, 0, 0, 2344, 2345, 5, 398, 0, 0, 2345,
		2346, 5, 355, 0, 0, 2346, 2347, 5, 406, 0, 0, 2347, 2348, 5, 169, 0, 0,
		2348, 2350, 3, 1006, 503, 0, 2349, 2351, 3, 816, 408, 0, 2350, 2349, 1,
		0, 0, 0, 2350, 2351, 1, 0, 0, 0, 2351, 2354, 1, 0, 0, 0, 2352, 2353, 5,
		476, 0, 0, 2353, 2355, 3, 842, 421, 0, 2354, 2352, 1, 0, 0, 0, 2354, 2355,
		1, 0, 0, 0, 2355, 159, 1, 0, 0, 0, 2356, 2357, 5, 14, 0, 0, 2357, 2358,
		5, 351, 0, 0, 2358, 2359, 5, 420, 0, 0, 2359, 2361, 3, 1006, 503, 0, 2360,
		2362, 3, 816, 408, 0, 2361, 2360, 1, 0, 0, 0, 2361, 2362, 1, 0, 0, 0, 2362,
		161, 1, 0, 0, 0, 2363, 2364, 5, 14, 0, 0, 2364, 2365, 5, 57, 0, 0, 2365,
		2366, 5, 351, 0, 0, 2366, 2367, 5, 420, 0, 0, 2367, 2369, 3, 1006, 503,
		0, 2368, 2370, 3, 816, 408, 0, 2369, 2368, 1, 0, 0, 0, 2369, 2370, 1, 0,
		0, 0, 2370, 163, 1, 0, 0, 0, 2371, 2372, 5, 14, 0, 0, 2372, 2373, 5, 67,
		0, 0, 2373, 2374, 3, 820, 410, 0, 2374, 2375, 5, 329, 0, 0, 2375, 2376,
		5, 2, 0, 0, 2376, 2377, 3, 956, 478, 0, 2377, 2378, 5, 4, 0, 0, 2378, 165,
		1, 0, 0, 0, 2379, 2380, 5, 14, 0, 0, 2380, 2381, 5, 393, 0, 0, 2381, 2382,
		5, 420, 0, 0, 2382, 2383, 3, 1006, 503, 0, 2383, 2384, 5, 300, 0, 0, 2384,
		2387, 5, 2, 0, 0, 2385, 2388, 3, 1020, 510, 0, 2386, 2388, 5, 516, 0, 0,
		2387, 2385, 1, 0, 0, 0, 2387, 2386, 1, 0, 0, 0, 2388, 2389, 1, 0, 0, 0,
		2389, 2390, 5, 4, 0, 0, 2390, 2391, 5, 466, 0, 0, 2391, 2392, 5, 438, 0,
		0, 2392, 2393, 5, 516, 0, 0, 2393, 167, 1, 0, 0, 0, 2394, 2399, 5, 226,
		0, 0, 2395, 2397, 5, 83, 0, 0, 2396, 2395, 1, 0, 0, 0, 2396, 2397, 1, 0,
		0, 0, 2397, 2400, 1, 0, 0, 0, 2398, 2400, 5, 335, 0, 0, 2399, 2396, 1,
		0, 0, 0, 2399, 2398, 1, 0, 0, 0, 2400, 2403, 1, 0, 0, 0, 2401, 2404, 5,
		516, 0, 0, 2402, 2404, 3, 970, 485, 0, 2403, 2401, 1, 0, 0, 0, 2403, 2402,
		1, 0, 0, 0, 2404, 169, 1, 0, 0, 0, 2405, 2406, 5, 415, 0, 0, 2406, 171,
		1, 0, 0, 0, 2407, 2408, 5, 14, 0, 0, 2408, 2409, 5, 393, 0, 0, 2409, 2410,
		5, 32, 0, 0, 2410, 2411, 5, 70, 0, 0, 2411, 2412, 5, 400, 0, 0, 2412, 2416,
		5, 287, 0, 0, 2413, 2414, 5, 408, 0, 0, 2414, 2415, 5, 469, 0, 0, 2415,
		2417, 3, 1012, 506, 0, 2416, 2413, 1, 0, 0, 0, 2416, 2417, 1, 0, 0, 0,
		2417, 173, 1, 0, 0, 0, 2418, 2419, 5, 14, 0, 0, 2419, 2420, 5, 393, 0,
		0, 2420, 2421, 5, 32, 0, 0, 2421, 2422, 5, 70, 0, 0, 2422, 2423, 5, 400,
		0, 0, 2423, 2424, 5, 285, 0, 0, 2424, 175, 1, 0, 0, 0, 2425, 2426, 5, 19,
		0, 0, 2426, 2427, 5, 416, 0, 0, 2427, 2428, 3, 232, 116, 0, 2428, 177,
		1, 0, 0, 0, 2429, 2430, 5, 57, 0, 0, 2430, 2431, 5, 114, 0, 0, 2431, 2432,
		5, 35, 0, 0, 2432, 2437, 3, 970, 485, 0, 2433, 2434, 5, 3, 0, 0, 2434,
		2436, 3, 970, 485, 0, 2435, 2433, 1, 0, 0, 0, 2436, 2439, 1, 0, 0, 0, 2437,
		2435, 1, 0, 0, 0, 2437, 2438, 1, 0, 0, 0, 2438, 179, 1, 0, 0, 0, 2439,
		2437, 1, 0, 0, 0, 2440, 2441, 5, 398, 0, 0, 2441, 2442, 5, 81, 0, 0, 2442,
		2443, 5, 276, 0, 0, 2443, 181, 1, 0, 0, 0, 2444, 2445, 5, 88, 0, 0, 2445,
		2446, 5, 148, 0, 0, 2446, 2450, 5, 60, 0, 0, 2447, 2448, 5, 194, 0, 0,
		2448, 2449, 5, 278, 0, 0, 2449, 2451, 5, 145, 0, 0, 2450, 2447, 1, 0, 0,
		0, 2450, 2451, 1, 0, 0, 0, 2451, 2452, 1, 0, 0, 0, 2452, 2454, 3, 1020,
		510, 0, 2453, 2455, 3, 964, 482, 0, 2454, 2453, 1, 0, 0, 0, 2454, 2455,
		1, 0, 0, 0, 2455, 2456, 1, 0, 0, 0, 2456, 2457, 3, 948, 474, 0, 2457, 183,
		1, 0, 0, 0, 2458, 2459, 5, 398, 0, 0, 2459, 2460, 5, 88, 0, 0, 2460, 2461,
		5, 60, 0, 0, 2461, 2462, 3, 1020, 510, 0, 2462, 185, 1, 0, 0, 0, 2463,
		2464, 5, 130, 0, 0, 2464, 2467, 5, 60, 0, 0, 2465, 2466, 5, 194, 0, 0,
		2466, 2468, 5, 145, 0, 0, 2467, 2465, 1, 0, 0, 0, 2467, 2468, 1, 0, 0,
		0, 2468, 2469, 1, 0, 0, 0, 2469, 2470, 3, 1020, 510, 0, 2470, 187, 1, 0,
		0, 0, 2471, 2472, 5, 398, 0, 0, 2472, 2475, 5, 61, 0, 0, 2473, 2474, 5,
		237, 0, 0, 2474, 2476, 3, 970, 485, 0, 2475, 2473, 1, 0, 0, 0, 2475, 2476,
		1, 0, 0, 0, 2476, 189, 1, 0, 0, 0, 2477, 2478, 5, 19, 0, 0, 2478, 2479,
		5, 60, 0, 0, 2479, 2480, 3, 1020, 510, 0, 2480, 2481, 3, 276, 138, 0, 2481,
		191, 1, 0, 0, 0, 2482, 2483, 5, 88, 0, 0, 2483, 2484, 5, 408, 0, 0, 2484,
		2488, 5, 469, 0, 0, 2485, 2486, 5, 194, 0, 0, 2486, 2487, 5, 278, 0, 0,
		2487, 2489, 5, 145, 0, 0, 2488, 2485, 1, 0, 0, 0, 2488, 2489, 1, 0, 0,
		0, 2489, 2490, 1, 0, 0, 0, 2490, 2491, 3, 1020, 510, 0, 2491, 2492, 3,
		194, 97, 0, 2492, 2494, 3, 196, 98, 0, 2493, 2495, 3, 964, 482, 0, 2494,
		2493, 1, 0, 0, 0, 2494, 2495, 1, 0, 0, 0, 2495, 2497, 1, 0, 0, 0, 2496,
		2498, 3, 948, 474, 0, 2497, 2496, 1, 0, 0, 0, 2497, 2498, 1, 0, 0, 0, 2498,
		193, 1, 0, 0, 0, 2499, 2500, 5, 444, 0, 0, 2500, 2501, 5, 490, 0, 0, 2501,
		2502, 3, 1012, 506, 0, 2502, 195, 1, 0, 0, 0, 2503, 2504, 5, 245, 0, 0,
		2504, 2505, 5, 490, 0, 0, 2505, 2506, 3, 916, 458, 0, 2506, 197, 1, 0,
		0, 0, 2507, 2508, 5, 398, 0, 0, 2508, 2509, 5, 408, 0, 0, 2509, 2512, 5,
		470, 0, 0, 2510, 2511, 5, 237, 0, 0, 2511, 2513, 3, 970, 485, 0, 2512,
		2510, 1, 0, 0, 0, 2512, 2513, 1, 0, 0, 0, 2513, 199, 1, 0, 0, 0, 2514,
		2515, 5, 130, 0, 0, 2515, 2516, 5, 408, 0, 0, 2516, 2519, 5, 469, 0, 0,
		2517, 2518, 5, 194, 0, 0, 2518, 2520, 5, 145, 0, 0, 2519, 2517, 1, 0, 0,
		0, 2519, 2520, 1, 0, 0, 0, 2520, 2521, 1, 0, 0, 0, 2521, 2522, 3, 1020,
		510, 0, 2522, 201, 1, 0, 0, 0, 2523, 2524, 5, 19, 0, 0, 2524, 2525, 5,
		408, 0, 0, 2525, 2526, 5, 469, 0, 0, 2526, 2527, 3, 1020, 510, 0, 2527,
		2532, 3, 204, 102, 0, 2528, 2529, 5, 3, 0, 0, 2529, 2531, 3, 204, 102,
		0, 2530, 2528, 1, 0, 0, 0, 2531, 2534, 1, 0, 0, 0, 2532, 2530, 1, 0, 0,
		0, 2532, 2533, 1, 0, 0, 0, 2533, 203, 1, 0, 0, 0, 2534, 2532, 1, 0, 0,
		0, 2535, 2538, 3, 208, 104, 0, 2536, 2538, 3, 206, 103, 0, 2537, 2535,
		1, 0, 0, 0, 2537, 2536, 1, 0, 0, 0, 2538, 205, 1, 0, 0, 0, 2539, 2540,
		5, 393, 0, 0, 2540, 2541, 3, 952, 476, 0, 2541, 207, 1, 0, 0, 0, 2542,
		2543, 5, 76, 0, 0, 2543, 2544, 5, 490, 0, 0, 2544, 2545, 3, 970, 485, 0,
		2545, 209, 1, 0, 0, 0, 2546, 2547, 7, 8, 0, 0, 2547, 2548, 5, 408, 0, 0,
		2548, 2549, 5, 469, 0, 0, 2549, 2550, 3, 1020, 510, 0, 2550, 211, 1, 0,
		0, 0, 2551, 2552, 5, 393, 0, 0, 2552, 2553, 3, 1020, 510, 0, 2553, 2554,
		5, 27, 0, 0, 2554, 2555, 5, 115, 0, 0, 2555, 2556, 5, 408, 0, 0, 2556,
		2557, 5, 469, 0, 0, 2557, 213, 1, 0, 0, 0, 2558, 2559, 5, 14, 0, 0, 2559,
		2560, 5, 125, 0, 0, 2560, 2561, 5, 151, 0, 0, 2561, 2565, 3, 970, 485,
		0, 2562, 2563, 5, 287, 0, 0, 2563, 2564, 5, 35, 0, 0, 2564, 2566, 3, 970,
		485, 0, 2565, 2562, 1, 0, 0, 0, 2565, 2566, 1, 0, 0, 0, 2566, 2596, 1,
		0, 0, 0, 2567, 2568, 5, 14, 0, 0, 2568, 2569, 5, 135, 0, 0, 2569, 2570,
		5, 151, 0, 0, 2570, 2574, 3, 970, 485, 0, 2571, 2572, 5, 478, 0, 0, 2572,
		2573, 5, 516, 0, 0, 2573, 2575, 5, 431, 0, 0, 2574, 2571, 1, 0, 0, 0, 2574,
		2575, 1, 0, 0, 0, 2575, 2579, 1, 0, 0, 0, 2576, 2577, 5, 287, 0, 0, 2577,
		2578, 5, 35, 0, 0, 2578, 2580, 3, 970, 485, 0, 2579, 2576, 1, 0, 0, 0,
		2579, 2580, 1, 0, 0, 0, 2580, 2596, 1, 0, 0, 0, 2581, 2582, 5, 14, 0, 0,
		2582, 2583, 5, 135, 0, 0, 2583, 2584, 5, 151, 0, 0, 2584, 2588, 3, 970,
		485, 0, 2585, 2586, 5, 478, 0, 0, 2586, 2587, 5, 517, 0, 0, 2587, 2589,
		5, 323, 0, 0, 2588, 2585, 1, 0, 0, 0, 2588, 2589, 1, 0, 0, 0, 2589, 2593,
		1, 0, 0, 0, 2590, 2591, 5, 287, 0, 0, 2591, 2592, 5, 35, 0, 0, 2592, 2594,
		3, 970, 485, 0, 2593, 2590, 1, 0, 0, 0, 2593, 2594, 1, 0, 0, 0, 2594, 2596,
		1, 0, 0, 0, 2595, 2558, 1, 0, 0, 0, 2595, 2567, 1, 0, 0, 0, 2595, 2581,
		1, 0, 0, 0, 2596, 215, 1, 0, 0, 0, 2597, 2598, 5, 398, 0, 0, 2598, 2601,
		5, 152, 0, 0, 2599, 2600, 5, 237, 0, 0, 2600, 2602, 3, 970, 485, 0, 2601,
		2599, 1, 0, 0, 0, 2601, 2602, 1, 0, 0, 0, 2602, 2606, 1, 0, 0, 0, 2603,
		2604, 5, 287, 0, 0, 2604, 2605, 5, 35, 0, 0, 2605, 2607, 3, 970, 485, 0,
		2606, 2603, 1, 0, 0, 0, 2606, 2607, 1, 0, 0, 0, 2607, 217, 1, 0, 0, 0,
		2608, 2609, 5, 88, 0, 0, 2609, 2610, 5, 120, 0, 0, 2610, 2611, 3, 230,
		115, 0, 2611, 2612, 5, 458, 0, 0, 2612, 2613, 3, 1006, 503, 0, 2613, 2614,
		5, 2, 0, 0, 2614, 2619, 3, 228, 114, 0, 2615, 2616, 5, 3, 0, 0, 2616, 2618,
		3, 228, 114, 0, 2617, 2615, 1, 0, 0, 0, 2618, 2621, 1, 0, 0, 0, 2619, 2617,
		1, 0, 0, 0, 2619, 2620, 1, 0, 0, 0, 2620, 2622, 1, 0, 0, 0, 2621, 2619,
		1, 0, 0, 0, 2622, 2624, 5, 4, 0, 0, 2623, 2625, 3, 948, 474, 0, 2624, 2623,
		1, 0, 0, 0, 2624, 2625, 1, 0, 0, 0, 2625, 219, 1, 0, 0, 0, 2626, 2627,
		5, 130, 0, 0, 2627, 2628, 5, 120, 0, 0, 2628, 2630, 3, 1006, 503, 0, 2629,
		2631, 5, 56, 0, 0, 2630, 2629, 1, 0, 0, 0, 2630, 2631, 1, 0, 0, 0, 2631,
		221, 1, 0, 0, 0, 2632, 2633, 5, 345, 0, 0, 2633, 2634, 5, 120, 0, 0, 2634,
		2635, 3, 1006, 503, 0, 2635, 223, 1, 0, 0, 0, 2636, 2637, 5, 398, 0, 0,
		2637, 2639, 5, 120, 0, 0, 2638, 2640, 3, 1006, 503, 0, 2639, 2638, 1, 0,
		0, 0, 2639, 2640, 1, 0, 0, 0, 2640, 225, 1, 0, 0, 0, 2641, 2642, 5, 57,
		0, 0, 2642, 2643, 5, 345, 0, 0, 2643, 2644, 5, 120, 0, 0, 2644, 2645, 3,
		1006, 503, 0, 2645, 227, 1, 0, 0, 0, 2646, 2647, 3, 1006, 503, 0, 2647,
		2648, 5, 224, 0, 0, 2648, 2653, 1, 0, 0, 0, 2649, 2650, 3, 1006, 503, 0,
		2650, 2651, 5, 459, 0, 0, 2651, 2653, 1, 0, 0, 0, 2652, 2646, 1, 0, 0,
		0, 2652, 2649, 1, 0, 0, 0, 2653, 229, 1, 0, 0, 0, 2654, 2655, 3, 1006,
		503, 0, 2655, 231, 1, 0, 0, 0, 2656, 2707, 3, 234, 117, 0, 2657, 2707,
		3, 236, 118, 0, 2658, 2707, 3, 238, 119, 0, 2659, 2707, 3, 240, 120, 0,
		2660, 2707, 3, 242, 121, 0, 2661, 2707, 3, 244, 122, 0, 2662, 2707, 3,
		246, 123, 0, 2663, 2707, 3, 248, 124, 0, 2664, 2707, 3, 250, 125, 0, 2665,
		2707, 3, 252, 126, 0, 2666, 2707, 3, 254, 127, 0, 2667, 2707, 3, 256, 128,
		0, 2668, 2707, 3, 258, 129, 0, 2669, 2707, 3, 260, 130, 0, 2670, 2707,
		3, 262, 131, 0, 2671, 2707, 3, 264, 132, 0, 2672, 2707, 3, 266, 133, 0,
		2673, 2707, 3, 268, 134, 0, 2674, 2707, 3, 270, 135, 0, 2675, 2707, 3,
		272, 136, 0, 2676, 2707, 3, 274, 137, 0, 2677, 2707, 3, 276, 138, 0, 2678,
		2707, 3, 284, 142, 0, 2679, 2707, 3, 286, 143, 0, 2680, 2707, 3, 288, 144,
		0, 2681, 2707, 3, 292, 146, 0, 2682, 2707, 3, 290, 145, 0, 2683, 2707,
		3, 294, 147, 0, 2684, 2707, 3, 296, 148, 0, 2685, 2707, 3, 298, 149, 0,
		2686, 2707, 3, 300, 150, 0, 2687, 2707, 3, 278, 139, 0, 2688, 2707, 3,
		282, 141, 0, 2689, 2707, 3, 306, 153, 0, 2690, 2707, 3, 308, 154, 0, 2691,
		2707, 3, 312, 156, 0, 2692, 2707, 3, 310, 155, 0, 2693, 2707, 3, 314, 157,
		0, 2694, 2707, 3, 316, 158, 0, 2695, 2707, 3, 318, 159, 0, 2696, 2707,
		3, 338, 169, 0, 2697, 2707, 3, 340, 170, 0, 2698, 2707, 3, 342, 171, 0,
		2699, 2707, 3, 344, 172, 0, 2700, 2707, 3, 938, 469, 0, 2701, 2707, 3,
		942, 471, 0, 2702, 2707, 3, 346, 173, 0, 2703, 2707, 3, 348, 174, 0, 2704,
		2707, 3, 350, 175, 0, 2705, 2707, 3, 352, 176, 0, 2706, 2656, 1, 0, 0,
		0, 2706, 2657, 1, 0, 0, 0, 2706, 2658, 1, 0, 0, 0, 2706, 2659, 1, 0, 0,
		0, 2706, 2660, 1, 0, 0, 0, 2706, 2661, 1, 0, 0, 0, 2706, 2662, 1, 0, 0,
		0, 2706, 2663, 1, 0, 0, 0, 2706, 2664, 1, 0, 0, 0, 2706, 2665, 1, 0, 0,
		0, 2706, 2666, 1, 0, 0, 0, 2706, 2667, 1, 0, 0, 0, 2706, 2668, 1, 0, 0,
		0, 2706, 2669, 1, 0, 0, 0, 2706, 2670, 1, 0, 0, 0, 2706, 2671, 1, 0, 0,
		0, 2706, 2672, 1, 0, 0, 0, 2706, 2673, 1, 0, 0, 0, 2706, 2674, 1, 0, 0,
		0, 2706, 2675, 1, 0, 0, 0, 2706, 2676, 1, 0, 0, 0, 2706, 2677, 1, 0, 0,
		0, 2706, 2678, 1, 0, 0, 0, 2706, 2679, 1, 0, 0, 0, 2706, 2680, 1, 0, 0,
		0, 2706, 2681, 1, 0, 0, 0, 2706, 2682, 1, 0, 0, 0, 2706, 2683, 1, 0, 0,
		0, 2706, 2684, 1, 0, 0, 0, 2706, 2685, 1, 0, 0, 0, 2706, 2686, 1, 0, 0,
		0, 2706, 2687, 1, 0, 0, 0, 2706, 2688, 1, 0, 0, 0, 2706, 2689, 1, 0, 0,
		0, 2706, 2690, 1, 0, 0, 0, 2706, 2691, 1, 0, 0, 0, 2706, 2692, 1, 0, 0,
		0, 2706, 2693, 1, 0, 0, 0, 2706, 2694, 1, 0, 0, 0, 2706, 2695, 1, 0, 0,
		0, 2706, 2696, 1, 0, 0, 0, 2706, 2697, 1, 0, 0, 0, 2706, 2698, 1, 0, 0,
		0, 2706, 2699, 1, 0, 0, 0, 2706, 2700, 1, 0, 0, 0, 2706, 2701, 1, 0, 0,
		0, 2706, 2702, 1, 0, 0, 0, 2706, 2703, 1, 0, 0, 0, 2706, 2704, 1, 0, 0,
		0, 2706, 2705, 1, 0, 0, 0, 2707, 233, 1, 0, 0, 0, 2708, 2709, 5, 13, 0,
		0, 2709, 2710, 7, 13, 0, 0, 2710, 2711, 3, 970, 485, 0, 2711, 235, 1, 0,
		0, 0, 2712, 2713, 5, 130, 0, 0, 2713, 2714, 7, 13, 0, 0, 2714, 2715, 3,
		970, 485, 0, 2715, 237, 1, 0, 0, 0, 2716, 2717, 5, 267, 0, 0, 2717, 2718,
		5, 170, 0, 0, 2718, 2719, 5, 189, 0, 0, 2719, 2720, 3, 970, 485, 0, 2720,
		2721, 5, 438, 0, 0, 2721, 2722, 3, 970, 485, 0, 2722, 239, 1, 0, 0, 0,
		2723, 2724, 5, 13, 0, 0, 2724, 2725, 5, 35, 0, 0, 2725, 2730, 3, 970, 485,
		0, 2726, 2727, 5, 3, 0, 0, 2727, 2729, 3, 970, 485, 0, 2728, 2726, 1, 0,
		0, 0, 2729, 2732, 1, 0, 0, 0, 2730, 2728, 1, 0, 0, 0, 2730, 2731, 1, 0,
		0, 0, 2731, 2736, 1, 0, 0, 0, 2732, 2730, 1, 0, 0, 0, 2733, 2734, 5, 215,
		0, 0, 2734, 2735, 5, 471, 0, 0, 2735, 2737, 3, 1020, 510, 0, 2736, 2733,
		1, 0, 0, 0, 2736, 2737, 1, 0, 0, 0, 2737, 241, 1, 0, 0, 0, 2738, 2739,
		5, 130, 0, 0, 2739, 2740, 5, 35, 0, 0, 2740, 2745, 3, 970, 485, 0, 2741,
		2742, 5, 3, 0, 0, 2742, 2744, 3, 970, 485, 0, 2743, 2741, 1, 0, 0, 0, 2744,
		2747, 1, 0, 0, 0, 2745, 2743, 1, 0, 0, 0, 2745, 2746, 1, 0, 0, 0, 2746,
		2751, 1, 0, 0, 0, 2747, 2745, 1, 0, 0, 0, 2748, 2749, 5, 169, 0, 0, 2749,
		2750, 5, 471, 0, 0, 2750, 2752, 3, 1020, 510, 0, 2751, 2748, 1, 0, 0, 0,
		2751, 2752, 1, 0, 0, 0, 2752, 2754, 1, 0, 0, 0, 2753, 2755, 5, 166, 0,
		0, 2754, 2753, 1, 0, 0, 0, 2754, 2755, 1, 0, 0, 0, 2755, 243, 1, 0, 0,
		0, 2756, 2757, 5, 114, 0, 0, 2757, 2758, 5, 35, 0, 0, 2758, 2763, 3, 970,
		485, 0, 2759, 2760, 5, 3, 0, 0, 2760, 2762, 3, 970, 485, 0, 2761, 2759,
		1, 0, 0, 0, 2762, 2765, 1, 0, 0, 0, 2763, 2761, 1, 0, 0, 0, 2763, 2764,
		1, 0, 0, 0, 2764, 245, 1, 0, 0, 0, 2765, 2763, 1, 0, 0, 0, 2766, 2767,
		5, 267, 0, 0, 2767, 2768, 5, 35, 0, 0, 2768, 2769, 5, 189, 0, 0, 2769,
		2770, 3, 970, 485, 0, 2770, 2771, 5, 438, 0, 0, 2771, 2772, 3, 970, 485,
		0, 2772, 2780, 1, 0, 0, 0, 2773, 2774, 5, 267, 0, 0, 2774, 2775, 5, 35,
		0, 0, 2775, 2776, 3, 970, 485, 0, 2776, 2777, 5, 393, 0, 0, 2777, 2778,
		3, 952, 476, 0, 2778, 2780, 1, 0, 0, 0, 2779, 2766, 1, 0, 0, 0, 2779, 2773,
		1, 0, 0, 0, 2780, 247, 1, 0, 0, 0, 2781, 2782, 5, 13, 0, 0, 2782, 2783,
		5, 81, 0, 0, 2783, 2784, 5, 275, 0, 0, 2784, 2789, 3, 970, 485, 0, 2785,
		2786, 5, 3, 0, 0, 2786, 2788, 3, 970, 485, 0, 2787, 2785, 1, 0, 0, 0, 2788,
		2791, 1, 0, 0, 0, 2789, 2787, 1, 0, 0, 0, 2789, 2790, 1, 0, 0, 0, 2790,
		2795, 1, 0, 0, 0, 2791, 2789, 1, 0, 0, 0, 2792, 2793, 5, 215, 0, 0, 2793,
		2794, 5, 471, 0, 0, 2794, 2796, 3, 1020, 510, 0, 2795, 2792, 1, 0, 0, 0,
		2795, 2796, 1, 0, 0, 0, 2796, 249, 1, 0, 0, 0, 2797, 2798, 5, 130, 0, 0,
		2798, 2799, 5, 81, 0, 0, 2799, 2800, 5, 275, 0, 0, 2800, 2805, 3, 970,
		485, 0, 2801, 2802, 5, 3, 0, 0, 2802, 2804, 3, 970, 485, 0, 2803, 2801,
		1, 0, 0, 0, 2804, 2807, 1, 0, 0, 0, 2805, 2803, 1, 0, 0, 0, 2805, 2806,
		1, 0, 0, 0, 2806, 2811, 1, 0, 0, 0, 2807, 2805, 1, 0, 0, 0, 2808, 2809,
		5, 169, 0, 0, 2809, 2810, 5, 471, 0, 0, 2810, 2812, 3, 1020, 510, 0, 2811,
		2808, 1, 0, 0, 0, 2811, 2812, 1, 0, 0, 0, 2812, 251, 1, 0, 0, 0, 2813,
		2814, 5, 13, 0, 0, 2814, 2815, 5, 52, 0, 0, 2815, 2816, 3, 1020, 510, 0,
		2816, 2821, 3, 970, 485, 0, 2817, 2818, 5, 3, 0, 0, 2818, 2820, 3, 970,
		485, 0, 2819, 2817, 1, 0, 0, 0, 2820, 2823, 1, 0, 0, 0, 2821, 2819, 1,
		0, 0, 0, 2821, 2822, 1, 0, 0, 0, 2822, 2840, 1, 0, 0, 0, 2823, 2821, 1,
		0, 0, 0, 2824, 2825, 5, 130, 0, 0, 2825, 2826, 5, 52, 0, 0, 2826, 2827,
		3, 1020, 510, 0, 2827, 2832, 3, 970, 485, 0, 2828, 2829, 5, 3, 0, 0, 2829,
		2831, 3, 970, 485, 0, 2830, 2828, 1, 0, 0, 0, 2831, 2834, 1, 0, 0, 0, 2832,
		2830, 1, 0, 0, 0, 2832, 2833, 1, 0, 0, 0, 2833, 2840, 1, 0, 0, 0, 2834,
		2832, 1, 0, 0, 0, 2835, 2836, 5, 130, 0, 0, 2836, 2837, 5, 18, 0, 0, 2837,
		2838, 5, 52, 0, 0, 2838, 2840, 3, 1020, 510, 0, 2839, 2813, 1, 0, 0, 0,
		2839, 2824, 1, 0, 0, 0, 2839, 2835, 1, 0, 0, 0, 2840, 253, 1, 0, 0, 0,
		2841, 2842, 5, 393, 0, 0, 2842, 2843, 5, 240, 0, 0, 2843, 2844, 5, 140,
		0, 0, 2844, 2846, 5, 192, 0, 0, 2845, 2847, 3, 948, 474, 0, 2846, 2845,
		1, 0, 0, 0, 2846, 2847, 1, 0, 0, 0, 2847, 255, 1, 0, 0, 0, 2848, 2849,
		5, 88, 0, 0, 2849, 2850, 5, 198, 0, 0, 2850, 257, 1, 0, 0, 0, 2851, 2852,
		5, 68, 0, 0, 2852, 2853, 5, 422, 0, 0, 2853, 2854, 5, 383, 0, 0, 2854,
		2855, 5, 337, 0, 0, 2855, 259, 1, 0, 0, 0, 2856, 2857, 5, 114, 0, 0, 2857,
		2858, 5, 485, 0, 0, 2858, 2863, 3, 970, 485, 0, 2859, 2860, 5, 3, 0, 0,
		2860, 2862, 3, 970, 485, 0, 2861, 2859, 1, 0, 0, 0, 2862, 2865, 1, 0, 0,
		0, 2863, 2861, 1, 0, 0, 0, 2863, 2864, 1, 0, 0, 0, 2864, 2866, 1, 0, 0,
		0, 2865, 2863, 1, 0, 0, 0, 2866, 2867, 5, 287, 0, 0, 2867, 2868, 5, 35,
		0, 0, 2868, 2869, 3, 970, 485, 0, 2869, 261, 1, 0, 0, 0, 2870, 2871, 5,
		57, 0, 0, 2871, 2872, 5, 114, 0, 0, 2872, 2873, 5, 485, 0, 0, 2873, 2878,
		3, 970, 485, 0, 2874, 2875, 5, 3, 0, 0, 2875, 2877, 3, 970, 485, 0, 2876,
		2874, 1, 0, 0, 0, 2877, 2880, 1, 0, 0, 0, 2878, 2876, 1, 0, 0, 0, 2878,
		2879, 1, 0, 0, 0, 2879, 2881, 1, 0, 0, 0, 2880, 2878, 1, 0, 0, 0, 2881,
		2882, 5, 287, 0, 0, 2882, 2883, 5, 35, 0, 0, 2883, 2884, 3, 970, 485, 0,
		2884, 263, 1, 0, 0, 0, 2885, 2886, 5, 125, 0, 0, 2886, 2887, 5, 485, 0,
		0, 2887, 2892, 3, 970, 485, 0, 2888, 2889, 5, 3, 0, 0, 2889, 2891, 3, 970,
		485, 0, 2890, 2888, 1, 0, 0, 0, 2891, 2894, 1, 0, 0, 0, 2892, 2890, 1,
		0, 0, 0, 2892, 2893, 1, 0, 0, 0, 2893, 2895, 1, 0, 0, 0, 2894, 2892, 1,
		0, 0, 0, 2895, 2896, 5, 287, 0, 0, 2896, 2897, 5, 35, 0, 0, 2897, 2898,
		3, 970, 485, 0, 2898, 265, 1, 0, 0, 0, 2899, 2900, 5, 57, 0, 0, 2900, 2901,
		5, 125, 0, 0, 2901, 2902, 5, 485, 0, 0, 2902, 2907, 3, 970, 485, 0, 2903,
		2904, 5, 3, 0, 0, 2904, 2906, 3, 970, 485, 0, 2905, 2903, 1, 0, 0, 0, 2906,
		2909, 1, 0, 0, 0, 2907, 2905, 1, 0, 0, 0, 2907, 2908, 1, 0, 0, 0, 2908,
		2910, 1, 0, 0, 0, 2909, 2907, 1, 0, 0, 0, 2910, 2911, 5, 287, 0, 0, 2911,
		2912, 5, 35, 0, 0, 2912, 2913, 3, 970, 485, 0, 2913, 267, 1, 0, 0, 0, 2914,
		2915, 5, 13, 0, 0, 2915, 2916, 5, 202, 0, 0, 2916, 2917, 3, 1012, 506,
		0, 2917, 2922, 3, 1018, 509, 0, 2918, 2920, 3, 86, 43, 0, 2919, 2921, 3,
		952, 476, 0, 2920, 2919, 1, 0, 0, 0, 2920, 2921, 1, 0, 0, 0, 2921, 2923,
		1, 0, 0, 0, 2922, 2918, 1, 0, 0, 0, 2922, 2923, 1, 0, 0, 0, 2923, 2925,
		1, 0, 0, 0, 2924, 2926, 3, 964, 482, 0, 2925, 2924, 1, 0, 0, 0, 2925, 2926,
		1, 0, 0, 0, 2926, 269, 1, 0, 0, 0, 2927, 2928, 5, 130, 0, 0, 2928, 2929,
		5, 202, 0, 0, 2929, 2930, 3, 1012, 506, 0, 2930, 271, 1, 0, 0, 0, 2931,
		2932, 5, 350, 0, 0, 2932, 2933, 3, 1012, 506, 0, 2933, 273, 1, 0, 0, 0,
		2934, 2935, 5, 418, 0, 0, 2935, 2936, 5, 478, 0, 0, 2936, 2937, 3, 1012,
		506, 0, 2937, 275, 1, 0, 0, 0, 2938, 2939, 5, 393, 0, 0, 2939, 2940, 3,
		952, 476, 0, 2940, 277, 1, 0, 0, 0, 2941, 2942, 5, 76, 0, 0, 2942, 2943,
		5, 490, 0, 0, 2943, 2944, 3, 970, 485, 0, 2944, 279, 1, 0, 0, 0, 2945,
		2946, 5, 41, 0, 0, 2946, 2947, 3, 970, 485, 0, 2947, 2948, 5, 21, 0, 0,
		2948, 2949, 3, 970, 485, 0, 2949, 281, 1, 0, 0, 0, 2950, 2952, 3, 816,
		408, 0, 2951, 2950, 1, 0, 0, 0, 2951, 2952, 1, 0, 0, 0, 2952, 2954, 1,
		0, 0, 0, 2953, 2955, 3, 50, 25, 0, 2954, 2953, 1, 0, 0, 0, 2954, 2955,
		1, 0, 0, 0, 2955, 2957, 1, 0, 0, 0, 2956, 2958, 3, 900, 450, 0, 2957, 2956,
		1, 0, 0, 0, 2957, 2958, 1, 0, 0, 0, 2958, 2960, 1, 0, 0, 0, 2959, 2961,
		3, 52, 26, 0, 2960, 2959, 1, 0, 0, 0, 2960, 2961, 1, 0, 0, 0, 2961, 2963,
		1, 0, 0, 0, 2962, 2964, 3, 940, 470, 0, 2963, 2962, 1, 0, 0, 0, 2963, 2964,
		1, 0, 0, 0, 2964, 2966, 1, 0, 0, 0, 2965, 2967, 3, 280, 140, 0, 2966, 2965,
		1, 0, 0, 0, 2966, 2967, 1, 0, 0, 0, 2967, 283, 1, 0, 0, 0, 2968, 2969,
		5, 13, 0, 0, 2969, 2970, 5, 74, 0, 0, 2970, 2974, 3, 34, 17, 0, 2971, 2975,
		5, 158, 0, 0, 2972, 2973, 5, 16, 0, 0, 2973, 2975, 3, 1012, 506, 0, 2974,
		2971, 1, 0, 0, 0, 2974, 2972, 1, 0, 0, 0, 2974, 2975, 1, 0, 0, 0, 2975,
		2978, 1, 0, 0, 0, 2976, 2977, 7, 14, 0, 0, 2977, 2979, 3, 1012, 506, 0,
		2978, 2976, 1, 0, 0, 0, 2978, 2979, 1, 0, 0, 0, 2979, 2981, 1, 0, 0, 0,
		2980, 2982, 3, 948, 474, 0, 2981, 2980, 1, 0, 0, 0, 2981, 2982, 1, 0, 0,
		0, 2982, 285, 1, 0, 0, 0, 2983, 2984, 5, 13, 0, 0, 2984, 2985, 5, 74, 0,
		0, 2985, 2986, 5, 2, 0, 0, 2986, 2991, 3, 34, 17, 0, 2987, 2988, 5, 3,
		0, 0, 2988, 2990, 3, 34, 17, 0, 2989, 2987, 1, 0, 0, 0, 2990, 2993, 1,
		0, 0, 0, 2991, 2989, 1, 0, 0, 0, 2991, 2992, 1, 0, 0, 0, 2992, 2994, 1,
		0, 0, 0, 2993, 2991, 1, 0, 0, 0, 2994, 2997, 5, 4, 0, 0, 2995, 2996, 7,
		14, 0, 0, 2996, 2998, 3, 1012, 506, 0, 2997, 2995, 1, 0, 0, 0, 2997, 2998,
		1, 0, 0, 0, 2998, 3000, 1, 0, 0, 0, 2999, 3001, 3, 948, 474, 0, 3000, 2999,
		1, 0, 0, 0, 3000, 3001, 1, 0, 0, 0, 3001, 287, 1, 0, 0, 0, 3002, 3003,
		5, 130, 0, 0, 3003, 3004, 5, 74, 0, 0, 3004, 3007, 3, 1012, 506, 0, 3005,
		3006, 5, 169, 0, 0, 3006, 3008, 3, 1012, 506, 0, 3007, 3005, 1, 0, 0, 0,
		3007, 3008, 1, 0, 0, 0, 3008, 3010, 1, 0, 0, 0, 3009, 3011, 3, 948, 474,
		0, 3010, 3009, 1, 0, 0, 0, 3010, 3011, 1, 0, 0, 0, 3011, 289, 1, 0, 0,
		0, 3012, 3013, 5, 267, 0, 0, 3013, 3014, 5, 74, 0, 0, 3014, 3018, 3, 34,
		17, 0, 3015, 3019, 5, 158, 0, 0, 3016, 3017, 5, 16, 0, 0, 3017, 3019, 3,
		1012, 506, 0, 3018, 3015, 1, 0, 0, 0, 3018, 3016, 1, 0, 0, 0, 3018, 3019,
		1, 0, 0, 0, 3019, 3022, 1, 0, 0, 0, 3020, 3021, 5, 169, 0, 0, 3021, 3023,
		3, 1012, 506, 0, 3022, 3020, 1, 0, 0, 0, 3022, 3023, 1, 0, 0, 0, 3023,
		3025, 1, 0, 0, 0, 3024, 3026, 3, 948, 474, 0, 3025, 3024, 1, 0, 0, 0, 3025,
		3026, 1, 0, 0, 0, 3026, 291, 1, 0, 0, 0, 3027, 3028, 5, 267, 0, 0, 3028,
		3029, 5, 74, 0, 0, 3029, 3030, 3, 1012, 506, 0, 3030, 3031, 3, 964, 482,
		0, 3031, 293, 1, 0, 0, 0, 3032, 3033, 5, 350, 0, 0, 3033, 3034, 5, 74,
		0, 0, 3034, 3035, 3, 1012, 506, 0, 3035, 3036, 5, 438, 0, 0, 3036, 3037,
		3, 1012, 506, 0, 3037, 295, 1, 0, 0, 0, 3038, 3039, 5, 295, 0, 0, 3039,
		3040, 5, 55, 0, 0, 3040, 3043, 3, 1018, 509, 0, 3041, 3042, 5, 169, 0,
		0, 3042, 3044, 3, 1012, 506, 0, 3043, 3041, 1, 0, 0, 0, 3043, 3044, 1,
		0, 0, 0, 3044, 3046, 1, 0, 0, 0, 3045, 3047, 3, 948, 474, 0, 3046, 3045,
		1, 0, 0, 0, 3046, 3047, 1, 0, 0, 0, 3047, 297, 1, 0, 0, 0, 3048, 3049,
		5, 350, 0, 0, 3049, 3050, 5, 373, 0, 0, 3050, 3051, 3, 1012, 506, 0, 3051,
		3052, 3, 1012, 506, 0, 3052, 299, 1, 0, 0, 0, 3053, 3055, 7, 15, 0, 0,
		3054, 3053, 1, 0, 0, 0, 3054, 3055, 1, 0, 0, 0, 3055, 3056, 1, 0, 0, 0,
		3056, 3059, 5, 79, 0, 0, 3057, 3060, 3, 1012, 506, 0, 3058, 3060, 3, 1018,
		509, 0, 3059, 3057, 1, 0, 0, 0, 3059, 3058, 1, 0, 0, 0, 3059, 3060, 1,
		0, 0, 0, 3060, 301, 1, 0, 0, 0, 3061, 3064, 3, 1012, 506, 0, 3062, 3064,
		5, 497, 0, 0, 3063, 3061, 1, 0, 0, 0, 3063, 3062, 1, 0, 0, 0, 3064, 303,
		1, 0, 0, 0, 3065, 3071, 3, 302, 151, 0, 3066, 3070, 5, 526, 0, 0, 3067,
		3068, 5, 1, 0, 0, 3068, 3070, 3, 302, 151, 0, 3069, 3066, 1, 0, 0, 0, 3069,
		3067, 1, 0, 0, 0, 3070, 3073, 1, 0, 0, 0, 3071, 3069, 1, 0, 0, 0, 3071,
		3072, 1, 0, 0, 0, 3072, 305, 1, 0, 0, 0, 3073, 3071, 1, 0, 0, 0, 3074,
		3075, 5, 267, 0, 0, 3075, 3076, 5, 74, 0, 0, 3076, 3077, 3, 1012, 506,
		0, 3077, 3078, 5, 13, 0, 0, 3078, 3079, 5, 488, 0, 0, 3079, 3083, 3, 994,
		497, 0, 3080, 3084, 5, 158, 0, 0, 3081, 3082, 5, 16, 0, 0, 3082, 3084,
		3, 1012, 506, 0, 3083, 3080, 1, 0, 0, 0, 3083, 3081, 1, 0, 0, 0, 3083,
		3084, 1, 0, 0, 0, 3084, 3086, 1, 0, 0, 0, 3085, 3087, 3, 948, 474, 0, 3086,
		3085, 1, 0, 0, 0, 3086, 3087, 1, 0, 0, 0, 3087, 307, 1, 0, 0, 0, 3088,
		3089, 5, 267, 0, 0, 3089, 3090, 5, 74, 0, 0, 3090, 3091, 3, 1012, 506,
		0, 3091, 3092, 5, 130, 0, 0, 3092, 3093, 5, 488, 0, 0, 3093, 3095, 3, 304,
		152, 0, 3094, 3096, 3, 948, 474, 0, 3095, 3094, 1, 0, 0, 0, 3095, 3096,
		1, 0, 0, 0, 3096, 309, 1, 0, 0, 0, 3097, 3098, 5, 88, 0, 0, 3098, 3100,
		5, 294, 0, 0, 3099, 3097, 1, 0, 0, 0, 3099, 3100, 1, 0, 0, 0, 3100, 3101,
		1, 0, 0, 0, 3101, 3102, 5, 353, 0, 0, 3102, 3103, 5, 424, 0, 0, 3103, 3104,
		3, 1012, 506, 0, 3104, 3105, 3, 320, 160, 0, 3105, 3117, 1, 0, 0, 0, 3106,
		3107, 5, 88, 0, 0, 3107, 3111, 5, 424, 0, 0, 3108, 3109, 5, 194, 0, 0,
		3109, 3110, 5, 278, 0, 0, 3110, 3112, 5, 145, 0, 0, 3111, 3108, 1, 0, 0,
		0, 3111, 3112, 1, 0, 0, 0, 3112, 3113, 1, 0, 0, 0, 3113, 3114, 3, 1012,
		506, 0, 3114, 3115, 3, 320, 160, 0, 3115, 3117, 1, 0, 0, 0, 3116, 3099,
		1, 0, 0, 0, 3116, 3106, 1, 0, 0, 0, 3117, 311, 1, 0, 0, 0, 3118, 3119,
		5, 88, 0, 0, 3119, 3121, 5, 294, 0, 0, 3120, 3118, 1, 0, 0, 0, 3120, 3121,
		1, 0, 0, 0, 3121, 3122, 1, 0, 0, 0, 3122, 3123, 5, 353, 0, 0, 3123, 3124,
		5, 51, 0, 0, 3124, 3125, 3, 1012, 506, 0, 3125, 3126, 3, 322, 161, 0, 3126,
		3138, 1, 0, 0, 0, 3127, 3128, 5, 88, 0, 0, 3128, 3132, 5, 51, 0, 0, 3129,
		3130, 5, 194, 0, 0, 3130, 3131, 5, 278, 0, 0, 3131, 3133, 5, 145, 0, 0,
		3132, 3129, 1, 0, 0, 0, 3132, 3133, 1, 0, 0, 0, 3133, 3134, 1, 0, 0, 0,
		3134, 3135, 3, 1012, 506, 0, 3135, 3136, 3, 322, 161, 0, 3136, 3138, 1,
		0, 0, 0, 3137, 3120, 1, 0, 0, 0, 3137, 3127, 1, 0, 0, 0, 3138, 313, 1,
		0, 0, 0, 3139, 3140, 5, 130, 0, 0, 3140, 3143, 5, 51, 0, 0, 3141, 3142,
		5, 194, 0, 0, 3142, 3144, 5, 145, 0, 0, 3143, 3141, 1, 0, 0, 0, 3143, 3144,
		1, 0, 0, 0, 3144, 3145, 1, 0, 0, 0, 3145, 3146, 3, 1012, 506, 0, 3146,
		315, 1, 0, 0, 0, 3147, 3148, 5, 130, 0, 0, 3148, 3151, 5, 424, 0, 0, 3149,
		3150, 5, 194, 0, 0, 3150, 3152, 5, 145, 0, 0, 3151, 3149, 1, 0, 0, 0, 3151,
		3152, 1, 0, 0, 0, 3152, 3153, 1, 0, 0, 0, 3153, 3154, 3, 1012, 506, 0,
		3154, 317, 1, 0, 0, 0, 3155, 3156, 5, 144, 0, 0, 3156, 3157, 3, 860, 430,
		0, 3157, 319, 1, 0, 0, 0, 3158, 3159, 5, 27, 0, 0, 3159, 3160, 5, 284,
		0, 0, 3160, 3161, 5, 466, 0, 0, 3161, 3163, 3, 332, 166, 0, 3162, 3158,
		1, 0, 0, 0, 3162, 3163, 1, 0, 0, 0, 3163, 3165, 1, 0, 0, 0, 3164, 3166,
		3, 326, 163, 0, 3165, 3164, 1, 0, 0, 0, 3165, 3166, 1, 0, 0, 0, 3166, 321,
		1, 0, 0, 0, 3167, 3168, 5, 27, 0, 0, 3168, 3169, 5, 284, 0, 0, 3169, 3170,
		5, 466, 0, 0, 3170, 3172, 3, 332, 166, 0, 3171, 3167, 1, 0, 0, 0, 3171,
		3172, 1, 0, 0, 0, 3172, 3174, 1, 0, 0, 0, 3173, 3175, 3, 326, 163, 0, 3174,
		3173, 1, 0, 0, 0, 3174, 3175, 1, 0, 0, 0, 3175, 3177, 1, 0, 0, 0, 3176,
		3178, 3, 324, 162, 0, 3177, 3176, 1, 0, 0, 0, 3177, 3178, 1, 0, 0, 0, 3178,
		323, 1, 0, 0, 0, 3179, 3180, 5, 478, 0, 0, 3180, 3181, 5, 400, 0, 0, 3181,
		3182, 5, 363, 0, 0, 3182, 3194, 3, 330, 165, 0, 3183, 3184, 5, 478, 0,
		0, 3184, 3185, 5, 400, 0, 0, 3185, 3186, 5, 363, 0, 0, 3186, 3194, 3, 328,
		164, 0, 3187, 3188, 5, 478, 0, 0, 3188, 3189, 5, 400, 0, 0, 3189, 3190,
		5, 363, 0, 0, 3190, 3191, 3, 330, 165, 0, 3191, 3192, 3, 328, 164, 0, 3192,
		3194, 1, 0, 0, 0, 3193, 3179, 1, 0, 0, 0, 3193, 3183, 1, 0, 0, 0, 3193,
		3187, 1, 0, 0, 0, 3194, 325, 1, 0, 0, 0, 3195, 3196, 5, 362, 0, 0, 3196,
		3197, 3, 1032, 516, 0, 3197, 3198, 3, 334, 167, 0, 3198, 327, 1, 0, 0,
		0, 3199, 3200, 3, 1032, 516, 0, 3200, 3201, 3, 334, 167, 0, 3201, 329,
		1, 0, 0, 0, 3202, 3203, 3, 1032, 516, 0, 3203, 3204, 5, 401, 0, 0, 3204,
		331, 1, 0, 0, 0, 3205, 3206, 3, 1032, 516, 0, 3206, 333, 1, 0, 0, 0, 3207,
		3208, 7, 16, 0, 0, 3208, 335, 1, 0, 0, 0, 3209, 3210, 5, 2, 0, 0, 3210,
		3215, 5, 516, 0, 0, 3211, 3212, 5, 3, 0, 0, 3212, 3214, 5, 516, 0, 0, 3213,
		3211, 1, 0, 0, 0, 3214, 3217, 1, 0, 0, 0, 3215, 3213, 1, 0, 0, 0, 3215,
		3216, 1, 0, 0, 0, 3216, 3218, 1, 0, 0, 0, 3217, 3215, 1, 0, 0, 0, 3218,
		3219, 5, 4, 0, 0, 3219, 337, 1, 0, 0, 0, 3220, 3221, 5, 130, 0, 0, 3221,
		3222, 5, 489, 0, 0, 3222, 3223, 5, 202, 0, 0, 3223, 3224, 5, 287, 0, 0,
		3224, 3225, 5, 423, 0, 0, 3225, 3226, 3, 336, 168, 0, 3226, 339, 1, 0,
		0, 0, 3227, 3228, 5, 33, 0, 0, 3228, 3229, 5, 490, 0, 0, 3229, 3230, 5,
		516, 0, 0, 3230, 341, 1, 0, 0, 0, 3231, 3233, 5, 13, 0, 0, 3232, 3234,
		5, 426, 0, 0, 3233, 3232, 1, 0, 0, 0, 3233, 3234, 1, 0, 0, 0, 3234, 3238,
		1, 0, 0, 0, 3235, 3239, 3, 924, 462, 0, 3236, 3237, 5, 301, 0, 0, 3237,
		3239, 3, 926, 463, 0, 3238, 3235, 1, 0, 0, 0, 3238, 3236, 1, 0, 0, 0, 3239,
		3241, 1, 0, 0, 0, 3240, 3242, 3, 940, 470, 0, 3241, 3240, 1, 0, 0, 0, 3241,
		3242, 1, 0, 0, 0, 3242, 3244, 1, 0, 0, 0, 3243, 3245, 3, 948, 474, 0, 3244,
		3243, 1, 0, 0, 0, 3244, 3245, 1, 0, 0, 0, 3245, 3261, 1, 0, 0, 0, 3246,
		3248, 5, 13, 0, 0, 3247, 3249, 5, 426, 0, 0, 3248, 3247, 1, 0, 0, 0, 3248,
		3249, 1, 0, 0, 0, 3249, 3252, 1, 0, 0, 0, 3250, 3253, 3, 904, 452, 0, 3251,
		3253, 3, 906, 453, 0, 3252, 3250, 1, 0, 0, 0, 3252, 3251, 1, 0, 0, 0, 3253,
		3255, 1, 0, 0, 0, 3254, 3256, 3, 940, 470, 0, 3255, 3254, 1, 0, 0, 0, 3255,
		3256, 1, 0, 0, 0, 3256, 3258, 1, 0, 0, 0, 3257, 3259, 3, 948, 474, 0, 3258,
		3257, 1, 0, 0, 0, 3258, 3259, 1, 0, 0, 0, 3259, 3261, 1, 0, 0, 0, 3260,
		3231, 1, 0, 0, 0, 3260, 3246, 1, 0, 0, 0, 3261, 343, 1, 0, 0, 0, 3262,
		3264, 5, 130, 0, 0, 3263, 3265, 5, 426, 0, 0, 3264, 3263, 1, 0, 0, 0, 3264,
		3265, 1, 0, 0, 0, 3265, 3278, 1, 0, 0, 0, 3266, 3269, 5, 300, 0, 0, 3267,
		3268, 5, 194, 0, 0, 3268, 3270, 5, 145, 0, 0, 3269, 3267, 1, 0, 0, 0, 3269,
		3270, 1, 0, 0, 0, 3270, 3271, 1, 0, 0, 0, 3271, 3279, 3, 1012, 506, 0,
		3272, 3275, 5, 301, 0, 0, 3273, 3274, 5, 194, 0, 0, 3274, 3276, 5, 145,
		0, 0, 3275, 3273, 1, 0, 0, 0, 3275, 3276, 1, 0, 0, 0, 3276, 3277, 1, 0,
		0, 0, 3277, 3279, 3, 1018, 509, 0, 3278, 3266, 1, 0, 0, 0, 3278, 3272,
		1, 0, 0, 0, 3279, 3281, 1, 0, 0, 0, 3280, 3282, 5, 166, 0, 0, 3281, 3280,
		1, 0, 0, 0, 3281, 3282, 1, 0, 0, 0, 3282, 3318, 1, 0, 0, 0, 3283, 3285,
		5, 130, 0, 0, 3284, 3286, 5, 426, 0, 0, 3285, 3284, 1, 0, 0, 0, 3285, 3286,
		1, 0, 0, 0, 3286, 3287, 1, 0, 0, 0, 3287, 3290, 5, 301, 0, 0, 3288, 3289,
		5, 194, 0, 0, 3289, 3291, 5, 145, 0, 0, 3290, 3288, 1, 0, 0, 0, 3290, 3291,
		1, 0, 0, 0, 3291, 3292, 1, 0, 0, 0, 3292, 3294, 3, 926, 463, 0, 3293, 3295,
		5, 166, 0, 0, 3294, 3293, 1, 0, 0, 0, 3294, 3295, 1, 0, 0, 0, 3295, 3318,
		1, 0, 0, 0, 3296, 3298, 5, 130, 0, 0, 3297, 3299, 5, 426, 0, 0, 3298, 3297,
		1, 0, 0, 0, 3298, 3299, 1, 0, 0, 0, 3299, 3300, 1, 0, 0, 0, 3300, 3303,
		5, 301, 0, 0, 3301, 3302, 5, 194, 0, 0, 3302, 3304, 5, 145, 0, 0, 3303,
		3301, 1, 0, 0, 0, 3303, 3304, 1, 0, 0, 0, 3304, 3305, 1, 0, 0, 0, 3305,
		3306, 5, 476, 0, 0, 3306, 3308, 3, 842, 421, 0, 3307, 3309, 5, 166, 0,
		0, 3308, 3307, 1, 0, 0, 0, 3308, 3309, 1, 0, 0, 0, 3309, 3318, 1, 0, 0,
		0, 3310, 3311, 5, 130, 0, 0, 3311, 3312, 5, 18, 0, 0, 3312, 3313, 5, 426,
		0, 0, 3313, 3315, 5, 301, 0, 0, 3314, 3316, 5, 166, 0, 0, 3315, 3314, 1,
		0, 0, 0, 3315, 3316, 1, 0, 0, 0, 3316, 3318, 1, 0, 0, 0, 3317, 3262, 1,
		0, 0, 0, 3317, 3283, 1, 0, 0, 0, 3317, 3296, 1, 0, 0, 0, 3317, 3310, 1,
		0, 0, 0, 3318, 345, 1, 0, 0, 0, 3319, 3320, 5, 443, 0, 0, 3320, 3321, 3,
		816, 408, 0, 3321, 347, 1, 0, 0, 0, 3322, 3323, 5, 267, 0, 0, 3323, 3329,
		5, 300, 0, 0, 3324, 3330, 3, 1012, 506, 0, 3325, 3330, 3, 1018, 509, 0,
		3326, 3327, 5, 2, 0, 0, 3327, 3328, 5, 500, 0, 0, 3328, 3330, 5, 4, 0,
		0, 3329, 3324, 1, 0, 0, 0, 3329, 3325, 1, 0, 0, 0, 3329, 3326, 1, 0, 0,
		0, 3330, 3331, 1, 0, 0, 0, 3331, 3332, 5, 393, 0, 0, 3332, 3337, 3, 952,
		476, 0, 3333, 3334, 5, 267, 0, 0, 3334, 3335, 5, 300, 0, 0, 3335, 3337,
		3, 940, 470, 0, 3336, 3322, 1, 0, 0, 0, 3336, 3333, 1, 0, 0, 0, 3337, 349,
		1, 0, 0, 0, 3338, 3339, 5, 353, 0, 0, 3339, 3340, 3, 816, 408, 0, 3340,
		3341, 5, 478, 0, 0, 3341, 3343, 3, 816, 408, 0, 3342, 3344, 3, 948, 474,
		0, 3343, 3342, 1, 0, 0, 0, 3343, 3344, 1, 0, 0, 0, 3344, 351, 1, 0, 0,
		0, 3345, 3346, 5, 350, 0, 0, 3346, 3347, 5, 300, 0, 0, 3347, 3348, 3, 1012,
		506, 0, 3348, 3349, 3, 1012, 506, 0, 3349, 353, 1, 0, 0, 0, 3350, 3352,
		3, 894, 447, 0, 3351, 3350, 1, 0, 0, 0, 3351, 3352, 1, 0, 0, 0, 3352, 3353,
		1, 0, 0, 0, 3353, 3354, 5, 207, 0, 0, 3354, 3367, 7, 17, 0, 0, 3355, 3357,
		3, 1006, 503, 0, 3356, 3358, 3, 1010, 505, 0, 3357, 3356, 1, 0, 0, 0, 3357,
		3358, 1, 0, 0, 0, 3358, 3360, 1, 0, 0, 0, 3359, 3361, 3, 816, 408, 0, 3360,
		3359, 1, 0, 0, 0, 3360, 3361, 1, 0, 0, 0, 3361, 3368, 1, 0, 0, 0, 3362,
		3363, 5, 156, 0, 0, 3363, 3368, 3, 952, 476, 0, 3364, 3365, 5, 46, 0, 0,
		3365, 3366, 5, 2, 0, 0, 3366, 3368, 5, 4, 0, 0, 3367, 3355, 1, 0, 0, 0,
		3367, 3362, 1, 0, 0, 0, 3367, 3364, 1, 0, 0, 0, 3368, 3372, 1, 0, 0, 0,
		3369, 3371, 3, 356, 178, 0, 3370, 3369, 1, 0, 0, 0, 3371, 3374, 1, 0, 0,
		0, 3372, 3370, 1, 0, 0, 0, 3372, 3373, 1, 0, 0, 0, 3373, 3376, 1, 0, 0,
		0, 3374, 3372, 1, 0, 0, 0, 3375, 3377, 3, 948, 474, 0, 3376, 3375, 1, 0,
		0, 0, 3376, 3377, 1, 0, 0, 0, 3377, 3388, 1, 0, 0, 0, 3378, 3389, 3, 744,
		372, 0, 3379, 3380, 5, 460, 0, 0, 3380, 3385, 3, 832, 416, 0, 3381, 3382,
		5, 3, 0, 0, 3382, 3384, 3, 832, 416, 0, 3383, 3381, 1, 0, 0, 0, 3384, 3387,
		1, 0, 0, 0, 3385, 3383, 1, 0, 0, 0, 3385, 3386, 1, 0, 0, 0, 3386, 3389,
		1, 0, 0, 0, 3387, 3385, 1, 0, 0, 0, 3388, 3378, 1, 0, 0, 0, 3388, 3379,
		1, 0, 0, 0, 3389, 355, 1, 0, 0, 0, 3390, 3395, 3, 358, 179, 0, 3391, 3392,
		5, 478, 0, 0, 3392, 3393, 5, 227, 0, 0, 3393, 3395, 3, 1012, 506, 0, 3394,
		3390, 1, 0, 0, 0, 3394, 3391, 1, 0, 0, 0, 3395, 357, 1, 0, 0, 0, 3396,
		3400, 3, 814, 407, 0, 3397, 3398, 5, 55, 0, 0, 3398, 3400, 5, 270, 0, 0,
		3399, 3396, 1, 0, 0, 0, 3399, 3397, 1, 0, 0, 0, 3400, 359, 1, 0, 0, 0,
		3401, 3403, 3, 894, 447, 0, 3402, 3401, 1, 0, 0, 0, 3402, 3403, 1, 0, 0,
		0, 3403, 3405, 1, 0, 0, 0, 3404, 3406, 3, 748, 374, 0, 3405, 3404, 1, 0,
		0, 0, 3405, 3406, 1, 0, 0, 0, 3406, 3407, 1, 0, 0, 0, 3407, 3408, 5, 453,
		0, 0, 3408, 3409, 3, 1006, 503, 0, 3409, 3410, 5, 393, 0, 0, 3410, 3411,
		3, 1030, 515, 0, 3411, 3414, 3, 770, 385, 0, 3412, 3413, 5, 476, 0, 0,
		3413, 3415, 3, 842, 421, 0, 3414, 3412, 1, 0, 0, 0, 3414, 3415, 1, 0, 0,
		0, 3415, 361, 1, 0, 0, 0, 3416, 3418, 3, 894, 447, 0, 3417, 3416, 1, 0,
		0, 0, 3417, 3418, 1, 0, 0, 0, 3418, 3420, 1, 0, 0, 0, 3419, 3421, 3, 748,
		374, 0, 3420, 3419, 1, 0, 0, 0, 3420, 3421, 1, 0, 0, 0, 3421, 3422, 1,
		0, 0, 0, 3422, 3423, 5, 116, 0, 0, 3423, 3424, 5, 169, 0, 0, 3424, 3426,
		3, 1006, 503, 0, 3425, 3427, 3, 816, 408, 0, 3426, 3425, 1, 0, 0, 0, 3426,
		3427, 1, 0, 0, 0, 3427, 3430, 1, 0, 0, 0, 3428, 3429, 5, 458, 0, 0, 3429,
		3431, 3, 782, 391, 0, 3430, 3428, 1, 0, 0, 0, 3430, 3431, 1, 0, 0, 0, 3431,
		3434, 1, 0, 0, 0, 3432, 3433, 5, 476, 0, 0, 3433, 3435, 3, 842, 421, 0,
		3434, 3432, 1, 0, 0, 0, 3434, 3435, 1, 0, 0, 0, 3435, 363, 1, 0, 0, 0,
		3436, 3437, 5, 88, 0, 0, 3437, 3438, 5, 374, 0, 0, 3438, 3442, 5, 240,
		0, 0, 3439, 3440, 3, 1006, 503, 0, 3440, 3441, 5, 1, 0, 0, 3441, 3443,
		1, 0, 0, 0, 3442, 3439, 1, 0, 0, 0, 3442, 3443, 1, 0, 0, 0, 3443, 3444,
		1, 0, 0, 0, 3444, 3445, 3, 1012, 506, 0, 3445, 3446, 5, 287, 0, 0, 3446,
		3455, 3, 1006, 503, 0, 3447, 3452, 3, 370, 185, 0, 3448, 3449, 5, 3, 0,
		0, 3449, 3451, 3, 370, 185, 0, 3450, 3448, 1, 0, 0, 0, 3451, 3454, 1, 0,
		0, 0, 3452, 3450, 1, 0, 0, 0, 3452, 3453, 1, 0, 0, 0, 3453, 3456, 1, 0,
		0, 0, 3454, 3452, 1, 0, 0, 0, 3455, 3447, 1, 0, 0, 0, 3455, 3456, 1, 0,
		0, 0, 3456, 3458, 1, 0, 0, 0, 3457, 3459, 3, 380, 190, 0, 3458, 3457, 1,
		0, 0, 0, 3458, 3459, 1, 0, 0, 0, 3459, 3460, 1, 0, 0, 0, 3460, 3461, 5,
		169, 0, 0, 3461, 3463, 3, 1012, 506, 0, 3462, 3464, 3, 382, 191, 0, 3463,
		3462, 1, 0, 0, 0, 3463, 3464, 1, 0, 0, 0, 3464, 365, 1, 0, 0, 0, 3465,
		3466, 5, 19, 0, 0, 3466, 3467, 5, 374, 0, 0, 3467, 3468, 5, 240, 0, 0,
		3468, 3472, 5, 165, 0, 0, 3469, 3470, 3, 1006, 503, 0, 3470, 3471, 5, 1,
		0, 0, 3471, 3473, 1, 0, 0, 0, 3472, 3469, 1, 0, 0, 0, 3472, 3473, 1, 0,
		0, 0, 3473, 3474, 1, 0, 0, 0, 3474, 3483, 3, 1012, 506, 0, 3475, 3480,
		3, 370, 185, 0, 3476, 3477, 5, 3, 0, 0, 3477, 3479, 3, 370, 185, 0, 3478,
		3476, 1, 0, 0, 0, 3479, 3482, 1, 0, 0, 0, 3480, 3478, 1, 0, 0, 0, 3480,
		3481, 1, 0, 0, 0, 3481, 3484, 1, 0, 0, 0, 3482, 3480, 1, 0, 0, 0, 3483,
		3475, 1, 0, 0, 0, 3483, 3484, 1, 0, 0, 0, 3484, 3486, 1, 0, 0, 0, 3485,
		3487, 3, 380, 190, 0, 3486, 3485, 1, 0, 0, 0, 3486, 3487, 1, 0, 0, 0, 3487,
		3489, 1, 0, 0, 0, 3488, 3490, 3, 368, 184, 0, 3489, 3488, 1, 0, 0, 0, 3489,
		3490, 1, 0, 0, 0, 3490, 367, 1, 0, 0, 0, 3491, 3492, 5, 169, 0, 0, 3492,
		3493, 3, 1012, 506, 0, 3493, 3494, 3, 382, 191, 0, 3494, 369, 1, 0, 0,
		0, 3495, 3502, 3, 372, 186, 0, 3496, 3502, 3, 374, 187, 0, 3497, 3502,
		3, 376, 188, 0, 3498, 3499, 5, 476, 0, 0, 3499, 3502, 3, 842, 421, 0, 3500,
		3502, 3, 816, 408, 0, 3501, 3495, 1, 0, 0, 0, 3501, 3496, 1, 0, 0, 0, 3501,
		3497, 1, 0, 0, 0, 3501, 3498, 1, 0, 0, 0, 3501, 3500, 1, 0, 0, 0, 3502,
		371, 1, 0, 0, 0, 3503, 3504, 5, 75, 0, 0, 3504, 3505, 5, 427, 0, 0, 3505,
		3506, 5, 55, 0, 0, 3506, 3507, 3, 970, 485, 0, 3507, 373, 1, 0, 0, 0, 3508,
		3509, 5, 376, 0, 0, 3509, 3510, 5, 427, 0, 0, 3510, 3511, 5, 55, 0, 0,
		3511, 3512, 3, 970, 485, 0, 3512, 375, 1, 0, 0, 0, 3513, 3514, 5, 75, 0,
		0, 3514, 3515, 3, 378, 189, 0, 3515, 377, 1, 0, 0, 0, 3516, 3519, 5, 2,
		0, 0, 3517, 3520, 3, 1006, 503, 0, 3518, 3520, 3, 1028, 514, 0, 3519, 3517,
		1, 0, 0, 0, 3519, 3518, 1, 0, 0, 0, 3520, 3528, 1, 0, 0, 0, 3521, 3524,
		5, 3, 0, 0, 3522, 3525, 3, 1006, 503, 0, 3523, 3525, 3, 1028, 514, 0, 3524,
		3522, 1, 0, 0, 0, 3524, 3523, 1, 0, 0, 0, 3525, 3527, 1, 0, 0, 0, 3526,
		3521, 1, 0, 0, 0, 3527, 3530, 1, 0, 0, 0, 3528, 3526, 1, 0, 0, 0, 3528,
		3529, 1, 0, 0, 0, 3529, 3531, 1, 0, 0, 0, 3530, 3528, 1, 0, 0, 0, 3531,
		3532, 5, 4, 0, 0, 3532, 379, 1, 0, 0, 0, 3533, 3534, 3, 948, 474, 0, 3534,
		381, 1, 0, 0, 0, 3535, 3536, 3, 952, 476, 0, 3536, 383, 1, 0, 0, 0, 3537,
		3538, 5, 407, 0, 0, 3538, 3539, 5, 374, 0, 0, 3539, 3540, 5, 240, 0, 0,
		3540, 3544, 5, 165, 0, 0, 3541, 3542, 3, 1006, 503, 0, 3542, 3543, 5, 1,
		0, 0, 3543, 3545, 1, 0, 0, 0, 3544, 3541, 1, 0, 0, 0, 3544, 3545, 1, 0,
		0, 0, 3545, 3546, 1, 0, 0, 0, 3546, 3547, 3, 1012, 506, 0, 3547, 385, 1,
		0, 0, 0, 3548, 3549, 5, 361, 0, 0, 3549, 3550, 5, 374, 0, 0, 3550, 3551,
		5, 240, 0, 0, 3551, 3555, 5, 165, 0, 0, 3552, 3553, 3, 1006, 503, 0, 3553,
		3554, 5, 1, 0, 0, 3554, 3556, 1, 0, 0, 0, 3555, 3552, 1, 0, 0, 0, 3555,
		3556, 1, 0, 0, 0, 3556, 3557, 1, 0, 0, 0, 3557, 3558, 3, 1012, 506, 0,
		3558, 387, 1, 0, 0, 0, 3559, 3560, 5, 304, 0, 0, 3560, 3561, 5, 374, 0,
		0, 3561, 3562, 5, 240, 0, 0, 3562, 3566, 5, 165, 0, 0, 3563, 3564, 3, 1006,
		503, 0, 3564, 3565, 5, 1, 0, 0, 3565, 3567, 1, 0, 0, 0, 3566, 3563, 1,
		0, 0, 0, 3566, 3567, 1, 0, 0, 0, 3567, 3568, 1, 0, 0, 0, 3568, 3569, 3,
		1012, 506, 0, 3569, 389, 1, 0, 0, 0, 3570, 3572, 5, 398, 0, 0, 3571, 3573,
		5, 18, 0, 0, 3572, 3571, 1, 0, 0, 0, 3572, 3573, 1, 0, 0, 0, 3573, 3574,
		1, 0, 0, 0, 3574, 3575, 5, 374, 0, 0, 3575, 3583, 5, 240, 0, 0, 3576, 3580,
		5, 165, 0, 0, 3577, 3578, 3, 1006, 503, 0, 3578, 3579, 5, 1, 0, 0, 3579,
		3581, 1, 0, 0, 0, 3580, 3577, 1, 0, 0, 0, 3580, 3581, 1, 0, 0, 0, 3581,
		3582, 1, 0, 0, 0, 3582, 3584, 3, 1012, 506, 0, 3583, 3576, 1, 0, 0, 0,
		3583, 3584, 1, 0, 0, 0, 3584, 3587, 1, 0, 0, 0, 3585, 3586, 5, 169, 0,
		0, 3586, 3588, 3, 1006, 503, 0, 3587, 3585, 1, 0, 0, 0, 3587, 3588, 1,
		0, 0, 0, 3588, 3591, 1, 0, 0, 0, 3589, 3590, 5, 476, 0, 0, 3590, 3592,
		3, 842, 421, 0, 3591, 3589, 1, 0, 0, 0, 3591, 3592, 1, 0, 0, 0, 3592, 3603,
		1, 0, 0, 0, 3593, 3594, 5, 295, 0, 0, 3594, 3595, 5, 55, 0, 0, 3595, 3600,
		3, 762, 381, 0, 3596, 3597, 5, 3, 0, 0, 3597, 3599, 3, 762, 381, 0, 3598,
		3596, 1, 0, 0, 0, 3599, 3602, 1, 0, 0, 0, 3600, 3598, 1, 0, 0, 0, 3600,
		3601, 1, 0, 0, 0, 3601, 3604, 1, 0, 0, 0, 3602, 3600, 1, 0, 0, 0, 3603,
		3593, 1, 0, 0, 0, 3603, 3604, 1, 0, 0, 0, 3604, 3606, 1, 0, 0, 0, 3605,
		3607, 3, 766, 383, 0, 3606, 3605, 1, 0, 0, 0, 3606, 3607, 1, 0, 0, 0, 3607,
		391, 1, 0, 0, 0, 3608, 3609, 5, 398, 0, 0, 3609, 3610, 5, 374, 0, 0, 3610,
		3611, 5, 240, 0, 0, 3611, 3614, 5, 425, 0, 0, 3612, 3613, 5, 169, 0, 0,
		3613, 3615, 3, 1006, 503, 0, 3614, 3612, 1, 0, 0, 0, 3614, 3615, 1, 0,
		0, 0, 3615, 3616, 1, 0, 0, 0, 3616, 3617, 5, 476, 0, 0, 3617, 3618, 3,
		842, 421, 0, 3618, 393, 1, 0, 0, 0, 3619, 3620, 5, 398, 0, 0, 3620, 3621,
		5, 88, 0, 0, 3621, 3622, 5, 374, 0, 0, 3622, 3626, 5, 240, 0, 0, 3623,
		3624, 3, 1006, 503, 0, 3624, 3625, 5, 1, 0, 0, 3625, 3627, 1, 0, 0, 0,
		3626, 3623, 1, 0, 0, 0, 3626, 3627, 1, 0, 0, 0, 3627, 3628, 1, 0, 0, 0,
		3628, 3629, 3, 1012, 506, 0, 3629, 395, 1, 0, 0, 0, 3630, 3632, 5, 398,
		0, 0, 3631, 3633, 5, 18, 0, 0, 3632, 3631, 1, 0, 0, 0, 3632, 3633, 1, 0,
		0, 0, 3633, 3634, 1, 0, 0, 0, 3634, 3635, 5, 409, 0, 0, 3635, 3643, 5,
		240, 0, 0, 3636, 3640, 5, 165, 0, 0, 3637, 3638, 3, 1006, 503, 0, 3638,
		3639, 5, 1, 0, 0, 3639, 3641, 1, 0, 0, 0, 3640, 3637, 1, 0, 0, 0, 3640,
		3641, 1, 0, 0, 0, 3641, 3642, 1, 0, 0, 0, 3642, 3644, 3, 1012, 506, 0,
		3643, 3636, 1, 0, 0, 0, 3643, 3644, 1, 0, 0, 0, 3644, 3647, 1, 0, 0, 0,
		3645, 3646, 5, 169, 0, 0, 3646, 3648, 3, 1006, 503, 0, 3647, 3645, 1, 0,
		0, 0, 3647, 3648, 1, 0, 0, 0, 3648, 3651, 1, 0, 0, 0, 3649, 3650, 5, 476,
		0, 0, 3650, 3652, 3, 842, 421, 0, 3651, 3649, 1, 0, 0, 0, 3651, 3652, 1,
		0, 0, 0, 3652, 3663, 1, 0, 0, 0, 3653, 3654, 5, 295, 0, 0, 3654, 3655,
		5, 55, 0, 0, 3655, 3660, 3, 762, 381, 0, 3656, 3657, 5, 3, 0, 0, 3657,
		3659, 3, 762, 381, 0, 3658, 3656, 1, 0, 0, 0, 3659, 3662, 1, 0, 0, 0, 3660,
		3658, 1, 0, 0, 0, 3660, 3661, 1, 0, 0, 0, 3661, 3664, 1, 0, 0, 0, 3662,
		3660, 1, 0, 0, 0, 3663, 3653, 1, 0, 0, 0, 3663, 3664, 1, 0, 0, 0, 3664,
		3666, 1, 0, 0, 0, 3665, 3667, 3, 766, 383, 0, 3666, 3665, 1, 0, 0, 0, 3666,
		3667, 1, 0, 0, 0, 3667, 397, 1, 0, 0, 0, 3668, 3670, 5, 20, 0, 0, 3669,
		3671, 7, 18, 0, 0, 3670, 3669, 1, 0, 0, 0, 3670, 3671, 1, 0, 0, 0, 3671,
		3672, 1, 0, 0, 0, 3672, 3673, 5, 420, 0, 0, 3673, 3675, 3, 1008, 504, 0,
		3674, 3676, 3, 400, 200, 0, 3675, 3674, 1, 0, 0, 0, 3675, 3676, 1, 0, 0,
		0, 3676, 3678, 1, 0, 0, 0, 3677, 3679, 3, 816, 408, 0, 3678, 3677, 1, 0,
		0, 0, 3678, 3679, 1, 0, 0, 0, 3679, 3683, 1, 0, 0, 0, 3680, 3681, 5, 478,
		0, 0, 3681, 3682, 7, 12, 0, 0, 3682, 3684, 5, 266, 0, 0, 3683, 3680, 1,
		0, 0, 0, 3683, 3684, 1, 0, 0, 0, 3684, 3686, 1, 0, 0, 0, 3685, 3687, 3,
		948, 474, 0, 3686, 3685, 1, 0, 0, 0, 3686, 3687, 1, 0, 0, 0, 3687, 399,
		1, 0, 0, 0, 3688, 3689, 5, 2, 0, 0, 3689, 3694, 3, 1006, 503, 0, 3690,
		3691, 5, 3, 0, 0, 3691, 3693, 3, 1006, 503, 0, 3692, 3690, 1, 0, 0, 0,
		3693, 3696, 1, 0, 0, 0, 3694, 3692, 1, 0, 0, 0, 3694, 3695, 1, 0, 0, 0,
		3695, 3697, 1, 0, 0, 0, 3696, 3694, 1, 0, 0, 0, 3697, 3698, 5, 4, 0, 0,
		3698, 3725, 1, 0, 0, 0, 3699, 3704, 3, 1006, 503, 0, 3700, 3701, 5, 3,
		0, 0, 3701, 3703, 3, 1006, 503, 0, 3702, 3700, 1, 0, 0, 0, 3703, 3706,
		1, 0, 0, 0, 3704, 3702, 1, 0, 0, 0, 3704, 3705, 1, 0, 0, 0, 3705, 3725,
		1, 0, 0, 0, 3706, 3704, 1, 0, 0, 0, 3707, 3708, 5, 18, 0, 0, 3708, 3725,
		5, 75, 0, 0, 3709, 3710, 5, 318, 0, 0, 3710, 3725, 5, 75, 0, 0, 3711, 3712,
		5, 269, 0, 0, 3712, 3713, 5, 75, 0, 0, 3713, 3714, 5, 2, 0, 0, 3714, 3719,
		3, 1006, 503, 0, 3715, 3716, 5, 3, 0, 0, 3716, 3718, 3, 1006, 503, 0, 3717,
		3715, 1, 0, 0, 0, 3718, 3721, 1, 0, 0, 0, 3719, 3717, 1, 0, 0, 0, 3719,
		3720, 1, 0, 0, 0, 3720, 3722, 1, 0, 0, 0, 3721, 3719, 1, 0, 0, 0, 3722,
		3723, 5, 4, 0, 0, 3723, 3725, 1, 0, 0, 0, 3724, 3688, 1, 0, 0, 0, 3724,
		3699, 1, 0, 0, 0, 3724, 3707, 1, 0, 0, 0, 3724, 3709, 1, 0, 0, 0, 3724,
		3711, 1, 0, 0, 0, 3725, 401, 1, 0, 0, 0, 3726, 3729, 5, 130, 0, 0, 3727,
		3728, 5, 269, 0, 0, 3728, 3730, 5, 75, 0, 0, 3729, 3727, 1, 0, 0, 0, 3729,
		3730, 1, 0, 0, 0, 3730, 3731, 1, 0, 0, 0, 3731, 3732, 5, 405, 0, 0, 3732,
		3733, 3, 1006, 503, 0, 3733, 403, 1, 0, 0, 0, 3734, 3735, 5, 20, 0, 0,
		3735, 3736, 5, 420, 0, 0, 3736, 3737, 3, 1008, 504, 0, 3737, 3738, 5, 453,
		0, 0, 3738, 3739, 5, 186, 0, 0, 3739, 3740, 5, 287, 0, 0, 3740, 3744, 3,
		400, 200, 0, 3741, 3742, 5, 478, 0, 0, 3742, 3743, 5, 516, 0, 0, 3743,
		3745, 5, 53, 0, 0, 3744, 3741, 1, 0, 0, 0, 3744, 3745, 1, 0, 0, 0, 3745,
		3747, 1, 0, 0, 0, 3746, 3748, 3, 948, 474, 0, 3747, 3746, 1, 0, 0, 0, 3747,
		3748, 1, 0, 0, 0, 3748, 405, 1, 0, 0, 0, 3749, 3753, 3, 404, 202, 0, 3750,
		3751, 5, 478, 0, 0, 3751, 3752, 7, 12, 0, 0, 3752, 3754, 5, 266, 0, 0,
		3753, 3750, 1, 0, 0, 0, 3753, 3754, 1, 0, 0, 0, 3754, 407, 1, 0, 0, 0,
		3755, 3756, 5, 20, 0, 0, 3756, 3757, 5, 420, 0, 0, 3757, 3758, 3, 1006,
		503, 0, 3758, 3759, 5, 130, 0, 0, 3759, 3760, 5, 186, 0, 0, 3760, 3761,
		5, 287, 0, 0, 3761, 3766, 3, 1006, 503, 0, 3762, 3763, 5, 3, 0, 0, 3763,
		3765, 3, 1006, 503, 0, 3764, 3762, 1, 0, 0, 0, 3765, 3768, 1, 0, 0, 0,
		3766, 3764, 1, 0, 0, 0, 3766, 3767, 1, 0, 0, 0, 3767, 409, 1, 0, 0, 0,
		3768, 3766, 1, 0, 0, 0, 3769, 3770, 5, 88, 0, 0, 3770, 3772, 5, 20, 0,
		0, 3771, 3773, 7, 18, 0, 0, 3772, 3771, 1, 0, 0, 0, 3772, 3773, 1, 0, 0,
		0, 3773, 3774, 1, 0, 0, 0, 3774, 3776, 5, 18, 0, 0, 3775, 3777, 3, 948,
		474, 0, 3776, 3775, 1, 0, 0, 0, 3776, 3777, 1, 0, 0, 0, 3777, 3814, 1,
		0, 0, 0, 3778, 3779, 5, 88, 0, 0, 3779, 3781, 5, 20, 0, 0, 3780, 3782,
		7, 18, 0, 0, 3781, 3780, 1, 0, 0, 0, 3781, 3782, 1, 0, 0, 0, 3782, 3783,
		1, 0, 0, 0, 3783, 3784, 5, 102, 0, 0, 3784, 3786, 3, 1012, 506, 0, 3785,
		3787, 3, 948, 474, 0, 3786, 3785, 1, 0, 0, 0, 3786, 3787, 1, 0, 0, 0, 3787,
		3814, 1, 0, 0, 0, 3788, 3789, 5, 88, 0, 0, 3789, 3791, 5, 20, 0, 0, 3790,
		3792, 7, 18, 0, 0, 3791, 3790, 1, 0, 0, 0, 3791, 3792, 1, 0, 0, 0, 3792,
		3793, 1, 0, 0, 0, 3793, 3794, 5, 420, 0, 0, 3794, 3806, 3, 1006, 503, 0,
		3795, 3796, 5, 2, 0, 0, 3796, 3801, 3, 1006, 503, 0, 3797, 3798, 5, 3,
		0, 0, 3798, 3800, 3, 1006, 503, 0, 3799, 3797, 1, 0, 0, 0, 3800, 3803,
		1, 0, 0, 0, 3801, 3799, 1, 0, 0, 0, 3801, 3802, 1, 0, 0, 0, 3802, 3804,
		1, 0, 0, 0, 3803, 3801, 1, 0, 0, 0, 3804, 3805, 5, 4, 0, 0, 3805, 3807,
		1, 0, 0, 0, 3806, 3795, 1, 0, 0, 0, 3806, 3807, 1, 0, 0, 0, 3807, 3809,
		1, 0, 0, 0, 3808, 3810, 3, 948, 474, 0, 3809, 3808, 1, 0, 0, 0, 3809, 3810,
		1, 0, 0, 0, 3810, 3814, 1, 0, 0, 0, 3811, 3812, 5, 88, 0, 0, 3812, 3814,
		3, 404, 202, 0, 3813, 3769, 1, 0, 0, 0, 3813, 3778, 1, 0, 0, 0, 3813, 3788,
		1, 0, 0, 0, 3813, 3811, 1, 0, 0, 0, 3814, 411, 1, 0, 0, 0, 3815, 3816,
		5, 130, 0, 0, 3816, 3817, 5, 20, 0, 0, 3817, 3823, 5, 516, 0, 0, 3818,
		3819, 5, 130, 0, 0, 3819, 3820, 5, 18, 0, 0, 3820, 3821, 5, 20, 0, 0, 3821,
		3823, 5, 221, 0, 0, 3822, 3815, 1, 0, 0, 0, 3822, 3818, 1, 0, 0, 0, 3823,
		413, 1, 0, 0, 0, 3824, 3825, 5, 398, 0, 0, 3825, 3827, 5, 20, 0, 0, 3826,
		3828, 7, 19, 0, 0, 3827, 3826, 1, 0, 0, 0, 3827, 3828, 1, 0, 0, 0, 3828,
		3831, 1, 0, 0, 0, 3829, 3830, 5, 476, 0, 0, 3830, 3832, 3, 842, 421, 0,
		3831, 3829, 1, 0, 0, 0, 3831, 3832, 1, 0, 0, 0, 3832, 3843, 1, 0, 0, 0,
		3833, 3834, 5, 295, 0, 0, 3834, 3835, 5, 55, 0, 0, 3835, 3840, 3, 762,
		381, 0, 3836, 3837, 5, 3, 0, 0, 3837, 3839, 3, 762, 381, 0, 3838, 3836,
		1, 0, 0, 0, 3839, 3842, 1, 0, 0, 0, 3840, 3838, 1, 0, 0, 0, 3840, 3841,
		1, 0, 0, 0, 3841, 3844, 1, 0, 0, 0, 3842, 3840, 1, 0, 0, 0, 3843, 3833,
		1, 0, 0, 0, 3843, 3844, 1, 0, 0, 0, 3844, 3846, 1, 0, 0, 0, 3845, 3847,
		3, 766, 383, 0, 3846, 3845, 1, 0, 0, 0, 3846, 3847, 1, 0, 0, 0, 3847, 415,
		1, 0, 0, 0, 3848, 3851, 5, 398, 0, 0, 3849, 3850, 5, 269, 0, 0, 3850, 3852,
		5, 75, 0, 0, 3851, 3849, 1, 0, 0, 0, 3851, 3852, 1, 0, 0, 0, 3852, 3853,
		1, 0, 0, 0, 3853, 3854, 5, 405, 0, 0, 3854, 3857, 5, 264, 0, 0, 3855, 3856,
		5, 476, 0, 0, 3856, 3858, 3, 842, 421, 0, 3857, 3855, 1, 0, 0, 0, 3857,
		3858, 1, 0, 0, 0, 3858, 3869, 1, 0, 0, 0, 3859, 3860, 5, 295, 0, 0, 3860,
		3861, 5, 55, 0, 0, 3861, 3866, 3, 762, 381, 0, 3862, 3863, 5, 3, 0, 0,
		3863, 3865, 3, 762, 381, 0, 3864, 3862, 1, 0, 0, 0, 3865, 3868, 1, 0, 0,
		0, 3866, 3864, 1, 0, 0, 0, 3866, 3867, 1, 0, 0, 0, 3867, 3870, 1, 0, 0,
		0, 3868, 3866, 1, 0, 0, 0, 3869, 3859, 1, 0, 0, 0, 3869, 3870, 1, 0, 0,
		0, 3870, 3872, 1, 0, 0, 0, 3871, 3873, 3, 766, 383, 0, 3872, 3871, 1, 0,
		0, 0, 3872, 3873, 1, 0, 0, 0, 3873, 417, 1, 0, 0, 0, 3874, 3875, 5, 398,
		0, 0, 3875, 3876, 5, 186, 0, 0, 3876, 3879, 5, 264, 0, 0, 3877, 3878, 5,
		476, 0, 0, 3878, 3880, 3, 842, 421, 0, 3879, 3877, 1, 0, 0, 0, 3879, 3880,
		1, 0, 0, 0, 3880, 3891, 1, 0, 0, 0, 3881, 3882, 5, 295, 0, 0, 3882, 3883,
		5, 55, 0, 0, 3883, 3888, 3, 762, 381, 0, 3884, 3885, 5, 3, 0, 0, 3885,
		3887, 3, 762, 381, 0, 3886, 3884, 1, 0, 0, 0, 3887, 3890, 1, 0, 0, 0, 3888,
		3886, 1, 0, 0, 0, 3888, 3889, 1, 0, 0, 0, 3889, 3892, 1, 0, 0, 0, 3890,
		3888, 1, 0, 0, 0, 3891, 3881, 1, 0, 0, 0, 3891, 3892, 1, 0, 0, 0, 3892,
		3894, 1, 0, 0, 0, 3893, 3895, 3, 766, 383, 0, 3894, 3893, 1, 0, 0, 0, 3894,
		3895, 1, 0, 0, 0, 3895, 419, 1, 0, 0, 0, 3896, 3897, 5, 226, 0, 0, 3897,
		3898, 5, 20, 0, 0, 3898, 3904, 5, 516, 0, 0, 3899, 3900, 5, 226, 0, 0,
		3900, 3901, 5, 18, 0, 0, 3901, 3902, 5, 305, 0, 0, 3902, 3904, 5, 20, 0,
		0, 3903, 3896, 1, 0, 0, 0, 3903, 3899, 1, 0, 0, 0, 3904, 421, 1, 0, 0,
		0, 3905, 3906, 5, 20, 0, 0, 3906, 3907, 5, 327, 0, 0, 3907, 3908, 5, 169,
		0, 0, 3908, 3923, 3, 970, 485, 0, 3909, 3910, 5, 20, 0, 0, 3910, 3911,
		5, 327, 0, 0, 3911, 3912, 5, 169, 0, 0, 3912, 3913, 3, 970, 485, 0, 3913,
		3914, 5, 3, 0, 0, 3914, 3919, 5, 516, 0, 0, 3915, 3916, 5, 3, 0, 0, 3916,
		3918, 5, 516, 0, 0, 3917, 3915, 1, 0, 0, 0, 3918, 3921, 1, 0, 0, 0, 3919,
		3917, 1, 0, 0, 0, 3919, 3920, 1, 0, 0, 0, 3920, 3923, 1, 0, 0, 0, 3921,
		3919, 1, 0, 0, 0, 3922, 3905, 1, 0, 0, 0, 3922, 3909, 1, 0, 0, 0, 3923,
		423, 1, 0, 0, 0, 3924, 3926, 5, 88, 0, 0, 3925, 3927, 5, 175, 0, 0, 3926,
		3925, 1, 0, 0, 0, 3926, 3927, 1, 0, 0, 0, 3927, 3928, 1, 0, 0, 0, 3928,
		3931, 5, 39, 0, 0, 3929, 3930, 5, 287, 0, 0, 3930, 3932, 3, 746, 373, 0,
		3931, 3929, 1, 0, 0, 0, 3931, 3932, 1, 0, 0, 0, 3932, 3933, 1, 0, 0, 0,
		3933, 3934, 5, 458, 0, 0, 3934, 3936, 3, 746, 373, 0, 3935, 3937, 3, 948,
		474, 0, 3936, 3935, 1, 0, 0, 0, 3936, 3937, 1, 0, 0, 0, 3937, 425, 1, 0,
		0, 0, 3938, 3939, 5, 130, 0, 0, 3939, 3940, 5, 39, 0, 0, 3940, 3941, 5,
		516, 0, 0, 3941, 427, 1, 0, 0, 0, 3942, 3943, 5, 398, 0, 0, 3943, 3944,
		5, 39, 0, 0, 3944, 429, 1, 0, 0, 0, 3945, 3946, 5, 88, 0, 0, 3946, 3947,
		5, 358, 0, 0, 3947, 3951, 5, 178, 0, 0, 3948, 3949, 5, 194, 0, 0, 3949,
		3950, 5, 278, 0, 0, 3950, 3952, 5, 145, 0, 0, 3951, 3948, 1, 0, 0, 0, 3951,
		3952, 1, 0, 0, 0, 3952, 3955, 1, 0, 0, 0, 3953, 3954, 5, 294, 0, 0, 3954,
		3956, 5, 353, 0, 0, 3955, 3953, 1, 0, 0, 0, 3955, 3956, 1, 0, 0, 0, 3956,
		3957, 1, 0, 0, 0, 3957, 3967, 3, 1012, 506, 0, 3958, 3959, 5, 438, 0, 0,
		3959, 3964, 3, 448, 224, 0, 3960, 3961, 5, 3, 0, 0, 3961, 3963, 3, 448,
		224, 0, 3962, 3960, 1, 0, 0, 0, 3963, 3966, 1, 0, 0, 0, 3964, 3962, 1,
		0, 0, 0, 3964, 3965, 1, 0, 0, 0, 3965, 3968, 1, 0, 0, 0, 3966, 3964, 1,
		0, 0, 0, 3967, 3958, 1, 0, 0, 0, 3967, 3968, 1, 0, 0, 0, 3968, 3969, 1,
		0, 0, 0, 3969, 3970, 5, 478, 0, 0, 3970, 3971, 5, 2, 0, 0, 3971, 3976,
		3, 956, 478, 0, 3972, 3973, 5, 3, 0, 0, 3973, 3975, 3, 956, 478, 0, 3974,
		3972, 1, 0, 0, 0, 3975, 3978, 1, 0, 0, 0, 3976, 3974, 1, 0, 0, 0, 3976,
		3977, 1, 0, 0, 0, 3977, 3979, 1, 0, 0, 0, 3978, 3976, 1, 0, 0, 0, 3979,
		3980, 5, 4, 0, 0, 3980, 431, 1, 0, 0, 0, 3981, 3982, 5, 130, 0, 0, 3982,
		3983, 5, 358, 0, 0, 3983, 3984, 5, 178, 0, 0, 3984, 3985, 3, 1012, 506,
		0, 3985, 433, 1, 0, 0, 0, 3986, 3987, 5, 19, 0, 0, 3987, 3988, 5, 358,
		0, 0, 3988, 3989, 5, 178, 0, 0, 3989, 3990, 3, 1012, 506, 0, 3990, 3991,
		5, 13, 0, 0, 3991, 3996, 3, 448, 224, 0, 3992, 3993, 5, 3, 0, 0, 3993,
		3995, 3, 448, 224, 0, 3994, 3992, 1, 0, 0, 0, 3995, 3998, 1, 0, 0, 0, 3996,
		3994, 1, 0, 0, 0, 3996, 3997, 1, 0, 0, 0, 3997, 4039, 1, 0, 0, 0, 3998,
		3996, 1, 0, 0, 0, 3999, 4000, 5, 19, 0, 0, 4000, 4001, 5, 358, 0, 0, 4001,
		4002, 5, 178, 0, 0, 4002, 4003, 3, 1012, 506, 0, 4003, 4004, 5, 130, 0,
		0, 4004, 4005, 5, 2, 0, 0, 4005, 4010, 5, 516, 0, 0, 4006, 4007, 5, 3,
		0, 0, 4007, 4009, 5, 516, 0, 0, 4008, 4006, 1, 0, 0, 0, 4009, 4012, 1,
		0, 0, 0, 4010, 4008, 1, 0, 0, 0, 4010, 4011, 1, 0, 0, 0, 4011, 4013, 1,
		0, 0, 0, 4012, 4010, 1, 0, 0, 0, 4013, 4014, 5, 4, 0, 0, 4014, 4039, 1,
		0, 0, 0, 4015, 4016, 5, 19, 0, 0, 4016, 4017, 5, 358, 0, 0, 4017, 4018,
		5, 178, 0, 0, 4018, 4019, 3, 1012, 506, 0, 4019, 4020, 5, 130, 0, 0, 4020,
		4021, 5, 18, 0, 0, 4021, 4039, 1, 0, 0, 0, 4022, 4023, 5, 19, 0, 0, 4023,
		4024, 5, 358, 0, 0, 4024, 4025, 5, 178, 0, 0, 4025, 4026, 3, 1012, 506,
		0, 4026, 4027, 5, 478, 0, 0, 4027, 4028, 5, 2, 0, 0, 4028, 4033, 3, 956,
		478, 0, 4029, 4030, 5, 3, 0, 0, 4030, 4032, 3, 956, 478, 0, 4031, 4029,
		1, 0, 0, 0, 4032, 4035, 1, 0, 0, 0, 4033, 4031, 1, 0, 0, 0, 4033, 4034,
		1, 0, 0, 0, 4034, 4036, 1, 0, 0, 0, 4035, 4033, 1, 0, 0, 0, 4036, 4037,
		5, 4, 0, 0, 4037, 4039, 1, 0, 0, 0, 4038, 3986, 1, 0, 0, 0, 4038, 3999,
		1, 0, 0, 0, 4038, 4015, 1, 0, 0, 0, 4038, 4022, 1, 0, 0, 0, 4039, 435,
		1, 0, 0, 0, 4040, 4042, 5, 398, 0, 0, 4041, 4043, 5, 465, 0, 0, 4042, 4041,
		1, 0, 0, 0, 4042, 4043, 1, 0, 0, 0, 4043, 4044, 1, 0, 0, 0, 4044, 4045,
		5, 358, 0, 0, 4045, 4046, 5, 178, 0, 0, 4046, 4057, 3, 1012, 506, 0, 4047,
		4049, 5, 398, 0, 0, 4048, 4050, 5, 465, 0, 0, 4049, 4048, 1, 0, 0, 0, 4049,
		4050, 1, 0, 0, 0, 4050, 4051, 1, 0, 0, 0, 4051, 4052, 5, 358, 0, 0, 4052,
		4054, 5, 179, 0, 0, 4053, 4055, 5, 18, 0, 0, 4054, 4053, 1, 0, 0, 0, 4054,
		4055, 1, 0, 0, 0, 4055, 4057, 1, 0, 0, 0, 4056, 4040, 1, 0, 0, 0, 4056,
		4047, 1, 0, 0, 0, 4057, 437, 1, 0, 0, 0, 4058, 4059, 5, 398, 0, 0, 4059,
		4060, 5, 454, 0, 0, 4060, 4061, 5, 358, 0, 0, 4061, 4062, 5, 178, 0, 0,
		4062, 4068, 3, 1012, 506, 0, 4063, 4064, 5, 398, 0, 0, 4064, 4065, 5, 454,
		0, 0, 4065, 4066, 5, 358, 0, 0, 4066, 4068, 5, 179, 0, 0, 4067, 4058, 1,
		0, 0, 0, 4067, 4063, 1, 0, 0, 0, 4068, 439, 1, 0, 0, 0, 4069, 4071, 5,
		88, 0, 0, 4070, 4072, 5, 148, 0, 0, 4071, 4070, 1, 0, 0, 0, 4071, 4072,
		1, 0, 0, 0, 4072, 4073, 1, 0, 0, 0, 4073, 4074, 5, 358, 0, 0, 4074, 4076,
		3, 1020, 510, 0, 4075, 4077, 3, 948, 474, 0, 4076, 4075, 1, 0, 0, 0, 4076,
		4077, 1, 0, 0, 0, 4077, 441, 1, 0, 0, 0, 4078, 4079, 5, 19, 0, 0, 4079,
		4080, 5, 358, 0, 0, 4080, 4081, 3, 1020, 510, 0, 4081, 4082, 5, 393, 0,
		0, 4082, 4083, 3, 948, 474, 0, 4083, 443, 1, 0, 0, 0, 4084, 4085, 5, 130,
		0, 0, 4085, 4086, 5, 358, 0, 0, 4086, 4087, 3, 1020, 510, 0, 4087, 445,
		1, 0, 0, 0, 4088, 4089, 5, 398, 0, 0, 4089, 4090, 5, 359, 0, 0, 4090, 447,
		1, 0, 0, 0, 4091, 4092, 5, 2, 0, 0, 4092, 4093, 3, 844, 422, 0, 4093, 4094,
		5, 4, 0, 0, 4094, 449, 1, 0, 0, 0, 4095, 4097, 5, 398, 0, 0, 4096, 4098,
		5, 172, 0, 0, 4097, 4096, 1, 0, 0, 0, 4097, 4098, 1, 0, 0, 0, 4098, 4100,
		1, 0, 0, 0, 4099, 4101, 7, 20, 0, 0, 4100, 4099, 1, 0, 0, 0, 4100, 4101,
		1, 0, 0, 0, 4101, 4102, 1, 0, 0, 0, 4102, 4105, 5, 174, 0, 0, 4103, 4104,
		7, 1, 0, 0, 4104, 4106, 3, 1006, 503, 0, 4105, 4103, 1, 0, 0, 0, 4105,
		4106, 1, 0, 0, 0, 4106, 4111, 1, 0, 0, 0, 4107, 4108, 5, 237, 0, 0, 4108,
		4112, 3, 970, 485, 0, 4109, 4110, 5, 476, 0, 0, 4110, 4112, 3, 842, 421,
		0, 4111, 4107, 1, 0, 0, 0, 4111, 4109, 1, 0, 0, 0, 4111, 4112, 1, 0, 0,
		0, 4112, 451, 1, 0, 0, 0, 4113, 4115, 5, 130, 0, 0, 4114, 4116, 5, 175,
		0, 0, 4115, 4114, 1, 0, 0, 0, 4115, 4116, 1, 0, 0, 0, 4116, 4117, 1, 0,
		0, 0, 4117, 4120, 5, 173, 0, 0, 4118, 4119, 5, 194, 0, 0, 4119, 4121, 5,
		145, 0, 0, 4120, 4118, 1, 0, 0, 0, 4120, 4121, 1, 0, 0, 0, 4121, 4122,
		1, 0, 0, 0, 4122, 4123, 3, 1006, 503, 0, 4123, 4124, 5, 2, 0, 0, 4124,
		4125, 3, 458, 229, 0, 4125, 4126, 5, 4, 0, 0, 4126, 453, 1, 0, 0, 0, 4127,
		4128, 5, 88, 0, 0, 4128, 4130, 3, 70, 35, 0, 4129, 4131, 5, 175, 0, 0,
		4130, 4129, 1, 0, 0, 0, 4130, 4131, 1, 0, 0, 0, 4131, 4133, 1, 0, 0, 0,
		4132, 4134, 7, 21, 0, 0, 4133, 4132, 1, 0, 0, 0, 4133, 4134, 1, 0, 0, 0,
		4134, 4135, 1, 0, 0, 0, 4135, 4136, 5, 173, 0, 0, 4136, 4137, 3, 72, 36,
		0, 4137, 4138, 3, 1006, 503, 0, 4138, 4139, 5, 2, 0, 0, 4139, 4140, 3,
		458, 229, 0, 4140, 4141, 5, 4, 0, 0, 4141, 4142, 5, 364, 0, 0, 4142, 4145,
		3, 988, 494, 0, 4143, 4146, 3, 948, 474, 0, 4144, 4146, 3, 958, 479, 0,
		4145, 4146, 1, 0, 0, 0, 4145, 4143, 1, 0, 0, 0, 4145, 4144, 1, 0, 0, 0,
		4146, 4148, 1, 0, 0, 0, 4147, 4149, 3, 456, 228, 0, 4148, 4147, 1, 0, 0,
		0, 4148, 4149, 1, 0, 0, 0, 4149, 455, 1, 0, 0, 0, 4150, 4151, 5, 27, 0,
		0, 4151, 4152, 5, 533, 0, 0, 4152, 457, 1, 0, 0, 0, 4153, 4155, 3, 988,
		494, 0, 4154, 4153, 1, 0, 0, 0, 4154, 4155, 1, 0, 0, 0, 4155, 4160, 1,
		0, 0, 0, 4156, 4157, 5, 3, 0, 0, 4157, 4159, 3, 988, 494, 0, 4158, 4156,
		1, 0, 0, 0, 4159, 4162, 1, 0, 0, 0, 4160, 4158, 1, 0, 0, 0, 4160, 4161,
		1, 0, 0, 0, 4161, 4165, 1, 0, 0, 0, 4162, 4160, 1, 0, 0, 0, 4163, 4164,
		5, 3, 0, 0, 4164, 4166, 5, 531, 0, 0, 4165, 4163, 1, 0, 0, 0, 4165, 4166,
		1, 0, 0, 0, 4166, 459, 1, 0, 0, 0, 4167, 4168, 5, 240, 0, 0, 4168, 4169,
		5, 227, 0, 0, 4169, 4171, 3, 462, 231, 0, 4170, 4172, 3, 464, 232, 0, 4171,
		4170, 1, 0, 0, 0, 4171, 4172, 1, 0, 0, 0, 4172, 4174, 1, 0, 0, 0, 4173,
		4175, 3, 470, 235, 0, 4174, 4173, 1, 0, 0, 0, 4174, 4175, 1, 0, 0, 0, 4175,
		4178, 1, 0, 0, 0, 4176, 4177, 5, 55, 0, 0, 4177, 4179, 3, 1020, 510, 0,
		4178, 4176, 1, 0, 0, 0, 4178, 4179, 1, 0, 0, 0, 4179, 4182, 1, 0, 0, 0,
		4180, 4181, 5, 329, 0, 0, 4181, 4183, 3, 952, 476, 0, 4182, 4180, 1, 0,
		0, 0, 4182, 4183, 1, 0, 0, 0, 4183, 4196, 1, 0, 0, 0, 4184, 4185, 5, 240,
		0, 0, 4185, 4186, 5, 227, 0, 0, 4186, 4188, 3, 462, 231, 0, 4187, 4189,
		3, 464, 232, 0, 4188, 4187, 1, 0, 0, 0, 4188, 4189, 1, 0, 0, 0, 4189, 4190,
		1, 0, 0, 0, 4190, 4193, 3, 472, 236, 0, 4191, 4192, 5, 329, 0, 0, 4192,
		4194, 3, 952, 476, 0, 4193, 4191, 1, 0, 0, 0, 4193, 4194, 1, 0, 0, 0, 4194,
		4196, 1, 0, 0, 0, 4195, 4167, 1, 0, 0, 0, 4195, 4184, 1, 0, 0, 0, 4196,
		461, 1, 0, 0, 0, 4197, 4198, 3, 1012, 506, 0, 4198, 4199, 5, 1, 0, 0, 4199,
		4201, 1, 0, 0, 0, 4200, 4197, 1, 0, 0, 0, 4200, 4201, 1, 0, 0, 0, 4201,
		4202, 1, 0, 0, 0, 4202, 4203, 3, 1012, 506, 0, 4203, 463, 1, 0, 0, 0, 4204,
		4205, 5, 2, 0, 0, 4205, 4210, 3, 466, 233, 0, 4206, 4207, 5, 3, 0, 0, 4207,
		4209, 3, 466, 233, 0, 4208, 4206, 1, 0, 0, 0, 4209, 4212, 1, 0, 0, 0, 4210,
		4208, 1, 0, 0, 0, 4210, 4211, 1, 0, 0, 0, 4211, 4213, 1, 0, 0, 0, 4212,
		4210, 1, 0, 0, 0, 4213, 4214, 5, 4, 0, 0, 4214, 465, 1, 0, 0, 0, 4215,
		4216, 5, 100, 0, 0, 4216, 4217, 5, 204, 0, 0, 4217, 4219, 3, 916, 458,
		0, 4218, 4220, 5, 272, 0, 0, 4219, 4218, 1, 0, 0, 0, 4219, 4220, 1, 0,
		0, 0, 4220, 4221, 1, 0, 0, 0, 4221, 4222, 5, 215, 0, 0, 4222, 4223, 5,
		420, 0, 0, 4223, 4225, 3, 1012, 506, 0, 4224, 4226, 3, 816, 408, 0, 4225,
		4224, 1, 0, 0, 0, 4225, 4226, 1, 0, 0, 0, 4226, 4231, 1, 0, 0, 0, 4227,
		4228, 5, 75, 0, 0, 4228, 4229, 5, 427, 0, 0, 4229, 4230, 5, 55, 0, 0, 4230,
		4232, 3, 970, 485, 0, 4231, 4227, 1, 0, 0, 0, 4231, 4232, 1, 0, 0, 0, 4232,
		4237, 1, 0, 0, 0, 4233, 4234, 5, 376, 0, 0, 4234, 4235, 5, 427, 0, 0, 4235,
		4236, 5, 55, 0, 0, 4236, 4238, 3, 970, 485, 0, 4237, 4233, 1, 0, 0, 0,
		4237, 4238, 1, 0, 0, 0, 4238, 4240, 1, 0, 0, 0, 4239, 4241, 3, 968, 484,
		0, 4240, 4239, 1, 0, 0, 0, 4240, 4241, 1, 0, 0, 0, 4241, 4243, 1, 0, 0,
		0, 4242, 4244, 3, 468, 234, 0, 4243, 4242, 1, 0, 0, 0, 4243, 4244, 1, 0,
		0, 0, 4244, 4246, 1, 0, 0, 0, 4245, 4247, 3, 814, 407, 0, 4246, 4245, 1,
		0, 0, 0, 4246, 4247, 1, 0, 0, 0, 4247, 4253, 1, 0, 0, 0, 4248, 4249, 5,
		75, 0, 0, 4249, 4250, 5, 169, 0, 0, 4250, 4251, 5, 303, 0, 0, 4251, 4252,
		5, 27, 0, 0, 4252, 4254, 3, 1018, 509, 0, 4253, 4248, 1, 0, 0, 0, 4253,
		4254, 1, 0, 0, 0, 4254, 4257, 1, 0, 0, 0, 4255, 4256, 5, 393, 0, 0, 4256,
		4258, 3, 448, 224, 0, 4257, 4255, 1, 0, 0, 0, 4257, 4258, 1, 0, 0, 0, 4258,
		4261, 1, 0, 0, 0, 4259, 4260, 5, 476, 0, 0, 4260, 4262, 3, 842, 421, 0,
		4261, 4259, 1, 0, 0, 0, 4261, 4262, 1, 0, 0, 0, 4262, 4285, 1, 0, 0, 0,
		4263, 4264, 5, 100, 0, 0, 4264, 4265, 5, 169, 0, 0, 4265, 4266, 5, 420,
		0, 0, 4266, 4268, 3, 1012, 506, 0, 4267, 4269, 5, 272, 0, 0, 4268, 4267,
		1, 0, 0, 0, 4268, 4269, 1, 0, 0, 0, 4269, 4270, 1, 0, 0, 0, 4270, 4271,
		5, 215, 0, 0, 4271, 4272, 5, 420, 0, 0, 4272, 4274, 3, 1012, 506, 0, 4273,
		4275, 3, 816, 408, 0, 4274, 4273, 1, 0, 0, 0, 4274, 4275, 1, 0, 0, 0, 4275,
		4278, 1, 0, 0, 0, 4276, 4277, 5, 393, 0, 0, 4277, 4279, 3, 448, 224, 0,
		4278, 4276, 1, 0, 0, 0, 4278, 4279, 1, 0, 0, 0, 4279, 4282, 1, 0, 0, 0,
		4280, 4281, 5, 476, 0, 0, 4281, 4283, 3, 842, 421, 0, 4282, 4280, 1, 0,
		0, 0, 4282, 4283, 1, 0, 0, 0, 4283, 4285, 1, 0, 0, 0, 4284, 4215, 1, 0,
		0, 0, 4284, 4263, 1, 0, 0, 0, 4285, 467, 1, 0, 0, 0, 4286, 4290, 5, 2,
		0, 0, 4287, 4288, 5, 397, 0, 0, 4288, 4289, 5, 490, 0, 0, 4289, 4291, 5,
		516, 0, 0, 4290, 4287, 1, 0, 0, 0, 4290, 4291, 1, 0, 0, 0, 4291, 4295,
		1, 0, 0, 0, 4292, 4293, 5, 441, 0, 0, 4293, 4294, 5, 490, 0, 0, 4294, 4296,
		3, 976, 488, 0, 4295, 4292, 1, 0, 0, 0, 4295, 4296, 1, 0, 0, 0, 4296, 4300,
		1, 0, 0, 0, 4297, 4298, 5, 136, 0, 0, 4298, 4299, 5, 490, 0, 0, 4299, 4301,
		3, 970, 485, 0, 4300, 4297, 1, 0, 0, 0, 4300, 4301, 1, 0, 0, 0, 4301, 4305,
		1, 0, 0, 0, 4302, 4303, 5, 141, 0, 0, 4303, 4304, 5, 490, 0, 0, 4304, 4306,
		3, 970, 485, 0, 4305, 4302, 1, 0, 0, 0, 4305, 4306, 1, 0, 0, 0, 4306, 4307,
		1, 0, 0, 0, 4307, 4308, 5, 4, 0, 0, 4308, 469, 1, 0, 0, 0, 4309, 4310,
		5, 478, 0, 0, 4310, 4312, 5, 52, 0, 0, 4311, 4313, 3, 952, 476, 0, 4312,
		4311, 1, 0, 0, 0, 4312, 4313, 1, 0, 0, 0, 4313, 4321, 1, 0, 0, 0, 4314,
		4315, 5, 478, 0, 0, 4315, 4316, 5, 52, 0, 0, 4316, 4318, 3, 1020, 510,
		0, 4317, 4319, 3, 952, 476, 0, 4318, 4317, 1, 0, 0, 0, 4318, 4319, 1, 0,
		0, 0, 4319, 4321, 1, 0, 0, 0, 4320, 4309, 1, 0, 0, 0, 4320, 4314, 1, 0,
		0, 0, 4321, 471, 1, 0, 0, 0, 4322, 4323, 5, 478, 0, 0, 4323, 4324, 5, 358,
		0, 0, 4324, 4326, 3, 1020, 510, 0, 4325, 4327, 3, 952, 476, 0, 4326, 4325,
		1, 0, 0, 0, 4326, 4327, 1, 0, 0, 0, 4327, 473, 1, 0, 0, 0, 4328, 4329,
		5, 398, 0, 0, 4329, 4331, 5, 240, 0, 0, 4330, 4332, 5, 18, 0, 0, 4331,
		4330, 1, 0, 0, 0, 4331, 4332, 1, 0, 0, 0, 4332, 4335, 1, 0, 0, 0, 4333,
		4334, 5, 169, 0, 0, 4334, 4336, 3, 1012, 506, 0, 4335, 4333, 1, 0, 0, 0,
		4335, 4336, 1, 0, 0, 0, 4336, 4339, 1, 0, 0, 0, 4337, 4338, 5, 476, 0,
		0, 4338, 4340, 3, 842, 421, 0, 4339, 4337, 1, 0, 0, 0, 4339, 4340, 1, 0,
		0, 0, 4340, 4351, 1, 0, 0, 0, 4341, 4342, 5, 295, 0, 0, 4342, 4343, 5,
		55, 0, 0, 4343, 4348, 3, 762, 381, 0, 4344, 4345, 5, 3, 0, 0, 4345, 4347,
		3, 762, 381, 0, 4346, 4344, 1, 0, 0, 0, 4347, 4350, 1, 0, 0, 0, 4348, 4346,
		1, 0, 0, 0, 4348, 4349, 1, 0, 0, 0, 4349, 4352, 1, 0, 0, 0, 4350, 4348,
		1, 0, 0, 0, 4351, 4341, 1, 0, 0, 0, 4351, 4352, 1, 0, 0, 0, 4352, 4354,
		1, 0, 0, 0, 4353, 4355, 3, 766, 383, 0, 4354, 4353, 1, 0, 0, 0, 4354, 4355,
		1, 0, 0, 0, 4355, 475, 1, 0, 0, 0, 4356, 4357, 5, 398, 0, 0, 4357, 4358,
		5, 240, 0, 0, 4358, 4361, 5, 473, 0, 0, 4359, 4360, 5, 169, 0, 0, 4360,
		4362, 3, 1012, 506, 0, 4361, 4359, 1, 0, 0, 0, 4361, 4362, 1, 0, 0, 0,
		4362, 4365, 1, 0, 0, 0, 4363, 4364, 5, 476, 0, 0, 4364, 4366, 3, 842, 421,
		0, 4365, 4363, 1, 0, 0, 0, 4365, 4366, 1, 0, 0, 0, 4366, 4368, 1, 0, 0,
		0, 4367, 4369, 3, 766, 383, 0, 4368, 4367, 1, 0, 0, 0, 4368, 4369, 1, 0,
		0, 0, 4369, 4376, 1, 0, 0, 0, 4370, 4371, 5, 398, 0, 0, 4371, 4372, 5,
		240, 0, 0, 4372, 4373, 5, 473, 0, 0, 4373, 4374, 5, 287, 0, 0, 4374, 4376,
		3, 970, 485, 0, 4375, 4356, 1, 0, 0, 0, 4375, 4370, 1, 0, 0, 0, 4376, 477,
		1, 0, 0, 0, 4377, 4378, 5, 57, 0, 0, 4378, 4381, 5, 240, 0, 0, 4379, 4380,
		5, 169, 0, 0, 4380, 4382, 3, 1012, 506, 0, 4381, 4379, 1, 0, 0, 0, 4381,
		4382, 1, 0, 0, 0, 4382, 4385, 1, 0, 0, 0, 4383, 4384, 5, 476, 0, 0, 4384,
		4386, 3, 842, 421, 0, 4385, 4383, 1, 0, 0, 0, 4385, 4386, 1, 0, 0, 0, 4386,
		479, 1, 0, 0, 0, 4387, 4388, 5, 19, 0, 0, 4388, 4389, 5, 240, 0, 0, 4389,
		4393, 5, 165, 0, 0, 4390, 4391, 3, 1006, 503, 0, 4391, 4392, 5, 1, 0, 0,
		4392, 4394, 1, 0, 0, 0, 4393, 4390, 1, 0, 0, 0, 4393, 4394, 1, 0, 0, 0,
		4394, 4395, 1, 0, 0, 0, 4395, 4397, 3, 1012, 506, 0, 4396, 4398, 3, 380,
		190, 0, 4397, 4396, 1, 0, 0, 0, 4397, 4398, 1, 0, 0, 0, 4398, 481, 1, 0,
		0, 0, 4399, 4400, 5, 57, 0, 0, 4400, 4401, 5, 80, 0, 0, 4401, 4402, 5,
		476, 0, 0, 4402, 4403, 3, 842, 421, 0, 4403, 483, 1, 0, 0, 0, 4404, 4405,
		5, 398, 0, 0, 4405, 4406, 5, 30, 0, 0, 4406, 485, 1, 0, 0, 0, 4407, 4408,
		5, 398, 0, 0, 4408, 4409, 5, 36, 0, 0, 4409, 487, 1, 0, 0, 0, 4410, 4411,
		5, 398, 0, 0, 4411, 4412, 5, 52, 0, 0, 4412, 489, 1, 0, 0, 0, 4413, 4419,
		5, 398, 0, 0, 4414, 4415, 5, 64, 0, 0, 4415, 4420, 5, 393, 0, 0, 4416,
		4420, 5, 66, 0, 0, 4417, 4418, 5, 65, 0, 0, 4418, 4420, 5, 393, 0, 0, 4419,
		4414, 1, 0, 0, 0, 4419, 4416, 1, 0, 0, 0, 4419, 4417, 1, 0, 0, 0, 4420,
		4425, 1, 0, 0, 0, 4421, 4422, 5, 237, 0, 0, 4422, 4426, 3, 970, 485, 0,
		4423, 4424, 5, 476, 0, 0, 4424, 4426, 3, 842, 421, 0, 4425, 4421, 1, 0,
		0, 0, 4425, 4423, 1, 0, 0, 0, 4425, 4426, 1, 0, 0, 0, 4426, 491, 1, 0,
		0, 0, 4427, 4428, 5, 398, 0, 0, 4428, 4433, 5, 73, 0, 0, 4429, 4430, 5,
		237, 0, 0, 4430, 4434, 3, 970, 485, 0, 4431, 4432, 5, 476, 0, 0, 4432,
		4434, 3, 842, 421, 0, 4433, 4429, 1, 0, 0, 0, 4433, 4431, 1, 0, 0, 0, 4433,
		4434, 1, 0, 0, 0, 4434, 493, 1, 0, 0, 0, 4435, 4436, 5, 398, 0, 0, 4436,
		4439, 5, 116, 0, 0, 4437, 4438, 7, 1, 0, 0, 4438, 4440, 3, 1006, 503, 0,
		4439, 4437, 1, 0, 0, 0, 4439, 4440, 1, 0, 0, 0, 4440, 495, 1, 0, 0, 0,
		4441, 4442, 5, 398, 0, 0, 4442, 4443, 5, 133, 0, 0, 4443, 4444, 5, 300,
		0, 0, 4444, 4447, 5, 421, 0, 0, 4445, 4446, 7, 1, 0, 0, 4446, 4448, 3,
		1006, 503, 0, 4447, 4445, 1, 0, 0, 0, 4447, 4448, 1, 0, 0, 0, 4448, 497,
		1, 0, 0, 0, 4449, 4450, 5, 398, 0, 0, 4450, 4453, 5, 142, 0, 0, 4451, 4452,
		7, 1, 0, 0, 4452, 4454, 3, 1006, 503, 0, 4453, 4451, 1, 0, 0, 0, 4453,
		4454, 1, 0, 0, 0, 4454, 4459, 1, 0, 0, 0, 4455, 4456, 5, 237, 0, 0, 4456,
		4460, 3, 970, 485, 0, 4457, 4458, 5, 476, 0, 0, 4458, 4460, 3, 842, 421,
		0, 4459, 4455, 1, 0, 0, 0, 4459, 4457, 1, 0, 0, 0, 4459, 4460, 1, 0, 0,
		0, 4460, 499, 1, 0, 0, 0, 4461, 4462, 5, 398, 0, 0, 4462, 4463, 5, 139,
		0, 0, 4463, 501, 1, 0, 0, 0, 4464, 4465, 5, 398, 0, 0, 4465, 4466, 5, 171,
		0, 0, 4466, 503, 1, 0, 0, 0, 4467, 4468, 5, 398, 0, 0, 4468, 4469, 5, 311,
		0, 0, 4469, 505, 1, 0, 0, 0, 4470, 4471, 5, 398, 0, 0, 4471, 4472, 5, 357,
		0, 0, 4472, 507, 1, 0, 0, 0, 4473, 4474, 5, 398, 0, 0, 4474, 4475, 5, 289,
		0, 0, 4475, 4476, 5, 421, 0, 0, 4476, 509, 1, 0, 0, 0, 4477, 4478, 5, 398,
		0, 0, 4478, 4479, 5, 322, 0, 0, 4479, 511, 1, 0, 0, 0, 4480, 4481, 5, 398,
		0, 0, 4481, 4482, 7, 22, 0, 0, 4482, 4487, 5, 406, 0, 0, 4483, 4484, 5,
		237, 0, 0, 4484, 4488, 3, 970, 485, 0, 4485, 4486, 5, 476, 0, 0, 4486,
		4488, 3, 842, 421, 0, 4487, 4483, 1, 0, 0, 0, 4487, 4485, 1, 0, 0, 0, 4487,
		4488, 1, 0, 0, 0, 4488, 513, 1, 0, 0, 0, 4489, 4490, 5, 398, 0, 0, 4490,
		4491, 5, 324, 0, 0, 4491, 4492, 3, 970, 485, 0, 4492, 515, 1, 0, 0, 0,
		4493, 4495, 5, 398, 0, 0, 4494, 4496, 5, 172, 0, 0, 4495, 4494, 1, 0, 0,
		0, 4495, 4496, 1, 0, 0, 0, 4496, 4497, 1, 0, 0, 0, 4497, 4500, 5, 326,
		0, 0, 4498, 4499, 5, 165, 0, 0, 4499, 4501, 3, 970, 485, 0, 4500, 4498,
		1, 0, 0, 0, 4500, 4501, 1, 0, 0, 0, 4501, 517, 1, 0, 0, 0, 4502, 4503,
		5, 398, 0, 0, 4503, 4506, 5, 328, 0, 0, 4504, 4505, 5, 238, 0, 0, 4505,
		4507, 5, 516, 0, 0, 4506, 4504, 1, 0, 0, 0, 4506, 4507, 1, 0, 0, 0, 4507,
		519, 1, 0, 0, 0, 4508, 4509, 5, 398, 0, 0, 4509, 4510, 5, 380, 0, 0, 4510,
		4513, 5, 336, 0, 0, 4511, 4512, 5, 238, 0, 0, 4512, 4514, 5, 516, 0, 0,
		4513, 4511, 1, 0, 0, 0, 4513, 4514, 1, 0, 0, 0, 4514, 521, 1, 0, 0, 0,
		4515, 4517, 5, 398, 0, 0, 4516, 4518, 3, 962, 481, 0, 4517, 4516, 1, 0,
		0, 0, 4517, 4518, 1, 0, 0, 0, 4518, 4519, 1, 0, 0, 0, 4519, 4524, 5, 406,
		0, 0, 4520, 4521, 5, 237, 0, 0, 4521, 4525, 3, 970, 485, 0, 4522, 4523,
		5, 476, 0, 0, 4523, 4525, 3, 842, 421, 0, 4524, 4520, 1, 0, 0, 0, 4524,
		4522, 1, 0, 0, 0, 4524, 4525, 1, 0, 0, 0, 4525, 523, 1, 0, 0, 0, 4526,
		4527, 5, 398, 0, 0, 4527, 4528, 5, 422, 0, 0, 4528, 4556, 5, 516, 0, 0,
		4529, 4530, 5, 398, 0, 0, 4530, 4531, 7, 23, 0, 0, 4531, 4532, 5, 169,
		0, 0, 4532, 4534, 3, 1006, 503, 0, 4533, 4535, 3, 816, 408, 0, 4534, 4533,
		1, 0, 0, 0, 4534, 4535, 1, 0, 0, 0, 4535, 4538, 1, 0, 0, 0, 4536, 4537,
		5, 476, 0, 0, 4537, 4539, 3, 842, 421, 0, 4538, 4536, 1, 0, 0, 0, 4538,
		4539, 1, 0, 0, 0, 4539, 4550, 1, 0, 0, 0, 4540, 4541, 5, 295, 0, 0, 4541,
		4542, 5, 55, 0, 0, 4542, 4547, 3, 762, 381, 0, 4543, 4544, 5, 3, 0, 0,
		4544, 4546, 3, 762, 381, 0, 4545, 4543, 1, 0, 0, 0, 4546, 4549, 1, 0, 0,
		0, 4547, 4545, 1, 0, 0, 0, 4547, 4548, 1, 0, 0, 0, 4548, 4551, 1, 0, 0,
		0, 4549, 4547, 1, 0, 0, 0, 4550, 4540, 1, 0, 0, 0, 4550, 4551, 1, 0, 0,
		0, 4551, 4553, 1, 0, 0, 0, 4552, 4554, 3, 766, 383, 0, 4553, 4552, 1, 0,
		0, 0, 4553, 4554, 1, 0, 0, 0, 4554, 4556, 1, 0, 0, 0, 4555, 4526, 1, 0,
		0, 0, 4555, 4529, 1, 0, 0, 0, 4556, 525, 1, 0, 0, 0, 4557, 4558, 5, 398,
		0, 0, 4558, 4561, 5, 436, 0, 0, 4559, 4560, 7, 1, 0, 0, 4560, 4562, 3,
		1006, 503, 0, 4561, 4559, 1, 0, 0, 0, 4561, 4562, 1, 0, 0, 0, 4562, 4565,
		1, 0, 0, 0, 4563, 4564, 5, 476, 0, 0, 4564, 4566, 3, 842, 421, 0, 4565,
		4563, 1, 0, 0, 0, 4565, 4566, 1, 0, 0, 0, 4566, 527, 1, 0, 0, 0, 4567,
		4569, 5, 398, 0, 0, 4568, 4570, 5, 172, 0, 0, 4569, 4568, 1, 0, 0, 0, 4569,
		4570, 1, 0, 0, 0, 4570, 4571, 1, 0, 0, 0, 4571, 4574, 5, 440, 0, 0, 4572,
		4573, 7, 1, 0, 0, 4573, 4575, 3, 1006, 503, 0, 4574, 4572, 1, 0, 0, 0,
		4574, 4575, 1, 0, 0, 0, 4575, 4580, 1, 0, 0, 0, 4576, 4577, 5, 237, 0,
		0, 4577, 4581, 3, 970, 485, 0, 4578, 4579, 5, 476, 0, 0, 4579, 4581, 3,
		842, 421, 0, 4580, 4576, 1, 0, 0, 0, 4580, 4578, 1, 0, 0, 0, 4580, 4581,
		1, 0, 0, 0, 4581, 529, 1, 0, 0, 0, 4582, 4583, 5, 398, 0, 0, 4583, 4586,
		5, 330, 0, 0, 4584, 4585, 5, 165, 0, 0, 4585, 4587, 3, 970, 485, 0, 4586,
		4584, 1, 0, 0, 0, 4586, 4587, 1, 0, 0, 0, 4587, 4590, 1, 0, 0, 0, 4588,
		4589, 5, 237, 0, 0, 4589, 4591, 3, 970, 485, 0, 4590, 4588, 1, 0, 0, 0,
		4590, 4591, 1, 0, 0, 0, 4591, 4603, 1, 0, 0, 0, 4592, 4593, 5, 398, 0,
		0, 4593, 4596, 5, 329, 0, 0, 4594, 4595, 5, 165, 0, 0, 4595, 4597, 3, 970,
		485, 0, 4596, 4594, 1, 0, 0, 0, 4596, 4597, 1, 0, 0, 0, 4597, 4600, 1,
		0, 0, 0, 4598, 4599, 5, 237, 0, 0, 4599, 4601, 3, 970, 485, 0, 4600, 4598,
		1, 0, 0, 0, 4600, 4601, 1, 0, 0, 0, 4601, 4603, 1, 0, 0, 0, 4602, 4582,
		1, 0, 0, 0, 4602, 4592, 1, 0, 0, 0, 4603, 531, 1, 0, 0, 0, 4604, 4606,
		5, 398, 0, 0, 4605, 4607, 3, 962, 481, 0, 4606, 4605, 1, 0, 0, 0, 4606,
		4607, 1, 0, 0, 0, 4607, 4608, 1, 0, 0, 0, 4608, 4613, 5, 463, 0, 0, 4609,
		4610, 5, 237, 0, 0, 4610, 4614, 3, 970, 485, 0, 4611, 4612, 5, 476, 0,
		0, 4612, 4614, 3, 842, 421, 0, 4613, 4609, 1, 0, 0, 0, 4613, 4611, 1, 0,
		0, 0, 4613, 4614, 1, 0, 0, 0, 4614, 533, 1, 0, 0, 0, 4615, 4616, 5, 398,
		0, 0, 4616, 4618, 7, 24, 0, 0, 4617, 4619, 3, 766, 383, 0, 4618, 4617,
		1, 0, 0, 0, 4618, 4619, 1, 0, 0, 0, 4619, 535, 1, 0, 0, 0, 4620, 4621,
		5, 185, 0, 0, 4621, 4622, 3, 1020, 510, 0, 4622, 537, 1, 0, 0, 0, 4623,
		4624, 5, 88, 0, 0, 4624, 4628, 5, 456, 0, 0, 4625, 4626, 5, 194, 0, 0,
		4626, 4627, 5, 278, 0, 0, 4627, 4629, 5, 145, 0, 0, 4628, 4625, 1, 0, 0,
		0, 4628, 4629, 1, 0, 0, 0, 4629, 4630, 1, 0, 0, 0, 4630, 4632, 3, 1026,
		513, 0, 4631, 4633, 3, 574, 287, 0, 4632, 4631, 1, 0, 0, 0, 4632, 4633,
		1, 0, 0, 0, 4633, 4637, 1, 0, 0, 0, 4634, 4635, 5, 115, 0, 0, 4635, 4636,
		5, 370, 0, 0, 4636, 4638, 3, 696, 348, 0, 4637, 4634, 1, 0, 0, 0, 4637,
		4638, 1, 0, 0, 0, 4638, 4640, 1, 0, 0, 0, 4639, 4641, 3, 948, 474, 0, 4640,
		4639, 1, 0, 0, 0, 4640, 4641, 1, 0, 0, 0, 4641, 539, 1, 0, 0, 0, 4642,
		4643, 5, 130, 0, 0, 4643, 4646, 5, 456, 0, 0, 4644, 4645, 5, 194, 0, 0,
		4645, 4647, 5, 145, 0, 0, 4646, 4644, 1, 0, 0, 0, 4646, 4647, 1, 0, 0,
		0, 4647, 4648, 1, 0, 0, 0, 4648, 4649, 3, 1026, 513, 0, 4649, 541, 1, 0,
		0, 0, 4650, 4651, 5, 19, 0, 0, 4651, 4654, 5, 456, 0, 0, 4652, 4653, 5,
		194, 0, 0, 4653, 4655, 5, 145, 0, 0, 4654, 4652, 1, 0, 0, 0, 4654, 4655,
		1, 0, 0, 0, 4655, 4656, 1, 0, 0, 0, 4656, 4657, 3, 1026, 513, 0, 4657,
		4658, 3, 574, 287, 0, 4658, 4684, 1, 0, 0, 0, 4659, 4660, 5, 19, 0, 0,
		4660, 4663, 5, 456, 0, 0, 4661, 4662, 5, 194, 0, 0, 4662, 4664, 5, 145,
		0, 0, 4663, 4661, 1, 0, 0, 0, 4663, 4664, 1, 0, 0, 0, 4664, 4665, 1, 0,
		0, 0, 4665, 4666, 3, 1026, 513, 0, 4666, 4667, 5, 115, 0, 0, 4667, 4671,
		5, 370, 0, 0, 4668, 4672, 5, 277, 0, 0, 4669, 4672, 5, 18, 0, 0, 4670,
		4672, 3, 696, 348, 0, 4671, 4668, 1, 0, 0, 0, 4671, 4669, 1, 0, 0, 0, 4671,
		4670, 1, 0, 0, 0, 4672, 4684, 1, 0, 0, 0, 4673, 4674, 5, 19, 0, 0, 4674,
		4677, 5, 456, 0, 0, 4675, 4676, 5, 194, 0, 0, 4676, 4678, 5, 145, 0, 0,
		4677, 4675, 1, 0, 0, 0, 4677, 4678, 1, 0, 0, 0, 4678, 4679, 1, 0, 0, 0,
		4679, 4680, 3, 1026, 513, 0, 4680, 4681, 5, 393, 0, 0, 4681, 4682, 3, 948,
		474, 0, 4682, 4684, 1, 0, 0, 0, 4683, 4650, 1, 0, 0, 0, 4683, 4659, 1,
		0, 0, 0, 4683, 4673, 1, 0, 0, 0, 4684, 543, 1, 0, 0, 0, 4685, 4686, 5,
		398, 0, 0, 4686, 4687, 7, 25, 0, 0, 4687, 545, 1, 0, 0, 0, 4688, 4689,
		5, 398, 0, 0, 4689, 4690, 5, 18, 0, 0, 4690, 4698, 5, 31, 0, 0, 4691, 4692,
		5, 398, 0, 0, 4692, 4695, 5, 31, 0, 0, 4693, 4694, 5, 165, 0, 0, 4694,
		4696, 3, 1026, 513, 0, 4695, 4693, 1, 0, 0, 0, 4695, 4696, 1, 0, 0, 0,
		4696, 4698, 1, 0, 0, 0, 4697, 4688, 1, 0, 0, 0, 4697, 4691, 1, 0, 0, 0,
		4698, 547, 1, 0, 0, 0, 4699, 4700, 5, 144, 0, 0, 4700, 4701, 5, 27, 0,
		0, 4701, 4705, 3, 1026, 513, 0, 4702, 4703, 5, 478, 0, 0, 4703, 4704, 5,
		274, 0, 0, 4704, 4706, 5, 367, 0, 0, 4705, 4702, 1, 0, 0, 0, 4705, 4706,
		1, 0, 0, 0, 4706, 549, 1, 0, 0, 0, 4707, 4708, 5, 88, 0, 0, 4708, 4712,
		5, 370, 0, 0, 4709, 4710, 5, 194, 0, 0, 4710, 4711, 5, 278, 0, 0, 4711,
		4713, 5, 145, 0, 0, 4712, 4709, 1, 0, 0, 0, 4712, 4713, 1, 0, 0, 0, 4713,
		4714, 1, 0, 0, 0, 4714, 4716, 3, 696, 348, 0, 4715, 4717, 3, 964, 482,
		0, 4716, 4715, 1, 0, 0, 0, 4716, 4717, 1, 0, 0, 0, 4717, 551, 1, 0, 0,
		0, 4718, 4719, 5, 19, 0, 0, 4719, 4722, 5, 370, 0, 0, 4720, 4721, 5, 194,
		0, 0, 4721, 4723, 5, 145, 0, 0, 4722, 4720, 1, 0, 0, 0, 4722, 4723, 1,
		0, 0, 0, 4723, 4724, 1, 0, 0, 0, 4724, 4725, 3, 696, 348, 0, 4725, 4726,
		5, 393, 0, 0, 4726, 4727, 5, 76, 0, 0, 4727, 4728, 5, 490, 0, 0, 4728,
		4729, 3, 970, 485, 0, 4729, 553, 1, 0, 0, 0, 4730, 4731, 5, 130, 0, 0,
		4731, 4734, 5, 370, 0, 0, 4732, 4733, 5, 194, 0, 0, 4733, 4735, 5, 145,
		0, 0, 4734, 4732, 1, 0, 0, 0, 4734, 4735, 1, 0, 0, 0, 4735, 4736, 1, 0,
		0, 0, 4736, 4737, 3, 696, 348, 0, 4737, 555, 1, 0, 0, 0, 4738, 4739, 5,
		398, 0, 0, 4739, 4740, 5, 371, 0, 0, 4740, 557, 1, 0, 0, 0, 4741, 4742,
		5, 176, 0, 0, 4742, 4743, 3, 1022, 511, 0, 4743, 4745, 5, 438, 0, 0, 4744,
		4746, 5, 456, 0, 0, 4745, 4744, 1, 0, 0, 0, 4745, 4746, 1, 0, 0, 0, 4746,
		4747, 1, 0, 0, 0, 4747, 4748, 3, 1026, 513, 0, 4748, 4756, 1, 0, 0, 0,
		4749, 4750, 5, 176, 0, 0, 4750, 4751, 3, 1022, 511, 0, 4751, 4752, 5, 438,
		0, 0, 4752, 4753, 5, 370, 0, 0, 4753, 4754, 3, 1020, 510, 0, 4754, 4756,
		1, 0, 0, 0, 4755, 4741, 1, 0, 0, 0, 4755, 4749, 1, 0, 0, 0, 4756, 559,
		1, 0, 0, 0, 4757, 4758, 5, 366, 0, 0, 4758, 4759, 3, 1022, 511, 0, 4759,
		4761, 5, 169, 0, 0, 4760, 4762, 5, 456, 0, 0, 4761, 4760, 1, 0, 0, 0, 4761,
		4762, 1, 0, 0, 0, 4762, 4763, 1, 0, 0, 0, 4763, 4764, 3, 1026, 513, 0,
		4764, 4772, 1, 0, 0, 0, 4765, 4766, 5, 366, 0, 0, 4766, 4767, 3, 1022,
		511, 0, 4767, 4768, 5, 169, 0, 0, 4768, 4769, 5, 370, 0, 0, 4769, 4770,
		3, 1020, 510, 0, 4770, 4772, 1, 0, 0, 0, 4771, 4757, 1, 0, 0, 0, 4771,
		4765, 1, 0, 0, 0, 4772, 561, 1, 0, 0, 0, 4773, 4774, 5, 393, 0, 0, 4774,
		4775, 5, 370, 0, 0, 4775, 4790, 5, 115, 0, 0, 4776, 4777, 5, 393, 0, 0,
		4777, 4778, 5, 370, 0, 0, 4778, 4790, 5, 277, 0, 0, 4779, 4780, 5, 393,
		0, 0, 4780, 4781, 5, 370, 0, 0, 4781, 4784, 5, 18, 0, 0, 4782, 4783, 5,
		143, 0, 0, 4783, 4785, 3, 696, 348, 0, 4784, 4782, 1, 0, 0, 0, 4784, 4785,
		1, 0, 0, 0, 4785, 4790, 1, 0, 0, 0, 4786, 4787, 5, 393, 0, 0, 4787, 4788,
		5, 370, 0, 0, 4788, 4790, 3, 696, 348, 0, 4789, 4773, 1, 0, 0, 0, 4789,
		4776, 1, 0, 0, 0, 4789, 4779, 1, 0, 0, 0, 4789, 4786, 1, 0, 0, 0, 4790,
		563, 1, 0, 0, 0, 4791, 4792, 5, 393, 0, 0, 4792, 4793, 5, 115, 0, 0, 4793,
		4797, 5, 370, 0, 0, 4794, 4798, 5, 277, 0, 0, 4795, 4798, 5, 18, 0, 0,
		4796, 4798, 3, 696, 348, 0, 4797, 4794, 1, 0, 0, 0, 4797, 4795, 1, 0, 0,
		0, 4797, 4796, 1, 0, 0, 0, 4798, 4799, 1, 0, 0, 0, 4799, 4800, 5, 438,
		0, 0, 4800, 4801, 3, 1026, 513, 0, 4801, 565, 1, 0, 0, 0, 4802, 4804, 5,
		456, 0, 0, 4803, 4802, 1, 0, 0, 0, 4803, 4804, 1, 0, 0, 0, 4804, 4805,
		1, 0, 0, 0, 4805, 4809, 3, 1026, 513, 0, 4806, 4807, 5, 370, 0, 0, 4807,
		4809, 3, 1020, 510, 0, 4808, 4803, 1, 0, 0, 0, 4808, 4806, 1, 0, 0, 0,
		4809, 567, 1, 0, 0, 0, 4810, 4811, 5, 176, 0, 0, 4811, 4812, 5, 195, 0,
		0, 4812, 4813, 5, 287, 0, 0, 4813, 4814, 5, 456, 0, 0, 4814, 4819, 3, 1026,
		513, 0, 4815, 4816, 5, 3, 0, 0, 4816, 4818, 3, 1026, 513, 0, 4817, 4815,
		1, 0, 0, 0, 4818, 4821, 1, 0, 0, 0, 4819, 4817, 1, 0, 0, 0, 4819, 4820,
		1, 0, 0, 0, 4820, 4822, 1, 0, 0, 0, 4821, 4819, 1, 0, 0, 0, 4822, 4823,
		5, 438, 0, 0, 4823, 4827, 3, 566, 283, 0, 4824, 4825, 5, 478, 0, 0, 4825,
		4826, 5, 176, 0, 0, 4826, 4828, 5, 293, 0, 0, 4827, 4824, 1, 0, 0, 0, 4827,
		4828, 1, 0, 0, 0, 4828, 4899, 1, 0, 0, 0, 4829, 4830, 5, 176, 0, 0, 4830,
		4831, 3, 582, 291, 0, 4831, 4832, 5, 287, 0, 0, 4832, 4833, 3, 578, 289,
		0, 4833, 4834, 5, 438, 0, 0, 4834, 4838, 3, 566, 283, 0, 4835, 4836, 5,
		478, 0, 0, 4836, 4837, 5, 176, 0, 0, 4837, 4839, 5, 293, 0, 0, 4838, 4835,
		1, 0, 0, 0, 4838, 4839, 1, 0, 0, 0, 4839, 4899, 1, 0, 0, 0, 4840, 4841,
		5, 176, 0, 0, 4841, 4842, 3, 582, 291, 0, 4842, 4844, 5, 287, 0, 0, 4843,
		4845, 5, 175, 0, 0, 4844, 4843, 1, 0, 0, 0, 4844, 4845, 1, 0, 0, 0, 4845,
		4846, 1, 0, 0, 0, 4846, 4847, 5, 173, 0, 0, 4847, 4848, 3, 580, 290, 0,
		4848, 4849, 5, 438, 0, 0, 4849, 4853, 3, 566, 283, 0, 4850, 4851, 5, 478,
		0, 0, 4851, 4852, 5, 176, 0, 0, 4852, 4854, 5, 293, 0, 0, 4853, 4850, 1,
		0, 0, 0, 4853, 4854, 1, 0, 0, 0, 4854, 4899, 1, 0, 0, 0, 4855, 4856, 5,
		176, 0, 0, 4856, 4857, 3, 582, 291, 0, 4857, 4858, 5, 287, 0, 0, 4858,
		4859, 5, 416, 0, 0, 4859, 4860, 5, 438, 0, 0, 4860, 4864, 3, 566, 283,
		0, 4861, 4862, 5, 478, 0, 0, 4862, 4863, 5, 176, 0, 0, 4863, 4865, 5, 293,
		0, 0, 4864, 4861, 1, 0, 0, 0, 4864, 4865, 1, 0, 0, 0, 4865, 4899, 1, 0,
		0, 0, 4866, 4867, 5, 176, 0, 0, 4867, 4868, 3, 582, 291, 0, 4868, 4869,
		5, 287, 0, 0, 4869, 4870, 3, 586, 293, 0, 4870, 4871, 3, 578, 289, 0, 4871,
		4872, 5, 438, 0, 0, 4872, 4876, 3, 566, 283, 0, 4873, 4874, 5, 478, 0,
		0, 4874, 4875, 5, 176, 0, 0, 4875, 4877, 5, 293, 0, 0, 4876, 4873, 1, 0,
		0, 0, 4876, 4877, 1, 0, 0, 0, 4877, 4899, 1, 0, 0, 0, 4878, 4879, 5, 176,
		0, 0, 4879, 4880, 3, 582, 291, 0, 4880, 4881, 5, 287, 0, 0, 4881, 4882,
		5, 18, 0, 0, 4882, 4889, 3, 588, 294, 0, 4883, 4884, 5, 199, 0, 0, 4884,
		4885, 5, 18, 0, 0, 4885, 4890, 5, 103, 0, 0, 4886, 4887, 5, 199, 0, 0,
		4887, 4888, 5, 102, 0, 0, 4888, 4890, 3, 1020, 510, 0, 4889, 4883, 1, 0,
		0, 0, 4889, 4886, 1, 0, 0, 0, 4889, 4890, 1, 0, 0, 0, 4890, 4891, 1, 0,
		0, 0, 4891, 4892, 5, 438, 0, 0, 4892, 4896, 3, 566, 283, 0, 4893, 4894,
		5, 478, 0, 0, 4894, 4895, 5, 176, 0, 0, 4895, 4897, 5, 293, 0, 0, 4896,
		4893, 1, 0, 0, 0, 4896, 4897, 1, 0, 0, 0, 4897, 4899, 1, 0, 0, 0, 4898,
		4810, 1, 0, 0, 0, 4898, 4829, 1, 0, 0, 0, 4898, 4840, 1, 0, 0, 0, 4898,
		4855, 1, 0, 0, 0, 4898, 4866, 1, 0, 0, 0, 4898, 4878, 1, 0, 0, 0, 4899,
		569, 1, 0, 0, 0, 4900, 4901, 5, 366, 0, 0, 4901, 4902, 5, 195, 0, 0, 4902,
		4903, 5, 287, 0, 0, 4903, 4904, 5, 456, 0, 0, 4904, 4909, 3, 1026, 513,
		0, 4905, 4906, 5, 3, 0, 0, 4906, 4908, 3, 1026, 513, 0, 4907, 4905, 1,
		0, 0, 0, 4908, 4911, 1, 0, 0, 0, 4909, 4907, 1, 0, 0, 0, 4909, 4910, 1,
		0, 0, 0, 4910, 4912, 1, 0, 0, 0, 4911, 4909, 1, 0, 0, 0, 4912, 4913, 5,
		169, 0, 0, 4913, 4914, 3, 566, 283, 0, 4914, 4965, 1, 0, 0, 0, 4915, 4916,
		5, 366, 0, 0, 4916, 4917, 3, 582, 291, 0, 4917, 4918, 5, 287, 0, 0, 4918,
		4919, 3, 578, 289, 0, 4919, 4920, 5, 169, 0, 0, 4920, 4921, 3, 566, 283,
		0, 4921, 4965, 1, 0, 0, 0, 4922, 4923, 5, 366, 0, 0, 4923, 4924, 3, 582,
		291, 0, 4924, 4926, 5, 287, 0, 0, 4925, 4927, 5, 175, 0, 0, 4926, 4925,
		1, 0, 0, 0, 4926, 4927, 1, 0, 0, 0, 4927, 4928, 1, 0, 0, 0, 4928, 4929,
		5, 173, 0, 0, 4929, 4930, 3, 580, 290, 0, 4930, 4931, 5, 169, 0, 0, 4931,
		4932, 3, 566, 283, 0, 4932, 4965, 1, 0, 0, 0, 4933, 4934, 5, 366, 0, 0,
		4934, 4935, 3, 582, 291, 0, 4935, 4936, 5, 287, 0, 0, 4936, 4937, 5, 416,
		0, 0, 4937, 4938, 5, 169, 0, 0, 4938, 4939, 3, 566, 283, 0, 4939, 4965,
		1, 0, 0, 0, 4940, 4941, 5, 366, 0, 0, 4941, 4942, 3, 582, 291, 0, 4942,
		4943, 5, 287, 0, 0, 4943, 4944, 3, 586, 293, 0, 4944, 4945, 3, 578, 289,
		0, 4945, 4946, 5, 169, 0, 0, 4946, 4947, 3, 566, 283, 0, 4947, 4965, 1,
		0, 0, 0, 4948, 4949, 5, 366, 0, 0, 4949, 4950, 3, 582, 291, 0, 4950, 4951,
		5, 287, 0, 0, 4951, 4952, 5, 18, 0, 0, 4952, 4959, 3, 588, 294, 0, 4953,
		4954, 5, 199, 0, 0, 4954, 4955, 5, 18, 0, 0, 4955, 4960, 5, 103, 0, 0,
		4956, 4957, 5, 199, 0, 0, 4957, 4958, 5, 102, 0, 0, 4958, 4960, 3, 1020,
		510, 0, 4959, 4953, 1, 0, 0, 0, 4959, 4956, 1, 0, 0, 0, 4959, 4960, 1,
		0, 0, 0, 4960, 4961, 1, 0, 0, 0, 4961, 4962, 5, 169, 0, 0, 4962, 4963,
		3, 566, 283, 0, 4963, 4965, 1, 0, 0, 0, 4964, 4900, 1, 0, 0, 0, 4964, 4915,
		1, 0, 0, 0, 4964, 4922, 1, 0, 0, 0, 4964, 4933, 1, 0, 0, 0, 4964, 4940,
		1, 0, 0, 0, 4964, 4948, 1, 0, 0, 0, 4965, 571, 1, 0, 0, 0, 4966, 4967,
		5, 398, 0, 0, 4967, 4981, 5, 177, 0, 0, 4968, 4969, 5, 398, 0, 0, 4969,
		4970, 5, 177, 0, 0, 4970, 4972, 5, 165, 0, 0, 4971, 4973, 5, 456, 0, 0,
		4972, 4971, 1, 0, 0, 0, 4972, 4973, 1, 0, 0, 0, 4973, 4974, 1, 0, 0, 0,
		4974, 4981, 3, 1026, 513, 0, 4975, 4976, 5, 398, 0, 0, 4976, 4977, 5, 177,
		0, 0, 4977, 4978, 5, 165, 0, 0, 4978, 4979, 5, 370, 0, 0, 4979, 4981, 3,
		1020, 510, 0, 4980, 4966, 1, 0, 0, 0, 4980, 4968, 1, 0, 0, 0, 4980, 4975,
		1, 0, 0, 0, 4981, 573, 1, 0, 0, 0, 4982, 4983, 5, 193, 0, 0, 4983, 4985,
		5, 55, 0, 0, 4984, 4986, 5, 302, 0, 0, 4985, 4984, 1, 0, 0, 0, 4985, 4986,
		1, 0, 0, 0, 4986, 4987, 1, 0, 0, 0, 4987, 4996, 3, 970, 485, 0, 4988, 4989,
		5, 193, 0, 0, 4989, 4990, 5, 478, 0, 0, 4990, 4993, 3, 1020, 510, 0, 4991,
		4992, 7, 26, 0, 0, 4992, 4994, 3, 970, 485, 0, 4993, 4991, 1, 0, 0, 0,
		4993, 4994, 1, 0, 0, 0, 4994, 4996, 1, 0, 0, 0, 4995, 4982, 1, 0, 0, 0,
		4995, 4988, 1, 0, 0, 0, 4996, 575, 1, 0, 0, 0, 4997, 5000, 3, 1024, 512,
		0, 4998, 4999, 5, 1, 0, 0, 4999, 5001, 3, 1024, 512, 0, 5000, 4998, 1,
		0, 0, 0, 5000, 5001, 1, 0, 0, 0, 5001, 577, 1, 0, 0, 0, 5002, 5007, 3,
		576, 288, 0, 5003, 5004, 5, 3, 0, 0, 5004, 5006, 3, 576, 288, 0, 5005,
		5003, 1, 0, 0, 0, 5006, 5009, 1, 0, 0, 0, 5007, 5005, 1, 0, 0, 0, 5007,
		5008, 1, 0, 0, 0, 5008, 579, 1, 0, 0, 0, 5009, 5007, 1, 0, 0, 0, 5010,
		5011, 3, 1006, 503, 0, 5011, 5012, 5, 2, 0, 0, 5012, 5013, 3, 458, 229,
		0, 5013, 5022, 5, 4, 0, 0, 5014, 5015, 5, 3, 0, 0, 5015, 5016, 3, 1006,
		503, 0, 5016, 5017, 5, 2, 0, 0, 5017, 5018, 3, 458, 229, 0, 5018, 5019,
		5, 4, 0, 0, 5019, 5021, 1, 0, 0, 0, 5020, 5014, 1, 0, 0, 0, 5021, 5024,
		1, 0, 0, 0, 5022, 5020, 1, 0, 0, 0, 5022, 5023, 1, 0, 0, 0, 5023, 581,
		1, 0, 0, 0, 5024, 5022, 1, 0, 0, 0, 5025, 5030, 3, 584, 292, 0, 5026, 5027,
		5, 3, 0, 0, 5027, 5029, 3, 584, 292, 0, 5028, 5026, 1, 0, 0, 0, 5029, 5032,
		1, 0, 0, 0, 5030, 5028, 1, 0, 0, 0, 5030, 5031, 1, 0, 0, 0, 5031, 583,
		1, 0, 0, 0, 5032, 5030, 1, 0, 0, 0, 5033, 5035, 5, 18, 0, 0, 5034, 5036,
		5, 322, 0, 0, 5035, 5034, 1, 0, 0, 0, 5035, 5036, 1, 0, 0, 0, 5036, 5077,
		1, 0, 0, 0, 5037, 5077, 5, 19, 0, 0, 5038, 5077, 5, 23, 0, 0, 5039, 5077,
		5, 47, 0, 0, 5040, 5058, 5, 88, 0, 0, 5041, 5059, 5, 102, 0, 0, 5042, 5059,
		5, 420, 0, 0, 5043, 5059, 5, 467, 0, 0, 5044, 5059, 5, 173, 0, 0, 5045,
		5046, 5, 175, 0, 0, 5046, 5059, 5, 173, 0, 0, 5047, 5048, 5, 254, 0, 0,
		5048, 5059, 5, 467, 0, 0, 5049, 5059, 5, 358, 0, 0, 5050, 5051, 5, 358,
		0, 0, 5051, 5059, 5, 178, 0, 0, 5052, 5053, 5, 148, 0, 0, 5053, 5059, 5,
		60, 0, 0, 5054, 5055, 5, 408, 0, 0, 5055, 5059, 5, 469, 0, 0, 5056, 5059,
		5, 471, 0, 0, 5057, 5059, 5, 312, 0, 0, 5058, 5041, 1, 0, 0, 0, 5058, 5042,
		1, 0, 0, 0, 5058, 5043, 1, 0, 0, 0, 5058, 5044, 1, 0, 0, 0, 5058, 5045,
		1, 0, 0, 0, 5058, 5047, 1, 0, 0, 0, 5058, 5049, 1, 0, 0, 0, 5058, 5050,
		1, 0, 0, 0, 5058, 5052, 1, 0, 0, 0, 5058, 5054, 1, 0, 0, 0, 5058, 5056,
		1, 0, 0, 0, 5058, 5057, 1, 0, 0, 0, 5059, 5077, 1, 0, 0, 0, 5060, 5077,
		5, 116, 0, 0, 5061, 5077, 5, 130, 0, 0, 5062, 5077, 5, 147, 0, 0, 5063,
		5077, 5, 155, 0, 0, 5064, 5077, 5, 195, 0, 0, 5065, 5077, 5, 207, 0, 0,
		5066, 5077, 5, 176, 0, 0, 5067, 5077, 5, 275, 0, 0, 5068, 5077, 5, 290,
		0, 0, 5069, 5077, 5, 387, 0, 0, 5070, 5077, 5, 310, 0, 0, 5071, 5077, 5,
		356, 0, 0, 5072, 5077, 5, 345, 0, 0, 5073, 5077, 5, 388, 0, 0, 5074, 5077,
		5, 453, 0, 0, 5075, 5077, 5, 454, 0, 0, 5076, 5033, 1, 0, 0, 0, 5076, 5037,
		1, 0, 0, 0, 5076, 5038, 1, 0, 0, 0, 5076, 5039, 1, 0, 0, 0, 5076, 5040,
		1, 0, 0, 0, 5076, 5060, 1, 0, 0, 0, 5076, 5061, 1, 0, 0, 0, 5076, 5062,
		1, 0, 0, 0, 5076, 5063, 1, 0, 0, 0, 5076, 5064, 1, 0, 0, 0, 5076, 5065,
		1, 0, 0, 0, 5076, 5066, 1, 0, 0, 0, 5076, 5067, 1, 0, 0, 0, 5076, 5068,
		1, 0, 0, 0, 5076, 5069, 1, 0, 0, 0, 5076, 5070, 1, 0, 0, 0, 5076, 5071,
		1, 0, 0, 0, 5076, 5072, 1, 0, 0, 0, 5076, 5073, 1, 0, 0, 0, 5076, 5074,
		1, 0, 0, 0, 5076, 5075, 1, 0, 0, 0, 5077, 585, 1, 0, 0, 0, 5078, 5093,
		5, 60, 0, 0, 5079, 5093, 5, 102, 0, 0, 5080, 5081, 5, 254, 0, 0, 5081,
		5093, 5, 467, 0, 0, 5082, 5093, 5, 358, 0, 0, 5083, 5084, 5, 358, 0, 0,
		5084, 5093, 5, 178, 0, 0, 5085, 5086, 5, 408, 0, 0, 5086, 5093, 5, 469,
		0, 0, 5087, 5093, 5, 416, 0, 0, 5088, 5093, 5, 420, 0, 0, 5089, 5093, 5,
		467, 0, 0, 5090, 5093, 5, 471, 0, 0, 5091, 5093, 5, 312, 0, 0, 5092, 5078,
		1, 0, 0, 0, 5092, 5079, 1, 0, 0, 0, 5092, 5080, 1, 0, 0, 0, 5092, 5082,
		1, 0, 0, 0, 5092, 5083, 1, 0, 0, 0, 5092, 5085, 1, 0, 0, 0, 5092, 5087,
		1, 0, 0, 0, 5092, 5088, 1, 0, 0, 0, 5092, 5089, 1, 0, 0, 0, 5092, 5090,
		1, 0, 0, 0, 5092, 5091, 1, 0, 0, 0, 5093, 587, 1, 0, 0, 0, 5094, 5113,
		5, 61, 0, 0, 5095, 5113, 5, 103, 0, 0, 5096, 5113, 5, 174, 0, 0, 5097,
		5098, 5, 175, 0, 0, 5098, 5113, 5, 174, 0, 0, 5099, 5100, 5, 254, 0, 0,
		5100, 5113, 5, 468, 0, 0, 5101, 5113, 5, 316, 0, 0, 5102, 5113, 5, 359,
		0, 0, 5103, 5104, 5, 358, 0, 0, 5104, 5113, 5, 179, 0, 0, 5105, 5106, 5,
		408, 0, 0, 5106, 5113, 5, 470, 0, 0, 5107, 5113, 5, 421, 0, 0, 5108, 5113,
		5, 457, 0, 0, 5109, 5113, 5, 468, 0, 0, 5110, 5113, 5, 472, 0, 0, 5111,
		5113, 5, 313, 0, 0, 5112, 5094, 1, 0, 0, 0, 5112, 5095, 1, 0, 0, 0, 5112,
		5096, 1, 0, 0, 0, 5112, 5097, 1, 0, 0, 0, 5112, 5099, 1, 0, 0, 0, 5112,
		5101, 1, 0, 0, 0, 5112, 5102, 1, 0, 0, 0, 5112, 5103, 1, 0, 0, 0, 5112,
		5105, 1, 0, 0, 0, 5112, 5107, 1, 0, 0, 0, 5112, 5108, 1, 0, 0, 0, 5112,
		5109, 1, 0, 0, 0, 5112, 5110, 1, 0, 0, 0, 5112, 5111, 1, 0, 0, 0, 5113,
		589, 1, 0, 0, 0, 5114, 5115, 5, 88, 0, 0, 5115, 5116, 5, 387, 0, 0, 5116,
		5117, 5, 210, 0, 0, 5117, 5118, 3, 1012, 506, 0, 5118, 5119, 3, 948, 474,
		0, 5119, 591, 1, 0, 0, 0, 5120, 5121, 5, 19, 0, 0, 5121, 5122, 5, 387,
		0, 0, 5122, 5123, 5, 210, 0, 0, 5123, 5124, 3, 1012, 506, 0, 5124, 5125,
		5, 393, 0, 0, 5125, 5126, 3, 952, 476, 0, 5126, 593, 1, 0, 0, 0, 5127,
		5128, 5, 130, 0, 0, 5128, 5129, 5, 387, 0, 0, 5129, 5130, 5, 210, 0, 0,
		5130, 5131, 3, 1012, 506, 0, 5131, 595, 1, 0, 0, 0, 5132, 5133, 5, 398,
		0, 0, 5133, 5134, 5, 387, 0, 0, 5134, 5135, 5, 211, 0, 0, 5135, 597, 1,
		0, 0, 0, 5136, 5137, 5, 398, 0, 0, 5137, 5138, 5, 88, 0, 0, 5138, 5139,
		5, 387, 0, 0, 5139, 5140, 5, 210, 0, 0, 5140, 5141, 3, 1012, 506, 0, 5141,
		599, 1, 0, 0, 0, 5142, 5143, 5, 88, 0, 0, 5143, 5144, 5, 178, 0, 0, 5144,
		5148, 5, 331, 0, 0, 5145, 5146, 5, 194, 0, 0, 5146, 5147, 5, 278, 0, 0,
		5147, 5149, 5, 145, 0, 0, 5148, 5145, 1, 0, 0, 0, 5148, 5149, 1, 0, 0,
		0, 5149, 5150, 1, 0, 0, 0, 5150, 5151, 3, 1012, 506, 0, 5151, 5152, 3,
		948, 474, 0, 5152, 601, 1, 0, 0, 0, 5153, 5154, 5, 130, 0, 0, 5154, 5155,
		5, 178, 0, 0, 5155, 5158, 5, 331, 0, 0, 5156, 5157, 5, 194, 0, 0, 5157,
		5159, 5, 145, 0, 0, 5158, 5156, 1, 0, 0, 0, 5158, 5159, 1, 0, 0, 0, 5159,
		5160, 1, 0, 0, 0, 5160, 5161, 3, 1012, 506, 0, 5161, 603, 1, 0, 0, 0, 5162,
		5163, 5, 398, 0, 0, 5163, 5164, 5, 178, 0, 0, 5164, 5165, 5, 332, 0, 0,
		5165, 605, 1, 0, 0, 0, 5166, 5167, 5, 398, 0, 0, 5167, 5168, 5, 88, 0,
		0, 5168, 5169, 5, 178, 0, 0, 5169, 5170, 5, 331, 0, 0, 5170, 5171, 3, 1012,
		506, 0, 5171, 607, 1, 0, 0, 0, 5172, 5179, 5, 37, 0, 0, 5173, 5174, 5,
		18, 0, 0, 5174, 5175, 5, 148, 0, 0, 5175, 5180, 5, 61, 0, 0, 5176, 5177,
		5, 148, 0, 0, 5177, 5178, 7, 27, 0, 0, 5178, 5180, 3, 1018, 509, 0, 5179,
		5173, 1, 0, 0, 0, 5179, 5176, 1, 0, 0, 0, 5179, 5180, 1, 0, 0, 0, 5180,
		5183, 1, 0, 0, 0, 5181, 5182, 5, 102, 0, 0, 5182, 5184, 3, 1012, 506, 0,
		5183, 5181, 1, 0, 0, 0, 5183, 5184, 1, 0, 0, 0, 5184, 5185, 1, 0, 0, 0,
		5185, 5186, 5, 400, 0, 0, 5186, 5187, 3, 1006, 503, 0, 5187, 5188, 5, 438,
		0, 0, 5188, 5201, 3, 1012, 506, 0, 5189, 5190, 5, 287, 0, 0, 5190, 5191,
		5, 2, 0, 0, 5191, 5196, 3, 888, 444, 0, 5192, 5193, 5, 3, 0, 0, 5193, 5195,
		3, 888, 444, 0, 5194, 5192, 1, 0, 0, 0, 5195, 5198, 1, 0, 0, 0, 5196, 5194,
		1, 0, 0, 0, 5196, 5197, 1, 0, 0, 0, 5197, 5199, 1, 0, 0, 0, 5198, 5196,
		1, 0, 0, 0, 5199, 5200, 5, 4, 0, 0, 5200, 5202, 1, 0, 0, 0, 5201, 5189,
		1, 0, 0, 0, 5201, 5202, 1, 0, 0, 0, 5202, 5205, 1, 0, 0, 0, 5203, 5204,
		5, 329, 0, 0, 5204, 5206, 3, 952, 476, 0, 5205, 5203, 1, 0, 0, 0, 5205,
		5206, 1, 0, 0, 0, 5206, 609, 1, 0, 0, 0, 5207, 5208, 5, 57, 0, 0, 5208,
		5214, 5, 37, 0, 0, 5209, 5210, 7, 1, 0, 0, 5210, 5215, 3, 1012, 506, 0,
		5211, 5212, 5, 165, 0, 0, 5212, 5213, 5, 148, 0, 0, 5213, 5215, 5, 60,
		0, 0, 5214, 5209, 1, 0, 0, 0, 5214, 5211, 1, 0, 0, 0, 5214, 5215, 1, 0,
		0, 0, 5215, 611, 1, 0, 0, 0, 5216, 5217, 5, 398, 0, 0, 5217, 5220, 5, 37,
		0, 0, 5218, 5219, 7, 1, 0, 0, 5219, 5221, 3, 1012, 506, 0, 5220, 5218,
		1, 0, 0, 0, 5220, 5221, 1, 0, 0, 0, 5221, 613, 1, 0, 0, 0, 5222, 5223,
		5, 360, 0, 0, 5223, 5224, 5, 400, 0, 0, 5224, 5225, 3, 1006, 503, 0, 5225,
		5226, 5, 169, 0, 0, 5226, 5233, 3, 1012, 506, 0, 5227, 5228, 5, 18, 0,
		0, 5228, 5229, 5, 148, 0, 0, 5229, 5234, 5, 61, 0, 0, 5230, 5231, 5, 148,
		0, 0, 5231, 5232, 7, 27, 0, 0, 5232, 5234, 3, 1016, 508, 0, 5233, 5227,
		1, 0, 0, 0, 5233, 5230, 1, 0, 0, 0, 5233, 5234, 1, 0, 0, 0, 5234, 5241,
		1, 0, 0, 0, 5235, 5236, 5, 102, 0, 0, 5236, 5239, 3, 1012, 506, 0, 5237,
		5238, 5, 27, 0, 0, 5238, 5240, 3, 1012, 506, 0, 5239, 5237, 1, 0, 0, 0,
		5239, 5240, 1, 0, 0, 0, 5240, 5242, 1, 0, 0, 0, 5241, 5235, 1, 0, 0, 0,
		5241, 5242, 1, 0, 0, 0, 5242, 5255, 1, 0, 0, 0, 5243, 5244, 5, 287, 0,
		0, 5244, 5245, 5, 2, 0, 0, 5245, 5250, 3, 888, 444, 0, 5246, 5247, 5, 3,
		0, 0, 5247, 5249, 3, 888, 444, 0, 5248, 5246, 1, 0, 0, 0, 5249, 5252, 1,
		0, 0, 0, 5250, 5248, 1, 0, 0, 0, 5250, 5251, 1, 0, 0, 0, 5251, 5253, 1,
		0, 0, 0, 5252, 5250, 1, 0, 0, 0, 5253, 5254, 5, 4, 0, 0, 5254, 5256, 1,
		0, 0, 0, 5255, 5243, 1, 0, 0, 0, 5255, 5256, 1, 0, 0, 0, 5256, 5259, 1,
		0, 0, 0, 5257, 5258, 5, 329, 0, 0, 5258, 5260, 3, 952, 476, 0, 5259, 5257,
		1, 0, 0, 0, 5259, 5260, 1, 0, 0, 0, 5260, 615, 1, 0, 0, 0, 5261, 5262,
		5, 57, 0, 0, 5262, 5268, 5, 360, 0, 0, 5263, 5264, 7, 1, 0, 0, 5264, 5269,
		3, 1012, 506, 0, 5265, 5266, 5, 165, 0, 0, 5266, 5267, 5, 148, 0, 0, 5267,
		5269, 5, 60, 0, 0, 5268, 5263, 1, 0, 0, 0, 5268, 5265, 1, 0, 0, 0, 5268,
		5269, 1, 0, 0, 0, 5269, 617, 1, 0, 0, 0, 5270, 5271, 5, 398, 0, 0, 5271,
		5274, 5, 360, 0, 0, 5272, 5273, 7, 1, 0, 0, 5273, 5275, 3, 1012, 506, 0,
		5274, 5272, 1, 0, 0, 0, 5274, 5275, 1, 0, 0, 0, 5275, 5278, 1, 0, 0, 0,
		5276, 5277, 5, 476, 0, 0, 5277, 5279, 3, 842, 421, 0, 5278, 5276, 1, 0,
		0, 0, 5278, 5279, 1, 0, 0, 0, 5279, 619, 1, 0, 0, 0, 5280, 5281, 5, 398,
		0, 0, 5281, 5282, 5, 400, 0, 0, 5282, 5283, 5, 287, 0, 0, 5283, 5286, 3,
		1012, 506, 0, 5284, 5285, 5, 476, 0, 0, 5285, 5287, 3, 842, 421, 0, 5286,
		5284, 1, 0, 0, 0, 5286, 5287, 1, 0, 0, 0, 5287, 621, 1, 0, 0, 0, 5288,
		5291, 5, 88, 0, 0, 5289, 5290, 5, 342, 0, 0, 5290, 5292, 5, 288, 0, 0,
		5291, 5289, 1, 0, 0, 0, 5291, 5292, 1, 0, 0, 0, 5292, 5293, 1, 0, 0, 0,
		5293, 5294, 5, 356, 0, 0, 5294, 5295, 3, 1012, 506, 0, 5295, 5296, 5, 478,
		0, 0, 5296, 5298, 5, 52, 0, 0, 5297, 5299, 3, 1020, 510, 0, 5298, 5297,
		1, 0, 0, 0, 5298, 5299, 1, 0, 0, 0, 5299, 5300, 1, 0, 0, 0, 5300, 5301,
		5, 287, 0, 0, 5301, 5302, 5, 244, 0, 0, 5302, 5305, 3, 970, 485, 0, 5303,
		5304, 5, 329, 0, 0, 5304, 5306, 3, 952, 476, 0, 5305, 5303, 1, 0, 0, 0,
		5305, 5306, 1, 0, 0, 0, 5306, 623, 1, 0, 0, 0, 5307, 5308, 5, 130, 0, 0,
		5308, 5309, 5, 356, 0, 0, 5309, 5310, 3, 1012, 506, 0, 5310, 625, 1, 0,
		0, 0, 5311, 5312, 5, 13, 0, 0, 5312, 5313, 5, 402, 0, 0, 5313, 5314, 3,
		970, 485, 0, 5314, 627, 1, 0, 0, 0, 5315, 5316, 5, 116, 0, 0, 5316, 5317,
		5, 402, 0, 0, 5317, 5322, 5, 516, 0, 0, 5318, 5319, 5, 3, 0, 0, 5319, 5321,
		5, 516, 0, 0, 5320, 5318, 1, 0, 0, 0, 5321, 5324, 1, 0, 0, 0, 5322, 5320,
		1, 0, 0, 0, 5322, 5323, 1, 0, 0, 0, 5323, 629, 1, 0, 0, 0, 5324, 5322,
		1, 0, 0, 0, 5325, 5326, 5, 398, 0, 0, 5326, 5327, 5, 402, 0, 0, 5327, 631,
		1, 0, 0, 0, 5328, 5329, 5, 398, 0, 0, 5329, 5330, 5, 477, 0, 0, 5330, 633,
		1, 0, 0, 0, 5331, 5332, 5, 13, 0, 0, 5332, 5333, 5, 35, 0, 0, 5333, 5334,
		5, 47, 0, 0, 5334, 5339, 5, 516, 0, 0, 5335, 5336, 5, 3, 0, 0, 5336, 5338,
		5, 516, 0, 0, 5337, 5335, 1, 0, 0, 0, 5338, 5341, 1, 0, 0, 0, 5339, 5337,
		1, 0, 0, 0, 5339, 5340, 1, 0, 0, 0, 5340, 635, 1, 0, 0, 0, 5341, 5339,
		1, 0, 0, 0, 5342, 5343, 5, 116, 0, 0, 5343, 5344, 5, 35, 0, 0, 5344, 5345,
		5, 47, 0, 0, 5345, 5350, 5, 516, 0, 0, 5346, 5347, 5, 3, 0, 0, 5347, 5349,
		5, 516, 0, 0, 5348, 5346, 1, 0, 0, 0, 5349, 5352, 1, 0, 0, 0, 5350, 5348,
		1, 0, 0, 0, 5350, 5351, 1, 0, 0, 0, 5351, 637, 1, 0, 0, 0, 5352, 5350,
		1, 0, 0, 0, 5353, 5354, 5, 398, 0, 0, 5354, 5355, 5, 35, 0, 0, 5355, 5356,
		5, 47, 0, 0, 5356, 639, 1, 0, 0, 0, 5357, 5358, 3, 1024, 512, 0, 5358,
		5359, 5, 1, 0, 0, 5359, 5360, 3, 1024, 512, 0, 5360, 5361, 5, 1, 0, 0,
		5361, 5362, 3, 1024, 512, 0, 5362, 641, 1, 0, 0, 0, 5363, 5364, 5, 88,
		0, 0, 5364, 5365, 5, 101, 0, 0, 5365, 5366, 5, 378, 0, 0, 5366, 5369, 3,
		640, 320, 0, 5367, 5368, 5, 476, 0, 0, 5368, 5370, 3, 842, 421, 0, 5369,
		5367, 1, 0, 0, 0, 5369, 5370, 1, 0, 0, 0, 5370, 5371, 1, 0, 0, 0, 5371,
		5372, 5, 321, 0, 0, 5372, 5374, 5, 490, 0, 0, 5373, 5375, 5, 499, 0, 0,
		5374, 5373, 1, 0, 0, 0, 5374, 5375, 1, 0, 0, 0, 5375, 5376, 1, 0, 0, 0,
		5376, 5378, 5, 516, 0, 0, 5377, 5379, 3, 948, 474, 0, 5378, 5377, 1, 0,
		0, 0, 5378, 5379, 1, 0, 0, 0, 5379, 643, 1, 0, 0, 0, 5380, 5381, 5, 398,
		0, 0, 5381, 5382, 5, 101, 0, 0, 5382, 5383, 5, 379, 0, 0, 5383, 645, 1,
		0, 0, 0, 5384, 5385, 5, 130, 0, 0, 5385, 5386, 5, 101, 0, 0, 5386, 5387,
		5, 378, 0, 0, 5387, 5388, 5, 516, 0, 0, 5388, 647, 1, 0, 0, 0, 5389, 5390,
		5, 69, 0, 0, 5390, 5391, 5, 101, 0, 0, 5391, 5392, 5, 379, 0, 0, 5392,
		649, 1, 0, 0, 0, 5393, 5394, 5, 56, 0, 0, 5394, 5395, 5, 388, 0, 0, 5395,
		5400, 3, 780, 390, 0, 5396, 5397, 5, 3, 0, 0, 5397, 5399, 3, 780, 390,
		0, 5398, 5396, 1, 0, 0, 0, 5399, 5402, 1, 0, 0, 0, 5400, 5398, 1, 0, 0,
		0, 5400, 5401, 1, 0, 0, 0, 5401, 5403, 1, 0, 0, 0, 5402, 5400, 1, 0, 0,
		0, 5403, 5404, 5, 169, 0, 0, 5404, 5407, 3, 1006, 503, 0, 5405, 5406, 5,
		476, 0, 0, 5406, 5408, 3, 842, 421, 0, 5407, 5405, 1, 0, 0, 0, 5407, 5408,
		1, 0, 0, 0, 5408, 5410, 1, 0, 0, 0, 5409, 5411, 3, 948, 474, 0, 5410, 5409,
		1, 0, 0, 0, 5410, 5411, 1, 0, 0, 0, 5411, 651, 1, 0, 0, 0, 5412, 5413,
		5, 147, 0, 0, 5413, 5414, 5, 420, 0, 0, 5414, 5416, 3, 890, 445, 0, 5415,
		5417, 3, 814, 407, 0, 5416, 5415, 1, 0, 0, 0, 5416, 5417, 1, 0, 0, 0, 5417,
		5418, 1, 0, 0, 0, 5418, 5419, 5, 438, 0, 0, 5419, 5423, 3, 970, 485, 0,
		5420, 5421, 5, 478, 0, 0, 5421, 5422, 7, 12, 0, 0, 5422, 5424, 5, 266,
		0, 0, 5423, 5420, 1, 0, 0, 0, 5423, 5424, 1, 0, 0, 0, 5424, 5426, 1, 0,
		0, 0, 5425, 5427, 3, 948, 474, 0, 5426, 5425, 1, 0, 0, 0, 5426, 5427, 1,
		0, 0, 0, 5427, 5429, 1, 0, 0, 0, 5428, 5430, 3, 470, 235, 0, 5429, 5428,
		1, 0, 0, 0, 5429, 5430, 1, 0, 0, 0, 5430, 653, 1, 0, 0, 0, 5431, 5432,
		5, 57, 0, 0, 5432, 5435, 5, 147, 0, 0, 5433, 5434, 7, 1, 0, 0, 5434, 5436,
		3, 1006, 503, 0, 5435, 5433, 1, 0, 0, 0, 5435, 5436, 1, 0, 0, 0, 5436,
		5441, 1, 0, 0, 0, 5437, 5438, 5, 237, 0, 0, 5438, 5442, 3, 970, 485, 0,
		5439, 5440, 5, 476, 0, 0, 5440, 5442, 3, 842, 421, 0, 5441, 5437, 1, 0,
		0, 0, 5441, 5439, 1, 0, 0, 0, 5441, 5442, 1, 0, 0, 0, 5442, 655, 1, 0,
		0, 0, 5443, 5444, 5, 398, 0, 0, 5444, 5447, 5, 147, 0, 0, 5445, 5446, 7,
		1, 0, 0, 5446, 5448, 3, 1006, 503, 0, 5447, 5445, 1, 0, 0, 0, 5447, 5448,
		1, 0, 0, 0, 5448, 5453, 1, 0, 0, 0, 5449, 5450, 5, 237, 0, 0, 5450, 5454,
		3, 970, 485, 0, 5451, 5452, 5, 476, 0, 0, 5452, 5454, 3, 842, 421, 0, 5453,
		5449, 1, 0, 0, 0, 5453, 5451, 1, 0, 0, 0, 5453, 5454, 1, 0, 0, 0, 5454,
		5465, 1, 0, 0, 0, 5455, 5456, 5, 295, 0, 0, 5456, 5457, 5, 55, 0, 0, 5457,
		5462, 3, 762, 381, 0, 5458, 5459, 5, 3, 0, 0, 5459, 5461, 3, 762, 381,
		0, 5460, 5458, 1, 0, 0, 0, 5461, 5464, 1, 0, 0, 0, 5462, 5460, 1, 0, 0,
		0, 5462, 5463, 1, 0, 0, 0, 5463, 5466, 1, 0, 0, 0, 5464, 5462, 1, 0, 0,
		0, 5465, 5455, 1, 0, 0, 0, 5465, 5466, 1, 0, 0, 0, 5466, 5468, 1, 0, 0,
		0, 5467, 5469, 3, 766, 383, 0, 5468, 5467, 1, 0, 0, 0, 5468, 5469, 1, 0,
		0, 0, 5469, 657, 1, 0, 0, 0, 5470, 5471, 5, 206, 0, 0, 5471, 5472, 5, 310,
		0, 0, 5472, 5473, 5, 169, 0, 0, 5473, 5475, 3, 1020, 510, 0, 5474, 5476,
		3, 948, 474, 0, 5475, 5474, 1, 0, 0, 0, 5475, 5476, 1, 0, 0, 0, 5476, 659,
		1, 0, 0, 0, 5477, 5478, 5, 450, 0, 0, 5478, 5479, 5, 310, 0, 0, 5479, 5480,
		3, 1020, 510, 0, 5480, 661, 1, 0, 0, 0, 5481, 5482, 5, 88, 0, 0, 5482,
		5483, 5, 155, 0, 0, 5483, 5486, 3, 970, 485, 0, 5484, 5485, 7, 1, 0, 0,
		5485, 5487, 3, 1006, 503, 0, 5486, 5484, 1, 0, 0, 0, 5486, 5487, 1, 0,
		0, 0, 5487, 5488, 1, 0, 0, 0, 5488, 5489, 3, 948, 474, 0, 5489, 663, 1,
		0, 0, 0, 5490, 5491, 5, 130, 0, 0, 5491, 5492, 5, 155, 0, 0, 5492, 5495,
		3, 970, 485, 0, 5493, 5494, 7, 1, 0, 0, 5494, 5496, 3, 1006, 503, 0, 5495,
		5493, 1, 0, 0, 0, 5495, 5496, 1, 0, 0, 0, 5496, 5497, 1, 0, 0, 0, 5497,
		5498, 3, 948, 474, 0, 5498, 665, 1, 0, 0, 0, 5499, 5500, 5, 398, 0, 0,
		5500, 5503, 5, 155, 0, 0, 5501, 5502, 7, 1, 0, 0, 5502, 5504, 3, 1006,
		503, 0, 5503, 5501, 1, 0, 0, 0, 5503, 5504, 1, 0, 0, 0, 5504, 667, 1, 0,
		0, 0, 5505, 5506, 5, 88, 0, 0, 5506, 5507, 3, 70, 35, 0, 5507, 5508, 5,
		312, 0, 0, 5508, 5509, 3, 72, 36, 0, 5509, 5511, 3, 1006, 503, 0, 5510,
		5512, 3, 948, 474, 0, 5511, 5510, 1, 0, 0, 0, 5511, 5512, 1, 0, 0, 0, 5512,
		5513, 1, 0, 0, 0, 5513, 5514, 5, 27, 0, 0, 5514, 5515, 3, 354, 177, 0,
		5515, 669, 1, 0, 0, 0, 5516, 5517, 5, 130, 0, 0, 5517, 5520, 5, 312, 0,
		0, 5518, 5519, 5, 194, 0, 0, 5519, 5521, 5, 145, 0, 0, 5520, 5518, 1, 0,
		0, 0, 5520, 5521, 1, 0, 0, 0, 5521, 5522, 1, 0, 0, 0, 5522, 5523, 3, 1006,
		503, 0, 5523, 671, 1, 0, 0, 0, 5524, 5534, 5, 414, 0, 0, 5525, 5534, 5,
		361, 0, 0, 5526, 5527, 5, 365, 0, 0, 5527, 5534, 5, 18, 0, 0, 5528, 5529,
		5, 365, 0, 0, 5529, 5530, 5, 155, 0, 0, 5530, 5534, 3, 970, 485, 0, 5531,
		5532, 5, 393, 0, 0, 5532, 5534, 3, 952, 476, 0, 5533, 5524, 1, 0, 0, 0,
		5533, 5525, 1, 0, 0, 0, 5533, 5526, 1, 0, 0, 0, 5533, 5528, 1, 0, 0, 0,
		5533, 5531, 1, 0, 0, 0, 5534, 673, 1, 0, 0, 0, 5535, 5536, 5, 19, 0, 0,
		5536, 5537, 5, 312, 0, 0, 5537, 5538, 3, 1006, 503, 0, 5538, 5539, 3, 672,
		336, 0, 5539, 675, 1, 0, 0, 0, 5540, 5541, 7, 8, 0, 0, 5541, 5542, 5, 312,
		0, 0, 5542, 5543, 3, 1006, 503, 0, 5543, 677, 1, 0, 0, 0, 5544, 5545, 5,
		398, 0, 0, 5545, 5552, 5, 313, 0, 0, 5546, 5547, 5, 237, 0, 0, 5547, 5553,
		3, 970, 485, 0, 5548, 5549, 5, 476, 0, 0, 5549, 5553, 3, 842, 421, 0, 5550,
		5551, 5, 169, 0, 0, 5551, 5553, 3, 1006, 503, 0, 5552, 5546, 1, 0, 0, 0,
		5552, 5548, 1, 0, 0, 0, 5552, 5550, 1, 0, 0, 0, 5552, 5553, 1, 0, 0, 0,
		5553, 5564, 1, 0, 0, 0, 5554, 5555, 5, 295, 0, 0, 5555, 5556, 5, 55, 0,
		0, 5556, 5561, 3, 762, 381, 0, 5557, 5558, 5, 3, 0, 0, 5558, 5560, 3, 762,
		381, 0, 5559, 5557, 1, 0, 0, 0, 5560, 5563, 1, 0, 0, 0, 5561, 5559, 1,
		0, 0, 0, 5561, 5562, 1, 0, 0, 0, 5562, 5565, 1, 0, 0, 0, 5563, 5561, 1,
		0, 0, 0, 5564, 5554, 1, 0, 0, 0, 5564, 5565, 1, 0, 0, 0, 5565, 5567, 1,
		0, 0, 0, 5566, 5568, 3, 766, 383, 0, 5567, 5566, 1, 0, 0, 0, 5567, 5568,
		1, 0, 0, 0, 5568, 679, 1, 0, 0, 0, 5569, 5570, 5, 393, 0, 0, 5570, 5575,
		3, 682, 341, 0, 5571, 5572, 5, 3, 0, 0, 5572, 5574, 3, 682, 341, 0, 5573,
		5571, 1, 0, 0, 0, 5574, 5577, 1, 0, 0, 0, 5575, 5573, 1, 0, 0, 0, 5575,
		5576, 1, 0, 0, 0, 5576, 681, 1, 0, 0, 0, 5577, 5575, 1, 0, 0, 0, 5578,
		5579, 5, 64, 0, 0, 5579, 5584, 5, 393, 0, 0, 5580, 5584, 5, 66, 0, 0, 5581,
		5582, 5, 65, 0, 0, 5582, 5584, 5, 393, 0, 0, 5583, 5578, 1, 0, 0, 0, 5583,
		5580, 1, 0, 0, 0, 5583, 5581, 1, 0, 0, 0, 5584, 5587, 1, 0, 0, 0, 5585,
		5588, 3, 1020, 510, 0, 5586, 5588, 5, 115, 0, 0, 5587, 5585, 1, 0, 0, 0,
		5587, 5586, 1, 0, 0, 0, 5588, 5644, 1, 0, 0, 0, 5589, 5592, 5, 271, 0,
		0, 5590, 5593, 3, 1020, 510, 0, 5591, 5593, 5, 115, 0, 0, 5592, 5590, 1,
		0, 0, 0, 5592, 5591, 1, 0, 0, 0, 5593, 5599, 1, 0, 0, 0, 5594, 5597, 5,
		72, 0, 0, 5595, 5598, 3, 1020, 510, 0, 5596, 5598, 5, 115, 0, 0, 5597,
		5595, 1, 0, 0, 0, 5597, 5596, 1, 0, 0, 0, 5598, 5600, 1, 0, 0, 0, 5599,
		5594, 1, 0, 0, 0, 5599, 5600, 1, 0, 0, 0, 5600, 5644, 1, 0, 0, 0, 5601,
		5602, 5, 302, 0, 0, 5602, 5609, 5, 490, 0, 0, 5603, 5610, 3, 970, 485,
		0, 5604, 5605, 5, 302, 0, 0, 5605, 5606, 5, 2, 0, 0, 5606, 5607, 3, 970,
		485, 0, 5607, 5608, 5, 4, 0, 0, 5608, 5610, 1, 0, 0, 0, 5609, 5603, 1,
		0, 0, 0, 5609, 5604, 1, 0, 0, 0, 5610, 5644, 1, 0, 0, 0, 5611, 5612, 5,
		302, 0, 0, 5612, 5613, 5, 165, 0, 0, 5613, 5614, 3, 1026, 513, 0, 5614,
		5621, 5, 490, 0, 0, 5615, 5622, 3, 970, 485, 0, 5616, 5617, 5, 302, 0,
		0, 5617, 5618, 5, 2, 0, 0, 5618, 5619, 3, 970, 485, 0, 5619, 5620, 5, 4,
		0, 0, 5620, 5622, 1, 0, 0, 0, 5621, 5615, 1, 0, 0, 0, 5621, 5616, 1, 0,
		0, 0, 5622, 5644, 1, 0, 0, 0, 5623, 5624, 3, 864, 432, 0, 5624, 5625, 5,
		490, 0, 0, 5625, 5626, 3, 842, 421, 0, 5626, 5644, 1, 0, 0, 0, 5627, 5629,
		3, 962, 481, 0, 5628, 5627, 1, 0, 0, 0, 5628, 5629, 1, 0, 0, 0, 5629, 5630,
		1, 0, 0, 0, 5630, 5631, 3, 1012, 506, 0, 5631, 5632, 5, 490, 0, 0, 5632,
		5633, 3, 692, 346, 0, 5633, 5644, 1, 0, 0, 0, 5634, 5635, 3, 866, 433,
		0, 5635, 5636, 5, 490, 0, 0, 5636, 5637, 3, 692, 346, 0, 5637, 5644, 1,
		0, 0, 0, 5638, 5640, 3, 962, 481, 0, 5639, 5638, 1, 0, 0, 0, 5639, 5640,
		1, 0, 0, 0, 5640, 5641, 1, 0, 0, 0, 5641, 5642, 5, 436, 0, 0, 5642, 5644,
		3, 684, 342, 0, 5643, 5583, 1, 0, 0, 0, 5643, 5589, 1, 0, 0, 0, 5643, 5601,
		1, 0, 0, 0, 5643, 5611, 1, 0, 0, 0, 5643, 5623, 1, 0, 0, 0, 5643, 5628,
		1, 0, 0, 0, 5643, 5634, 1, 0, 0, 0, 5643, 5639, 1, 0, 0, 0, 5644, 683,
		1, 0, 0, 0, 5645, 5656, 3, 686, 343, 0, 5646, 5656, 3, 688, 344, 0, 5647,
		5648, 3, 686, 343, 0, 5648, 5649, 5, 3, 0, 0, 5649, 5650, 3, 688, 344,
		0, 5650, 5656, 1, 0, 0, 0, 5651, 5652, 3, 688, 344, 0, 5652, 5653, 5, 3,
		0, 0, 5653, 5654, 3, 686, 343, 0, 5654, 5656, 1, 0, 0, 0, 5655, 5645, 1,
		0, 0, 0, 5655, 5646, 1, 0, 0, 0, 5655, 5647, 1, 0, 0, 0, 5655, 5651, 1,
		0, 0, 0, 5656, 685, 1, 0, 0, 0, 5657, 5658, 5, 342, 0, 0, 5658, 5662, 5,
		288, 0, 0, 5659, 5660, 5, 342, 0, 0, 5660, 5662, 5, 480, 0, 0, 5661, 5657,
		1, 0, 0, 0, 5661, 5659, 1, 0, 0, 0, 5662, 687, 1, 0, 0, 0, 5663, 5664,
		5, 220, 0, 0, 5664, 5665, 5, 236, 0, 0, 5665, 5666, 3, 690, 345, 0, 5666,
		689, 1, 0, 0, 0, 5667, 5668, 5, 342, 0, 0, 5668, 5675, 5, 447, 0, 0, 5669,
		5670, 5, 342, 0, 0, 5670, 5675, 5, 78, 0, 0, 5671, 5672, 5, 352, 0, 0,
		5672, 5675, 5, 342, 0, 0, 5673, 5675, 5, 391, 0, 0, 5674, 5667, 1, 0, 0,
		0, 5674, 5669, 1, 0, 0, 0, 5674, 5671, 1, 0, 0, 0, 5674, 5673, 1, 0, 0,
		0, 5675, 691, 1, 0, 0, 0, 5676, 5681, 5, 115, 0, 0, 5677, 5681, 5, 287,
		0, 0, 5678, 5681, 5, 18, 0, 0, 5679, 5681, 3, 842, 421, 0, 5680, 5676,
		1, 0, 0, 0, 5680, 5677, 1, 0, 0, 0, 5680, 5678, 1, 0, 0, 0, 5680, 5679,
		1, 0, 0, 0, 5681, 693, 1, 0, 0, 0, 5682, 5683, 5, 393, 0, 0, 5683, 5686,
		5, 330, 0, 0, 5684, 5685, 5, 165, 0, 0, 5685, 5687, 3, 970, 485, 0, 5686,
		5684, 1, 0, 0, 0, 5686, 5687, 1, 0, 0, 0, 5687, 5688, 1, 0, 0, 0, 5688,
		5689, 3, 954, 477, 0, 5689, 695, 1, 0, 0, 0, 5690, 5695, 3, 1020, 510,
		0, 5691, 5692, 5, 3, 0, 0, 5692, 5694, 3, 1020, 510, 0, 5693, 5691, 1,
		0, 0, 0, 5694, 5697, 1, 0, 0, 0, 5695, 5693, 1, 0, 0, 0, 5695, 5696, 1,
		0, 0, 0, 5696, 697, 1, 0, 0, 0, 5697, 5695, 1, 0, 0, 0, 5698, 5699, 5,
		14, 0, 0, 5699, 5700, 5, 144, 0, 0, 5700, 5701, 5, 287, 0, 0, 5701, 5702,
		7, 28, 0, 0, 5702, 5703, 3, 970, 485, 0, 5703, 699, 1, 0, 0, 0, 5704, 5705,
		5, 482, 0, 0, 5705, 5706, 5, 421, 0, 0, 5706, 5711, 3, 702, 351, 0, 5707,
		5708, 5, 3, 0, 0, 5708, 5710, 3, 702, 351, 0, 5709, 5707, 1, 0, 0, 0, 5710,
		5713, 1, 0, 0, 0, 5711, 5709, 1, 0, 0, 0, 5711, 5712, 1, 0, 0, 0, 5712,
		5717, 1, 0, 0, 0, 5713, 5711, 1, 0, 0, 0, 5714, 5715, 5, 483, 0, 0, 5715,
		5717, 5, 421, 0, 0, 5716, 5704, 1, 0, 0, 0, 5716, 5714, 1, 0, 0, 0, 5717,
		701, 1, 0, 0, 0, 5718, 5723, 3, 1012, 506, 0, 5719, 5721, 5, 27, 0, 0,
		5720, 5719, 1, 0, 0, 0, 5720, 5721, 1, 0, 0, 0, 5721, 5722, 1, 0, 0, 0,
		5722, 5724, 3, 1012, 506, 0, 5723, 5720, 1, 0, 0, 0, 5723, 5724, 1, 0,
		0, 0, 5724, 5725, 1, 0, 0, 0, 5725, 5726, 3, 704, 352, 0, 5726, 703, 1,
		0, 0, 0, 5727, 5729, 5, 342, 0, 0, 5728, 5730, 5, 241, 0, 0, 5729, 5728,
		1, 0, 0, 0, 5729, 5730, 1, 0, 0, 0, 5730, 5736, 1, 0, 0, 0, 5731, 5733,
		5, 484, 0, 0, 5732, 5731, 1, 0, 0, 0, 5732, 5733, 1, 0, 0, 0, 5733, 5734,
		1, 0, 0, 0, 5734, 5736, 5, 480, 0, 0, 5735, 5727, 1, 0, 0, 0, 5735, 5732,
		1, 0, 0, 0, 5736, 705, 1, 0, 0, 0, 5737, 5738, 5, 19, 0, 0, 5738, 5739,
		5, 309, 0, 0, 5739, 5740, 5, 15, 0, 0, 5740, 5741, 5, 13, 0, 0, 5741, 5742,
		3, 744, 372, 0, 5742, 707, 1, 0, 0, 0, 5743, 5744, 5, 443, 0, 0, 5744,
		5745, 5, 309, 0, 0, 5745, 5746, 5, 15, 0, 0, 5746, 709, 1, 0, 0, 0, 5747,
		5748, 5, 19, 0, 0, 5748, 5749, 5, 309, 0, 0, 5749, 5750, 5, 15, 0, 0, 5750,
		5751, 5, 130, 0, 0, 5751, 5752, 3, 970, 485, 0, 5752, 711, 1, 0, 0, 0,
		5753, 5754, 5, 398, 0, 0, 5754, 5755, 5, 309, 0, 0, 5755, 5756, 5, 15,
		0, 0, 5756, 713, 1, 0, 0, 0, 5757, 5758, 5, 88, 0, 0, 5758, 5762, 5, 471,
		0, 0, 5759, 5760, 5, 194, 0, 0, 5760, 5761, 5, 278, 0, 0, 5761, 5763, 5,
		145, 0, 0, 5762, 5759, 1, 0, 0, 0, 5762, 5763, 1, 0, 0, 0, 5763, 5764,
		1, 0, 0, 0, 5764, 5766, 3, 1020, 510, 0, 5765, 5767, 3, 964, 482, 0, 5766,
		5765, 1, 0, 0, 0, 5766, 5767, 1, 0, 0, 0, 5767, 5769, 1, 0, 0, 0, 5768,
		5770, 3, 948, 474, 0, 5769, 5768, 1, 0, 0, 0, 5769, 5770, 1, 0, 0, 0, 5770,
		715, 1, 0, 0, 0, 5771, 5772, 5, 130, 0, 0, 5772, 5775, 5, 471, 0, 0, 5773,
		5774, 5, 194, 0, 0, 5774, 5776, 5, 145, 0, 0, 5775, 5773, 1, 0, 0, 0, 5775,
		5776, 1, 0, 0, 0, 5776, 5777, 1, 0, 0, 0, 5777, 5778, 3, 1020, 510, 0,
		5778, 717, 1, 0, 0, 0, 5779, 5780, 5, 414, 0, 0, 5780, 5783, 5, 471, 0,
		0, 5781, 5782, 5, 194, 0, 0, 5782, 5784, 5, 145, 0, 0, 5783, 5781, 1, 0,
		0, 0, 5783, 5784, 1, 0, 0, 0, 5784, 5785, 1, 0, 0, 0, 5785, 5786, 3, 1012,
		506, 0, 5786, 719, 1, 0, 0, 0, 5787, 5788, 5, 361, 0, 0, 5788, 5791, 5,
		471, 0, 0, 5789, 5790, 5, 194, 0, 0, 5790, 5792, 5, 145, 0, 0, 5791, 5789,
		1, 0, 0, 0, 5791, 5792, 1, 0, 0, 0, 5792, 5793, 1, 0, 0, 0, 5793, 5794,
		3, 1012, 506, 0, 5794, 721, 1, 0, 0, 0, 5795, 5797, 5, 393, 0, 0, 5796,
		5798, 5, 392, 0, 0, 5797, 5796, 1, 0, 0, 0, 5797, 5798, 1, 0, 0, 0, 5798,
		5799, 1, 0, 0, 0, 5799, 5801, 5, 471, 0, 0, 5800, 5802, 5, 490, 0, 0, 5801,
		5800, 1, 0, 0, 0, 5801, 5802, 1, 0, 0, 0, 5802, 5803, 1, 0, 0, 0, 5803,
		5804, 3, 1020, 510, 0, 5804, 723, 1, 0, 0, 0, 5805, 5806, 5, 398, 0, 0,
		5806, 5809, 5, 472, 0, 0, 5807, 5808, 5, 237, 0, 0, 5808, 5810, 3, 970,
		485, 0, 5809, 5807, 1, 0, 0, 0, 5809, 5810, 1, 0, 0, 0, 5810, 725, 1, 0,
		0, 0, 5811, 5812, 5, 398, 0, 0, 5812, 5813, 5, 71, 0, 0, 5813, 5814, 5,
		169, 0, 0, 5814, 5815, 5, 471, 0, 0, 5815, 5816, 3, 1012, 506, 0, 5816,
		727, 1, 0, 0, 0, 5817, 5818, 5, 398, 0, 0, 5818, 5819, 5, 276, 0, 0, 5819,
		5820, 5, 169, 0, 0, 5820, 5823, 5, 472, 0, 0, 5821, 5822, 5, 237, 0, 0,
		5822, 5824, 3, 970, 485, 0, 5823, 5821, 1, 0, 0, 0, 5823, 5824, 1, 0, 0,
		0, 5824, 5831, 1, 0, 0, 0, 5825, 5826, 5, 398, 0, 0, 5826, 5827, 5, 276,
		0, 0, 5827, 5828, 5, 169, 0, 0, 5828, 5829, 5, 471, 0, 0, 5829, 5831, 3,
		1012, 506, 0, 5830, 5817, 1, 0, 0, 0, 5830, 5825, 1, 0, 0, 0, 5831, 729,
		1, 0, 0, 0, 5832, 5833, 5, 19, 0, 0, 5833, 5834, 5, 471, 0, 0, 5834, 5835,
		3, 1020, 510, 0, 5835, 5836, 3, 276, 138, 0, 5836, 731, 1, 0, 0, 0, 5837,
		5838, 5, 404, 0, 0, 5838, 5842, 5, 436, 0, 0, 5839, 5840, 5, 478, 0, 0,
		5840, 5841, 5, 84, 0, 0, 5841, 5843, 5, 400, 0, 0, 5842, 5839, 1, 0, 0,
		0, 5842, 5843, 1, 0, 0, 0, 5843, 5849, 1, 0, 0, 0, 5844, 5846, 5, 40, 0,
		0, 5845, 5847, 5, 479, 0, 0, 5846, 5845, 1, 0, 0, 0, 5846, 5847, 1, 0,
		0, 0, 5847, 5849, 1, 0, 0, 0, 5848, 5837, 1, 0, 0, 0, 5848, 5844, 1, 0,
		0, 0, 5849, 733, 1, 0, 0, 0, 5850, 5852, 5, 77, 0, 0, 5851, 5853, 5, 479,
		0, 0, 5852, 5851, 1, 0, 0, 0, 5852, 5853, 1, 0, 0, 0, 5853, 5859, 1, 0,
		0, 0, 5854, 5856, 5, 21, 0, 0, 5855, 5857, 5, 274, 0, 0, 5856, 5855, 1,
		0, 0, 0, 5856, 5857, 1, 0, 0, 0, 5857, 5858, 1, 0, 0, 0, 5858, 5860, 5,
		63, 0, 0, 5859, 5854, 1, 0, 0, 0, 5859, 5860, 1, 0, 0, 0, 5860, 5865, 1,
		0, 0, 0, 5861, 5863, 5, 274, 0, 0, 5862, 5861, 1, 0, 0, 0, 5862, 5863,
		1, 0, 0, 0, 5863, 5864, 1, 0, 0, 0, 5864, 5866, 5, 348, 0, 0, 5865, 5862,
		1, 0, 0, 0, 5865, 5866, 1, 0, 0, 0, 5866, 735, 1, 0, 0, 0, 5867, 5869,
		5, 372, 0, 0, 5868, 5870, 5, 479, 0, 0, 5869, 5868, 1, 0, 0, 0, 5869, 5870,
		1, 0, 0, 0, 5870, 5876, 1, 0, 0, 0, 5871, 5873, 5, 21, 0, 0, 5872, 5874,
		5, 274, 0, 0, 5873, 5872, 1, 0, 0, 0, 5873, 5874, 1, 0, 0, 0, 5874, 5875,
		1, 0, 0, 0, 5875, 5877, 5, 63, 0, 0, 5876, 5871, 1, 0, 0, 0, 5876, 5877,
		1, 0, 0, 0, 5877, 5882, 1, 0, 0, 0, 5878, 5880, 5, 274, 0, 0, 5879, 5878,
		1, 0, 0, 0, 5879, 5880, 1, 0, 0, 0, 5880, 5881, 1, 0, 0, 0, 5881, 5883,
		5, 348, 0, 0, 5882, 5879, 1, 0, 0, 0, 5882, 5883, 1, 0, 0, 0, 5883, 737,
		1, 0, 0, 0, 5884, 5885, 5, 437, 0, 0, 5885, 5886, 3, 740, 370, 0, 5886,
		5887, 3, 742, 371, 0, 5887, 739, 1, 0, 0, 0, 5888, 5889, 3, 1012, 506,
		0, 5889, 741, 1, 0, 0, 0, 5890, 5892, 9, 0, 0, 0, 5891, 5890, 1, 0, 0,
		0, 5892, 5893, 1, 0, 0, 0, 5893, 5891, 1, 0, 0, 0, 5893, 5894, 1, 0, 0,
		0, 5894, 743, 1, 0, 0, 0, 5895, 5898, 3, 894, 447, 0, 5896, 5898, 3, 896,
		448, 0, 5897, 5895, 1, 0, 0, 0, 5897, 5896, 1, 0, 0, 0, 5897, 5898, 1,
		0, 0, 0, 5898, 5899, 1, 0, 0, 0, 5899, 5901, 3, 746, 373, 0, 5900, 5902,
		3, 966, 483, 0, 5901, 5900, 1, 0, 0, 0, 5901, 5902, 1, 0, 0, 0, 5902, 745,
		1, 0, 0, 0, 5903, 5905, 3, 748, 374, 0, 5904, 5903, 1, 0, 0, 0, 5904, 5905,
		1, 0, 0, 0, 5905, 5906, 1, 0, 0, 0, 5906, 5907, 3, 750, 375, 0, 5907, 747,
		1, 0, 0, 0, 5908, 5909, 5, 478, 0, 0, 5909, 5914, 3, 776, 388, 0, 5910,
		5911, 5, 3, 0, 0, 5911, 5913, 3, 776, 388, 0, 5912, 5910, 1, 0, 0, 0, 5913,
		5916, 1, 0, 0, 0, 5914, 5912, 1, 0, 0, 0, 5914, 5915, 1, 0, 0, 0, 5915,
		749, 1, 0, 0, 0, 5916, 5914, 1, 0, 0, 0, 5917, 5928, 3, 756, 378, 0, 5918,
		5919, 5, 295, 0, 0, 5919, 5920, 5, 55, 0, 0, 5920, 5925, 3, 762, 381, 0,
		5921, 5922, 5, 3, 0, 0, 5922, 5924, 3, 762, 381, 0, 5923, 5921, 1, 0, 0,
		0, 5924, 5927, 1, 0, 0, 0, 5925, 5923, 1, 0, 0, 0, 5925, 5926, 1, 0, 0,
		0, 5926, 5929, 1, 0, 0, 0, 5927, 5925, 1, 0, 0, 0, 5928, 5918, 1, 0, 0,
		0, 5928, 5929, 1, 0, 0, 0, 5929, 5931, 1, 0, 0, 0, 5930, 5932, 3, 766,
		383, 0, 5931, 5930, 1, 0, 0, 0, 5931, 5932, 1, 0, 0, 0, 5932, 751, 1, 0,
		0, 0, 5933, 5935, 5, 165, 0, 0, 5934, 5933, 1, 0, 0, 0, 5934, 5935, 1,
		0, 0, 0, 5935, 5936, 1, 0, 0, 0, 5936, 5937, 3, 754, 377, 0, 5937, 5938,
		5, 41, 0, 0, 5938, 5939, 3, 842, 421, 0, 5939, 5940, 5, 21, 0, 0, 5940,
		5941, 3, 842, 421, 0, 5941, 5966, 1, 0, 0, 0, 5942, 5944, 5, 165, 0, 0,
		5943, 5942, 1, 0, 0, 0, 5943, 5944, 1, 0, 0, 0, 5944, 5945, 1, 0, 0, 0,
		5945, 5946, 3, 754, 377, 0, 5946, 5947, 5, 169, 0, 0, 5947, 5948, 3, 842,
		421, 0, 5948, 5949, 5, 438, 0, 0, 5949, 5950, 3, 842, 421, 0, 5950, 5966,
		1, 0, 0, 0, 5951, 5953, 5, 165, 0, 0, 5952, 5951, 1, 0, 0, 0, 5952, 5953,
		1, 0, 0, 0, 5953, 5954, 1, 0, 0, 0, 5954, 5955, 3, 754, 377, 0, 5955, 5956,
		5, 18, 0, 0, 5956, 5966, 1, 0, 0, 0, 5957, 5959, 5, 165, 0, 0, 5958, 5957,
		1, 0, 0, 0, 5958, 5959, 1, 0, 0, 0, 5959, 5960, 1, 0, 0, 0, 5960, 5961,
		3, 754, 377, 0, 5961, 5962, 5, 27, 0, 0, 5962, 5963, 5, 284, 0, 0, 5963,
		5964, 3, 842, 421, 0, 5964, 5966, 1, 0, 0, 0, 5965, 5934, 1, 0, 0, 0, 5965,
		5943, 1, 0, 0, 0, 5965, 5952, 1, 0, 0, 0, 5965, 5958, 1, 0, 0, 0, 5966,
		753, 1, 0, 0, 0, 5967, 5968, 7, 29, 0, 0, 5968, 755, 1, 0, 0, 0, 5969,
		5970, 6, 378, -1, 0, 5970, 5973, 3, 768, 384, 0, 5971, 5973, 3, 758, 379,
		0, 5972, 5969, 1, 0, 0, 0, 5972, 5971, 1, 0, 0, 0, 5973, 5988, 1, 0, 0,
		0, 5974, 5975, 10, 2, 0, 0, 5975, 5977, 5, 213, 0, 0, 5976, 5978, 3, 778,
		389, 0, 5977, 5976, 1, 0, 0, 0, 5977, 5978, 1, 0, 0, 0, 5978, 5979, 1,
		0, 0, 0, 5979, 5987, 3, 756, 378, 3, 5980, 5981, 10, 1, 0, 0, 5981, 5983,
		7, 30, 0, 0, 5982, 5984, 3, 778, 389, 0, 5983, 5982, 1, 0, 0, 0, 5983,
		5984, 1, 0, 0, 0, 5984, 5985, 1, 0, 0, 0, 5985, 5987, 3, 756, 378, 2, 5986,
		5974, 1, 0, 0, 0, 5986, 5980, 1, 0, 0, 0, 5987, 5990, 1, 0, 0, 0, 5988,
		5986, 1, 0, 0, 0, 5988, 5989, 1, 0, 0, 0, 5989, 757, 1, 0, 0, 0, 5990,
		5988, 1, 0, 0, 0, 5991, 5992, 5, 2, 0, 0, 5992, 5993, 3, 746, 373, 0, 5993,
		5994, 5, 4, 0, 0, 5994, 759, 1, 0, 0, 0, 5995, 5996, 5, 2, 0, 0, 5996,
		5997, 3, 844, 422, 0, 5997, 5998, 5, 4, 0, 0, 5998, 761, 1, 0, 0, 0, 5999,
		6001, 3, 842, 421, 0, 6000, 6002, 7, 31, 0, 0, 6001, 6000, 1, 0, 0, 0,
		6001, 6002, 1, 0, 0, 0, 6002, 6005, 1, 0, 0, 0, 6003, 6004, 5, 280, 0,
		0, 6004, 6006, 7, 32, 0, 0, 6005, 6003, 1, 0, 0, 0, 6005, 6006, 1, 0, 0,
		0, 6006, 763, 1, 0, 0, 0, 6007, 6011, 5, 516, 0, 0, 6008, 6011, 5, 299,
		0, 0, 6009, 6011, 3, 864, 432, 0, 6010, 6007, 1, 0, 0, 0, 6010, 6008, 1,
		0, 0, 0, 6010, 6009, 1, 0, 0, 0, 6011, 765, 1, 0, 0, 0, 6012, 6013, 5,
		238, 0, 0, 6013, 6016, 3, 764, 382, 0, 6014, 6015, 5, 286, 0, 0, 6015,
		6017, 3, 764, 382, 0, 6016, 6014, 1, 0, 0, 0, 6016, 6017, 1, 0, 0, 0, 6017,
		6024, 1, 0, 0, 0, 6018, 6019, 5, 238, 0, 0, 6019, 6020, 3, 764, 382, 0,
		6020, 6021, 5, 3, 0, 0, 6021, 6022, 3, 764, 382, 0, 6022, 6024, 1, 0, 0,
		0, 6023, 6012, 1, 0, 0, 0, 6023, 6018, 1, 0, 0, 0, 6024, 767, 1, 0, 0,
		0, 6025, 6027, 5, 388, 0, 0, 6026, 6028, 3, 778, 389, 0, 6027, 6026, 1,
		0, 0, 0, 6027, 6028, 1, 0, 0, 0, 6028, 6029, 1, 0, 0, 0, 6029, 6034, 3,
		780, 390, 0, 6030, 6031, 5, 3, 0, 0, 6031, 6033, 3, 780, 390, 0, 6032,
		6030, 1, 0, 0, 0, 6033, 6036, 1, 0, 0, 0, 6034, 6032, 1, 0, 0, 0, 6034,
		6035, 1, 0, 0, 0, 6035, 6037, 1, 0, 0, 0, 6036, 6034, 1, 0, 0, 0, 6037,
		6040, 3, 770, 385, 0, 6038, 6039, 5, 476, 0, 0, 6039, 6041, 3, 842, 421,
		0, 6040, 6038, 1, 0, 0, 0, 6040, 6041, 1, 0, 0, 0, 6041, 6045, 1, 0, 0,
		0, 6042, 6043, 5, 178, 0, 0, 6043, 6044, 5, 55, 0, 0, 6044, 6046, 3, 772,
		386, 0, 6045, 6042, 1, 0, 0, 0, 6045, 6046, 1, 0, 0, 0, 6046, 6049, 1,
		0, 0, 0, 6047, 6048, 5, 184, 0, 0, 6048, 6050, 3, 842, 421, 0, 6049, 6047,
		1, 0, 0, 0, 6049, 6050, 1, 0, 0, 0, 6050, 6056, 1, 0, 0, 0, 6051, 6052,
		5, 333, 0, 0, 6052, 6053, 3, 780, 390, 0, 6053, 6054, 3, 974, 487, 0, 6054,
		6055, 5, 516, 0, 0, 6055, 6057, 1, 0, 0, 0, 6056, 6051, 1, 0, 0, 0, 6056,
		6057, 1, 0, 0, 0, 6057, 769, 1, 0, 0, 0, 6058, 6059, 5, 169, 0, 0, 6059,
		6061, 3, 782, 391, 0, 6060, 6062, 3, 788, 394, 0, 6061, 6060, 1, 0, 0,
		0, 6061, 6062, 1, 0, 0, 0, 6062, 6064, 1, 0, 0, 0, 6063, 6058, 1, 0, 0,
		0, 6063, 6064, 1, 0, 0, 0, 6064, 6068, 1, 0, 0, 0, 6065, 6066, 5, 169,
		0, 0, 6066, 6068, 5, 131, 0, 0, 6067, 6063, 1, 0, 0, 0, 6067, 6065, 1,
		0, 0, 0, 6068, 771, 1, 0, 0, 0, 6069, 6070, 5, 373, 0, 0, 6070, 6072, 5,
		2, 0, 0, 6071, 6073, 3, 844, 422, 0, 6072, 6071, 1, 0, 0, 0, 6072, 6073,
		1, 0, 0, 0, 6073, 6074, 1, 0, 0, 0, 6074, 6096, 5, 4, 0, 0, 6075, 6076,
		5, 90, 0, 0, 6076, 6078, 5, 2, 0, 0, 6077, 6079, 3, 844, 422, 0, 6078,
		6077, 1, 0, 0, 0, 6078, 6079, 1, 0, 0, 0, 6079, 6080, 1, 0, 0, 0, 6080,
		6096, 5, 4, 0, 0, 6081, 6082, 5, 180, 0, 0, 6082, 6083, 5, 394, 0, 0, 6083,
		6084, 5, 2, 0, 0, 6084, 6089, 3, 774, 387, 0, 6085, 6086, 5, 3, 0, 0, 6086,
		6088, 3, 774, 387, 0, 6087, 6085, 1, 0, 0, 0, 6088, 6091, 1, 0, 0, 0, 6089,
		6087, 1, 0, 0, 0, 6089, 6090, 1, 0, 0, 0, 6090, 6092, 1, 0, 0, 0, 6091,
		6089, 1, 0, 0, 0, 6092, 6093, 5, 4, 0, 0, 6093, 6096, 1, 0, 0, 0, 6094,
		6096, 3, 844, 422, 0, 6095, 6069, 1, 0, 0, 0, 6095, 6075, 1, 0, 0, 0, 6095,
		6081, 1, 0, 0, 0, 6095, 6094, 1, 0, 0, 0, 6096, 773, 1, 0, 0, 0, 6097,
		6099, 5, 2, 0, 0, 6098, 6100, 3, 842, 421, 0, 6099, 6098, 1, 0, 0, 0, 6099,
		6100, 1, 0, 0, 0, 6100, 6105, 1, 0, 0, 0, 6101, 6102, 5, 3, 0, 0, 6102,
		6104, 3, 842, 421, 0, 6103, 6101, 1, 0, 0, 0, 6104, 6107, 1, 0, 0, 0, 6105,
		6103, 1, 0, 0, 0, 6105, 6106, 1, 0, 0, 0, 6106, 6108, 1, 0, 0, 0, 6107,
		6105, 1, 0, 0, 0, 6108, 6109, 5, 4, 0, 0, 6109, 775, 1, 0, 0, 0, 6110,
		6112, 3, 1012, 506, 0, 6111, 6113, 3, 814, 407, 0, 6112, 6111, 1, 0, 0,
		0, 6112, 6113, 1, 0, 0, 0, 6113, 6114, 1, 0, 0, 0, 6114, 6115, 5, 27, 0,
		0, 6115, 6116, 5, 2, 0, 0, 6116, 6117, 3, 746, 373, 0, 6117, 6118, 5, 4,
		0, 0, 6118, 777, 1, 0, 0, 0, 6119, 6120, 7, 33, 0, 0, 6120, 779, 1, 0,
		0, 0, 6121, 6129, 3, 842, 421, 0, 6122, 6124, 5, 27, 0, 0, 6123, 6122,
		1, 0, 0, 0, 6123, 6124, 1, 0, 0, 0, 6124, 6127, 1, 0, 0, 0, 6125, 6128,
		3, 1012, 506, 0, 6126, 6128, 3, 970, 485, 0, 6127, 6125, 1, 0, 0, 0, 6127,
		6126, 1, 0, 0, 0, 6128, 6130, 1, 0, 0, 0, 6129, 6123, 1, 0, 0, 0, 6129,
		6130, 1, 0, 0, 0, 6130, 6137, 1, 0, 0, 0, 6131, 6132, 3, 1006, 503, 0,
		6132, 6133, 5, 1, 0, 0, 6133, 6134, 5, 500, 0, 0, 6134, 6137, 1, 0, 0,
		0, 6135, 6137, 5, 500, 0, 0, 6136, 6121, 1, 0, 0, 0, 6136, 6131, 1, 0,
		0, 0, 6136, 6135, 1, 0, 0, 0, 6137, 781, 1, 0, 0, 0, 6138, 6146, 3, 784,
		392, 0, 6139, 6141, 5, 3, 0, 0, 6140, 6142, 5, 232, 0, 0, 6141, 6140, 1,
		0, 0, 0, 6141, 6142, 1, 0, 0, 0, 6142, 6143, 1, 0, 0, 0, 6143, 6145, 3,
		784, 392, 0, 6144, 6139, 1, 0, 0, 0, 6145, 6148, 1, 0, 0, 0, 6146, 6144,
		1, 0, 0, 0, 6146, 6147, 1, 0, 0, 0, 6147, 783, 1, 0, 0, 0, 6148, 6146,
		1, 0, 0, 0, 6149, 6153, 3, 786, 393, 0, 6150, 6152, 3, 802, 401, 0, 6151,
		6150, 1, 0, 0, 0, 6152, 6155, 1, 0, 0, 0, 6153, 6151, 1, 0, 0, 0, 6153,
		6154, 1, 0, 0, 0, 6154, 6167, 1, 0, 0, 0, 6155, 6153, 1, 0, 0, 0, 6156,
		6157, 5, 2, 0, 0, 6157, 6161, 3, 786, 393, 0, 6158, 6160, 3, 802, 401,
		0, 6159, 6158, 1, 0, 0, 0, 6160, 6163, 1, 0, 0, 0, 6161, 6159, 1, 0, 0,
		0, 6161, 6162, 1, 0, 0, 0, 6162, 6164, 1, 0, 0, 0, 6163, 6161, 1, 0, 0,
		0, 6164, 6165, 5, 4, 0, 0, 6165, 6167, 1, 0, 0, 0, 6166, 6149, 1, 0, 0,
		0, 6166, 6156, 1, 0, 0, 0, 6167, 785, 1, 0, 0, 0, 6168, 6170, 3, 1006,
		503, 0, 6169, 6171, 3, 752, 376, 0, 6170, 6169, 1, 0, 0, 0, 6170, 6171,
		1, 0, 0, 0, 6171, 6173, 1, 0, 0, 0, 6172, 6174, 3, 816, 408, 0, 6173, 6172,
		1, 0, 0, 0, 6173, 6174, 1, 0, 0, 0, 6174, 6176, 1, 0, 0, 0, 6175, 6177,
		3, 820, 410, 0, 6176, 6175, 1, 0, 0, 0, 6176, 6177, 1, 0, 0, 0, 6177, 6179,
		1, 0, 0, 0, 6178, 6180, 3, 830, 415, 0, 6179, 6178, 1, 0, 0, 0, 6179, 6180,
		1, 0, 0, 0, 6180, 6182, 1, 0, 0, 0, 6181, 6183, 3, 794, 397, 0, 6182, 6181,
		1, 0, 0, 0, 6182, 6183, 1, 0, 0, 0, 6183, 6188, 1, 0, 0, 0, 6184, 6186,
		5, 27, 0, 0, 6185, 6184, 1, 0, 0, 0, 6185, 6186, 1, 0, 0, 0, 6186, 6187,
		1, 0, 0, 0, 6187, 6189, 3, 1012, 506, 0, 6188, 6185, 1, 0, 0, 0, 6188,
		6189, 1, 0, 0, 0, 6189, 6191, 1, 0, 0, 0, 6190, 6192, 3, 808, 404, 0, 6191,
		6190, 1, 0, 0, 0, 6191, 6192, 1, 0, 0, 0, 6192, 6195, 1, 0, 0, 0, 6193,
		6194, 5, 486, 0, 0, 6194, 6196, 3, 970, 485, 0, 6195, 6193, 1, 0, 0, 0,
		6195, 6196, 1, 0, 0, 0, 6196, 6272, 1, 0, 0, 0, 6197, 6198, 5, 2, 0, 0,
		6198, 6199, 5, 460, 0, 0, 6199, 6204, 3, 760, 380, 0, 6200, 6201, 5, 3,
		0, 0, 6201, 6203, 3, 760, 380, 0, 6202, 6200, 1, 0, 0, 0, 6203, 6206, 1,
		0, 0, 0, 6204, 6202, 1, 0, 0, 0, 6204, 6205, 1, 0, 0, 0, 6205, 6207, 1,
		0, 0, 0, 6206, 6204, 1, 0, 0, 0, 6207, 6215, 5, 4, 0, 0, 6208, 6210, 5,
		27, 0, 0, 6209, 6208, 1, 0, 0, 0, 6209, 6210, 1, 0, 0, 0, 6210, 6211, 1,
		0, 0, 0, 6211, 6213, 3, 1012, 506, 0, 6212, 6214, 3, 814, 407, 0, 6213,
		6212, 1, 0, 0, 0, 6213, 6214, 1, 0, 0, 0, 6214, 6216, 1, 0, 0, 0, 6215,
		6209, 1, 0, 0, 0, 6215, 6216, 1, 0, 0, 0, 6216, 6272, 1, 0, 0, 0, 6217,
		6225, 3, 758, 379, 0, 6218, 6220, 5, 27, 0, 0, 6219, 6218, 1, 0, 0, 0,
		6219, 6220, 1, 0, 0, 0, 6220, 6221, 1, 0, 0, 0, 6221, 6223, 3, 1012, 506,
		0, 6222, 6224, 3, 814, 407, 0, 6223, 6222, 1, 0, 0, 0, 6223, 6224, 1, 0,
		0, 0, 6224, 6226, 1, 0, 0, 0, 6225, 6219, 1, 0, 0, 0, 6225, 6226, 1, 0,
		0, 0, 6226, 6272, 1, 0, 0, 0, 6227, 6228, 3, 1006, 503, 0, 6228, 6229,
		5, 2, 0, 0, 6229, 6230, 3, 844, 422, 0, 6230, 6238, 5, 4, 0, 0, 6231, 6233,
		5, 27, 0, 0, 6232, 6231, 1, 0, 0, 0, 6232, 6233, 1, 0, 0, 0, 6233, 6234,
		1, 0, 0, 0, 6234, 6236, 3, 1012, 506, 0, 6235, 6237, 3, 814, 407, 0, 6236,
		6235, 1, 0, 0, 0, 6236, 6237, 1, 0, 0, 0, 6237, 6239, 1, 0, 0, 0, 6238,
		6232, 1, 0, 0, 0, 6238, 6239, 1, 0, 0, 0, 6239, 6272, 1, 0, 0, 0, 6240,
		6241, 5, 420, 0, 0, 6241, 6242, 5, 2, 0, 0, 6242, 6243, 3, 1006, 503, 0,
		6243, 6244, 5, 2, 0, 0, 6244, 6245, 3, 796, 398, 0, 6245, 6246, 5, 4, 0,
		0, 6246, 6254, 5, 4, 0, 0, 6247, 6249, 5, 27, 0, 0, 6248, 6247, 1, 0, 0,
		0, 6248, 6249, 1, 0, 0, 0, 6249, 6250, 1, 0, 0, 0, 6250, 6252, 3, 1012,
		506, 0, 6251, 6253, 3, 814, 407, 0, 6252, 6251, 1, 0, 0, 0, 6252, 6253,
		1, 0, 0, 0, 6253, 6255, 1, 0, 0, 0, 6254, 6248, 1, 0, 0, 0, 6254, 6255,
		1, 0, 0, 0, 6255, 6272, 1, 0, 0, 0, 6256, 6257, 5, 156, 0, 0, 6257, 6265,
		3, 952, 476, 0, 6258, 6260, 5, 27, 0, 0, 6259, 6258, 1, 0, 0, 0, 6259,
		6260, 1, 0, 0, 0, 6260, 6261, 1, 0, 0, 0, 6261, 6263, 3, 1012, 506, 0,
		6262, 6264, 3, 814, 407, 0, 6263, 6262, 1, 0, 0, 0, 6263, 6264, 1, 0, 0,
		0, 6264, 6266, 1, 0, 0, 0, 6265, 6259, 1, 0, 0, 0, 6265, 6266, 1, 0, 0,
		0, 6266, 6272, 1, 0, 0, 0, 6267, 6268, 5, 2, 0, 0, 6268, 6269, 3, 782,
		391, 0, 6269, 6270, 5, 4, 0, 0, 6270, 6272, 1, 0, 0, 0, 6271, 6168, 1,
		0, 0, 0, 6271, 6197, 1, 0, 0, 0, 6271, 6217, 1, 0, 0, 0, 6271, 6227, 1,
		0, 0, 0, 6271, 6240, 1, 0, 0, 0, 6271, 6256, 1, 0, 0, 0, 6271, 6267, 1,
		0, 0, 0, 6272, 787, 1, 0, 0, 0, 6273, 6274, 5, 314, 0, 0, 6274, 6275, 5,
		2, 0, 0, 6275, 6280, 3, 790, 395, 0, 6276, 6277, 5, 3, 0, 0, 6277, 6279,
		3, 790, 395, 0, 6278, 6276, 1, 0, 0, 0, 6279, 6282, 1, 0, 0, 0, 6280, 6278,
		1, 0, 0, 0, 6280, 6281, 1, 0, 0, 0, 6281, 6283, 1, 0, 0, 0, 6282, 6280,
		1, 0, 0, 0, 6283, 6286, 5, 165, 0, 0, 6284, 6287, 3, 1012, 506, 0, 6285,
		6287, 3, 1018, 509, 0, 6286, 6284, 1, 0, 0, 0, 6286, 6285, 1, 0, 0, 0,
		6287, 6288, 1, 0, 0, 0, 6288, 6289, 5, 199, 0, 0, 6289, 6290, 5, 2, 0,
		0, 6290, 6295, 3, 792, 396, 0, 6291, 6292, 5, 3, 0, 0, 6292, 6294, 3, 792,
		396, 0, 6293, 6291, 1, 0, 0, 0, 6294, 6297, 1, 0, 0, 0, 6295, 6293, 1,
		0, 0, 0, 6295, 6296, 1, 0, 0, 0, 6296, 6298, 1, 0, 0, 0, 6297, 6295, 1,
		0, 0, 0, 6298, 6299, 5, 4, 0, 0, 6299, 6300, 5, 4, 0, 0, 6300, 789, 1,
		0, 0, 0, 6301, 6309, 3, 860, 430, 0, 6302, 6304, 5, 27, 0, 0, 6303, 6302,
		1, 0, 0, 0, 6303, 6304, 1, 0, 0, 0, 6304, 6307, 1, 0, 0, 0, 6305, 6308,
		3, 1012, 506, 0, 6306, 6308, 3, 970, 485, 0, 6307, 6305, 1, 0, 0, 0, 6307,
		6306, 1, 0, 0, 0, 6308, 6310, 1, 0, 0, 0, 6309, 6303, 1, 0, 0, 0, 6309,
		6310, 1, 0, 0, 0, 6310, 791, 1, 0, 0, 0, 6311, 6314, 3, 858, 429, 0, 6312,
		6314, 3, 920, 460, 0, 6313, 6311, 1, 0, 0, 0, 6313, 6312, 1, 0, 0, 0, 6314,
		6322, 1, 0, 0, 0, 6315, 6317, 5, 27, 0, 0, 6316, 6315, 1, 0, 0, 0, 6316,
		6317, 1, 0, 0, 0, 6317, 6320, 1, 0, 0, 0, 6318, 6321, 3, 1012, 506, 0,
		6319, 6321, 3, 970, 485, 0, 6320, 6318, 1, 0, 0, 0, 6320, 6319, 1, 0, 0,
		0, 6321, 6323, 1, 0, 0, 0, 6322, 6316, 1, 0, 0, 0, 6322, 6323, 1, 0, 0,
		0, 6323, 793, 1, 0, 0, 0, 6324, 6326, 5, 381, 0, 0, 6325, 6327, 3, 952,
		476, 0, 6326, 6325, 1, 0, 0, 0, 6326, 6327, 1, 0, 0, 0, 6327, 795, 1, 0,
		0, 0, 6328, 6331, 3, 844, 422, 0, 6329, 6331, 3, 798, 399, 0, 6330, 6328,
		1, 0, 0, 0, 6330, 6329, 1, 0, 0, 0, 6331, 797, 1, 0, 0, 0, 6332, 6337,
		3, 800, 400, 0, 6333, 6334, 5, 3, 0, 0, 6334, 6336, 3, 800, 400, 0, 6335,
		6333, 1, 0, 0, 0, 6336, 6339, 1, 0, 0, 0, 6337, 6335, 1, 0, 0, 0, 6337,
		6338, 1, 0, 0, 0, 6338, 799, 1, 0, 0, 0, 6339, 6337, 1, 0, 0, 0, 6340,
		6341, 3, 1012, 506, 0, 6341, 6342, 5, 5, 0, 0, 6342, 6343, 3, 842, 421,
		0, 6343, 801, 1, 0, 0, 0, 6344, 6346, 3, 804, 402, 0, 6345, 6347, 3, 808,
		404, 0, 6346, 6345, 1, 0, 0, 0, 6346, 6347, 1, 0, 0, 0, 6347, 6349, 1,
		0, 0, 0, 6348, 6350, 5, 232, 0, 0, 6349, 6348, 1, 0, 0, 0, 6349, 6350,
		1, 0, 0, 0, 6350, 6351, 1, 0, 0, 0, 6351, 6353, 3, 786, 393, 0, 6352, 6354,
		3, 812, 406, 0, 6353, 6352, 1, 0, 0, 0, 6353, 6354, 1, 0, 0, 0, 6354, 6366,
		1, 0, 0, 0, 6355, 6357, 3, 806, 403, 0, 6356, 6358, 3, 808, 404, 0, 6357,
		6356, 1, 0, 0, 0, 6357, 6358, 1, 0, 0, 0, 6358, 6360, 1, 0, 0, 0, 6359,
		6361, 5, 232, 0, 0, 6360, 6359, 1, 0, 0, 0, 6360, 6361, 1, 0, 0, 0, 6361,
		6362, 1, 0, 0, 0, 6362, 6363, 3, 786, 393, 0, 6363, 6364, 3, 812, 406,
		0, 6364, 6366, 1, 0, 0, 0, 6365, 6344, 1, 0, 0, 0, 6365, 6355, 1, 0, 0,
		0, 6366, 803, 1, 0, 0, 0, 6367, 6374, 5, 222, 0, 0, 6368, 6369, 5, 205,
		0, 0, 6369, 6374, 5, 222, 0, 0, 6370, 6374, 5, 89, 0, 0, 6371, 6372, 5,
		89, 0, 0, 6372, 6374, 5, 222, 0, 0, 6373, 6367, 1, 0, 0, 0, 6373, 6368,
		1, 0, 0, 0, 6373, 6370, 1, 0, 0, 0, 6373, 6371, 1, 0, 0, 0, 6374, 805,
		1, 0, 0, 0, 6375, 6376, 5, 234, 0, 0, 6376, 6403, 5, 222, 0, 0, 6377, 6378,
		5, 368, 0, 0, 6378, 6403, 5, 222, 0, 0, 6379, 6380, 5, 172, 0, 0, 6380,
		6403, 5, 222, 0, 0, 6381, 6382, 5, 234, 0, 0, 6382, 6383, 5, 296, 0, 0,
		6383, 6403, 5, 222, 0, 0, 6384, 6385, 5, 368, 0, 0, 6385, 6386, 5, 296,
		0, 0, 6386, 6403, 5, 222, 0, 0, 6387, 6388, 5, 172, 0, 0, 6388, 6389, 5,
		296, 0, 0, 6389, 6403, 5, 222, 0, 0, 6390, 6391, 5, 234, 0, 0, 6391, 6392,
		5, 389, 0, 0, 6392, 6403, 5, 222, 0, 0, 6393, 6394, 5, 368, 0, 0, 6394,
		6395, 5, 389, 0, 0, 6395, 6403, 5, 222, 0, 0, 6396, 6397, 5, 234, 0, 0,
		6397, 6398, 5, 22, 0, 0, 6398, 6403, 5, 222, 0, 0, 6399, 6400, 5, 368,
		0, 0, 6400, 6401, 5, 22, 0, 0, 6401, 6403, 5, 222, 0, 0, 6402, 6375, 1,
		0, 0, 0, 6402, 6377, 1, 0, 0, 0, 6402, 6379, 1, 0, 0, 0, 6402, 6381, 1,
		0, 0, 0, 6402, 6384, 1, 0, 0, 0, 6402, 6387, 1, 0, 0, 0, 6402, 6390, 1,
		0, 0, 0, 6402, 6393, 1, 0, 0, 0, 6402, 6396, 1, 0, 0, 0, 6402, 6399, 1,
		0, 0, 0, 6403, 807, 1, 0, 0, 0, 6404, 6405, 5, 6, 0, 0, 6405, 6410, 3,
		1012, 506, 0, 6406, 6407, 5, 3, 0, 0, 6407, 6409, 3, 1012, 506, 0, 6408,
		6406, 1, 0, 0, 0, 6409, 6412, 1, 0, 0, 0, 6410, 6408, 1, 0, 0, 0, 6410,
		6411, 1, 0, 0, 0, 6411, 6413, 1, 0, 0, 0, 6412, 6410, 1, 0, 0, 0, 6413,
		6414, 5, 7, 0, 0, 6414, 6423, 1, 0, 0, 0, 6415, 6416, 5, 6, 0, 0, 6416,
		6417, 3, 1012, 506, 0, 6417, 6418, 5, 508, 0, 0, 6418, 6419, 3, 856, 428,
		0, 6419, 6420, 3, 920, 460, 0, 6420, 6421, 5, 7, 0, 0, 6421, 6423, 1, 0,
		0, 0, 6422, 6404, 1, 0, 0, 0, 6422, 6415, 1, 0, 0, 0, 6423, 809, 1, 0,
		0, 0, 6424, 6425, 3, 1020, 510, 0, 6425, 6426, 5, 490, 0, 0, 6426, 6427,
		3, 858, 429, 0, 6427, 811, 1, 0, 0, 0, 6428, 6429, 5, 287, 0, 0, 6429,
		6443, 3, 842, 421, 0, 6430, 6431, 5, 458, 0, 0, 6431, 6432, 5, 2, 0, 0,
		6432, 6437, 3, 1012, 506, 0, 6433, 6434, 5, 3, 0, 0, 6434, 6436, 3, 1012,
		506, 0, 6435, 6433, 1, 0, 0, 0, 6436, 6439, 1, 0, 0, 0, 6437, 6435, 1,
		0, 0, 0, 6437, 6438, 1, 0, 0, 0, 6438, 6440, 1, 0, 0, 0, 6439, 6437, 1,
		0, 0, 0, 6440, 6441, 5, 4, 0, 0, 6441, 6443, 1, 0, 0, 0, 6442, 6428, 1,
		0, 0, 0, 6442, 6430, 1, 0, 0, 0, 6443, 813, 1, 0, 0, 0, 6444, 6445, 5,
		2, 0, 0, 6445, 6450, 3, 1012, 506, 0, 6446, 6447, 5, 3, 0, 0, 6447, 6449,
		3, 1012, 506, 0, 6448, 6446, 1, 0, 0, 0, 6449, 6452, 1, 0, 0, 0, 6450,
		6448, 1, 0, 0, 0, 6450, 6451, 1, 0, 0, 0, 6451, 6453, 1, 0, 0, 0, 6452,
		6450, 1, 0, 0, 0, 6453, 6454, 5, 4, 0, 0, 6454, 815, 1, 0, 0, 0, 6455,
		6457, 5, 426, 0, 0, 6456, 6455, 1, 0, 0, 0, 6456, 6457, 1, 0, 0, 0, 6457,
		6458, 1, 0, 0, 0, 6458, 6459, 7, 34, 0, 0, 6459, 6460, 5, 2, 0, 0, 6460,
		6465, 3, 1020, 510, 0, 6461, 6462, 5, 3, 0, 0, 6462, 6464, 3, 1020, 510,
		0, 6463, 6461, 1, 0, 0, 0, 6464, 6467, 1, 0, 0, 0, 6465, 6463, 1, 0, 0,
		0, 6465, 6466, 1, 0, 0, 0, 6466, 6468, 1, 0, 0, 0, 6467, 6465, 1, 0, 0,
		0, 6468, 6469, 5, 4, 0, 0, 6469, 6477, 1, 0, 0, 0, 6470, 6472, 5, 426,
		0, 0, 6471, 6470, 1, 0, 0, 0, 6471, 6472, 1, 0, 0, 0, 6472, 6473, 1, 0,
		0, 0, 6473, 6474, 7, 34, 0, 0, 6474, 6477, 3, 1020, 510, 0, 6475, 6477,
		3, 818, 409, 0, 6476, 6456, 1, 0, 0, 0, 6476, 6471, 1, 0, 0, 0, 6476, 6475,
		1, 0, 0, 0, 6477, 817, 1, 0, 0, 0, 6478, 6479, 5, 300, 0, 0, 6479, 6480,
		5, 2, 0, 0, 6480, 6485, 3, 934, 467, 0, 6481, 6482, 5, 3, 0, 0, 6482, 6484,
		3, 934, 467, 0, 6483, 6481, 1, 0, 0, 0, 6484, 6487, 1, 0, 0, 0, 6485, 6483,
		1, 0, 0, 0, 6485, 6486, 1, 0, 0, 0, 6486, 6488, 1, 0, 0, 0, 6487, 6485,
		1, 0, 0, 0, 6488, 6489, 5, 4, 0, 0, 6489, 819, 1, 0, 0, 0, 6490, 6491,
		5, 422, 0, 0, 6491, 6492, 5, 2, 0, 0, 6492, 6497, 5, 516, 0, 0, 6493, 6494,
		5, 3, 0, 0, 6494, 6496, 5, 516, 0, 0, 6495, 6493, 1, 0, 0, 0, 6496, 6499,
		1, 0, 0, 0, 6497, 6495, 1, 0, 0, 0, 6497, 6498, 1, 0, 0, 0, 6498, 6500,
		1, 0, 0, 0, 6499, 6497, 1, 0, 0, 0, 6500, 6501, 5, 4, 0, 0, 6501, 821,
		1, 0, 0, 0, 6502, 6503, 5, 319, 0, 0, 6503, 6504, 3, 1012, 506, 0, 6504,
		6505, 5, 169, 0, 0, 6505, 6506, 3, 824, 412, 0, 6506, 823, 1, 0, 0, 0,
		6507, 6510, 3, 6, 3, 0, 6508, 6510, 5, 519, 0, 0, 6509, 6507, 1, 0, 0,
		0, 6509, 6508, 1, 0, 0, 0, 6510, 825, 1, 0, 0, 0, 6511, 6512, 5, 144, 0,
		0, 6512, 6524, 3, 1012, 506, 0, 6513, 6514, 5, 458, 0, 0, 6514, 6515, 5,
		515, 0, 0, 6515, 6521, 3, 1020, 510, 0, 6516, 6517, 5, 3, 0, 0, 6517, 6518,
		5, 515, 0, 0, 6518, 6520, 3, 1020, 510, 0, 6519, 6516, 1, 0, 0, 0, 6520,
		6523, 1, 0, 0, 0, 6521, 6519, 1, 0, 0, 0, 6521, 6522, 1, 0, 0, 0, 6522,
		6525, 1, 0, 0, 0, 6523, 6521, 1, 0, 0, 0, 6524, 6513, 1, 0, 0, 0, 6524,
		6525, 1, 0, 0, 0, 6525, 827, 1, 0, 0, 0, 6526, 6527, 7, 35, 0, 0, 6527,
		6528, 5, 319, 0, 0, 6528, 6529, 3, 1012, 506, 0, 6529, 829, 1, 0, 0, 0,
		6530, 6531, 5, 355, 0, 0, 6531, 6532, 5, 2, 0, 0, 6532, 6537, 5, 516, 0,
		0, 6533, 6534, 5, 3, 0, 0, 6534, 6536, 5, 516, 0, 0, 6535, 6533, 1, 0,
		0, 0, 6536, 6539, 1, 0, 0, 0, 6537, 6535, 1, 0, 0, 0, 6537, 6538, 1, 0,
		0, 0, 6538, 6540, 1, 0, 0, 0, 6539, 6537, 1, 0, 0, 0, 6540, 6541, 5, 4,
		0, 0, 6541, 831, 1, 0, 0, 0, 6542, 6543, 5, 2, 0, 0, 6543, 6548, 3, 834,
		417, 0, 6544, 6545, 5, 3, 0, 0, 6545, 6547, 3, 834, 417, 0, 6546, 6544,
		1, 0, 0, 0, 6547, 6550, 1, 0, 0, 0, 6548, 6546, 1, 0, 0, 0, 6548, 6549,
		1, 0, 0, 0, 6549, 6551, 1, 0, 0, 0, 6550, 6548, 1, 0, 0, 0, 6551, 6552,
		5, 4, 0, 0, 6552, 833, 1, 0, 0, 0, 6553, 6556, 3, 842, 421, 0, 6554, 6556,
		5, 115, 0, 0, 6555, 6553, 1, 0, 0, 0, 6555, 6554, 1, 0, 0, 0, 6556, 835,
		1, 0, 0, 0, 6557, 6562, 3, 838, 419, 0, 6558, 6559, 5, 3, 0, 0, 6559, 6561,
		3, 838, 419, 0, 6560, 6558, 1, 0, 0, 0, 6561, 6564, 1, 0, 0, 0, 6562, 6560,
		1, 0, 0, 0, 6562, 6563, 1, 0, 0, 0, 6563, 837, 1, 0, 0, 0, 6564, 6562,
		1, 0, 0, 0, 6565, 6566, 3, 842, 421, 0, 6566, 6567, 5, 8, 0, 0, 6567, 6568,
		3, 842, 421, 0, 6568, 839, 1, 0, 0, 0, 6569, 6570, 3, 842, 421, 0, 6570,
		6571, 5, 0, 0, 1, 6571, 841, 1, 0, 0, 0, 6572, 6574, 6, 421, -1, 0, 6573,
		6575, 5, 43, 0, 0, 6574, 6573, 1, 0, 0, 0, 6574, 6575, 1, 0, 0, 0, 6575,
		6576, 1, 0, 0, 0, 6576, 6580, 3, 846, 423, 0, 6577, 6578, 5, 278, 0, 0,
		6578, 6580, 3, 842, 421, 3, 6579, 6572, 1, 0, 0, 0, 6579, 6577, 1, 0, 0,
		0, 6580, 6589, 1, 0, 0, 0, 6581, 6582, 10, 2, 0, 0, 6582, 6583, 7, 36,
		0, 0, 6583, 6588, 3, 842, 421, 3, 6584, 6585, 10, 1, 0, 0, 6585, 6586,
		7, 37, 0, 0, 6586, 6588, 3, 842, 421, 2, 6587, 6581, 1, 0, 0, 0, 6587,
		6584, 1, 0, 0, 0, 6588, 6591, 1, 0, 0, 0, 6589, 6587, 1, 0, 0, 0, 6589,
		6590, 1, 0, 0, 0, 6590, 843, 1, 0, 0, 0, 6591, 6589, 1, 0, 0, 0, 6592,
		6597, 3, 842, 421, 0, 6593, 6594, 5, 3, 0, 0, 6594, 6596, 3, 842, 421,
		0, 6595, 6593, 1, 0, 0, 0, 6596, 6599, 1, 0, 0, 0, 6597, 6595, 1, 0, 0,
		0, 6597, 6598, 1, 0, 0, 0, 6598, 845, 1, 0, 0, 0, 6599, 6597, 1, 0, 0,
		0, 6600, 6601, 6, 423, -1, 0, 6601, 6602, 3, 848, 424, 0, 6602, 6621, 1,
		0, 0, 0, 6603, 6604, 10, 3, 0, 0, 6604, 6606, 5, 219, 0, 0, 6605, 6607,
		5, 278, 0, 0, 6606, 6605, 1, 0, 0, 0, 6606, 6607, 1, 0, 0, 0, 6607, 6608,
		1, 0, 0, 0, 6608, 6620, 5, 279, 0, 0, 6609, 6610, 10, 2, 0, 0, 6610, 6611,
		3, 974, 487, 0, 6611, 6612, 3, 848, 424, 0, 6612, 6620, 1, 0, 0, 0, 6613,
		6614, 10, 1, 0, 0, 6614, 6615, 3, 974, 487, 0, 6615, 6616, 5, 2, 0, 0,
		6616, 6617, 3, 746, 373, 0, 6617, 6618, 5, 4, 0, 0, 6618, 6620, 1, 0, 0,
		0, 6619, 6603, 1, 0, 0, 0, 6619, 6609, 1, 0, 0, 0, 6619, 6613, 1, 0, 0,
		0, 6620, 6623, 1, 0, 0, 0, 6621, 6619, 1, 0, 0, 0, 6621, 6622, 1, 0, 0,
		0, 6622, 847, 1, 0, 0, 0, 6623, 6621, 1, 0, 0, 0, 6624, 6626, 3, 854, 427,
		0, 6625, 6627, 3, 852, 426, 0, 6626, 6625, 1, 0, 0, 0, 6626, 6627, 1, 0,
		0, 0, 6627, 6630, 1, 0, 0, 0, 6628, 6630, 3, 850, 425, 0, 6629, 6624, 1,
		0, 0, 0, 6629, 6628, 1, 0, 0, 0, 6630, 849, 1, 0, 0, 0, 6631, 6632, 5,
		2, 0, 0, 6632, 6635, 3, 842, 421, 0, 6633, 6634, 5, 3, 0, 0, 6634, 6636,
		3, 842, 421, 0, 6635, 6633, 1, 0, 0, 0, 6636, 6637, 1, 0, 0, 0, 6637, 6635,
		1, 0, 0, 0, 6637, 6638, 1, 0, 0, 0, 6638, 6639, 1, 0, 0, 0, 6639, 6641,
		5, 4, 0, 0, 6640, 6642, 5, 278, 0, 0, 6641, 6640, 1, 0, 0, 0, 6641, 6642,
		1, 0, 0, 0, 6642, 6643, 1, 0, 0, 0, 6643, 6644, 5, 199, 0, 0, 6644, 6645,
		5, 2, 0, 0, 6645, 6646, 3, 746, 373, 0, 6646, 6647, 5, 4, 0, 0, 6647, 851,
		1, 0, 0, 0, 6648, 6650, 5, 278, 0, 0, 6649, 6648, 1, 0, 0, 0, 6649, 6650,
		1, 0, 0, 0, 6650, 6651, 1, 0, 0, 0, 6651, 6652, 5, 199, 0, 0, 6652, 6688,
		3, 918, 459, 0, 6653, 6655, 5, 278, 0, 0, 6654, 6653, 1, 0, 0, 0, 6654,
		6655, 1, 0, 0, 0, 6655, 6656, 1, 0, 0, 0, 6656, 6657, 5, 199, 0, 0, 6657,
		6688, 3, 916, 458, 0, 6658, 6660, 5, 278, 0, 0, 6659, 6658, 1, 0, 0, 0,
		6659, 6660, 1, 0, 0, 0, 6660, 6661, 1, 0, 0, 0, 6661, 6662, 5, 199, 0,
		0, 6662, 6663, 5, 2, 0, 0, 6663, 6664, 3, 746, 373, 0, 6664, 6665, 5, 4,
		0, 0, 6665, 6688, 1, 0, 0, 0, 6666, 6668, 5, 278, 0, 0, 6667, 6666, 1,
		0, 0, 0, 6667, 6668, 1, 0, 0, 0, 6668, 6669, 1, 0, 0, 0, 6669, 6670, 5,
		199, 0, 0, 6670, 6671, 5, 2, 0, 0, 6671, 6672, 3, 844, 422, 0, 6672, 6673,
		5, 4, 0, 0, 6673, 6688, 1, 0, 0, 0, 6674, 6676, 5, 278, 0, 0, 6675, 6674,
		1, 0, 0, 0, 6675, 6676, 1, 0, 0, 0, 6676, 6677, 1, 0, 0, 0, 6677, 6678,
		5, 41, 0, 0, 6678, 6679, 3, 854, 427, 0, 6679, 6680, 5, 21, 0, 0, 6680,
		6681, 3, 848, 424, 0, 6681, 6688, 1, 0, 0, 0, 6682, 6684, 5, 278, 0, 0,
		6683, 6682, 1, 0, 0, 0, 6683, 6684, 1, 0, 0, 0, 6684, 6685, 1, 0, 0, 0,
		6685, 6686, 7, 38, 0, 0, 6686, 6688, 3, 854, 427, 0, 6687, 6649, 1, 0,
		0, 0, 6687, 6654, 1, 0, 0, 0, 6687, 6659, 1, 0, 0, 0, 6687, 6667, 1, 0,
		0, 0, 6687, 6675, 1, 0, 0, 0, 6687, 6683, 1, 0, 0, 0, 6688, 853, 1, 0,
		0, 0, 6689, 6690, 6, 427, -1, 0, 6690, 6691, 3, 856, 428, 0, 6691, 6718,
		1, 0, 0, 0, 6692, 6693, 10, 8, 0, 0, 6693, 6694, 5, 509, 0, 0, 6694, 6717,
		3, 854, 427, 9, 6695, 6696, 10, 7, 0, 0, 6696, 6697, 7, 39, 0, 0, 6697,
		6717, 3, 854, 427, 8, 6698, 6699, 10, 6, 0, 0, 6699, 6700, 7, 40, 0, 0,
		6700, 6717, 3, 854, 427, 7, 6701, 6702, 10, 5, 0, 0, 6702, 6703, 5, 507,
		0, 0, 6703, 6717, 3, 854, 427, 6, 6704, 6705, 10, 4, 0, 0, 6705, 6706,
		5, 508, 0, 0, 6706, 6717, 3, 854, 427, 5, 6707, 6708, 10, 3, 0, 0, 6708,
		6709, 5, 511, 0, 0, 6709, 6717, 3, 854, 427, 4, 6710, 6711, 10, 2, 0, 0,
		6711, 6712, 5, 512, 0, 0, 6712, 6717, 3, 854, 427, 3, 6713, 6714, 10, 1,
		0, 0, 6714, 6715, 5, 513, 0, 0, 6715, 6717, 3, 854, 427, 2, 6716, 6692,
		1, 0, 0, 0, 6716, 6695, 1, 0, 0, 0, 6716, 6698, 1, 0, 0, 0, 6716, 6701,
		1, 0, 0, 0, 6716, 6704, 1, 0, 0, 0, 6716, 6707, 1, 0, 0, 0, 6716, 6710,
		1, 0, 0, 0, 6716, 6713, 1, 0, 0, 0, 6717, 6720, 1, 0, 0, 0, 6718, 6716,
		1, 0, 0, 0, 6718, 6719, 1, 0, 0, 0, 6719, 855, 1, 0, 0, 0, 6720, 6718,
		1, 0, 0, 0, 6721, 6722, 6, 428, -1, 0, 6722, 6827, 3, 864, 432, 0, 6723,
		6827, 3, 866, 433, 0, 6724, 6725, 5, 121, 0, 0, 6725, 6726, 5, 2, 0, 0,
		6726, 6727, 3, 844, 422, 0, 6727, 6728, 5, 4, 0, 0, 6728, 6827, 1, 0, 0,
		0, 6729, 6827, 3, 860, 430, 0, 6730, 6731, 5, 9, 0, 0, 6731, 6732, 5, 162,
		0, 0, 6732, 6733, 3, 860, 430, 0, 6733, 6734, 5, 10, 0, 0, 6734, 6827,
		1, 0, 0, 0, 6735, 6827, 3, 858, 429, 0, 6736, 6827, 3, 868, 434, 0, 6737,
		6738, 7, 41, 0, 0, 6738, 6827, 3, 856, 428, 18, 6739, 6740, 5, 505, 0,
		0, 6740, 6827, 3, 856, 428, 17, 6741, 6742, 5, 2, 0, 0, 6742, 6743, 3,
		842, 421, 0, 6743, 6744, 5, 4, 0, 0, 6744, 6827, 1, 0, 0, 0, 6745, 6746,
		5, 145, 0, 0, 6746, 6747, 5, 2, 0, 0, 6747, 6748, 3, 746, 373, 0, 6748,
		6749, 5, 4, 0, 0, 6749, 6827, 1, 0, 0, 0, 6750, 6827, 3, 758, 379, 0, 6751,
		6752, 5, 59, 0, 0, 6752, 6753, 5, 2, 0, 0, 6753, 6754, 3, 842, 421, 0,
		6754, 6755, 5, 27, 0, 0, 6755, 6756, 3, 988, 494, 0, 6756, 6757, 5, 4,
		0, 0, 6757, 6827, 1, 0, 0, 0, 6758, 6759, 5, 85, 0, 0, 6759, 6760, 5, 2,
		0, 0, 6760, 6761, 3, 842, 421, 0, 6761, 6762, 5, 3, 0, 0, 6762, 6763, 3,
		988, 494, 0, 6763, 6764, 5, 4, 0, 0, 6764, 6827, 1, 0, 0, 0, 6765, 6766,
		5, 58, 0, 0, 6766, 6768, 3, 842, 421, 0, 6767, 6769, 3, 878, 439, 0, 6768,
		6767, 1, 0, 0, 0, 6769, 6770, 1, 0, 0, 0, 6770, 6768, 1, 0, 0, 0, 6770,
		6771, 1, 0, 0, 0, 6771, 6774, 1, 0, 0, 0, 6772, 6773, 5, 134, 0, 0, 6773,
		6775, 3, 842, 421, 0, 6774, 6772, 1, 0, 0, 0, 6774, 6775, 1, 0, 0, 0, 6775,
		6776, 1, 0, 0, 0, 6776, 6777, 5, 137, 0, 0, 6777, 6827, 1, 0, 0, 0, 6778,
		6780, 5, 58, 0, 0, 6779, 6781, 3, 878, 439, 0, 6780, 6779, 1, 0, 0, 0,
		6781, 6782, 1, 0, 0, 0, 6782, 6780, 1, 0, 0, 0, 6782, 6783, 1, 0, 0, 0,
		6783, 6786, 1, 0, 0, 0, 6784, 6785, 5, 134, 0, 0, 6785, 6787, 3, 842, 421,
		0, 6786, 6784, 1, 0, 0, 0, 6786, 6787, 1, 0, 0, 0, 6787, 6788, 1, 0, 0,
		0, 6788, 6789, 5, 137, 0, 0, 6789, 6827, 1, 0, 0, 0, 6790, 6792, 3, 990,
		495, 0, 6791, 6790, 1, 0, 0, 0, 6791, 6792, 1, 0, 0, 0, 6792, 6793, 1,
		0, 0, 0, 6793, 6795, 5, 6, 0, 0, 6794, 6796, 3, 844, 422, 0, 6795, 6794,
		1, 0, 0, 0, 6795, 6796, 1, 0, 0, 0, 6796, 6797, 1, 0, 0, 0, 6797, 6827,
		5, 7, 0, 0, 6798, 6799, 3, 992, 496, 0, 6799, 6801, 5, 9, 0, 0, 6800, 6802,
		3, 836, 418, 0, 6801, 6800, 1, 0, 0, 0, 6801, 6802, 1, 0, 0, 0, 6802, 6803,
		1, 0, 0, 0, 6803, 6804, 5, 10, 0, 0, 6804, 6827, 1, 0, 0, 0, 6805, 6806,
		5, 249, 0, 0, 6806, 6808, 5, 9, 0, 0, 6807, 6809, 3, 836, 418, 0, 6808,
		6807, 1, 0, 0, 0, 6808, 6809, 1, 0, 0, 0, 6809, 6810, 1, 0, 0, 0, 6810,
		6827, 5, 10, 0, 0, 6811, 6814, 3, 1012, 506, 0, 6812, 6814, 3, 1018, 509,
		0, 6813, 6811, 1, 0, 0, 0, 6813, 6812, 1, 0, 0, 0, 6814, 6815, 1, 0, 0,
		0, 6815, 6816, 5, 514, 0, 0, 6816, 6817, 3, 842, 421, 0, 6817, 6827, 1,
		0, 0, 0, 6818, 6819, 3, 1018, 509, 0, 6819, 6820, 5, 514, 0, 0, 6820, 6822,
		5, 2, 0, 0, 6821, 6823, 3, 844, 422, 0, 6822, 6821, 1, 0, 0, 0, 6822, 6823,
		1, 0, 0, 0, 6823, 6824, 1, 0, 0, 0, 6824, 6825, 5, 4, 0, 0, 6825, 6827,
		1, 0, 0, 0, 6826, 6721, 1, 0, 0, 0, 6826, 6723, 1, 0, 0, 0, 6826, 6724,
		1, 0, 0, 0, 6826, 6729, 1, 0, 0, 0, 6826, 6730, 1, 0, 0, 0, 6826, 6735,
		1, 0, 0, 0, 6826, 6736, 1, 0, 0, 0, 6826, 6737, 1, 0, 0, 0, 6826, 6739,
		1, 0, 0, 0, 6826, 6741, 1, 0, 0, 0, 6826, 6745, 1, 0, 0, 0, 6826, 6750,
		1, 0, 0, 0, 6826, 6751, 1, 0, 0, 0, 6826, 6758, 1, 0, 0, 0, 6826, 6765,
		1, 0, 0, 0, 6826, 6778, 1, 0, 0, 0, 6826, 6791, 1, 0, 0, 0, 6826, 6798,
		1, 0, 0, 0, 6826, 6805, 1, 0, 0, 0, 6826, 6813, 1, 0, 0, 0, 6826, 6818,
		1, 0, 0, 0, 6827, 6869, 1, 0, 0, 0, 6828, 6829, 10, 19, 0, 0, 6829, 6830,
		5, 534, 0, 0, 6830, 6868, 3, 856, 428, 20, 6831, 6833, 10, 1, 0, 0, 6832,
		6834, 5, 278, 0, 0, 6833, 6832, 1, 0, 0, 0, 6833, 6834, 1, 0, 0, 0, 6834,
		6835, 1, 0, 0, 0, 6835, 6836, 5, 253, 0, 0, 6836, 6868, 3, 856, 428, 2,
		6837, 6838, 10, 23, 0, 0, 6838, 6841, 5, 72, 0, 0, 6839, 6842, 3, 1012,
		506, 0, 6840, 6842, 3, 970, 485, 0, 6841, 6839, 1, 0, 0, 0, 6841, 6840,
		1, 0, 0, 0, 6842, 6868, 1, 0, 0, 0, 6843, 6847, 10, 20, 0, 0, 6844, 6848,
		5, 526, 0, 0, 6845, 6846, 5, 1, 0, 0, 6846, 6848, 3, 1012, 506, 0, 6847,
		6844, 1, 0, 0, 0, 6847, 6845, 1, 0, 0, 0, 6848, 6868, 1, 0, 0, 0, 6849,
		6850, 10, 6, 0, 0, 6850, 6851, 5, 6, 0, 0, 6851, 6852, 3, 854, 427, 0,
		6852, 6853, 5, 7, 0, 0, 6853, 6868, 1, 0, 0, 0, 6854, 6855, 10, 5, 0, 0,
		6855, 6857, 5, 6, 0, 0, 6856, 6858, 5, 516, 0, 0, 6857, 6856, 1, 0, 0,
		0, 6857, 6858, 1, 0, 0, 0, 6858, 6859, 1, 0, 0, 0, 6859, 6861, 5, 8, 0,
		0, 6860, 6862, 5, 516, 0, 0, 6861, 6860, 1, 0, 0, 0, 6861, 6862, 1, 0,
		0, 0, 6862, 6863, 1, 0, 0, 0, 6863, 6868, 5, 7, 0, 0, 6864, 6865, 10, 4,
		0, 0, 6865, 6866, 5, 514, 0, 0, 6866, 6868, 3, 970, 485, 0, 6867, 6828,
		1, 0, 0, 0, 6867, 6831, 1, 0, 0, 0, 6867, 6837, 1, 0, 0, 0, 6867, 6843,
		1, 0, 0, 0, 6867, 6849, 1, 0, 0, 0, 6867, 6854, 1, 0, 0, 0, 6867, 6864,
		1, 0, 0, 0, 6868, 6871, 1, 0, 0, 0, 6869, 6867, 1, 0, 0, 0, 6869, 6870,
		1, 0, 0, 0, 6870, 857, 1, 0, 0, 0, 6871, 6869, 1, 0, 0, 0, 6872, 6883,
		3, 1032, 516, 0, 6873, 6883, 5, 279, 0, 0, 6874, 6883, 3, 976, 488, 0,
		6875, 6876, 7, 42, 0, 0, 6876, 6883, 3, 970, 485, 0, 6877, 6883, 3, 970,
		485, 0, 6878, 6883, 3, 978, 489, 0, 6879, 6883, 3, 986, 493, 0, 6880, 6883,
		3, 972, 486, 0, 6881, 6883, 5, 299, 0, 0, 6882, 6872, 1, 0, 0, 0, 6882,
		6873, 1, 0, 0, 0, 6882, 6874, 1, 0, 0, 0, 6882, 6875, 1, 0, 0, 0, 6882,
		6877, 1, 0, 0, 0, 6882, 6878, 1, 0, 0, 0, 6882, 6879, 1, 0, 0, 0, 6882,
		6880, 1, 0, 0, 0, 6882, 6881, 1, 0, 0, 0, 6883, 859, 1, 0, 0, 0, 6884,
		6885, 5, 149, 0, 0, 6885, 6886, 5, 2, 0, 0, 6886, 6887, 3, 1012, 506, 0,
		6887, 6888, 5, 169, 0, 0, 6888, 6889, 3, 854, 427, 0, 6889, 6890, 5, 4,
		0, 0, 6890, 6957, 1, 0, 0, 0, 6891, 6892, 5, 180, 0, 0, 6892, 6901, 5,
		2, 0, 0, 6893, 6898, 3, 842, 421, 0, 6894, 6895, 5, 3, 0, 0, 6895, 6897,
		3, 842, 421, 0, 6896, 6894, 1, 0, 0, 0, 6897, 6900, 1, 0, 0, 0, 6898, 6896,
		1, 0, 0, 0, 6898, 6899, 1, 0, 0, 0, 6899, 6902, 1, 0, 0, 0, 6900, 6898,
		1, 0, 0, 0, 6901, 6893, 1, 0, 0, 0, 6901, 6902, 1, 0, 0, 0, 6902, 6903,
		1, 0, 0, 0, 6903, 6957, 5, 4, 0, 0, 6904, 6905, 5, 181, 0, 0, 6905, 6914,
		5, 2, 0, 0, 6906, 6911, 3, 842, 421, 0, 6907, 6908, 5, 3, 0, 0, 6908, 6910,
		3, 842, 421, 0, 6909, 6907, 1, 0, 0, 0, 6910, 6913, 1, 0, 0, 0, 6911, 6909,
		1, 0, 0, 0, 6911, 6912, 1, 0, 0, 0, 6912, 6915, 1, 0, 0, 0, 6913, 6911,
		1, 0, 0, 0, 6914, 6906, 1, 0, 0, 0, 6914, 6915, 1, 0, 0, 0, 6915, 6916,
		1, 0, 0, 0, 6916, 6957, 5, 4, 0, 0, 6917, 6957, 3, 870, 435, 0, 6918, 6957,
		3, 872, 436, 0, 6919, 6957, 3, 874, 437, 0, 6920, 6922, 3, 862, 431, 0,
		6921, 6923, 3, 880, 440, 0, 6922, 6921, 1, 0, 0, 0, 6922, 6923, 1, 0, 0,
		0, 6923, 6957, 1, 0, 0, 0, 6924, 6925, 3, 876, 438, 0, 6925, 6926, 3, 880,
		440, 0, 6926, 6957, 1, 0, 0, 0, 6927, 6928, 5, 437, 0, 0, 6928, 6937, 5,
		2, 0, 0, 6929, 6934, 3, 842, 421, 0, 6930, 6931, 5, 3, 0, 0, 6931, 6933,
		3, 842, 421, 0, 6932, 6930, 1, 0, 0, 0, 6933, 6936, 1, 0, 0, 0, 6934, 6932,
		1, 0, 0, 0, 6934, 6935, 1, 0, 0, 0, 6935, 6938, 1, 0, 0, 0, 6936, 6934,
		1, 0, 0, 0, 6937, 6929, 1, 0, 0, 0, 6937, 6938, 1, 0, 0, 0, 6938, 6939,
		1, 0, 0, 0, 6939, 6957, 5, 4, 0, 0, 6940, 6941, 3, 1006, 503, 0, 6941,
		6950, 5, 2, 0, 0, 6942, 6947, 3, 842, 421, 0, 6943, 6944, 5, 3, 0, 0, 6944,
		6946, 3, 842, 421, 0, 6945, 6943, 1, 0, 0, 0, 6946, 6949, 1, 0, 0, 0, 6947,
		6945, 1, 0, 0, 0, 6947, 6948, 1, 0, 0, 0, 6948, 6951, 1, 0, 0, 0, 6949,
		6947, 1, 0, 0, 0, 6950, 6942, 1, 0, 0, 0, 6950, 6951, 1, 0, 0, 0, 6951,
		6952, 1, 0, 0, 0, 6952, 6954, 5, 4, 0, 0, 6953, 6955, 3, 880, 440, 0, 6954,
		6953, 1, 0, 0, 0, 6954, 6955, 1, 0, 0, 0, 6955, 6957, 1, 0, 0, 0, 6956,
		6884, 1, 0, 0, 0, 6956, 6891, 1, 0, 0, 0, 6956, 6904, 1, 0, 0, 0, 6956,
		6917, 1, 0, 0, 0, 6956, 6918, 1, 0, 0, 0, 6956, 6919, 1, 0, 0, 0, 6956,
		6920, 1, 0, 0, 0, 6956, 6924, 1, 0, 0, 0, 6956, 6927, 1, 0, 0, 0, 6956,
		6940, 1, 0, 0, 0, 6957, 861, 1, 0, 0, 0, 6958, 6959, 5, 34, 0, 0, 6959,
		6961, 5, 2, 0, 0, 6960, 6962, 3, 778, 389, 0, 6961, 6960, 1, 0, 0, 0, 6961,
		6962, 1, 0, 0, 0, 6962, 6963, 1, 0, 0, 0, 6963, 6964, 3, 842, 421, 0, 6964,
		6965, 5, 4, 0, 0, 6965, 7084, 1, 0, 0, 0, 6966, 6967, 5, 87, 0, 0, 6967,
		6969, 5, 2, 0, 0, 6968, 6970, 5, 500, 0, 0, 6969, 6968, 1, 0, 0, 0, 6969,
		6970, 1, 0, 0, 0, 6970, 6971, 1, 0, 0, 0, 6971, 7084, 5, 4, 0, 0, 6972,
		6973, 5, 87, 0, 0, 6973, 6978, 5, 2, 0, 0, 6974, 6976, 3, 778, 389, 0,
		6975, 6977, 3, 808, 404, 0, 6976, 6975, 1, 0, 0, 0, 6976, 6977, 1, 0, 0,
		0, 6977, 6979, 1, 0, 0, 0, 6978, 6974, 1, 0, 0, 0, 6978, 6979, 1, 0, 0,
		0, 6979, 6988, 1, 0, 0, 0, 6980, 6985, 3, 842, 421, 0, 6981, 6982, 5, 3,
		0, 0, 6982, 6984, 3, 842, 421, 0, 6983, 6981, 1, 0, 0, 0, 6984, 6987, 1,
		0, 0, 0, 6985, 6983, 1, 0, 0, 0, 6985, 6986, 1, 0, 0, 0, 6986, 6989, 1,
		0, 0, 0, 6987, 6985, 1, 0, 0, 0, 6988, 6980, 1, 0, 0, 0, 6988, 6989, 1,
		0, 0, 0, 6989, 6990, 1, 0, 0, 0, 6990, 7084, 5, 4, 0, 0, 6991, 6992, 5,
		255, 0, 0, 6992, 6994, 5, 2, 0, 0, 6993, 6995, 3, 778, 389, 0, 6994, 6993,
		1, 0, 0, 0, 6994, 6995, 1, 0, 0, 0, 6995, 6996, 1, 0, 0, 0, 6996, 6997,
		3, 842, 421, 0, 6997, 6998, 5, 4, 0, 0, 6998, 7084, 1, 0, 0, 0, 6999, 7000,
		5, 260, 0, 0, 7000, 7002, 5, 2, 0, 0, 7001, 7003, 3, 778, 389, 0, 7002,
		7001, 1, 0, 0, 0, 7002, 7003, 1, 0, 0, 0, 7003, 7004, 1, 0, 0, 0, 7004,
		7005, 3, 842, 421, 0, 7005, 7006, 5, 4, 0, 0, 7006, 7084, 1, 0, 0, 0, 7007,
		7008, 5, 413, 0, 0, 7008, 7010, 5, 2, 0, 0, 7009, 7011, 3, 778, 389, 0,
		7010, 7009, 1, 0, 0, 0, 7010, 7011, 1, 0, 0, 0, 7011, 7012, 1, 0, 0, 0,
		7012, 7013, 3, 842, 421, 0, 7013, 7014, 5, 4, 0, 0, 7014, 7084, 1, 0, 0,
		0, 7015, 7016, 5, 25, 0, 0, 7016, 7018, 5, 2, 0, 0, 7017, 7019, 3, 778,
		389, 0, 7018, 7017, 1, 0, 0, 0, 7018, 7019, 1, 0, 0, 0, 7019, 7020, 1,
		0, 0, 0, 7020, 7031, 3, 842, 421, 0, 7021, 7022, 5, 295, 0, 0, 7022, 7023,
		5, 55, 0, 0, 7023, 7028, 3, 762, 381, 0, 7024, 7025, 5, 3, 0, 0, 7025,
		7027, 3, 762, 381, 0, 7026, 7024, 1, 0, 0, 0, 7027, 7030, 1, 0, 0, 0, 7028,
		7026, 1, 0, 0, 0, 7028, 7029, 1, 0, 0, 0, 7029, 7032, 1, 0, 0, 0, 7030,
		7028, 1, 0, 0, 0, 7031, 7021, 1, 0, 0, 0, 7031, 7032, 1, 0, 0, 0, 7032,
		7033, 1, 0, 0, 0, 7033, 7034, 5, 4, 0, 0, 7034, 7084, 1, 0, 0, 0, 7035,
		7036, 5, 26, 0, 0, 7036, 7037, 5, 2, 0, 0, 7037, 7048, 3, 842, 421, 0,
		7038, 7039, 5, 295, 0, 0, 7039, 7040, 5, 55, 0, 0, 7040, 7045, 3, 762,
		381, 0, 7041, 7042, 5, 3, 0, 0, 7042, 7044, 3, 762, 381, 0, 7043, 7041,
		1, 0, 0, 0, 7044, 7047, 1, 0, 0, 0, 7045, 7043, 1, 0, 0, 0, 7045, 7046,
		1, 0, 0, 0, 7046, 7049, 1, 0, 0, 0, 7047, 7045, 1, 0, 0, 0, 7048, 7038,
		1, 0, 0, 0, 7048, 7049, 1, 0, 0, 0, 7049, 7050, 1, 0, 0, 0, 7050, 7051,
		5, 4, 0, 0, 7051, 7084, 1, 0, 0, 0, 7052, 7053, 5, 182, 0, 0, 7053, 7055,
		5, 2, 0, 0, 7054, 7056, 3, 778, 389, 0, 7055, 7054, 1, 0, 0, 0, 7055, 7056,
		1, 0, 0, 0, 7056, 7057, 1, 0, 0, 0, 7057, 7062, 3, 842, 421, 0, 7058, 7059,
		5, 3, 0, 0, 7059, 7061, 3, 842, 421, 0, 7060, 7058, 1, 0, 0, 0, 7061, 7064,
		1, 0, 0, 0, 7062, 7060, 1, 0, 0, 0, 7062, 7063, 1, 0, 0, 0, 7063, 7075,
		1, 0, 0, 0, 7064, 7062, 1, 0, 0, 0, 7065, 7066, 5, 295, 0, 0, 7066, 7067,
		5, 55, 0, 0, 7067, 7072, 3, 762, 381, 0, 7068, 7069, 5, 3, 0, 0, 7069,
		7071, 3, 762, 381, 0, 7070, 7068, 1, 0, 0, 0, 7071, 7074, 1, 0, 0, 0, 7072,
		7070, 1, 0, 0, 0, 7072, 7073, 1, 0, 0, 0, 7073, 7076, 1, 0, 0, 0, 7074,
		7072, 1, 0, 0, 0, 7075, 7065, 1, 0, 0, 0, 7075, 7076, 1, 0, 0, 0, 7076,
		7079, 1, 0, 0, 0, 7077, 7078, 5, 390, 0, 0, 7078, 7080, 3, 842, 421, 0,
		7079, 7077, 1, 0, 0, 0, 7079, 7080, 1, 0, 0, 0, 7080, 7081, 1, 0, 0, 0,
		7081, 7082, 5, 4, 0, 0, 7082, 7084, 1, 0, 0, 0, 7083, 6958, 1, 0, 0, 0,
		7083, 6966, 1, 0, 0, 0, 7083, 6972, 1, 0, 0, 0, 7083, 6991, 1, 0, 0, 0,
		7083, 6999, 1, 0, 0, 0, 7083, 7007, 1, 0, 0, 0, 7083, 7015, 1, 0, 0, 0,
		7083, 7035, 1, 0, 0, 0, 7083, 7052, 1, 0, 0, 0, 7084, 863, 1, 0, 0, 0,
		7085, 7086, 5, 515, 0, 0, 7086, 7087, 3, 1020, 510, 0, 7087, 865, 1, 0,
		0, 0, 7088, 7089, 5, 515, 0, 0, 7089, 7093, 5, 515, 0, 0, 7090, 7091, 3,
		962, 481, 0, 7091, 7092, 5, 1, 0, 0, 7092, 7094, 1, 0, 0, 0, 7093, 7090,
		1, 0, 0, 0, 7093, 7094, 1, 0, 0, 0, 7094, 7095, 1, 0, 0, 0, 7095, 7096,
		3, 1012, 506, 0, 7096, 867, 1, 0, 0, 0, 7097, 7098, 3, 1012, 506, 0, 7098,
		869, 1, 0, 0, 0, 7099, 7100, 5, 60, 0, 0, 7100, 7101, 5, 2, 0, 0, 7101,
		7127, 5, 4, 0, 0, 7102, 7103, 5, 102, 0, 0, 7103, 7104, 5, 2, 0, 0, 7104,
		7127, 5, 4, 0, 0, 7105, 7106, 5, 384, 0, 0, 7106, 7107, 5, 2, 0, 0, 7107,
		7127, 5, 4, 0, 0, 7108, 7109, 5, 456, 0, 0, 7109, 7110, 5, 2, 0, 0, 7110,
		7127, 5, 4, 0, 0, 7111, 7114, 5, 99, 0, 0, 7112, 7113, 5, 2, 0, 0, 7113,
		7115, 5, 4, 0, 0, 7114, 7112, 1, 0, 0, 0, 7114, 7115, 1, 0, 0, 0, 7115,
		7127, 1, 0, 0, 0, 7116, 7119, 5, 96, 0, 0, 7117, 7118, 5, 2, 0, 0, 7118,
		7120, 5, 4, 0, 0, 7119, 7117, 1, 0, 0, 0, 7119, 7120, 1, 0, 0, 0, 7120,
		7127, 1, 0, 0, 0, 7121, 7124, 5, 95, 0, 0, 7122, 7123, 5, 2, 0, 0, 7123,
		7125, 5, 4, 0, 0, 7124, 7122, 1, 0, 0, 0, 7124, 7125, 1, 0, 0, 0, 7125,
		7127, 1, 0, 0, 0, 7126, 7099, 1, 0, 0, 0, 7126, 7102, 1, 0, 0, 0, 7126,
		7105, 1, 0, 0, 0, 7126, 7108, 1, 0, 0, 0, 7126, 7111, 1, 0, 0, 0, 7126,
		7116, 1, 0, 0, 0, 7126, 7121, 1, 0, 0, 0, 7127, 871, 1, 0, 0, 0, 7128,
		7131, 5, 94, 0, 0, 7129, 7130, 5, 2, 0, 0, 7130, 7132, 5, 4, 0, 0, 7131,
		7129, 1, 0, 0, 0, 7131, 7132, 1, 0, 0, 0, 7132, 7157, 1, 0, 0, 0, 7133,
		7136, 5, 97, 0, 0, 7134, 7135, 5, 2, 0, 0, 7135, 7137, 5, 4, 0, 0, 7136,
		7134, 1, 0, 0, 0, 7136, 7137, 1, 0, 0, 0, 7137, 7157, 1, 0, 0, 0, 7138,
		7144, 5, 98, 0, 0, 7139, 7141, 5, 2, 0, 0, 7140, 7142, 5, 516, 0, 0, 7141,
		7140, 1, 0, 0, 0, 7141, 7142, 1, 0, 0, 0, 7142, 7143, 1, 0, 0, 0, 7143,
		7145, 5, 4, 0, 0, 7144, 7139, 1, 0, 0, 0, 7144, 7145, 1, 0, 0, 0, 7145,
		7157, 1, 0, 0, 0, 7146, 7149, 5, 242, 0, 0, 7147, 7148, 5, 2, 0, 0, 7148,
		7150, 5, 4, 0, 0, 7149, 7147, 1, 0, 0, 0, 7149, 7150, 1, 0, 0, 0, 7150,
		7157, 1, 0, 0, 0, 7151, 7154, 5, 243, 0, 0, 7152, 7153, 5, 2, 0, 0, 7153,
		7155, 5, 4, 0, 0, 7154, 7152, 1, 0, 0, 0, 7154, 7155, 1, 0, 0, 0, 7155,
		7157, 1, 0, 0, 0, 7156, 7128, 1, 0, 0, 0, 7156, 7133, 1, 0, 0, 0, 7156,
		7138, 1, 0, 0, 0, 7156, 7146, 1, 0, 0, 0, 7156, 7151, 1, 0, 0, 0, 7157,
		873, 1, 0, 0, 0, 7158, 7159, 5, 64, 0, 0, 7159, 7160, 5, 2, 0, 0, 7160,
		7161, 3, 842, 421, 0, 7161, 7162, 5, 4, 0, 0, 7162, 7300, 1, 0, 0, 0, 7163,
		7164, 5, 106, 0, 0, 7164, 7165, 5, 2, 0, 0, 7165, 7166, 3, 842, 421, 0,
		7166, 7167, 5, 4, 0, 0, 7167, 7300, 1, 0, 0, 0, 7168, 7169, 5, 190, 0,
		0, 7169, 7170, 5, 2, 0, 0, 7170, 7171, 3, 842, 421, 0, 7171, 7172, 5, 4,
		0, 0, 7172, 7300, 1, 0, 0, 0, 7173, 7174, 5, 194, 0, 0, 7174, 7183, 5,
		2, 0, 0, 7175, 7180, 3, 842, 421, 0, 7176, 7177, 5, 3, 0, 0, 7177, 7179,
		3, 842, 421, 0, 7178, 7176, 1, 0, 0, 0, 7179, 7182, 1, 0, 0, 0, 7180, 7178,
		1, 0, 0, 0, 7180, 7181, 1, 0, 0, 0, 7181, 7184, 1, 0, 0, 0, 7182, 7180,
		1, 0, 0, 0, 7183, 7175, 1, 0, 0, 0, 7183, 7184, 1, 0, 0, 0, 7184, 7185,
		1, 0, 0, 0, 7185, 7300, 5, 4, 0, 0, 7186, 7187, 5, 234, 0, 0, 7187, 7188,
		5, 2, 0, 0, 7188, 7189, 3, 842, 421, 0, 7189, 7190, 5, 3, 0, 0, 7190, 7191,
		3, 842, 421, 0, 7191, 7192, 5, 4, 0, 0, 7192, 7300, 1, 0, 0, 0, 7193, 7194,
		5, 237, 0, 0, 7194, 7195, 5, 2, 0, 0, 7195, 7196, 3, 842, 421, 0, 7196,
		7197, 5, 3, 0, 0, 7197, 7198, 3, 842, 421, 0, 7198, 7199, 5, 4, 0, 0, 7199,
		7300, 1, 0, 0, 0, 7200, 7201, 5, 261, 0, 0, 7201, 7202, 5, 2, 0, 0, 7202,
		7203, 3, 842, 421, 0, 7203, 7204, 5, 4, 0, 0, 7204, 7300, 1, 0, 0, 0, 7205,
		7206, 5, 265, 0, 0, 7206, 7207, 5, 2, 0, 0, 7207, 7208, 3, 842, 421, 0,
		7208, 7209, 5, 3, 0, 0, 7209, 7210, 3, 842, 421, 0, 7210, 7211, 5, 4, 0,
		0, 7211, 7300, 1, 0, 0, 0, 7212, 7213, 5, 268, 0, 0, 7213, 7214, 5, 2,
		0, 0, 7214, 7215, 3, 842, 421, 0, 7215, 7216, 5, 4, 0, 0, 7216, 7300, 1,
		0, 0, 0, 7217, 7218, 5, 334, 0, 0, 7218, 7219, 5, 2, 0, 0, 7219, 7220,
		3, 842, 421, 0, 7220, 7221, 5, 4, 0, 0, 7221, 7300, 1, 0, 0, 0, 7222, 7223,
		5, 347, 0, 0, 7223, 7224, 5, 2, 0, 0, 7224, 7225, 3, 842, 421, 0, 7225,
		7226, 5, 3, 0, 0, 7226, 7227, 3, 842, 421, 0, 7227, 7228, 5, 4, 0, 0, 7228,
		7300, 1, 0, 0, 0, 7229, 7230, 5, 353, 0, 0, 7230, 7239, 5, 2, 0, 0, 7231,
		7236, 3, 842, 421, 0, 7232, 7233, 5, 3, 0, 0, 7233, 7235, 3, 842, 421,
		0, 7234, 7232, 1, 0, 0, 0, 7235, 7238, 1, 0, 0, 0, 7236, 7234, 1, 0, 0,
		0, 7236, 7237, 1, 0, 0, 0, 7237, 7240, 1, 0, 0, 0, 7238, 7236, 1, 0, 0,
		0, 7239, 7231, 1, 0, 0, 0, 7239, 7240, 1, 0, 0, 0, 7240, 7241, 1, 0, 0,
		0, 7241, 7300, 5, 4, 0, 0, 7242, 7243, 5, 368, 0, 0, 7243, 7244, 5, 2,
		0, 0, 7244, 7245, 3, 842, 421, 0, 7245, 7246, 5, 3, 0, 0, 7246, 7247, 3,
		842, 421, 0, 7247, 7248, 5, 4, 0, 0, 7248, 7300, 1, 0, 0, 0, 7249, 7250,
		5, 369, 0, 0, 7250, 7251, 5, 2, 0, 0, 7251, 7252, 3, 842, 421, 0, 7252,
		7253, 5, 3, 0, 0, 7253, 7254, 3, 842, 421, 0, 7254, 7255, 5, 4, 0, 0, 7255,
		7300, 1, 0, 0, 0, 7256, 7257, 5, 386, 0, 0, 7257, 7258, 5, 2, 0, 0, 7258,
		7259, 3, 842, 421, 0, 7259, 7260, 5, 4, 0, 0, 7260, 7300, 1, 0, 0, 0, 7261,
		7262, 5, 433, 0, 0, 7262, 7263, 5, 2, 0, 0, 7263, 7264, 3, 984, 492, 0,
		7264, 7265, 5, 3, 0, 0, 7265, 7266, 3, 842, 421, 0, 7266, 7267, 5, 3, 0,
		0, 7267, 7268, 3, 842, 421, 0, 7268, 7269, 5, 4, 0, 0, 7269, 7300, 1, 0,
		0, 0, 7270, 7271, 5, 434, 0, 0, 7271, 7272, 5, 2, 0, 0, 7272, 7273, 3,
		984, 492, 0, 7273, 7274, 5, 3, 0, 0, 7274, 7275, 3, 842, 421, 0, 7275,
		7276, 5, 3, 0, 0, 7276, 7277, 3, 842, 421, 0, 7277, 7278, 5, 4, 0, 0, 7278,
		7300, 1, 0, 0, 0, 7279, 7280, 5, 481, 0, 0, 7280, 7281, 5, 2, 0, 0, 7281,
		7282, 3, 842, 421, 0, 7282, 7283, 5, 4, 0, 0, 7283, 7300, 1, 0, 0, 0, 7284,
		7285, 5, 302, 0, 0, 7285, 7286, 5, 2, 0, 0, 7286, 7287, 3, 970, 485, 0,
		7287, 7288, 5, 4, 0, 0, 7288, 7300, 1, 0, 0, 0, 7289, 7290, 5, 161, 0,
		0, 7290, 7291, 5, 2, 0, 0, 7291, 7292, 3, 842, 421, 0, 7292, 7293, 5, 4,
		0, 0, 7293, 7300, 1, 0, 0, 0, 7294, 7295, 5, 62, 0, 0, 7295, 7296, 5, 2,
		0, 0, 7296, 7297, 3, 842, 421, 0, 7297, 7298, 5, 4, 0, 0, 7298, 7300, 1,
		0, 0, 0, 7299, 7158, 1, 0, 0, 0, 7299, 7163, 1, 0, 0, 0, 7299, 7168, 1,
		0, 0, 0, 7299, 7173, 1, 0, 0, 0, 7299, 7186, 1, 0, 0, 0, 7299, 7193, 1,
		0, 0, 0, 7299, 7200, 1, 0, 0, 0, 7299, 7205, 1, 0, 0, 0, 7299, 7212, 1,
		0, 0, 0, 7299, 7217, 1, 0, 0, 0, 7299, 7222, 1, 0, 0, 0, 7299, 7229, 1,
		0, 0, 0, 7299, 7242, 1, 0, 0, 0, 7299, 7249, 1, 0, 0, 0, 7299, 7256, 1,
		0, 0, 0, 7299, 7261, 1, 0, 0, 0, 7299, 7270, 1, 0, 0, 0, 7299, 7279, 1,
		0, 0, 0, 7299, 7284, 1, 0, 0, 0, 7299, 7289, 1, 0, 0, 0, 7299, 7294, 1,
		0, 0, 0, 7300, 875, 1, 0, 0, 0, 7301, 7302, 5, 377, 0, 0, 7302, 7303, 5,
		2, 0, 0, 7303, 7399, 5, 4, 0, 0, 7304, 7305, 5, 341, 0, 0, 7305, 7306,
		5, 2, 0, 0, 7306, 7399, 5, 4, 0, 0, 7307, 7308, 5, 117, 0, 0, 7308, 7309,
		5, 2, 0, 0, 7309, 7399, 5, 4, 0, 0, 7310, 7311, 5, 91, 0, 0, 7311, 7312,
		5, 2, 0, 0, 7312, 7399, 5, 4, 0, 0, 7313, 7314, 5, 306, 0, 0, 7314, 7315,
		5, 2, 0, 0, 7315, 7399, 5, 4, 0, 0, 7316, 7317, 5, 122, 0, 0, 7317, 7319,
		5, 2, 0, 0, 7318, 7320, 3, 842, 421, 0, 7319, 7318, 1, 0, 0, 0, 7319, 7320,
		1, 0, 0, 0, 7320, 7321, 1, 0, 0, 0, 7321, 7399, 5, 4, 0, 0, 7322, 7323,
		5, 233, 0, 0, 7323, 7335, 5, 2, 0, 0, 7324, 7326, 3, 842, 421, 0, 7325,
		7327, 3, 882, 441, 0, 7326, 7325, 1, 0, 0, 0, 7326, 7327, 1, 0, 0, 0, 7327,
		7332, 1, 0, 0, 0, 7328, 7329, 5, 3, 0, 0, 7329, 7331, 3, 842, 421, 0, 7330,
		7328, 1, 0, 0, 0, 7331, 7334, 1, 0, 0, 0, 7332, 7330, 1, 0, 0, 0, 7332,
		7333, 1, 0, 0, 0, 7333, 7336, 1, 0, 0, 0, 7334, 7332, 1, 0, 0, 0, 7335,
		7324, 1, 0, 0, 0, 7335, 7336, 1, 0, 0, 0, 7336, 7337, 1, 0, 0, 0, 7337,
		7339, 5, 4, 0, 0, 7338, 7340, 3, 882, 441, 0, 7339, 7338, 1, 0, 0, 0, 7339,
		7340, 1, 0, 0, 0, 7340, 7399, 1, 0, 0, 0, 7341, 7342, 5, 228, 0, 0, 7342,
		7354, 5, 2, 0, 0, 7343, 7345, 3, 842, 421, 0, 7344, 7346, 3, 882, 441,
		0, 7345, 7344, 1, 0, 0, 0, 7345, 7346, 1, 0, 0, 0, 7346, 7351, 1, 0, 0,
		0, 7347, 7348, 5, 3, 0, 0, 7348, 7350, 3, 842, 421, 0, 7349, 7347, 1, 0,
		0, 0, 7350, 7353, 1, 0, 0, 0, 7351, 7349, 1, 0, 0, 0, 7351, 7352, 1, 0,
		0, 0, 7352, 7355, 1, 0, 0, 0, 7353, 7351, 1, 0, 0, 0, 7354, 7343, 1, 0,
		0, 0, 7354, 7355, 1, 0, 0, 0, 7355, 7356, 1, 0, 0, 0, 7356, 7358, 5, 4,
		0, 0, 7357, 7359, 3, 882, 441, 0, 7358, 7357, 1, 0, 0, 0, 7358, 7359, 1,
		0, 0, 0, 7359, 7399, 1, 0, 0, 0, 7360, 7361, 5, 159, 0, 0, 7361, 7373,
		5, 2, 0, 0, 7362, 7364, 3, 842, 421, 0, 7363, 7365, 3, 882, 441, 0, 7364,
		7363, 1, 0, 0, 0, 7364, 7365, 1, 0, 0, 0, 7365, 7370, 1, 0, 0, 0, 7366,
		7367, 5, 3, 0, 0, 7367, 7369, 3, 842, 421, 0, 7368, 7366, 1, 0, 0, 0, 7369,
		7372, 1, 0, 0, 0, 7370, 7368, 1, 0, 0, 0, 7370, 7371, 1, 0, 0, 0, 7371,
		7374, 1, 0, 0, 0, 7372, 7370, 1, 0, 0, 0, 7373, 7362, 1, 0, 0, 0, 7373,
		7374, 1, 0, 0, 0, 7374, 7375, 1, 0, 0, 0, 7375, 7377, 5, 4, 0, 0, 7376,
		7378, 3, 882, 441, 0, 7377, 7376, 1, 0, 0, 0, 7377, 7378, 1, 0, 0, 0, 7378,
		7399, 1, 0, 0, 0, 7379, 7380, 5, 231, 0, 0, 7380, 7392, 5, 2, 0, 0, 7381,
		7383, 3, 842, 421, 0, 7382, 7384, 3, 882, 441, 0, 7383, 7382, 1, 0, 0,
		0, 7383, 7384, 1, 0, 0, 0, 7384, 7389, 1, 0, 0, 0, 7385, 7386, 5, 3, 0,
		0, 7386, 7388, 3, 842, 421, 0, 7387, 7385, 1, 0, 0, 0, 7388, 7391, 1, 0,
		0, 0, 7389, 7387, 1, 0, 0, 0, 7389, 7390, 1, 0, 0, 0, 7390, 7393, 1, 0,
		0, 0, 7391, 7389, 1, 0, 0, 0, 7392, 7381, 1, 0, 0, 0, 7392, 7393, 1, 0,
		0, 0, 7393, 7394, 1, 0, 0, 0, 7394, 7396, 5, 4, 0, 0, 7395, 7397, 3, 882,
		441, 0, 7396, 7395, 1, 0, 0, 0, 7396, 7397, 1, 0, 0, 0, 7397, 7399, 1,
		0, 0, 0, 7398, 7301, 1, 0, 0, 0, 7398, 7304, 1, 0, 0, 0, 7398, 7307, 1,
		0, 0, 0, 7398, 7310, 1, 0, 0, 0, 7398, 7313, 1, 0, 0, 0, 7398, 7316, 1,
		0, 0, 0, 7398, 7322, 1, 0, 0, 0, 7398, 7341, 1, 0, 0, 0, 7398, 7360, 1,
		0, 0, 0, 7398, 7379, 1, 0, 0, 0, 7399, 877, 1, 0, 0, 0, 7400, 7401, 5,
		475, 0, 0, 7401, 7402, 3, 842, 421, 0, 7402, 7403, 5, 429, 0, 0, 7403,
		7404, 3, 842, 421, 0, 7404, 879, 1, 0, 0, 0, 7405, 7406, 5, 298, 0, 0,
		7406, 7420, 5, 2, 0, 0, 7407, 7409, 3, 808, 404, 0, 7408, 7407, 1, 0, 0,
		0, 7408, 7409, 1, 0, 0, 0, 7409, 7410, 1, 0, 0, 0, 7410, 7411, 5, 300,
		0, 0, 7411, 7412, 5, 55, 0, 0, 7412, 7417, 3, 842, 421, 0, 7413, 7414,
		5, 3, 0, 0, 7414, 7416, 3, 842, 421, 0, 7415, 7413, 1, 0, 0, 0, 7416, 7419,
		1, 0, 0, 0, 7417, 7415, 1, 0, 0, 0, 7417, 7418, 1, 0, 0, 0, 7418, 7421,
		1, 0, 0, 0, 7419, 7417, 1, 0, 0, 0, 7420, 7408, 1, 0, 0, 0, 7420, 7421,
		1, 0, 0, 0, 7421, 7432, 1, 0, 0, 0, 7422, 7423, 5, 295, 0, 0, 7423, 7424,
		5, 55, 0, 0, 7424, 7429, 3, 762, 381, 0, 7425, 7426, 5, 3, 0, 0, 7426,
		7428, 3, 762, 381, 0, 7427, 7425, 1, 0, 0, 0, 7428, 7431, 1, 0, 0, 0, 7429,
		7427, 1, 0, 0, 0, 7429, 7430, 1, 0, 0, 0, 7430, 7433, 1, 0, 0, 0, 7431,
		7429, 1, 0, 0, 0, 7432, 7422, 1, 0, 0, 0, 7432, 7433, 1, 0, 0, 0, 7433,
		7435, 1, 0, 0, 0, 7434, 7436, 3, 884, 442, 0, 7435, 7434, 1, 0, 0, 0, 7435,
		7436, 1, 0, 0, 0, 7436, 7437, 1, 0, 0, 0, 7437, 7438, 5, 4, 0, 0, 7438,
		881, 1, 0, 0, 0, 7439, 7440, 5, 197, 0, 0, 7440, 7441, 5, 280, 0, 0, 7441,
		883, 1, 0, 0, 0, 7442, 7443, 5, 340, 0, 0, 7443, 7459, 3, 886, 443, 0,
		7444, 7445, 5, 376, 0, 0, 7445, 7459, 3, 886, 443, 0, 7446, 7447, 5, 340,
		0, 0, 7447, 7448, 5, 41, 0, 0, 7448, 7449, 3, 886, 443, 0, 7449, 7450,
		5, 21, 0, 0, 7450, 7451, 3, 886, 443, 0, 7451, 7459, 1, 0, 0, 0, 7452,
		7453, 5, 376, 0, 0, 7453, 7454, 5, 41, 0, 0, 7454, 7455, 3, 886, 443, 0,
		7455, 7456, 5, 21, 0, 0, 7456, 7457, 3, 886, 443, 0, 7457, 7459, 1, 0,
		0, 0, 7458, 7442, 1, 0, 0, 0, 7458, 7444, 1, 0, 0, 0, 7458, 7446, 1, 0,
		0, 0, 7458, 7452, 1, 0, 0, 0, 7459, 885, 1, 0, 0, 0, 7460, 7461, 5, 446,
		0, 0, 7461, 7470, 5, 317, 0, 0, 7462, 7463, 5, 446, 0, 0, 7463, 7470, 5,
		163, 0, 0, 7464, 7465, 5, 93, 0, 0, 7465, 7470, 5, 375, 0, 0, 7466, 7467,
		3, 842, 421, 0, 7467, 7468, 7, 43, 0, 0, 7468, 7470, 1, 0, 0, 0, 7469,
		7460, 1, 0, 0, 0, 7469, 7462, 1, 0, 0, 0, 7469, 7464, 1, 0, 0, 0, 7469,
		7466, 1, 0, 0, 0, 7470, 887, 1, 0, 0, 0, 7471, 7511, 3, 892, 446, 0, 7472,
		7473, 5, 18, 0, 0, 7473, 7481, 7, 44, 0, 0, 7474, 7475, 7, 44, 0, 0, 7475,
		7478, 3, 1006, 503, 0, 7476, 7477, 5, 27, 0, 0, 7477, 7479, 3, 1012, 506,
		0, 7478, 7476, 1, 0, 0, 0, 7478, 7479, 1, 0, 0, 0, 7479, 7481, 1, 0, 0,
		0, 7480, 7472, 1, 0, 0, 0, 7480, 7474, 1, 0, 0, 0, 7481, 7511, 1, 0, 0,
		0, 7482, 7483, 5, 18, 0, 0, 7483, 7487, 7, 45, 0, 0, 7484, 7485, 7, 45,
		0, 0, 7485, 7487, 3, 892, 446, 0, 7486, 7482, 1, 0, 0, 0, 7486, 7484, 1,
		0, 0, 0, 7487, 7511, 1, 0, 0, 0, 7488, 7489, 5, 18, 0, 0, 7489, 7490, 5,
		254, 0, 0, 7490, 7499, 7, 46, 0, 0, 7491, 7492, 5, 254, 0, 0, 7492, 7493,
		7, 46, 0, 0, 7493, 7496, 3, 1006, 503, 0, 7494, 7495, 5, 27, 0, 0, 7495,
		7497, 3, 1012, 506, 0, 7496, 7494, 1, 0, 0, 0, 7496, 7497, 1, 0, 0, 0,
		7497, 7499, 1, 0, 0, 0, 7498, 7488, 1, 0, 0, 0, 7498, 7491, 1, 0, 0, 0,
		7499, 7511, 1, 0, 0, 0, 7500, 7501, 5, 18, 0, 0, 7501, 7509, 7, 46, 0,
		0, 7502, 7503, 7, 46, 0, 0, 7503, 7506, 3, 1006, 503, 0, 7504, 7505, 5,
		27, 0, 0, 7505, 7507, 3, 1012, 506, 0, 7506, 7504, 1, 0, 0, 0, 7506, 7507,
		1, 0, 0, 0, 7507, 7509, 1, 0, 0, 0, 7508, 7500, 1, 0, 0, 0, 7508, 7502,
		1, 0, 0, 0, 7509, 7511, 1, 0, 0, 0, 7510, 7471, 1, 0, 0, 0, 7510, 7480,
		1, 0, 0, 0, 7510, 7486, 1, 0, 0, 0, 7510, 7498, 1, 0, 0, 0, 7510, 7508,
		1, 0, 0, 0, 7511, 889, 1, 0, 0, 0, 7512, 7514, 3, 1006, 503, 0, 7513, 7515,
		3, 816, 408, 0, 7514, 7513, 1, 0, 0, 0, 7514, 7515, 1, 0, 0, 0, 7515, 891,
		1, 0, 0, 0, 7516, 7518, 3, 1006, 503, 0, 7517, 7519, 3, 816, 408, 0, 7518,
		7517, 1, 0, 0, 0, 7518, 7519, 1, 0, 0, 0, 7519, 7522, 1, 0, 0, 0, 7520,
		7521, 5, 27, 0, 0, 7521, 7523, 3, 1012, 506, 0, 7522, 7520, 1, 0, 0, 0,
		7522, 7523, 1, 0, 0, 0, 7523, 893, 1, 0, 0, 0, 7524, 7526, 7, 47, 0, 0,
		7525, 7527, 7, 48, 0, 0, 7526, 7525, 1, 0, 0, 0, 7526, 7527, 1, 0, 0, 0,
		7527, 895, 1, 0, 0, 0, 7528, 7529, 5, 439, 0, 0, 7529, 7531, 7, 49, 0,
		0, 7530, 7532, 3, 1012, 506, 0, 7531, 7530, 1, 0, 0, 0, 7531, 7532, 1,
		0, 0, 0, 7532, 897, 1, 0, 0, 0, 7533, 7536, 3, 1012, 506, 0, 7534, 7536,
		3, 860, 430, 0, 7535, 7533, 1, 0, 0, 0, 7535, 7534, 1, 0, 0, 0, 7536, 899,
		1, 0, 0, 0, 7537, 7538, 5, 300, 0, 0, 7538, 7539, 5, 55, 0, 0, 7539, 7540,
		5, 340, 0, 0, 7540, 7541, 3, 1018, 509, 0, 7541, 7550, 5, 2, 0, 0, 7542,
		7547, 3, 922, 461, 0, 7543, 7544, 5, 3, 0, 0, 7544, 7546, 3, 922, 461,
		0, 7545, 7543, 1, 0, 0, 0, 7546, 7549, 1, 0, 0, 0, 7547, 7545, 1, 0, 0,
		0, 7547, 7548, 1, 0, 0, 0, 7548, 7551, 1, 0, 0, 0, 7549, 7547, 1, 0, 0,
		0, 7550, 7542, 1, 0, 0, 0, 7550, 7551, 1, 0, 0, 0, 7551, 7552, 1, 0, 0,
		0, 7552, 7553, 5, 4, 0, 0, 7553, 7626, 1, 0, 0, 0, 7554, 7555, 5, 300,
		0, 0, 7555, 7556, 5, 55, 0, 0, 7556, 7557, 5, 340, 0, 0, 7557, 7558, 3,
		856, 428, 0, 7558, 7567, 5, 2, 0, 0, 7559, 7564, 3, 922, 461, 0, 7560,
		7561, 5, 3, 0, 0, 7561, 7563, 3, 922, 461, 0, 7562, 7560, 1, 0, 0, 0, 7563,
		7566, 1, 0, 0, 0, 7564, 7562, 1, 0, 0, 0, 7564, 7565, 1, 0, 0, 0, 7565,
		7568, 1, 0, 0, 0, 7566, 7564, 1, 0, 0, 0, 7567, 7559, 1, 0, 0, 0, 7567,
		7568, 1, 0, 0, 0, 7568, 7569, 1, 0, 0, 0, 7569, 7570, 5, 4, 0, 0, 7570,
		7626, 1, 0, 0, 0, 7571, 7572, 5, 300, 0, 0, 7572, 7574, 5, 55, 0, 0, 7573,
		7575, 5, 239, 0, 0, 7574, 7573, 1, 0, 0, 0, 7574, 7575, 1, 0, 0, 0, 7575,
		7576, 1, 0, 0, 0, 7576, 7577, 3, 1018, 509, 0, 7577, 7586, 5, 2, 0, 0,
		7578, 7583, 3, 902, 451, 0, 7579, 7580, 5, 3, 0, 0, 7580, 7582, 3, 902,
		451, 0, 7581, 7579, 1, 0, 0, 0, 7582, 7585, 1, 0, 0, 0, 7583, 7581, 1,
		0, 0, 0, 7583, 7584, 1, 0, 0, 0, 7584, 7587, 1, 0, 0, 0, 7585, 7583, 1,
		0, 0, 0, 7586, 7578, 1, 0, 0, 0, 7586, 7587, 1, 0, 0, 0, 7587, 7588, 1,
		0, 0, 0, 7588, 7589, 5, 4, 0, 0, 7589, 7626, 1, 0, 0, 0, 7590, 7591, 5,
		300, 0, 0, 7591, 7593, 5, 55, 0, 0, 7592, 7594, 5, 239, 0, 0, 7593, 7592,
		1, 0, 0, 0, 7593, 7594, 1, 0, 0, 0, 7594, 7595, 1, 0, 0, 0, 7595, 7626,
		3, 1018, 509, 0, 7596, 7597, 5, 300, 0, 0, 7597, 7598, 5, 55, 0, 0, 7598,
		7599, 3, 860, 430, 0, 7599, 7608, 5, 2, 0, 0, 7600, 7605, 3, 922, 461,
		0, 7601, 7602, 5, 3, 0, 0, 7602, 7604, 3, 922, 461, 0, 7603, 7601, 1, 0,
		0, 0, 7604, 7607, 1, 0, 0, 0, 7605, 7603, 1, 0, 0, 0, 7605, 7606, 1, 0,
		0, 0, 7606, 7609, 1, 0, 0, 0, 7607, 7605, 1, 0, 0, 0, 7608, 7600, 1, 0,
		0, 0, 7608, 7609, 1, 0, 0, 0, 7609, 7610, 1, 0, 0, 0, 7610, 7611, 5, 4,
		0, 0, 7611, 7626, 1, 0, 0, 0, 7612, 7613, 5, 300, 0, 0, 7613, 7614, 5,
		55, 0, 0, 7614, 7626, 3, 860, 430, 0, 7615, 7616, 5, 300, 0, 0, 7616, 7617,
		5, 55, 0, 0, 7617, 7622, 3, 898, 449, 0, 7618, 7619, 5, 3, 0, 0, 7619,
		7621, 3, 898, 449, 0, 7620, 7618, 1, 0, 0, 0, 7621, 7624, 1, 0, 0, 0, 7622,
		7620, 1, 0, 0, 0, 7622, 7623, 1, 0, 0, 0, 7623, 7626, 1, 0, 0, 0, 7624,
		7622, 1, 0, 0, 0, 7625, 7537, 1, 0, 0, 0, 7625, 7554, 1, 0, 0, 0, 7625,
		7571, 1, 0, 0, 0, 7625, 7590, 1, 0, 0, 0, 7625, 7596, 1, 0, 0, 0, 7625,
		7612, 1, 0, 0, 0, 7625, 7615, 1, 0, 0, 0, 7626, 901, 1, 0, 0, 0, 7627,
		7630, 3, 904, 452, 0, 7628, 7630, 3, 906, 453, 0, 7629, 7627, 1, 0, 0,
		0, 7629, 7628, 1, 0, 0, 0, 7630, 903, 1, 0, 0, 0, 7631, 7635, 5, 300, 0,
		0, 7632, 7633, 5, 194, 0, 0, 7633, 7634, 5, 278, 0, 0, 7634, 7636, 5, 145,
		0, 0, 7635, 7632, 1, 0, 0, 0, 7635, 7636, 1, 0, 0, 0, 7636, 7637, 1, 0,
		0, 0, 7637, 7638, 3, 1012, 506, 0, 7638, 7639, 5, 460, 0, 0, 7639, 7640,
		5, 199, 0, 0, 7640, 7642, 3, 910, 455, 0, 7641, 7643, 3, 952, 476, 0, 7642,
		7641, 1, 0, 0, 0, 7642, 7643, 1, 0, 0, 0, 7643, 905, 1, 0, 0, 0, 7644,
		7648, 5, 300, 0, 0, 7645, 7646, 5, 194, 0, 0, 7646, 7647, 5, 278, 0, 0,
		7647, 7649, 5, 145, 0, 0, 7648, 7645, 1, 0, 0, 0, 7648, 7649, 1, 0, 0,
		0, 7649, 7650, 1, 0, 0, 0, 7650, 7651, 3, 1012, 506, 0, 7651, 7652, 5,
		460, 0, 0, 7652, 7653, 5, 199, 0, 0, 7653, 7655, 3, 908, 454, 0, 7654,
		7656, 3, 952, 476, 0, 7655, 7654, 1, 0, 0, 0, 7655, 7656, 1, 0, 0, 0, 7656,
		907, 1, 0, 0, 0, 7657, 7658, 5, 2, 0, 0, 7658, 7663, 3, 910, 455, 0, 7659,
		7660, 5, 3, 0, 0, 7660, 7662, 3, 910, 455, 0, 7661, 7659, 1, 0, 0, 0, 7662,
		7665, 1, 0, 0, 0, 7663, 7661, 1, 0, 0, 0, 7663, 7664, 1, 0, 0, 0, 7664,
		7666, 1, 0, 0, 0, 7665, 7663, 1, 0, 0, 0, 7666, 7667, 5, 4, 0, 0, 7667,
		909, 1, 0, 0, 0, 7668, 7669, 5, 2, 0, 0, 7669, 7674, 3, 914, 457, 0, 7670,
		7671, 5, 3, 0, 0, 7671, 7673, 3, 914, 457, 0, 7672, 7670, 1, 0, 0, 0, 7673,
		7676, 1, 0, 0, 0, 7674, 7672, 1, 0, 0, 0, 7674, 7675, 1, 0, 0, 0, 7675,
		7677, 1, 0, 0, 0, 7676, 7674, 1, 0, 0, 0, 7677, 7678, 5, 4, 0, 0, 7678,
		911, 1, 0, 0, 0, 7679, 7682, 3, 910, 455, 0, 7680, 7682, 3, 908, 454, 0,
		7681, 7679, 1, 0, 0, 0, 7681, 7680, 1, 0, 0, 0, 7682, 913, 1, 0, 0, 0,
		7683, 7686, 5, 279, 0, 0, 7684, 7686, 3, 970, 485, 0, 7685, 7683, 1, 0,
		0, 0, 7685, 7684, 1, 0, 0, 0, 7686, 915, 1, 0, 0, 0, 7687, 7688, 5, 2,
		0, 0, 7688, 7693, 3, 970, 485, 0, 7689, 7690, 5, 3, 0, 0, 7690, 7692, 3,
		970, 485, 0, 7691, 7689, 1, 0, 0, 0, 7692, 7695, 1, 0, 0, 0, 7693, 7691,
		1, 0, 0, 0, 7693, 7694, 1, 0, 0, 0, 7694, 7696, 1, 0, 0, 0, 7695, 7693,
		1, 0, 0, 0, 7696, 7697, 5, 4, 0, 0, 7697, 917, 1, 0, 0, 0, 7698, 7699,
		5, 2, 0, 0, 7699, 7704, 5, 516, 0, 0, 7700, 7701, 5, 3, 0, 0, 7701, 7703,
		5, 516, 0, 0, 7702, 7700, 1, 0, 0, 0, 7703, 7706, 1, 0, 0, 0, 7704, 7702,
		1, 0, 0, 0, 7704, 7705, 1, 0, 0, 0, 7705, 7707, 1, 0, 0, 0, 7706, 7704,
		1, 0, 0, 0, 7707, 7708, 5, 4, 0, 0, 7708, 919, 1, 0, 0, 0, 7709, 7710,
		5, 2, 0, 0, 7710, 7715, 3, 858, 429, 0, 7711, 7712, 5, 3, 0, 0, 7712, 7714,
		3, 858, 429, 0, 7713, 7711, 1, 0, 0, 0, 7714, 7717, 1, 0, 0, 0, 7715, 7713,
		1, 0, 0, 0, 7715, 7716, 1, 0, 0, 0, 7716, 7718, 1, 0, 0, 0, 7717, 7715,
		1, 0, 0, 0, 7718, 7719, 5, 4, 0, 0, 7719, 921, 1, 0, 0, 0, 7720, 7723,
		3, 924, 462, 0, 7721, 7723, 3, 926, 463, 0, 7722, 7720, 1, 0, 0, 0, 7722,
		7721, 1, 0, 0, 0, 7723, 923, 1, 0, 0, 0, 7724, 7728, 5, 300, 0, 0, 7725,
		7726, 5, 194, 0, 0, 7726, 7727, 5, 278, 0, 0, 7727, 7729, 5, 145, 0, 0,
		7728, 7725, 1, 0, 0, 0, 7728, 7729, 1, 0, 0, 0, 7729, 7730, 1, 0, 0, 0,
		7730, 7731, 3, 1012, 506, 0, 7731, 7732, 5, 460, 0, 0, 7732, 7734, 3, 930,
		465, 0, 7733, 7735, 3, 952, 476, 0, 7734, 7733, 1, 0, 0, 0, 7734, 7735,
		1, 0, 0, 0, 7735, 925, 1, 0, 0, 0, 7736, 7737, 5, 404, 0, 0, 7737, 7738,
		5, 2, 0, 0, 7738, 7739, 3, 970, 485, 0, 7739, 7740, 5, 4, 0, 0, 7740, 7741,
		5, 137, 0, 0, 7741, 7742, 5, 2, 0, 0, 7742, 7743, 3, 970, 485, 0, 7743,
		7744, 5, 4, 0, 0, 7744, 7745, 5, 150, 0, 0, 7745, 7746, 5, 2, 0, 0, 7746,
		7747, 3, 978, 489, 0, 7747, 7748, 5, 4, 0, 0, 7748, 7763, 1, 0, 0, 0, 7749,
		7750, 5, 404, 0, 0, 7750, 7751, 5, 2, 0, 0, 7751, 7752, 3, 970, 485, 0,
		7752, 7753, 5, 4, 0, 0, 7753, 7754, 5, 137, 0, 0, 7754, 7755, 5, 2, 0,
		0, 7755, 7756, 3, 970, 485, 0, 7756, 7757, 5, 4, 0, 0, 7757, 7758, 5, 150,
		0, 0, 7758, 7759, 5, 2, 0, 0, 7759, 7760, 5, 516, 0, 0, 7760, 7761, 5,
		4, 0, 0, 7761, 7763, 1, 0, 0, 0, 7762, 7736, 1, 0, 0, 0, 7762, 7749, 1,
		0, 0, 0, 7763, 927, 1, 0, 0, 0, 7764, 7765, 5, 404, 0, 0, 7765, 7766, 5,
		2, 0, 0, 7766, 7767, 3, 970, 485, 0, 7767, 7768, 5, 4, 0, 0, 7768, 7769,
		5, 137, 0, 0, 7769, 7770, 5, 2, 0, 0, 7770, 7771, 3, 970, 485, 0, 7771,
		7772, 5, 4, 0, 0, 7772, 929, 1, 0, 0, 0, 7773, 7774, 5, 235, 0, 0, 7774,
		7777, 5, 428, 0, 0, 7775, 7778, 5, 256, 0, 0, 7776, 7778, 3, 932, 466,
		0, 7777, 7775, 1, 0, 0, 0, 7777, 7776, 1, 0, 0, 0, 7778, 7786, 1, 0, 0,
		0, 7779, 7780, 5, 6, 0, 0, 7780, 7781, 3, 932, 466, 0, 7781, 7782, 5, 3,
		0, 0, 7782, 7783, 3, 932, 466, 0, 7783, 7784, 5, 4, 0, 0, 7784, 7786, 1,
		0, 0, 0, 7785, 7773, 1, 0, 0, 0, 7785, 7779, 1, 0, 0, 0, 7786, 931, 1,
		0, 0, 0, 7787, 7788, 5, 2, 0, 0, 7788, 7793, 3, 936, 468, 0, 7789, 7790,
		5, 3, 0, 0, 7790, 7792, 3, 936, 468, 0, 7791, 7789, 1, 0, 0, 0, 7792, 7795,
		1, 0, 0, 0, 7793, 7791, 1, 0, 0, 0, 7793, 7794, 1, 0, 0, 0, 7794, 7796,
		1, 0, 0, 0, 7795, 7793, 1, 0, 0, 0, 7796, 7797, 5, 4, 0, 0, 7797, 933,
		1, 0, 0, 0, 7798, 7799, 3, 1012, 506, 0, 7799, 7800, 5, 490, 0, 0, 7800,
		7801, 3, 858, 429, 0, 7801, 935, 1, 0, 0, 0, 7802, 7805, 5, 256, 0, 0,
		7803, 7805, 3, 970, 485, 0, 7804, 7802, 1, 0, 0, 0, 7804, 7803, 1, 0, 0,
		0, 7805, 937, 1, 0, 0, 0, 7806, 7807, 5, 127, 0, 0, 7807, 7808, 5, 55,
		0, 0, 7808, 7809, 5, 183, 0, 0, 7809, 7812, 3, 1018, 509, 0, 7810, 7811,
		5, 53, 0, 0, 7811, 7813, 5, 516, 0, 0, 7812, 7810, 1, 0, 0, 0, 7812, 7813,
		1, 0, 0, 0, 7813, 7819, 1, 0, 0, 0, 7814, 7815, 5, 127, 0, 0, 7815, 7816,
		5, 55, 0, 0, 7816, 7817, 5, 183, 0, 0, 7817, 7819, 3, 1018, 509, 0, 7818,
		7806, 1, 0, 0, 0, 7818, 7814, 1, 0, 0, 0, 7819, 939, 1, 0, 0, 0, 7820,
		7821, 5, 127, 0, 0, 7821, 7822, 5, 55, 0, 0, 7822, 7823, 5, 183, 0, 0,
		7823, 7826, 3, 1018, 509, 0, 7824, 7825, 5, 53, 0, 0, 7825, 7827, 5, 516,
		0, 0, 7826, 7824, 1, 0, 0, 0, 7826, 7827, 1, 0, 0, 0, 7827, 7840, 1, 0,
		0, 0, 7828, 7829, 5, 127, 0, 0, 7829, 7830, 5, 55, 0, 0, 7830, 7831, 5,
		183, 0, 0, 7831, 7840, 3, 1018, 509, 0, 7832, 7833, 5, 127, 0, 0, 7833,
		7834, 5, 55, 0, 0, 7834, 7837, 5, 339, 0, 0, 7835, 7836, 5, 53, 0, 0, 7836,
		7838, 5, 516, 0, 0, 7837, 7835, 1, 0, 0, 0, 7837, 7838, 1, 0, 0, 0, 7838,
		7840, 1, 0, 0, 0, 7839, 7820, 1, 0, 0, 0, 7839, 7828, 1, 0, 0, 0, 7839,
		7832, 1, 0, 0, 0, 7840, 941, 1, 0, 0, 0, 7841, 7842, 5, 127, 0, 0, 7842,
		7843, 5, 55, 0, 0, 7843, 7844, 5, 183, 0, 0, 7844, 7845, 3, 1018, 509,
		0, 7845, 7846, 5, 115, 0, 0, 7846, 7847, 5, 53, 0, 0, 7847, 7848, 5, 516,
		0, 0, 7848, 943, 1, 0, 0, 0, 7849, 7851, 5, 345, 0, 0, 7850, 7852, 7, 50,
		0, 0, 7851, 7850, 1, 0, 0, 0, 7851, 7852, 1, 0, 0, 0, 7852, 7869, 1, 0,
		0, 0, 7853, 7870, 5, 29, 0, 0, 7854, 7860, 5, 29, 0, 0, 7855, 7856, 5,
		404, 0, 0, 7856, 7857, 5, 2, 0, 0, 7857, 7858, 3, 970, 485, 0, 7858, 7859,
		5, 4, 0, 0, 7859, 7861, 1, 0, 0, 0, 7860, 7855, 1, 0, 0, 0, 7860, 7861,
		1, 0, 0, 0, 7861, 7862, 1, 0, 0, 0, 7862, 7863, 5, 150, 0, 0, 7863, 7864,
		5, 2, 0, 0, 7864, 7865, 3, 978, 489, 0, 7865, 7866, 5, 4, 0, 0, 7866, 7870,
		1, 0, 0, 0, 7867, 7870, 5, 201, 0, 0, 7868, 7870, 5, 248, 0, 0, 7869, 7853,
		1, 0, 0, 0, 7869, 7854, 1, 0, 0, 0, 7869, 7867, 1, 0, 0, 0, 7869, 7868,
		1, 0, 0, 0, 7870, 945, 1, 0, 0, 0, 7871, 7872, 7, 51, 0, 0, 7872, 947,
		1, 0, 0, 0, 7873, 7874, 5, 329, 0, 0, 7874, 7875, 5, 2, 0, 0, 7875, 7880,
		3, 956, 478, 0, 7876, 7877, 5, 3, 0, 0, 7877, 7879, 3, 956, 478, 0, 7878,
		7876, 1, 0, 0, 0, 7879, 7882, 1, 0, 0, 0, 7880, 7878, 1, 0, 0, 0, 7880,
		7881, 1, 0, 0, 0, 7881, 7883, 1, 0, 0, 0, 7882, 7880, 1, 0, 0, 0, 7883,
		7884, 5, 4, 0, 0, 7884, 949, 1, 0, 0, 0, 7885, 7886, 5, 52, 0, 0, 7886,
		7887, 3, 948, 474, 0, 7887, 951, 1, 0, 0, 0, 7888, 7889, 5, 2, 0, 0, 7889,
		7894, 3, 956, 478, 0, 7890, 7891, 5, 3, 0, 0, 7891, 7893, 3, 956, 478,
		0, 7892, 7890, 1, 0, 0, 0, 7893, 7896, 1, 0, 0, 0, 7894, 7892, 1, 0, 0,
		0, 7894, 7895, 1, 0, 0, 0, 7895, 7897, 1, 0, 0, 0, 7896, 7894, 1, 0, 0,
		0, 7897, 7898, 5, 4, 0, 0, 7898, 953, 1, 0, 0, 0, 7899, 7904, 3, 956, 478,
		0, 7900, 7901, 5, 3, 0, 0, 7901, 7903, 3, 956, 478, 0, 7902, 7900, 1, 0,
		0, 0, 7903, 7906, 1, 0, 0, 0, 7904, 7902, 1, 0, 0, 0, 7904, 7905, 1, 0,
		0, 0, 7905, 955, 1, 0, 0, 0, 7906, 7904, 1, 0, 0, 0, 7907, 7908, 3, 970,
		485, 0, 7908, 7909, 5, 490, 0, 0, 7909, 7910, 3, 970, 485, 0, 7910, 957,
		1, 0, 0, 0, 7911, 7915, 3, 960, 480, 0, 7912, 7914, 3, 960, 480, 0, 7913,
		7912, 1, 0, 0, 0, 7914, 7917, 1, 0, 0, 0, 7915, 7913, 1, 0, 0, 0, 7915,
		7916, 1, 0, 0, 0, 7916, 959, 1, 0, 0, 0, 7917, 7915, 1, 0, 0, 0, 7918,
		7919, 3, 1012, 506, 0, 7919, 7920, 5, 490, 0, 0, 7920, 7921, 3, 970, 485,
		0, 7921, 961, 1, 0, 0, 0, 7922, 7923, 7, 52, 0, 0, 7923, 963, 1, 0, 0,
		0, 7924, 7925, 5, 76, 0, 0, 7925, 7926, 3, 970, 485, 0, 7926, 965, 1, 0,
		0, 0, 7927, 7928, 5, 215, 0, 0, 7928, 7929, 5, 297, 0, 0, 7929, 7931, 3,
		970, 485, 0, 7930, 7932, 3, 968, 484, 0, 7931, 7930, 1, 0, 0, 0, 7931,
		7932, 1, 0, 0, 0, 7932, 7934, 1, 0, 0, 0, 7933, 7935, 3, 948, 474, 0, 7934,
		7933, 1, 0, 0, 0, 7934, 7935, 1, 0, 0, 0, 7935, 967, 1, 0, 0, 0, 7936,
		7937, 5, 167, 0, 0, 7937, 7940, 5, 27, 0, 0, 7938, 7941, 3, 1012, 506,
		0, 7939, 7941, 3, 970, 485, 0, 7940, 7938, 1, 0, 0, 0, 7940, 7939, 1, 0,
		0, 0, 7941, 969, 1, 0, 0, 0, 7942, 7943, 7, 53, 0, 0, 7943, 971, 1, 0,
		0, 0, 7944, 7945, 7, 54, 0, 0, 7945, 973, 1, 0, 0, 0, 7946, 7947, 7, 55,
		0, 0, 7947, 975, 1, 0, 0, 0, 7948, 7949, 7, 56, 0, 0, 7949, 977, 1, 0,
		0, 0, 7950, 7951, 5, 214, 0, 0, 7951, 7952, 3, 842, 421, 0, 7952, 7953,
		3, 984, 492, 0, 7953, 979, 1, 0, 0, 0, 7954, 7955, 5, 214, 0, 0, 7955,
		7956, 3, 842, 421, 0, 7956, 7957, 3, 982, 491, 0, 7957, 981, 1, 0, 0, 0,
		7958, 7959, 7, 57, 0, 0, 7959, 983, 1, 0, 0, 0, 7960, 7961, 7, 58, 0, 0,
		7961, 985, 1, 0, 0, 0, 7962, 7963, 7, 59, 0, 0, 7963, 987, 1, 0, 0, 0,
		7964, 7970, 3, 1002, 501, 0, 7965, 7970, 3, 1004, 502, 0, 7966, 7970, 3,
		990, 495, 0, 7967, 7970, 3, 998, 499, 0, 7968, 7970, 3, 992, 496, 0, 7969,
		7964, 1, 0, 0, 0, 7969, 7965, 1, 0, 0, 0, 7969, 7966, 1, 0, 0, 0, 7969,
		7967, 1, 0, 0, 0, 7969, 7968, 1, 0, 0, 0, 7970, 989, 1, 0, 0, 0, 7971,
		7972, 5, 24, 0, 0, 7972, 7973, 5, 492, 0, 0, 7973, 7974, 3, 988, 494, 0,
		7974, 7975, 5, 494, 0, 0, 7975, 991, 1, 0, 0, 0, 7976, 7977, 5, 249, 0,
		0, 7977, 7978, 5, 492, 0, 0, 7978, 7979, 3, 988, 494, 0, 7979, 7980, 5,
		3, 0, 0, 7980, 7981, 3, 988, 494, 0, 7981, 7982, 5, 494, 0, 0, 7982, 993,
		1, 0, 0, 0, 7983, 7986, 3, 1012, 506, 0, 7984, 7986, 3, 304, 152, 0, 7985,
		7983, 1, 0, 0, 0, 7985, 7984, 1, 0, 0, 0, 7986, 7987, 1, 0, 0, 0, 7987,
		7988, 3, 988, 494, 0, 7988, 995, 1, 0, 0, 0, 7989, 7994, 3, 994, 497, 0,
		7990, 7991, 5, 3, 0, 0, 7991, 7993, 3, 994, 497, 0, 7992, 7990, 1, 0, 0,
		0, 7993, 7996, 1, 0, 0, 0, 7994, 7992, 1, 0, 0, 0, 7994, 7995, 1, 0, 0,
		0, 7995, 997, 1, 0, 0, 0, 7996, 7994, 1, 0, 0, 0, 7997, 7998, 5, 419, 0,
		0, 7998, 7999, 5, 492, 0, 0, 7999, 8000, 3, 996, 498, 0, 8000, 8001, 5,
		494, 0, 0, 8001, 999, 1, 0, 0, 0, 8002, 8003, 5, 2, 0, 0, 8003, 8004, 5,
		516, 0, 0, 8004, 8005, 5, 4, 0, 0, 8005, 1001, 1, 0, 0, 0, 8006, 8075,
		5, 49, 0, 0, 8007, 8009, 5, 435, 0, 0, 8008, 8010, 3, 1000, 500, 0, 8009,
		8008, 1, 0, 0, 0, 8009, 8010, 1, 0, 0, 0, 8010, 8075, 1, 0, 0, 0, 8011,
		8013, 5, 399, 0, 0, 8012, 8014, 3, 1000, 500, 0, 8013, 8012, 1, 0, 0, 0,
		8013, 8014, 1, 0, 0, 0, 8014, 8075, 1, 0, 0, 0, 8015, 8017, 5, 396, 0,
		0, 8016, 8018, 5, 208, 0, 0, 8017, 8016, 1, 0, 0, 0, 8017, 8018, 1, 0,
		0, 0, 8018, 8075, 1, 0, 0, 0, 8019, 8021, 5, 396, 0, 0, 8020, 8022, 5,
		209, 0, 0, 8021, 8020, 1, 0, 0, 0, 8021, 8022, 1, 0, 0, 0, 8022, 8075,
		1, 0, 0, 0, 8023, 8025, 5, 452, 0, 0, 8024, 8026, 5, 208, 0, 0, 8025, 8024,
		1, 0, 0, 0, 8025, 8026, 1, 0, 0, 0, 8026, 8075, 1, 0, 0, 0, 8027, 8029,
		5, 452, 0, 0, 8028, 8030, 5, 209, 0, 0, 8029, 8028, 1, 0, 0, 0, 8029, 8030,
		1, 0, 0, 0, 8030, 8075, 1, 0, 0, 0, 8031, 8033, 5, 208, 0, 0, 8032, 8034,
		3, 1000, 500, 0, 8033, 8032, 1, 0, 0, 0, 8033, 8034, 1, 0, 0, 0, 8034,
		8075, 1, 0, 0, 0, 8035, 8037, 5, 209, 0, 0, 8036, 8038, 3, 1000, 500, 0,
		8037, 8036, 1, 0, 0, 0, 8037, 8038, 1, 0, 0, 0, 8038, 8075, 1, 0, 0, 0,
		8039, 8041, 5, 42, 0, 0, 8040, 8042, 3, 1000, 500, 0, 8041, 8040, 1, 0,
		0, 0, 8041, 8042, 1, 0, 0, 0, 8042, 8075, 1, 0, 0, 0, 8043, 8045, 5, 229,
		0, 0, 8044, 8046, 3, 1000, 500, 0, 8045, 8044, 1, 0, 0, 0, 8045, 8046,
		1, 0, 0, 0, 8046, 8075, 1, 0, 0, 0, 8047, 8075, 5, 160, 0, 0, 8048, 8075,
		5, 129, 0, 0, 8049, 8075, 5, 104, 0, 0, 8050, 8075, 5, 105, 0, 0, 8051,
		8075, 5, 430, 0, 0, 8052, 8054, 5, 64, 0, 0, 8053, 8055, 3, 1000, 500,
		0, 8054, 8053, 1, 0, 0, 0, 8054, 8055, 1, 0, 0, 0, 8055, 8075, 1, 0, 0,
		0, 8056, 8058, 5, 462, 0, 0, 8057, 8059, 3, 1000, 500, 0, 8058, 8057, 1,
		0, 0, 0, 8058, 8059, 1, 0, 0, 0, 8059, 8075, 1, 0, 0, 0, 8060, 8075, 5,
		410, 0, 0, 8061, 8075, 5, 411, 0, 0, 8062, 8075, 5, 44, 0, 0, 8063, 8075,
		5, 187, 0, 0, 8064, 8075, 5, 307, 0, 0, 8065, 8075, 5, 223, 0, 0, 8066,
		8068, 5, 461, 0, 0, 8067, 8069, 3, 1000, 500, 0, 8068, 8067, 1, 0, 0, 0,
		8068, 8069, 1, 0, 0, 0, 8069, 8075, 1, 0, 0, 0, 8070, 8072, 5, 43, 0, 0,
		8071, 8073, 3, 1000, 500, 0, 8072, 8071, 1, 0, 0, 0, 8072, 8073, 1, 0,
		0, 0, 8073, 8075, 1, 0, 0, 0, 8074, 8006, 1, 0, 0, 0, 8074, 8007, 1, 0,
		0, 0, 8074, 8011, 1, 0, 0, 0, 8074, 8015, 1, 0, 0, 0, 8074, 8019, 1, 0,
		0, 0, 8074, 8023, 1, 0, 0, 0, 8074, 8027, 1, 0, 0, 0, 8074, 8031, 1, 0,
		0, 0, 8074, 8035, 1, 0, 0, 0, 8074, 8039, 1, 0, 0, 0, 8074, 8043, 1, 0,
		0, 0, 8074, 8047, 1, 0, 0, 0, 8074, 8048, 1, 0, 0, 0, 8074, 8049, 1, 0,
		0, 0, 8074, 8050, 1, 0, 0, 0, 8074, 8051, 1, 0, 0, 0, 8074, 8052, 1, 0,
		0, 0, 8074, 8056, 1, 0, 0, 0, 8074, 8060, 1, 0, 0, 0, 8074, 8061, 1, 0,
		0, 0, 8074, 8062, 1, 0, 0, 0, 8074, 8063, 1, 0, 0, 0, 8074, 8064, 1, 0,
		0, 0, 8074, 8065, 1, 0, 0, 0, 8074, 8066, 1, 0, 0, 0, 8074, 8070, 1, 0,
		0, 0, 8075, 1003, 1, 0, 0, 0, 8076, 8084, 7, 60, 0, 0, 8077, 8078, 5, 2,
		0, 0, 8078, 8081, 5, 516, 0, 0, 8079, 8080, 5, 3, 0, 0, 8080, 8082, 5,
		516, 0, 0, 8081, 8079, 1, 0, 0, 0, 8081, 8082, 1, 0, 0, 0, 8082, 8083,
		1, 0, 0, 0, 8083, 8085, 5, 4, 0, 0, 8084, 8077, 1, 0, 0, 0, 8084, 8085,
		1, 0, 0, 0, 8085, 1005, 1, 0, 0, 0, 8086, 8092, 3, 1012, 506, 0, 8087,
		8091, 5, 526, 0, 0, 8088, 8089, 5, 1, 0, 0, 8089, 8091, 3, 1012, 506, 0,
		8090, 8087, 1, 0, 0, 0, 8090, 8088, 1, 0, 0, 0, 8091, 8094, 1, 0, 0, 0,
		8092, 8090, 1, 0, 0, 0, 8092, 8093, 1, 0, 0, 0, 8093, 1007, 1, 0, 0, 0,
		8094, 8092, 1, 0, 0, 0, 8095, 8096, 3, 1006, 503, 0, 8096, 1009, 1, 0,
		0, 0, 8097, 8099, 5, 165, 0, 0, 8098, 8097, 1, 0, 0, 0, 8098, 8099, 1,
		0, 0, 0, 8099, 8100, 1, 0, 0, 0, 8100, 8101, 5, 466, 0, 0, 8101, 8102,
		5, 27, 0, 0, 8102, 8103, 5, 284, 0, 0, 8103, 8104, 3, 1012, 506, 0, 8104,
		1011, 1, 0, 0, 0, 8105, 8110, 5, 523, 0, 0, 8106, 8110, 3, 1034, 517, 0,
		8107, 8110, 5, 524, 0, 0, 8108, 8110, 5, 525, 0, 0, 8109, 8105, 1, 0, 0,
		0, 8109, 8106, 1, 0, 0, 0, 8109, 8107, 1, 0, 0, 0, 8109, 8108, 1, 0, 0,
		0, 8110, 1013, 1, 0, 0, 0, 8111, 8114, 3, 1012, 506, 0, 8112, 8113, 5,
		27, 0, 0, 8113, 8115, 3, 1012, 506, 0, 8114, 8112, 1, 0, 0, 0, 8114, 8115,
		1, 0, 0, 0, 8115, 1015, 1, 0, 0, 0, 8116, 8117, 5, 2, 0, 0, 8117, 8122,
		3, 1014, 507, 0, 8118, 8119, 5, 3, 0, 0, 8119, 8121, 3, 1014, 507, 0, 8120,
		8118, 1, 0, 0, 0, 8121, 8124, 1, 0, 0, 0, 8122, 8120, 1, 0, 0, 0, 8122,
		8123, 1, 0, 0, 0, 8123, 8125, 1, 0, 0, 0, 8124, 8122, 1, 0, 0, 0, 8125,
		8126, 5, 4, 0, 0, 8126, 1017, 1, 0, 0, 0, 8127, 8128, 5, 2, 0, 0, 8128,
		8133, 3, 1012, 506, 0, 8129, 8130, 5, 3, 0, 0, 8130, 8132, 3, 1012, 506,
		0, 8131, 8129, 1, 0, 0, 0, 8132, 8135, 1, 0, 0, 0, 8133, 8131, 1, 0, 0,
		0, 8133, 8134, 1, 0, 0, 0, 8134, 8136, 1, 0, 0, 0, 8135, 8133, 1, 0, 0,
		0, 8136, 8137, 5, 4, 0, 0, 8137, 1019, 1, 0, 0, 0, 8138, 8141, 3, 1012,
		506, 0, 8139, 8141, 3, 970, 485, 0, 8140, 8138, 1, 0, 0, 0, 8140, 8139,
		1, 0, 0, 0, 8141, 1021, 1, 0, 0, 0, 8142, 8147, 3, 1020, 510, 0, 8143,
		8144, 5, 3, 0, 0, 8144, 8146, 3, 1020, 510, 0, 8145, 8143, 1, 0, 0, 0,
		8146, 8149, 1, 0, 0, 0, 8147, 8145, 1, 0, 0, 0, 8147, 8148, 1, 0, 0, 0,
		8148, 1023, 1, 0, 0, 0, 8149, 8147, 1, 0, 0, 0, 8150, 8154, 5, 500, 0,
		0, 8151, 8154, 3, 1012, 506, 0, 8152, 8154, 3, 970, 485, 0, 8153, 8150,
		1, 0, 0, 0, 8153, 8151, 1, 0, 0, 0, 8153, 8152, 1, 0, 0, 0, 8154, 1025,
		1, 0, 0, 0, 8155, 8167, 3, 1020, 510, 0, 8156, 8157, 3, 1020, 510, 0, 8157,
		8158, 5, 515, 0, 0, 8158, 8159, 3, 1020, 510, 0, 8159, 8167, 1, 0, 0, 0,
		8160, 8161, 3, 1020, 510, 0, 8161, 8162, 5, 515, 0, 0, 8162, 8163, 5, 6,
		0, 0, 8163, 8164, 3, 1020, 510, 0, 8164, 8165, 5, 7, 0, 0, 8165, 8167,
		1, 0, 0, 0, 8166, 8155, 1, 0, 0, 0, 8166, 8156, 1, 0, 0, 0, 8166, 8160,
		1, 0, 0, 0, 8167, 1027, 1, 0, 0, 0, 8168, 8169, 3, 1012, 506, 0, 8169,
		8170, 5, 490, 0, 0, 8170, 8171, 3, 834, 417, 0, 8171, 1029, 1, 0, 0, 0,
		8172, 8177, 3, 1028, 514, 0, 8173, 8174, 5, 3, 0, 0, 8174, 8176, 3, 1028,
		514, 0, 8175, 8173, 1, 0, 0, 0, 8176, 8179, 1, 0, 0, 0, 8177, 8175, 1,
		0, 0, 0, 8177, 8178, 1, 0, 0, 0, 8178, 1031, 1, 0, 0, 0, 8179, 8177, 1,
		0, 0, 0, 8180, 8184, 5, 516, 0, 0, 8181, 8184, 5, 517, 0, 0, 8182, 8184,
		5, 518, 0, 0, 8183, 8180, 1, 0, 0, 0, 8183, 8181, 1, 0, 0, 0, 8183, 8182,
		1, 0, 0, 0, 8184, 1033, 1, 0, 0, 0, 8185, 8186, 7, 61, 0, 0, 8186, 1035,
		1, 0, 0, 0, 973, 1039, 1047, 1286, 1302, 1308, 1316, 1318, 1336, 1343,
		1348, 1352, 1355, 1358, 1364, 1369, 1373, 1396, 1404, 1408, 1414, 1423,
		1430, 1435, 1438, 1441, 1444, 1447, 1450, 1453, 1456, 1459, 1462, 1466,
		1469, 1472, 1475, 1478, 1483, 1486, 1496, 1504, 1507, 1515, 1525, 1527,
		1530, 1537, 1544, 1547, 1552, 1556, 1571, 1575, 1584, 1598, 1607, 1615,
		1618, 1621, 1632, 1637, 1641, 1647, 1656, 1663, 1671, 1674, 1678, 1681,
		1684, 1687, 1690, 1693, 1696, 1703, 1708, 1712, 1729, 1742, 1755, 1758,
		1768, 1770, 1773, 1786, 1791, 1797, 1804, 1810, 1818, 1824, 1832, 1838,
		1845, 1851, 1864, 1869, 1877, 1881, 1890, 1893, 1896, 1904, 1908, 1917,
		1920, 1923, 1925, 1930, 1934, 1938, 1944, 1948, 1951, 1954, 1966, 1976,
		1982, 1992, 1996, 2004, 2008, 2015, 2024, 2027, 2030, 2041, 2047, 2056,
		2061, 2064, 2068, 2082, 2087, 2111, 2115, 2121, 2127, 2132, 2137, 2144,
		2148, 2154, 2158, 2166, 2179, 2188, 2195, 2200, 2203, 2208, 2221, 2226,
		2235, 2242, 2248, 2255, 2267, 2275, 2284, 2286, 2289, 2294, 2299, 2307,
		2318, 2332, 2341, 2350, 2354, 2361, 2369, 2387, 2396, 2399, 2403, 2416,
		2437, 2450, 2454, 2467, 2475, 2488, 2494, 2497, 2512, 2519, 2532, 2537,
		2565, 2574, 2579, 2588, 2593, 2595, 2601, 2606, 2619, 2624, 2630, 2639,
		2652, 2706, 2730, 2736, 2745, 2751, 2754, 2763, 2779, 2789, 2795, 2805,
		2811, 2821, 2832, 2839, 2846, 2863, 2878, 2892, 2907, 2920, 2922, 2925,
		2951, 2954, 2957, 2960, 2963, 2966, 2974, 2978, 2981, 2991, 2997, 3000,
		3007, 3010, 3018, 3022, 3025, 3043, 3046, 3054, 3059, 3063, 3069, 3071,
		3083, 3086, 3095, 3099, 3111, 3116, 3120, 3132, 3137, 3143, 3151, 3162,
		3165, 3171, 3174, 3177, 3193, 3215, 3233, 3238, 3241, 3244, 3248, 3252,
		3255, 3258, 3260, 3264, 3269, 3275, 3278, 3281, 3285, 3290, 3294, 3298,
		3303, 3308, 3315, 3317, 3329, 3336, 3343, 3351, 3357, 3360, 3367, 3372,
		3376, 3385, 3388, 3394, 3399, 3402, 3405, 3414, 3417, 3420, 3426, 3430,
		3434, 3442, 3452, 3455, 3458, 3463, 3472, 3480, 3483, 3486, 3489, 3501,
		3519, 3524, 3528, 3544, 3555, 3566, 3572, 3580, 3583, 3587, 3591, 3600,
		3603, 3606, 3614, 3626, 3632, 3640, 3643, 3647, 3651, 3660, 3663, 3666,
		3670, 3675, 3678, 3683, 3686, 3694, 3704, 3719, 3724, 3729, 3744, 3747,
		3753, 3766, 3772, 3776, 3781, 3786, 3791, 3801, 3806, 3809, 3813, 3822,
		3827, 3831, 3840, 3843, 3846, 3851, 3857, 3866, 3869, 3872, 3879, 3888,
		3891, 3894, 3903, 3919, 3922, 3926, 3931, 3936, 3951, 3955, 3964, 3967,
		3976, 3996, 4010, 4033, 4038, 4042, 4049, 4054, 4056, 4067, 4071, 4076,
		4097, 4100, 4105, 4111, 4115, 4120, 4130, 4133, 4145, 4148, 4154, 4160,
		4165, 4171, 4174, 4178, 4182, 4188, 4193, 4195, 4200, 4210, 4219, 4225,
		4231, 4237, 4240, 4243, 4246, 4253, 4257, 4261, 4268, 4274, 4278, 4282,
		4284, 4290, 4295, 4300, 4305, 4312, 4318, 4320, 4326, 4331, 4335, 4339,
		4348, 4351, 4354, 4361, 4365, 4368, 4375, 4381, 4385, 4393, 4397, 4419,
		4425, 4433, 4439, 4447, 4453, 4459, 4487, 4495, 4500, 4506, 4513, 4517,
		4524, 4534, 4538, 4547, 4550, 4553, 4555, 4561, 4565, 4569, 4574, 4580,
		4586, 4590, 4596, 4600, 4602, 4606, 4613, 4618, 4628, 4632, 4637, 4640,
		4646, 4654, 4663, 4671, 4677, 4683, 4695, 4697, 4705, 4712, 4716, 4722,
		4734, 4745, 4755, 4761, 4771, 4784, 4789, 4797, 4803, 4808, 4819, 4827,
		4838, 4844, 4853, 4864, 4876, 4889, 4896, 4898, 4909, 4926, 4959, 4964,
		4972, 4980, 4985, 4993, 4995, 5000, 5007, 5022, 5030, 5035, 5058, 5076,
		5092, 5112, 5148, 5158, 5179, 5183, 5196, 5201, 5205, 5214, 5220, 5233,
		5239, 5241, 5250, 5255, 5259, 5268, 5274, 5278, 5286, 5291, 5298, 5305,
		5322, 5339, 5350, 5369, 5374, 5378, 5400, 5407, 5410, 5416, 5423, 5426,
		5429, 5435, 5441, 5447, 5453, 5462, 5465, 5468, 5475, 5486, 5495, 5503,
		5511, 5520, 5533, 5552, 5561, 5564, 5567, 5575, 5583, 5587, 5592, 5597,
		5599, 5609, 5621, 5628, 5639, 5643, 5655, 5661, 5674, 5680, 5686, 5695,
		5711, 5716, 5720, 5723, 5729, 5732, 5735, 5762, 5766, 5769, 5775, 5783,
		5791, 5797, 5801, 5809, 5823, 5830, 5842, 5846, 5848, 5852, 5856, 5859,
		5862, 5865, 5869, 5873, 5876, 5879, 5882, 5893, 5897, 5901, 5904, 5914,
		5925, 5928, 5931, 5934, 5943, 5952, 5958, 5965, 5972, 5977, 5983, 5986,
		5988, 6001, 6005, 6010, 6016, 6023, 6027, 6034, 6040, 6045, 6049, 6056,
		6061, 6063, 6067, 6072, 6078, 6089, 6095, 6099, 6105, 6112, 6123, 6127,
		6129, 6136, 6141, 6146, 6153, 6161, 6166, 6170, 6173, 6176, 6179, 6182,
		6185, 6188, 6191, 6195, 6204, 6209, 6213, 6215, 6219, 6223, 6225, 6232,
		6236, 6238, 6248, 6252, 6254, 6259, 6263, 6265, 6271, 6280, 6286, 6295,
		6303, 6307, 6309, 6313, 6316, 6320, 6322, 6326, 6330, 6337, 6346, 6349,
		6353, 6357, 6360, 6365, 6373, 6402, 6410, 6422, 6437, 6442, 6450, 6456,
		6465, 6471, 6476, 6485, 6497, 6509, 6521, 6524, 6537, 6548, 6555, 6562,
		6574, 6579, 6587, 6589, 6597, 6606, 6619, 6621, 6626, 6629, 6637, 6641,
		6649, 6654, 6659, 6667, 6675, 6683, 6687, 6716, 6718, 6770, 6774, 6782,
		6786, 6791, 6795, 6801, 6808, 6813, 6822, 6826, 6833, 6841, 6847, 6857,
		6861, 6867, 6869, 6882, 6898, 6901, 6911, 6914, 6922, 6934, 6937, 6947,
		6950, 6954, 6956, 6961, 6969, 6976, 6978, 6985, 6988, 6994, 7002, 7010,
		7018, 7028, 7031, 7045, 7048, 7055, 7062, 7072, 7075, 7079, 7083, 7093,
		7114, 7119, 7124, 7126, 7131, 7136, 7141, 7144, 7149, 7154, 7156, 7180,
		7183, 7236, 7239, 7299, 7319, 7326, 7332, 7335, 7339, 7345, 7351, 7354,
		7358, 7364, 7370, 7373, 7377, 7383, 7389, 7392, 7396, 7398, 7408, 7417,
		7420, 7429, 7432, 7435, 7458, 7469, 7478, 7480, 7486, 7496, 7498, 7506,
		7508, 7510, 7514, 7518, 7522, 7526, 7531, 7535, 7547, 7550, 7564, 7567,
		7574, 7583, 7586, 7593, 7605, 7608, 7622, 7625, 7629, 7635, 7642, 7648,
		7655, 7663, 7674, 7681, 7685, 7693, 7704, 7715, 7722, 7728, 7734, 7762,
		7777, 7785, 7793, 7804, 7812, 7818, 7826, 7837, 7839, 7851, 7860, 7869,
		7880, 7894, 7904, 7915, 7931, 7934, 7940, 7969, 7985, 7994, 8009, 8013,
		8017, 8021, 8025, 8029, 8033, 8037, 8041, 8045, 8054, 8058, 8068, 8072,
		8074, 8081, 8084, 8090, 8092, 8098, 8109, 8114, 8122, 8133, 8140, 8147,
		8153, 8166, 8177, 8183,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// StarRocksParserInit initializes any static state used to implement StarRocksParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewStarRocksParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func StarRocksParserInit() {
	staticData := &StarRocksParserStaticData
	staticData.once.Do(starrocksParserInit)
}

// NewStarRocksParser produces a new parser instance for the optional input antlr.TokenStream.
func NewStarRocksParser(input antlr.TokenStream) *StarRocksParser {
	StarRocksParserInit()
	this := new(StarRocksParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &StarRocksParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "StarRocks.g4"

	return this
}

// StarRocksParser tokens.
const (
	StarRocksParserEOF                       = antlr.TokenEOF
	StarRocksParserT__0                      = 1
	StarRocksParserT__1                      = 2
	StarRocksParserT__2                      = 3
	StarRocksParserT__3                      = 4
	StarRocksParserT__4                      = 5
	StarRocksParserT__5                      = 6
	StarRocksParserT__6                      = 7
	StarRocksParserT__7                      = 8
	StarRocksParserT__8                      = 9
	StarRocksParserT__9                      = 10
	StarRocksParserACCESS                    = 11
	StarRocksParserACTIVE                    = 12
	StarRocksParserADD                       = 13
	StarRocksParserADMIN                     = 14
	StarRocksParserADVISOR                   = 15
	StarRocksParserAFTER                     = 16
	StarRocksParserAGGREGATE                 = 17
	StarRocksParserALL                       = 18
	StarRocksParserALTER                     = 19
	StarRocksParserANALYZE                   = 20
	StarRocksParserAND                       = 21
	StarRocksParserANTI                      = 22
	StarRocksParserAPPLY                     = 23
	StarRocksParserARRAY                     = 24
	StarRocksParserARRAY_AGG                 = 25
	StarRocksParserARRAY_AGG_DISTINCT        = 26
	StarRocksParserAS                        = 27
	StarRocksParserASC                       = 28
	StarRocksParserASYNC                     = 29
	StarRocksParserAUTHORS                   = 30
	StarRocksParserAUTHENTICATION            = 31
	StarRocksParserAUTOMATED                 = 32
	StarRocksParserAUTO_INCREMENT            = 33
	StarRocksParserAVG                       = 34
	StarRocksParserBACKEND                   = 35
	StarRocksParserBACKENDS                  = 36
	StarRocksParserBACKUP                    = 37
	StarRocksParserBASE                      = 38
	StarRocksParserBASELINE                  = 39
	StarRocksParserBEGIN                     = 40
	StarRocksParserBETWEEN                   = 41
	StarRocksParserBIGINT                    = 42
	StarRocksParserBINARY                    = 43
	StarRocksParserBITMAP                    = 44
	StarRocksParserBITMAP_UNION              = 45
	StarRocksParserBLACKHOLE                 = 46
	StarRocksParserBLACKLIST                 = 47
	StarRocksParserBODY                      = 48
	StarRocksParserBOOLEAN                   = 49
	StarRocksParserBOTH                      = 50
	StarRocksParserBRANCH                    = 51
	StarRocksParserBROKER                    = 52
	StarRocksParserBUCKETS                   = 53
	StarRocksParserBUILTIN                   = 54
	StarRocksParserBY                        = 55
	StarRocksParserCACHE                     = 56
	StarRocksParserCANCEL                    = 57
	StarRocksParserCASE                      = 58
	StarRocksParserCAST                      = 59
	StarRocksParserCATALOG                   = 60
	StarRocksParserCATALOGS                  = 61
	StarRocksParserCEIL                      = 62
	StarRocksParserCHAIN                     = 63
	StarRocksParserCHAR                      = 64
	StarRocksParserCHARACTER                 = 65
	StarRocksParserCHARSET                   = 66
	StarRocksParserCHECK                     = 67
	StarRocksParserCLEAN                     = 68
	StarRocksParserCLEAR                     = 69
	StarRocksParserCLUSTER                   = 70
	StarRocksParserCLUSTERS                  = 71
	StarRocksParserCOLLATE                   = 72
	StarRocksParserCOLLATION                 = 73
	StarRocksParserCOLUMN                    = 74
	StarRocksParserCOLUMNS                   = 75
	StarRocksParserCOMMENT                   = 76
	StarRocksParserCOMMIT                    = 77
	StarRocksParserCOMMITTED                 = 78
	StarRocksParserCOMPACT                   = 79
	StarRocksParserCOMPACTION                = 80
	StarRocksParserCOMPUTE                   = 81
	StarRocksParserCONFIG                    = 82
	StarRocksParserCONNECTION                = 83
	StarRocksParserCONSISTENT                = 84
	StarRocksParserCONVERT                   = 85
	StarRocksParserCOSTS                     = 86
	StarRocksParserCOUNT                     = 87
	StarRocksParserCREATE                    = 88
	StarRocksParserCROSS                     = 89
	StarRocksParserCUBE                      = 90
	StarRocksParserCUME_DIST                 = 91
	StarRocksParserCUMULATIVE                = 92
	StarRocksParserCURRENT                   = 93
	StarRocksParserCURRENT_DATE              = 94
	StarRocksParserCURRENT_GROUP             = 95
	StarRocksParserCURRENT_ROLE              = 96
	StarRocksParserCURRENT_TIME              = 97
	StarRocksParserCURRENT_TIMESTAMP         = 98
	StarRocksParserCURRENT_USER              = 99
	StarRocksParserDATA                      = 100
	StarRocksParserDATACACHE                 = 101
	StarRocksParserDATABASE                  = 102
	StarRocksParserDATABASES                 = 103
	StarRocksParserDATE                      = 104
	StarRocksParserDATETIME                  = 105
	StarRocksParserDAY                       = 106
	StarRocksParserDAYS                      = 107
	StarRocksParserDEALLOCATE                = 108
	StarRocksParserDECIMAL                   = 109
	StarRocksParserDECIMALV2                 = 110
	StarRocksParserDECIMAL32                 = 111
	StarRocksParserDECIMAL64                 = 112
	StarRocksParserDECIMAL128                = 113
	StarRocksParserDECOMMISSION              = 114
	StarRocksParserDEFAULT                   = 115
	StarRocksParserDELETE                    = 116
	StarRocksParserDENSE_RANK                = 117
	StarRocksParserDEFERRED                  = 118
	StarRocksParserDIALECT                   = 119
	StarRocksParserDICTIONARY                = 120
	StarRocksParserDICTIONARY_GET            = 121
	StarRocksParserNTILE                     = 122
	StarRocksParserDESC                      = 123
	StarRocksParserDESCRIBE                  = 124
	StarRocksParserDISABLE                   = 125
	StarRocksParserDISTINCT                  = 126
	StarRocksParserDISTRIBUTED               = 127
	StarRocksParserDISTRIBUTION              = 128
	StarRocksParserDOUBLE                    = 129
	StarRocksParserDROP                      = 130
	StarRocksParserDUAL                      = 131
	StarRocksParserDUPLICATE                 = 132
	StarRocksParserDYNAMIC                   = 133
	StarRocksParserELSE                      = 134
	StarRocksParserENABLE                    = 135
	StarRocksParserENCLOSE                   = 136
	StarRocksParserEND                       = 137
	StarRocksParserENGINE                    = 138
	StarRocksParserENGINES                   = 139
	StarRocksParserERRORS                    = 140
	StarRocksParserESCAPE                    = 141
	StarRocksParserEVENTS                    = 142
	StarRocksParserEXCEPT                    = 143
	StarRocksParserEXECUTE                   = 144
	StarRocksParserEXISTS                    = 145
	StarRocksParserEXPLAIN                   = 146
	StarRocksParserEXPORT                    = 147
	StarRocksParserEXTERNAL                  = 148
	StarRocksParserEXTRACT                   = 149
	StarRocksParserEVERY                     = 150
	StarRocksParserFAILPOINT                 = 151
	StarRocksParserFAILPOINTS                = 152
	StarRocksParserFALSE                     = 153
	StarRocksParserFIELDS                    = 154
	StarRocksParserFILE                      = 155
	StarRocksParserFILES                     = 156
	StarRocksParserFILTER                    = 157
	StarRocksParserFIRST                     = 158
	StarRocksParserFIRST_VALUE               = 159
	StarRocksParserFLOAT                     = 160
	StarRocksParserFLOOR                     = 161
	StarRocksParserFN                        = 162
	StarRocksParserFOLLOWING                 = 163
	StarRocksParserFOLLOWER                  = 164
	StarRocksParserFOR                       = 165
	StarRocksParserFORCE                     = 166
	StarRocksParserFORMAT                    = 167
	StarRocksParserFREE                      = 168
	StarRocksParserFROM                      = 169
	StarRocksParserFRONTEND                  = 170
	StarRocksParserFRONTENDS                 = 171
	StarRocksParserFULL                      = 172
	StarRocksParserFUNCTION                  = 173
	StarRocksParserFUNCTIONS                 = 174
	StarRocksParserGLOBAL                    = 175
	StarRocksParserGRANT                     = 176
	StarRocksParserGRANTS                    = 177
	StarRocksParserGROUP                     = 178
	StarRocksParserGROUPS                    = 179
	StarRocksParserGROUPING                  = 180
	StarRocksParserGROUPING_ID               = 181
	StarRocksParserGROUP_CONCAT              = 182
	StarRocksParserHASH                      = 183
	StarRocksParserHAVING                    = 184
	StarRocksParserHELP                      = 185
	StarRocksParserHISTOGRAM                 = 186
	StarRocksParserHLL                       = 187
	StarRocksParserHLL_UNION                 = 188
	StarRocksParserHOST                      = 189
	StarRocksParserHOUR                      = 190
	StarRocksParserHOURS                     = 191
	StarRocksParserHUB                       = 192
	StarRocksParserIDENTIFIED                = 193
	StarRocksParserIF                        = 194
	StarRocksParserIMPERSONATE               = 195
	StarRocksParserIMMEDIATE                 = 196
	StarRocksParserIGNORE                    = 197
	StarRocksParserIMAGE                     = 198
	StarRocksParserIN                        = 199
	StarRocksParserINACTIVE                  = 200
	StarRocksParserINCREMENTAL               = 201
	StarRocksParserINDEX                     = 202
	StarRocksParserINDEXES                   = 203
	StarRocksParserINFILE                    = 204
	StarRocksParserINNER                     = 205
	StarRocksParserINSTALL                   = 206
	StarRocksParserINSERT                    = 207
	StarRocksParserINT                       = 208
	StarRocksParserINTEGER                   = 209
	StarRocksParserINTEGRATION               = 210
	StarRocksParserINTEGRATIONS              = 211
	StarRocksParserINTERMEDIATE              = 212
	StarRocksParserINTERSECT                 = 213
	StarRocksParserINTERVAL                  = 214
	StarRocksParserINTO                      = 215
	StarRocksParserINVOKER                   = 216
	StarRocksParserGIN                       = 217
	StarRocksParserOVERWRITE                 = 218
	StarRocksParserIS                        = 219
	StarRocksParserISOLATION                 = 220
	StarRocksParserJOB                       = 221
	StarRocksParserJOIN                      = 222
	StarRocksParserJSON                      = 223
	StarRocksParserKEY                       = 224
	StarRocksParserKEYS                      = 225
	StarRocksParserKILL                      = 226
	StarRocksParserLABEL                     = 227
	StarRocksParserLAG                       = 228
	StarRocksParserLARGEINT                  = 229
	StarRocksParserLAST                      = 230
	StarRocksParserLAST_VALUE                = 231
	StarRocksParserLATERAL                   = 232
	StarRocksParserLEAD                      = 233
	StarRocksParserLEFT                      = 234
	StarRocksParserLESS                      = 235
	StarRocksParserLEVEL                     = 236
	StarRocksParserLIKE                      = 237
	StarRocksParserLIMIT                     = 238
	StarRocksParserLIST                      = 239
	StarRocksParserLOAD                      = 240
	StarRocksParserLOCAL                     = 241
	StarRocksParserLOCALTIME                 = 242
	StarRocksParserLOCALTIMESTAMP            = 243
	StarRocksParserLOCATION                  = 244
	StarRocksParserLOCATIONS                 = 245
	StarRocksParserLOGS                      = 246
	StarRocksParserLOGICAL                   = 247
	StarRocksParserMANUAL                    = 248
	StarRocksParserMAP                       = 249
	StarRocksParserMAPPING                   = 250
	StarRocksParserMAPPINGS                  = 251
	StarRocksParserMASKING                   = 252
	StarRocksParserMATCH                     = 253
	StarRocksParserMATERIALIZED              = 254
	StarRocksParserMAX                       = 255
	StarRocksParserMAXVALUE                  = 256
	StarRocksParserMERGE                     = 257
	StarRocksParserMICROSECOND               = 258
	StarRocksParserMILLISECOND               = 259
	StarRocksParserMIN                       = 260
	StarRocksParserMINUTE                    = 261
	StarRocksParserMINUTES                   = 262
	StarRocksParserMINUS                     = 263
	StarRocksParserMETA                      = 264
	StarRocksParserMOD                       = 265
	StarRocksParserMODE                      = 266
	StarRocksParserMODIFY                    = 267
	StarRocksParserMONTH                     = 268
	StarRocksParserMULTIPLE                  = 269
	StarRocksParserNAME                      = 270
	StarRocksParserNAMES                     = 271
	StarRocksParserNEGATIVE                  = 272
	StarRocksParserNGRAMBF                   = 273
	StarRocksParserNO                        = 274
	StarRocksParserNODE                      = 275
	StarRocksParserNODES                     = 276
	StarRocksParserNONE                      = 277
	StarRocksParserNOT                       = 278
	StarRocksParserNULL                      = 279
	StarRocksParserNULLS                     = 280
	StarRocksParserNUMBER                    = 281
	StarRocksParserNUMERIC                   = 282
	StarRocksParserOBSERVER                  = 283
	StarRocksParserOF                        = 284
	StarRocksParserOFF                       = 285
	StarRocksParserOFFSET                    = 286
	StarRocksParserON                        = 287
	StarRocksParserONLY                      = 288
	StarRocksParserOPEN                      = 289
	StarRocksParserOPERATE                   = 290
	StarRocksParserOPTIMIZE                  = 291
	StarRocksParserOPTIMIZER                 = 292
	StarRocksParserOPTION                    = 293
	StarRocksParserOR                        = 294
	StarRocksParserORDER                     = 295
	StarRocksParserOUTER                     = 296
	StarRocksParserOUTFILE                   = 297
	StarRocksParserOVER                      = 298
	StarRocksParserPARAMETER                 = 299
	StarRocksParserPARTITION                 = 300
	StarRocksParserPARTITIONS                = 301
	StarRocksParserPASSWORD                  = 302
	StarRocksParserPATH                      = 303
	StarRocksParserPAUSE                     = 304
	StarRocksParserPENDING                   = 305
	StarRocksParserPERCENT_RANK              = 306
	StarRocksParserPERCENTILE                = 307
	StarRocksParserPERCENTILE_UNION          = 308
	StarRocksParserPLAN                      = 309
	StarRocksParserPLUGIN                    = 310
	StarRocksParserPLUGINS                   = 311
	StarRocksParserPIPE                      = 312
	StarRocksParserPIPES                     = 313
	StarRocksParserPIVOT                     = 314
	StarRocksParserPOLICY                    = 315
	StarRocksParserPOLICIES                  = 316
	StarRocksParserPRECEDING                 = 317
	StarRocksParserPREDICATE                 = 318
	StarRocksParserPREPARE                   = 319
	StarRocksParserPRIMARY                   = 320
	StarRocksParserPRIORITY                  = 321
	StarRocksParserPRIVILEGES                = 322
	StarRocksParserPROBABILITY               = 323
	StarRocksParserPROC                      = 324
	StarRocksParserPROCEDURE                 = 325
	StarRocksParserPROCESSLIST               = 326
	StarRocksParserPROFILE                   = 327
	StarRocksParserPROFILELIST               = 328
	StarRocksParserPROPERTIES                = 329
	StarRocksParserPROPERTY                  = 330
	StarRocksParserPROVIDER                  = 331
	StarRocksParserPROVIDERS                 = 332
	StarRocksParserQUALIFY                   = 333
	StarRocksParserQUARTER                   = 334
	StarRocksParserQUERY                     = 335
	StarRocksParserQUERIES                   = 336
	StarRocksParserQUEUE                     = 337
	StarRocksParserQUOTA                     = 338
	StarRocksParserRANDOM                    = 339
	StarRocksParserRANGE                     = 340
	StarRocksParserRANK                      = 341
	StarRocksParserREAD                      = 342
	StarRocksParserREASON                    = 343
	StarRocksParserRECOVER                   = 344
	StarRocksParserREFRESH                   = 345
	StarRocksParserREWRITE                   = 346
	StarRocksParserREGEXP                    = 347
	StarRocksParserRELEASE                   = 348
	StarRocksParserREMOVE                    = 349
	StarRocksParserRENAME                    = 350
	StarRocksParserREPAIR                    = 351
	StarRocksParserREPEATABLE                = 352
	StarRocksParserREPLACE                   = 353
	StarRocksParserREPLACE_IF_NOT_NULL       = 354
	StarRocksParserREPLICA                   = 355
	StarRocksParserREPOSITORY                = 356
	StarRocksParserREPOSITORIES              = 357
	StarRocksParserRESOURCE                  = 358
	StarRocksParserRESOURCES                 = 359
	StarRocksParserRESTORE                   = 360
	StarRocksParserRESUME                    = 361
	StarRocksParserRETAIN                    = 362
	StarRocksParserRETENTION                 = 363
	StarRocksParserRETURNS                   = 364
	StarRocksParserRETRY                     = 365
	StarRocksParserREVOKE                    = 366
	StarRocksParserREVERT                    = 367
	StarRocksParserRIGHT                     = 368
	StarRocksParserRLIKE                     = 369
	StarRocksParserROLE                      = 370
	StarRocksParserROLES                     = 371
	StarRocksParserROLLBACK                  = 372
	StarRocksParserROLLUP                    = 373
	StarRocksParserROUTINE                   = 374
	StarRocksParserROW                       = 375
	StarRocksParserROWS                      = 376
	StarRocksParserROW_NUMBER                = 377
	StarRocksParserRULE                      = 378
	StarRocksParserRULES                     = 379
	StarRocksParserRUNNING                   = 380
	StarRocksParserSAMPLE                    = 381
	StarRocksParserSCHEDULE                  = 382
	StarRocksParserSCHEDULER                 = 383
	StarRocksParserSCHEMA                    = 384
	StarRocksParserSCHEMAS                   = 385
	StarRocksParserSECOND                    = 386
	StarRocksParserSECURITY                  = 387
	StarRocksParserSELECT                    = 388
	StarRocksParserSEMI                      = 389
	StarRocksParserSEPARATOR                 = 390
	StarRocksParserSERIALIZABLE              = 391
	StarRocksParserSESSION                   = 392
	StarRocksParserSET                       = 393
	StarRocksParserSETS                      = 394
	StarRocksParserSET_VAR                   = 395
	StarRocksParserSIGNED                    = 396
	StarRocksParserSKIP_HEADER               = 397
	StarRocksParserSHOW                      = 398
	StarRocksParserSMALLINT                  = 399
	StarRocksParserSNAPSHOT                  = 400
	StarRocksParserSNAPSHOTS                 = 401
	StarRocksParserSQLBLACKLIST              = 402
	StarRocksParserSTARROCKS                 = 403
	StarRocksParserSTART                     = 404
	StarRocksParserSTATS                     = 405
	StarRocksParserSTATUS                    = 406
	StarRocksParserSTOP                      = 407
	StarRocksParserSTORAGE                   = 408
	StarRocksParserSTREAM                    = 409
	StarRocksParserSTRING                    = 410
	StarRocksParserTEXT                      = 411
	StarRocksParserSUBMIT                    = 412
	StarRocksParserSUM                       = 413
	StarRocksParserSUSPEND                   = 414
	StarRocksParserSYNC                      = 415
	StarRocksParserSYSTEM                    = 416
	StarRocksParserSYSTEM_TIME               = 417
	StarRocksParserSWAP                      = 418
	StarRocksParserSTRUCT                    = 419
	StarRocksParserTABLE                     = 420
	StarRocksParserTABLES                    = 421
	StarRocksParserTABLET                    = 422
	StarRocksParserTABLETS                   = 423
	StarRocksParserTAG                       = 424
	StarRocksParserTASK                      = 425
	StarRocksParserTEMPORARY                 = 426
	StarRocksParserTERMINATED                = 427
	StarRocksParserTHAN                      = 428
	StarRocksParserTHEN                      = 429
	StarRocksParserTIME                      = 430
	StarRocksParserTIMES                     = 431
	StarRocksParserTIMESTAMP                 = 432
	StarRocksParserTIMESTAMPADD              = 433
	StarRocksParserTIMESTAMPDIFF             = 434
	StarRocksParserTINYINT                   = 435
	StarRocksParserTRANSACTION               = 436
	StarRocksParserTRANSLATE                 = 437
	StarRocksParserTO                        = 438
	StarRocksParserTRACE                     = 439
	StarRocksParserTRIGGERS                  = 440
	StarRocksParserTRIM_SPACE                = 441
	StarRocksParserTRUE                      = 442
	StarRocksParserTRUNCATE                  = 443
	StarRocksParserTYPE                      = 444
	StarRocksParserTYPES                     = 445
	StarRocksParserUNBOUNDED                 = 446
	StarRocksParserUNCOMMITTED               = 447
	StarRocksParserUNION                     = 448
	StarRocksParserUNIQUE                    = 449
	StarRocksParserUNINSTALL                 = 450
	StarRocksParserUNSET                     = 451
	StarRocksParserUNSIGNED                  = 452
	StarRocksParserUPDATE                    = 453
	StarRocksParserUSAGE                     = 454
	StarRocksParserUSE                       = 455
	StarRocksParserUSER                      = 456
	StarRocksParserUSERS                     = 457
	StarRocksParserUSING                     = 458
	StarRocksParserVALUE                     = 459
	StarRocksParserVALUES                    = 460
	StarRocksParserVARBINARY                 = 461
	StarRocksParserVARCHAR                   = 462
	StarRocksParserVARIABLES                 = 463
	StarRocksParserVECTOR                    = 464
	StarRocksParserVERBOSE                   = 465
	StarRocksParserVERSION                   = 466
	StarRocksParserVIEW                      = 467
	StarRocksParserVIEWS                     = 468
	StarRocksParserVOLUME                    = 469
	StarRocksParserVOLUMES                   = 470
	StarRocksParserWAREHOUSE                 = 471
	StarRocksParserWAREHOUSES                = 472
	StarRocksParserWARNINGS                  = 473
	StarRocksParserWEEK                      = 474
	StarRocksParserWHEN                      = 475
	StarRocksParserWHERE                     = 476
	StarRocksParserWHITELIST                 = 477
	StarRocksParserWITH                      = 478
	StarRocksParserWORK                      = 479
	StarRocksParserWRITE                     = 480
	StarRocksParserYEAR                      = 481
	StarRocksParserLOCK                      = 482
	StarRocksParserUNLOCK                    = 483
	StarRocksParserLOW_PRIORITY              = 484
	StarRocksParserDISK                      = 485
	StarRocksParserBEFORE                    = 486
	StarRocksParserDOUBLE_DOLLAR             = 487
	StarRocksParserFIELD                     = 488
	StarRocksParserPERSISTENT                = 489
	StarRocksParserEQ                        = 490
	StarRocksParserNEQ                       = 491
	StarRocksParserLT                        = 492
	StarRocksParserLTE                       = 493
	StarRocksParserGT                        = 494
	StarRocksParserGTE                       = 495
	StarRocksParserEQ_FOR_NULL               = 496
	StarRocksParserARRAY_ELEMENT             = 497
	StarRocksParserPLUS_SYMBOL               = 498
	StarRocksParserMINUS_SYMBOL              = 499
	StarRocksParserASTERISK_SYMBOL           = 500
	StarRocksParserSLASH_SYMBOL              = 501
	StarRocksParserPERCENT_SYMBOL            = 502
	StarRocksParserLOGICAL_OR                = 503
	StarRocksParserLOGICAL_AND               = 504
	StarRocksParserLOGICAL_NOT               = 505
	StarRocksParserINT_DIV                   = 506
	StarRocksParserBITAND                    = 507
	StarRocksParserBITOR                     = 508
	StarRocksParserBITXOR                    = 509
	StarRocksParserBITNOT                    = 510
	StarRocksParserBIT_SHIFT_LEFT            = 511
	StarRocksParserBIT_SHIFT_RIGHT           = 512
	StarRocksParserBIT_SHIFT_RIGHT_LOGICAL   = 513
	StarRocksParserARROW                     = 514
	StarRocksParserAT                        = 515
	StarRocksParserINTEGER_VALUE             = 516
	StarRocksParserDECIMAL_VALUE             = 517
	StarRocksParserDOUBLE_VALUE              = 518
	StarRocksParserSINGLE_QUOTED_TEXT        = 519
	StarRocksParserDOUBLE_QUOTED_TEXT        = 520
	StarRocksParserBINARY_SINGLE_QUOTED_TEXT = 521
	StarRocksParserBINARY_DOUBLE_QUOTED_TEXT = 522
	StarRocksParserLETTER_IDENTIFIER         = 523
	StarRocksParserDIGIT_IDENTIFIER          = 524
	StarRocksParserBACKQUOTED_IDENTIFIER     = 525
	StarRocksParserDOT_IDENTIFIER            = 526
	StarRocksParserSIMPLE_COMMENT            = 527
	StarRocksParserBRACKETED_COMMENT         = 528
	StarRocksParserOPTIMIZER_HINT            = 529
	StarRocksParserSEMICOLON                 = 530
	StarRocksParserDOTDOTDOT                 = 531
	StarRocksParserWS                        = 532
	StarRocksParserATTACHMENT                = 533
	StarRocksParserCONCAT                    = 534
)

// StarRocksParser rules.
const (
	StarRocksParserRULE_sqlStatements                          = 0
	StarRocksParserRULE_singleStatement                        = 1
	StarRocksParserRULE_emptyStatement                         = 2
	StarRocksParserRULE_statement                              = 3
	StarRocksParserRULE_useDatabaseStatement                   = 4
	StarRocksParserRULE_useCatalogStatement                    = 5
	StarRocksParserRULE_setCatalogStatement                    = 6
	StarRocksParserRULE_showDatabasesStatement                 = 7
	StarRocksParserRULE_alterDbQuotaStatement                  = 8
	StarRocksParserRULE_createDbStatement                      = 9
	StarRocksParserRULE_dropDbStatement                        = 10
	StarRocksParserRULE_showCreateDbStatement                  = 11
	StarRocksParserRULE_alterDatabaseRenameStatement           = 12
	StarRocksParserRULE_recoverDbStmt                          = 13
	StarRocksParserRULE_showDataStmt                           = 14
	StarRocksParserRULE_showDataDistributionStmt               = 15
	StarRocksParserRULE_createTableStatement                   = 16
	StarRocksParserRULE_columnDesc                             = 17
	StarRocksParserRULE_charsetName                            = 18
	StarRocksParserRULE_defaultDesc                            = 19
	StarRocksParserRULE_generatedColumnDesc                    = 20
	StarRocksParserRULE_indexDesc                              = 21
	StarRocksParserRULE_engineDesc                             = 22
	StarRocksParserRULE_charsetDesc                            = 23
	StarRocksParserRULE_collateDesc                            = 24
	StarRocksParserRULE_keyDesc                                = 25
	StarRocksParserRULE_orderByDesc                            = 26
	StarRocksParserRULE_columnNullable                         = 27
	StarRocksParserRULE_typeWithNullable                       = 28
	StarRocksParserRULE_aggStateDesc                           = 29
	StarRocksParserRULE_aggDesc                                = 30
	StarRocksParserRULE_rollupDesc                             = 31
	StarRocksParserRULE_rollupItem                             = 32
	StarRocksParserRULE_dupKeys                                = 33
	StarRocksParserRULE_fromRollup                             = 34
	StarRocksParserRULE_orReplace                              = 35
	StarRocksParserRULE_ifNotExists                            = 36
	StarRocksParserRULE_createTableAsSelectStatement           = 37
	StarRocksParserRULE_dropTableStatement                     = 38
	StarRocksParserRULE_cleanTemporaryTableStatement           = 39
	StarRocksParserRULE_alterTableStatement                    = 40
	StarRocksParserRULE_createIndexStatement                   = 41
	StarRocksParserRULE_dropIndexStatement                     = 42
	StarRocksParserRULE_indexType                              = 43
	StarRocksParserRULE_showTableStatement                     = 44
	StarRocksParserRULE_showTemporaryTablesStatement           = 45
	StarRocksParserRULE_showCreateTableStatement               = 46
	StarRocksParserRULE_showColumnStatement                    = 47
	StarRocksParserRULE_showTableStatusStatement               = 48
	StarRocksParserRULE_refreshTableStatement                  = 49
	StarRocksParserRULE_showAlterStatement                     = 50
	StarRocksParserRULE_descTableStatement                     = 51
	StarRocksParserRULE_createTableLikeStatement               = 52
	StarRocksParserRULE_showIndexStatement                     = 53
	StarRocksParserRULE_recoverTableStatement                  = 54
	StarRocksParserRULE_truncateTableStatement                 = 55
	StarRocksParserRULE_cancelAlterTableStatement              = 56
	StarRocksParserRULE_showPartitionsStatement                = 57
	StarRocksParserRULE_recoverPartitionStatement              = 58
	StarRocksParserRULE_createViewStatement                    = 59
	StarRocksParserRULE_alterViewStatement                     = 60
	StarRocksParserRULE_dropViewStatement                      = 61
	StarRocksParserRULE_columnNameWithComment                  = 62
	StarRocksParserRULE_submitTaskStatement                    = 63
	StarRocksParserRULE_taskClause                             = 64
	StarRocksParserRULE_dropTaskStatement                      = 65
	StarRocksParserRULE_taskScheduleDesc                       = 66
	StarRocksParserRULE_createMaterializedViewStatement        = 67
	StarRocksParserRULE_mvPartitionExprs                       = 68
	StarRocksParserRULE_materializedViewDesc                   = 69
	StarRocksParserRULE_showMaterializedViewsStatement         = 70
	StarRocksParserRULE_dropMaterializedViewStatement          = 71
	StarRocksParserRULE_alterMaterializedViewStatement         = 72
	StarRocksParserRULE_refreshMaterializedViewStatement       = 73
	StarRocksParserRULE_cancelRefreshMaterializedViewStatement = 74
	StarRocksParserRULE_adminSetConfigStatement                = 75
	StarRocksParserRULE_adminSetReplicaStatusStatement         = 76
	StarRocksParserRULE_adminShowConfigStatement               = 77
	StarRocksParserRULE_adminShowReplicaDistributionStatement  = 78
	StarRocksParserRULE_adminShowReplicaStatusStatement        = 79
	StarRocksParserRULE_adminRepairTableStatement              = 80
	StarRocksParserRULE_adminCancelRepairTableStatement        = 81
	StarRocksParserRULE_adminCheckTabletsStatement             = 82
	StarRocksParserRULE_adminSetPartitionVersion               = 83
	StarRocksParserRULE_killStatement                          = 84
	StarRocksParserRULE_syncStatement                          = 85
	StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement   = 86
	StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement  = 87
	StarRocksParserRULE_alterSystemStatement                   = 88
	StarRocksParserRULE_cancelAlterSystemStatement             = 89
	StarRocksParserRULE_showComputeNodesStatement              = 90
	StarRocksParserRULE_createExternalCatalogStatement         = 91
	StarRocksParserRULE_showCreateExternalCatalogStatement     = 92
	StarRocksParserRULE_dropExternalCatalogStatement           = 93
	StarRocksParserRULE_showCatalogsStatement                  = 94
	StarRocksParserRULE_alterCatalogStatement                  = 95
	StarRocksParserRULE_createStorageVolumeStatement           = 96
	StarRocksParserRULE_typeDesc                               = 97
	StarRocksParserRULE_locationsDesc                          = 98
	StarRocksParserRULE_showStorageVolumesStatement            = 99
	StarRocksParserRULE_dropStorageVolumeStatement             = 100
	StarRocksParserRULE_alterStorageVolumeStatement            = 101
	StarRocksParserRULE_alterStorageVolumeClause               = 102
	StarRocksParserRULE_modifyStorageVolumePropertiesClause    = 103
	StarRocksParserRULE_modifyStorageVolumeCommentClause       = 104
	StarRocksParserRULE_descStorageVolumeStatement             = 105
	StarRocksParserRULE_setDefaultStorageVolumeStatement       = 106
	StarRocksParserRULE_updateFailPointStatusStatement         = 107
	StarRocksParserRULE_showFailPointStatement                 = 108
	StarRocksParserRULE_createDictionaryStatement              = 109
	StarRocksParserRULE_dropDictionaryStatement                = 110
	StarRocksParserRULE_refreshDictionaryStatement             = 111
	StarRocksParserRULE_showDictionaryStatement                = 112
	StarRocksParserRULE_cancelRefreshDictionaryStatement       = 113
	StarRocksParserRULE_dictionaryColumnDesc                   = 114
	StarRocksParserRULE_dictionaryName                         = 115
	StarRocksParserRULE_alterClause                            = 116
	StarRocksParserRULE_addFrontendClause                      = 117
	StarRocksParserRULE_dropFrontendClause                     = 118
	StarRocksParserRULE_modifyFrontendHostClause               = 119
	StarRocksParserRULE_addBackendClause                       = 120
	StarRocksParserRULE_dropBackendClause                      = 121
	StarRocksParserRULE_decommissionBackendClause              = 122
	StarRocksParserRULE_modifyBackendClause                    = 123
	StarRocksParserRULE_addComputeNodeClause                   = 124
	StarRocksParserRULE_dropComputeNodeClause                  = 125
	StarRocksParserRULE_modifyBrokerClause                     = 126
	StarRocksParserRULE_alterLoadErrorUrlClause                = 127
	StarRocksParserRULE_createImageClause                      = 128
	StarRocksParserRULE_cleanTabletSchedQClause                = 129
	StarRocksParserRULE_decommissionDiskClause                 = 130
	StarRocksParserRULE_cancelDecommissionDiskClause           = 131
	StarRocksParserRULE_disableDiskClause                      = 132
	StarRocksParserRULE_cancelDisableDiskClause                = 133
	StarRocksParserRULE_createIndexClause                      = 134
	StarRocksParserRULE_dropIndexClause                        = 135
	StarRocksParserRULE_tableRenameClause                      = 136
	StarRocksParserRULE_swapTableClause                        = 137
	StarRocksParserRULE_modifyPropertiesClause                 = 138
	StarRocksParserRULE_modifyCommentClause                    = 139
	StarRocksParserRULE_optimizeRange                          = 140
	StarRocksParserRULE_optimizeClause                         = 141
	StarRocksParserRULE_addColumnClause                        = 142
	StarRocksParserRULE_addColumnsClause                       = 143
	StarRocksParserRULE_dropColumnClause                       = 144
	StarRocksParserRULE_modifyColumnClause                     = 145
	StarRocksParserRULE_modifyColumnCommentClause              = 146
	StarRocksParserRULE_columnRenameClause                     = 147
	StarRocksParserRULE_reorderColumnsClause                   = 148
	StarRocksParserRULE_rollupRenameClause                     = 149
	StarRocksParserRULE_compactionClause                       = 150
	StarRocksParserRULE_subfieldName                           = 151
	StarRocksParserRULE_nestedFieldName                        = 152
	StarRocksParserRULE_addFieldClause                         = 153
	StarRocksParserRULE_dropFieldClause                        = 154
	StarRocksParserRULE_createOrReplaceTagClause               = 155
	StarRocksParserRULE_createOrReplaceBranchClause            = 156
	StarRocksParserRULE_dropBranchClause                       = 157
	StarRocksParserRULE_dropTagClause                          = 158
	StarRocksParserRULE_tableOperationClause                   = 159
	StarRocksParserRULE_tagOptions                             = 160
	StarRocksParserRULE_branchOptions                          = 161
	StarRocksParserRULE_snapshotRetention                      = 162
	StarRocksParserRULE_refRetain                              = 163
	StarRocksParserRULE_maxSnapshotAge                         = 164
	StarRocksParserRULE_minSnapshotsToKeep                     = 165
	StarRocksParserRULE_snapshotId                             = 166
	StarRocksParserRULE_timeUnit                               = 167
	StarRocksParserRULE_integer_list                           = 168
	StarRocksParserRULE_dropPersistentIndexClause              = 169
	StarRocksParserRULE_alterTableAutoIncrementClause          = 170
	StarRocksParserRULE_addPartitionClause                     = 171
	StarRocksParserRULE_dropPartitionClause                    = 172
	StarRocksParserRULE_truncatePartitionClause                = 173
	StarRocksParserRULE_modifyPartitionClause                  = 174
	StarRocksParserRULE_replacePartitionClause                 = 175
	StarRocksParserRULE_partitionRenameClause                  = 176
	StarRocksParserRULE_insertStatement                        = 177
	StarRocksParserRULE_insertLabelOrColumnAliases             = 178
	StarRocksParserRULE_columnAliasesOrByName                  = 179
	StarRocksParserRULE_updateStatement                        = 180
	StarRocksParserRULE_deleteStatement                        = 181
	StarRocksParserRULE_createRoutineLoadStatement             = 182
	StarRocksParserRULE_alterRoutineLoadStatement              = 183
	StarRocksParserRULE_dataSource                             = 184
	StarRocksParserRULE_loadProperties                         = 185
	StarRocksParserRULE_colSeparatorProperty                   = 186
	StarRocksParserRULE_rowDelimiterProperty                   = 187
	StarRocksParserRULE_importColumns                          = 188
	StarRocksParserRULE_columnProperties                       = 189
	StarRocksParserRULE_jobProperties                          = 190
	StarRocksParserRULE_dataSourceProperties                   = 191
	StarRocksParserRULE_stopRoutineLoadStatement               = 192
	StarRocksParserRULE_resumeRoutineLoadStatement             = 193
	StarRocksParserRULE_pauseRoutineLoadStatement              = 194
	StarRocksParserRULE_showRoutineLoadStatement               = 195
	StarRocksParserRULE_showRoutineLoadTaskStatement           = 196
	StarRocksParserRULE_showCreateRoutineLoadStatement         = 197
	StarRocksParserRULE_showStreamLoadStatement                = 198
	StarRocksParserRULE_analyzeStatement                       = 199
	StarRocksParserRULE_analyzeColumnClause                    = 200
	StarRocksParserRULE_dropStatsStatement                     = 201
	StarRocksParserRULE_histogramStatement                     = 202
	StarRocksParserRULE_analyzeHistogramStatement              = 203
	StarRocksParserRULE_dropHistogramStatement                 = 204
	StarRocksParserRULE_createAnalyzeStatement                 = 205
	StarRocksParserRULE_dropAnalyzeJobStatement                = 206
	StarRocksParserRULE_showAnalyzeStatement                   = 207
	StarRocksParserRULE_showStatsMetaStatement                 = 208
	StarRocksParserRULE_showHistogramMetaStatement             = 209
	StarRocksParserRULE_killAnalyzeStatement                   = 210
	StarRocksParserRULE_analyzeProfileStatement                = 211
	StarRocksParserRULE_createBaselinePlanStatement            = 212
	StarRocksParserRULE_dropBaselinePlanStatement              = 213
	StarRocksParserRULE_showBaselinePlanStatement              = 214
	StarRocksParserRULE_createResourceGroupStatement           = 215
	StarRocksParserRULE_dropResourceGroupStatement             = 216
	StarRocksParserRULE_alterResourceGroupStatement            = 217
	StarRocksParserRULE_showResourceGroupStatement             = 218
	StarRocksParserRULE_showResourceGroupUsageStatement        = 219
	StarRocksParserRULE_createResourceStatement                = 220
	StarRocksParserRULE_alterResourceStatement                 = 221
	StarRocksParserRULE_dropResourceStatement                  = 222
	StarRocksParserRULE_showResourceStatement                  = 223
	StarRocksParserRULE_classifier                             = 224
	StarRocksParserRULE_showFunctionsStatement                 = 225
	StarRocksParserRULE_dropFunctionStatement                  = 226
	StarRocksParserRULE_createFunctionStatement                = 227
	StarRocksParserRULE_inlineFunction                         = 228
	StarRocksParserRULE_typeList                               = 229
	StarRocksParserRULE_loadStatement                          = 230
	StarRocksParserRULE_labelName                              = 231
	StarRocksParserRULE_dataDescList                           = 232
	StarRocksParserRULE_dataDesc                               = 233
	StarRocksParserRULE_formatProps                            = 234
	StarRocksParserRULE_brokerDesc                             = 235
	StarRocksParserRULE_resourceDesc                           = 236
	StarRocksParserRULE_showLoadStatement                      = 237
	StarRocksParserRULE_showLoadWarningsStatement              = 238
	StarRocksParserRULE_cancelLoadStatement                    = 239
	StarRocksParserRULE_alterLoadStatement                     = 240
	StarRocksParserRULE_cancelCompactionStatement              = 241
	StarRocksParserRULE_showAuthorStatement                    = 242
	StarRocksParserRULE_showBackendsStatement                  = 243
	StarRocksParserRULE_showBrokerStatement                    = 244
	StarRocksParserRULE_showCharsetStatement                   = 245
	StarRocksParserRULE_showCollationStatement                 = 246
	StarRocksParserRULE_showDeleteStatement                    = 247
	StarRocksParserRULE_showDynamicPartitionStatement          = 248
	StarRocksParserRULE_showEventsStatement                    = 249
	StarRocksParserRULE_showEnginesStatement                   = 250
	StarRocksParserRULE_showFrontendsStatement                 = 251
	StarRocksParserRULE_showPluginsStatement                   = 252
	StarRocksParserRULE_showRepositoriesStatement              = 253
	StarRocksParserRULE_showOpenTableStatement                 = 254
	StarRocksParserRULE_showPrivilegesStatement                = 255
	StarRocksParserRULE_showProcedureStatement                 = 256
	StarRocksParserRULE_showProcStatement                      = 257
	StarRocksParserRULE_showProcesslistStatement               = 258
	StarRocksParserRULE_showProfilelistStatement               = 259
	StarRocksParserRULE_showRunningQueriesStatement            = 260
	StarRocksParserRULE_showStatusStatement                    = 261
	StarRocksParserRULE_showTabletStatement                    = 262
	StarRocksParserRULE_showTransactionStatement               = 263
	StarRocksParserRULE_showTriggersStatement                  = 264
	StarRocksParserRULE_showUserPropertyStatement              = 265
	StarRocksParserRULE_showVariablesStatement                 = 266
	StarRocksParserRULE_showWarningStatement                   = 267
	StarRocksParserRULE_helpStatement                          = 268
	StarRocksParserRULE_createUserStatement                    = 269
	StarRocksParserRULE_dropUserStatement                      = 270
	StarRocksParserRULE_alterUserStatement                     = 271
	StarRocksParserRULE_showUserStatement                      = 272
	StarRocksParserRULE_showAuthenticationStatement            = 273
	StarRocksParserRULE_executeAsStatement                     = 274
	StarRocksParserRULE_createRoleStatement                    = 275
	StarRocksParserRULE_alterRoleStatement                     = 276
	StarRocksParserRULE_dropRoleStatement                      = 277
	StarRocksParserRULE_showRolesStatement                     = 278
	StarRocksParserRULE_grantRoleStatement                     = 279
	StarRocksParserRULE_revokeRoleStatement                    = 280
	StarRocksParserRULE_setRoleStatement                       = 281
	StarRocksParserRULE_setDefaultRoleStatement                = 282
	StarRocksParserRULE_grantRevokeClause                      = 283
	StarRocksParserRULE_grantPrivilegeStatement                = 284
	StarRocksParserRULE_revokePrivilegeStatement               = 285
	StarRocksParserRULE_showGrantsStatement                    = 286
	StarRocksParserRULE_authOption                             = 287
	StarRocksParserRULE_privObjectName                         = 288
	StarRocksParserRULE_privObjectNameList                     = 289
	StarRocksParserRULE_privFunctionObjectNameList             = 290
	StarRocksParserRULE_privilegeTypeList                      = 291
	StarRocksParserRULE_privilegeType                          = 292
	StarRocksParserRULE_privObjectType                         = 293
	StarRocksParserRULE_privObjectTypePlural                   = 294
	StarRocksParserRULE_createSecurityIntegrationStatement     = 295
	StarRocksParserRULE_alterSecurityIntegrationStatement      = 296
	StarRocksParserRULE_dropSecurityIntegrationStatement       = 297
	StarRocksParserRULE_showSecurityIntegrationStatement       = 298
	StarRocksParserRULE_showCreateSecurityIntegrationStatement = 299
	StarRocksParserRULE_createGroupProviderStatement           = 300
	StarRocksParserRULE_dropGroupProviderStatement             = 301
	StarRocksParserRULE_showGroupProvidersStatement            = 302
	StarRocksParserRULE_showCreateGroupProviderStatement       = 303
	StarRocksParserRULE_backupStatement                        = 304
	StarRocksParserRULE_cancelBackupStatement                  = 305
	StarRocksParserRULE_showBackupStatement                    = 306
	StarRocksParserRULE_restoreStatement                       = 307
	StarRocksParserRULE_cancelRestoreStatement                 = 308
	StarRocksParserRULE_showRestoreStatement                   = 309
	StarRocksParserRULE_showSnapshotStatement                  = 310
	StarRocksParserRULE_createRepositoryStatement              = 311
	StarRocksParserRULE_dropRepositoryStatement                = 312
	StarRocksParserRULE_addSqlBlackListStatement               = 313
	StarRocksParserRULE_delSqlBlackListStatement               = 314
	StarRocksParserRULE_showSqlBlackListStatement              = 315
	StarRocksParserRULE_showWhiteListStatement                 = 316
	StarRocksParserRULE_addBackendBlackListStatement           = 317
	StarRocksParserRULE_delBackendBlackListStatement           = 318
	StarRocksParserRULE_showBackendBlackListStatement          = 319
	StarRocksParserRULE_dataCacheTarget                        = 320
	StarRocksParserRULE_createDataCacheRuleStatement           = 321
	StarRocksParserRULE_showDataCacheRulesStatement            = 322
	StarRocksParserRULE_dropDataCacheRuleStatement             = 323
	StarRocksParserRULE_clearDataCacheRulesStatement           = 324
	StarRocksParserRULE_dataCacheSelectStatement               = 325
	StarRocksParserRULE_exportStatement                        = 326
	StarRocksParserRULE_cancelExportStatement                  = 327
	StarRocksParserRULE_showExportStatement                    = 328
	StarRocksParserRULE_installPluginStatement                 = 329
	StarRocksParserRULE_uninstallPluginStatement               = 330
	StarRocksParserRULE_createFileStatement                    = 331
	StarRocksParserRULE_dropFileStatement                      = 332
	StarRocksParserRULE_showSmallFilesStatement                = 333
	StarRocksParserRULE_createPipeStatement                    = 334
	StarRocksParserRULE_dropPipeStatement                      = 335
	StarRocksParserRULE_alterPipeClause                        = 336
	StarRocksParserRULE_alterPipeStatement                     = 337
	StarRocksParserRULE_descPipeStatement                      = 338
	StarRocksParserRULE_showPipeStatement                      = 339
	StarRocksParserRULE_setStatement                           = 340
	StarRocksParserRULE_setVar                                 = 341
	StarRocksParserRULE_transaction_characteristics            = 342
	StarRocksParserRULE_transaction_access_mode                = 343
	StarRocksParserRULE_isolation_level                        = 344
	StarRocksParserRULE_isolation_types                        = 345
	StarRocksParserRULE_setExprOrDefault                       = 346
	StarRocksParserRULE_setUserPropertyStatement               = 347
	StarRocksParserRULE_roleList                               = 348
	StarRocksParserRULE_executeScriptStatement                 = 349
	StarRocksParserRULE_unsupportedStatement                   = 350
	StarRocksParserRULE_lock_item                              = 351
	StarRocksParserRULE_lock_type                              = 352
	StarRocksParserRULE_alterPlanAdvisorAddStatement           = 353
	StarRocksParserRULE_truncatePlanAdvisorStatement           = 354
	StarRocksParserRULE_alterPlanAdvisorDropStatement          = 355
	StarRocksParserRULE_showPlanAdvisorStatement               = 356
	StarRocksParserRULE_createWarehouseStatement               = 357
	StarRocksParserRULE_dropWarehouseStatement                 = 358
	StarRocksParserRULE_suspendWarehouseStatement              = 359
	StarRocksParserRULE_resumeWarehouseStatement               = 360
	StarRocksParserRULE_setWarehouseStatement                  = 361
	StarRocksParserRULE_showWarehousesStatement                = 362
	StarRocksParserRULE_showClustersStatement                  = 363
	StarRocksParserRULE_showNodesStatement                     = 364
	StarRocksParserRULE_alterWarehouseStatement                = 365
	StarRocksParserRULE_beginStatement                         = 366
	StarRocksParserRULE_commitStatement                        = 367
	StarRocksParserRULE_rollbackStatement                      = 368
	StarRocksParserRULE_translateStatement                     = 369
	StarRocksParserRULE_dialect                                = 370
	StarRocksParserRULE_translateSQL                           = 371
	StarRocksParserRULE_queryStatement                         = 372
	StarRocksParserRULE_queryRelation                          = 373
	StarRocksParserRULE_withClause                             = 374
	StarRocksParserRULE_queryNoWith                            = 375
	StarRocksParserRULE_queryPeriod                            = 376
	StarRocksParserRULE_periodType                             = 377
	StarRocksParserRULE_queryPrimary                           = 378
	StarRocksParserRULE_subquery                               = 379
	StarRocksParserRULE_rowConstructor                         = 380
	StarRocksParserRULE_sortItem                               = 381
	StarRocksParserRULE_limitConstExpr                         = 382
	StarRocksParserRULE_limitElement                           = 383
	StarRocksParserRULE_querySpecification                     = 384
	StarRocksParserRULE_fromClause                             = 385
	StarRocksParserRULE_groupingElement                        = 386
	StarRocksParserRULE_groupingSet                            = 387
	StarRocksParserRULE_commonTableExpression                  = 388
	StarRocksParserRULE_setQuantifier                          = 389
	StarRocksParserRULE_selectItem                             = 390
	StarRocksParserRULE_relations                              = 391
	StarRocksParserRULE_relation                               = 392
	StarRocksParserRULE_relationPrimary                        = 393
	StarRocksParserRULE_pivotClause                            = 394
	StarRocksParserRULE_pivotAggregationExpression             = 395
	StarRocksParserRULE_pivotValue                             = 396
	StarRocksParserRULE_sampleClause                           = 397
	StarRocksParserRULE_argumentList                           = 398
	StarRocksParserRULE_namedArgumentList                      = 399
	StarRocksParserRULE_namedArgument                          = 400
	StarRocksParserRULE_joinRelation                           = 401
	StarRocksParserRULE_crossOrInnerJoinType                   = 402
	StarRocksParserRULE_outerAndSemiJoinType                   = 403
	StarRocksParserRULE_bracketHint                            = 404
	StarRocksParserRULE_hintMap                                = 405
	StarRocksParserRULE_joinCriteria                           = 406
	StarRocksParserRULE_columnAliases                          = 407
	StarRocksParserRULE_partitionNames                         = 408
	StarRocksParserRULE_keyPartitions                          = 409
	StarRocksParserRULE_tabletList                             = 410
	StarRocksParserRULE_prepareStatement                       = 411
	StarRocksParserRULE_prepareSql                             = 412
	StarRocksParserRULE_executeStatement                       = 413
	StarRocksParserRULE_deallocateStatement                    = 414
	StarRocksParserRULE_replicaList                            = 415
	StarRocksParserRULE_expressionsWithDefault                 = 416
	StarRocksParserRULE_expressionOrDefault                    = 417
	StarRocksParserRULE_mapExpressionList                      = 418
	StarRocksParserRULE_mapExpression                          = 419
	StarRocksParserRULE_expressionSingleton                    = 420
	StarRocksParserRULE_expression                             = 421
	StarRocksParserRULE_expressionList                         = 422
	StarRocksParserRULE_booleanExpression                      = 423
	StarRocksParserRULE_predicate                              = 424
	StarRocksParserRULE_tupleInSubquery                        = 425
	StarRocksParserRULE_predicateOperations                    = 426
	StarRocksParserRULE_valueExpression                        = 427
	StarRocksParserRULE_primaryExpression                      = 428
	StarRocksParserRULE_literalExpression                      = 429
	StarRocksParserRULE_functionCall                           = 430
	StarRocksParserRULE_aggregationFunction                    = 431
	StarRocksParserRULE_userVariable                           = 432
	StarRocksParserRULE_systemVariable                         = 433
	StarRocksParserRULE_columnReference                        = 434
	StarRocksParserRULE_informationFunctionExpression          = 435
	StarRocksParserRULE_specialDateTimeExpression              = 436
	StarRocksParserRULE_specialFunctionExpression              = 437
	StarRocksParserRULE_windowFunction                         = 438
	StarRocksParserRULE_whenClause                             = 439
	StarRocksParserRULE_over                                   = 440
	StarRocksParserRULE_ignoreNulls                            = 441
	StarRocksParserRULE_windowFrame                            = 442
	StarRocksParserRULE_frameBound                             = 443
	StarRocksParserRULE_backupRestoreObjectDesc                = 444
	StarRocksParserRULE_tableDesc                              = 445
	StarRocksParserRULE_backupRestoreTableDesc                 = 446
	StarRocksParserRULE_explainDesc                            = 447
	StarRocksParserRULE_optimizerTrace                         = 448
	StarRocksParserRULE_partitionExpr                          = 449
	StarRocksParserRULE_partitionDesc                          = 450
	StarRocksParserRULE_listPartitionDesc                      = 451
	StarRocksParserRULE_singleItemListPartitionDesc            = 452
	StarRocksParserRULE_multiItemListPartitionDesc             = 453
	StarRocksParserRULE_multiListPartitionValues               = 454
	StarRocksParserRULE_singleListPartitionValues              = 455
	StarRocksParserRULE_listPartitionValues                    = 456
	StarRocksParserRULE_listPartitionValue                     = 457
	StarRocksParserRULE_stringList                             = 458
	StarRocksParserRULE_integerList                            = 459
	StarRocksParserRULE_literalExpressionList                  = 460
	StarRocksParserRULE_rangePartitionDesc                     = 461
	StarRocksParserRULE_singleRangePartition                   = 462
	StarRocksParserRULE_multiRangePartition                    = 463
	StarRocksParserRULE_partitionRangeDesc                     = 464
	StarRocksParserRULE_partitionKeyDesc                       = 465
	StarRocksParserRULE_partitionValueList                     = 466
	StarRocksParserRULE_keyPartition                           = 467
	StarRocksParserRULE_partitionValue                         = 468
	StarRocksParserRULE_distributionClause                     = 469
	StarRocksParserRULE_distributionDesc                       = 470
	StarRocksParserRULE_alterModifyDefaultBuckets              = 471
	StarRocksParserRULE_refreshSchemeDesc                      = 472
	StarRocksParserRULE_statusDesc                             = 473
	StarRocksParserRULE_properties                             = 474
	StarRocksParserRULE_extProperties                          = 475
	StarRocksParserRULE_propertyList                           = 476
	StarRocksParserRULE_userPropertyList                       = 477
	StarRocksParserRULE_property                               = 478
	StarRocksParserRULE_inlineProperties                       = 479
	StarRocksParserRULE_inlineProperty                         = 480
	StarRocksParserRULE_varType                                = 481
	StarRocksParserRULE_comment                                = 482
	StarRocksParserRULE_outfile                                = 483
	StarRocksParserRULE_fileFormat                             = 484
	StarRocksParserRULE_string                                 = 485
	StarRocksParserRULE_binary                                 = 486
	StarRocksParserRULE_comparisonOperator                     = 487
	StarRocksParserRULE_booleanValue                           = 488
	StarRocksParserRULE_interval                               = 489
	StarRocksParserRULE_taskInterval                           = 490
	StarRocksParserRULE_taskUnitIdentifier                     = 491
	StarRocksParserRULE_unitIdentifier                         = 492
	StarRocksParserRULE_unitBoundary                           = 493
	StarRocksParserRULE_type                                   = 494
	StarRocksParserRULE_arrayType                              = 495
	StarRocksParserRULE_mapType                                = 496
	StarRocksParserRULE_subfieldDesc                           = 497
	StarRocksParserRULE_subfieldDescs                          = 498
	StarRocksParserRULE_structType                             = 499
	StarRocksParserRULE_typeParameter                          = 500
	StarRocksParserRULE_baseType                               = 501
	StarRocksParserRULE_decimalType                            = 502
	StarRocksParserRULE_qualifiedName                          = 503
	StarRocksParserRULE_tableName                              = 504
	StarRocksParserRULE_writeBranch                            = 505
	StarRocksParserRULE_identifier                             = 506
	StarRocksParserRULE_identifierWithAlias                    = 507
	StarRocksParserRULE_identifierWithAliasList                = 508
	StarRocksParserRULE_identifierList                         = 509
	StarRocksParserRULE_identifierOrString                     = 510
	StarRocksParserRULE_identifierOrStringList                 = 511
	StarRocksParserRULE_identifierOrStringOrStar               = 512
	StarRocksParserRULE_user                                   = 513
	StarRocksParserRULE_assignment                             = 514
	StarRocksParserRULE_assignmentList                         = 515
	StarRocksParserRULE_number                                 = 516
	StarRocksParserRULE_nonReserved                            = 517
)

// ISqlStatementsContext is an interface to support dynamic dispatch.
type ISqlStatementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	AllSingleStatement() []ISingleStatementContext
	SingleStatement(i int) ISingleStatementContext

	// IsSqlStatementsContext differentiates from other interfaces.
	IsSqlStatementsContext()
}

type SqlStatementsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySqlStatementsContext() *SqlStatementsContext {
	var p = new(SqlStatementsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sqlStatements
	return p
}

func InitEmptySqlStatementsContext(p *SqlStatementsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sqlStatements
}

func (*SqlStatementsContext) IsSqlStatementsContext() {}

func NewSqlStatementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SqlStatementsContext {
	var p = new(SqlStatementsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_sqlStatements

	return p
}

func (s *SqlStatementsContext) GetParser() antlr.Parser { return s.parser }

func (s *SqlStatementsContext) EOF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEOF, 0)
}

func (s *SqlStatementsContext) AllSingleStatement() []ISingleStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleStatementContext); ok {
			len++
		}
	}

	tst := make([]ISingleStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleStatementContext); ok {
			tst[i] = t.(ISingleStatementContext)
			i++
		}
	}

	return tst
}

func (s *SqlStatementsContext) SingleStatement(i int) ISingleStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleStatementContext)
}

func (s *SqlStatementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SqlStatementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SqlStatementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSqlStatements(s)
	}
}

func (s *SqlStatementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSqlStatements(s)
	}
}

func (p *StarRocksParser) SqlStatements() (localctx ISqlStatementsContext) {
	localctx = NewSqlStatementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, StarRocksParserRULE_sqlStatements)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&216174019065962500) != 0) || ((int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&4720054983973667331) != 0) || ((int64((_la-144)) & ^0x3f) == 0 && ((int64(1)<<(_la-144))&-4611683815109165043) != 0) || _la == StarRocksParserKILL || _la == StarRocksParserLOAD || ((int64((_la-304)) & ^0x3f) == 0 && ((int64(1)<<(_la-304))&4827862099076087809) != 0) || ((int64((_la-372)) & ^0x3f) == 0 && ((int64(1)<<(_la-372))&14332375138305) != 0) || ((int64((_la-437)) & ^0x3f) == 0 && ((int64(1)<<(_la-437))&107752139857989) != 0) || _la == StarRocksParserSEMICOLON {
		{
			p.SetState(1036)
			p.SingleStatement()
		}

		p.SetState(1039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1041)
		p.Match(StarRocksParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleStatementContext is an interface to support dynamic dispatch.
type ISingleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SEMICOLON() antlr.TerminalNode
	EOF() antlr.TerminalNode
	EmptyStatement() IEmptyStatementContext

	// IsSingleStatementContext differentiates from other interfaces.
	IsSingleStatementContext()
}

type SingleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleStatementContext() *SingleStatementContext {
	var p = new(SingleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleStatement
	return p
}

func InitEmptySingleStatementContext(p *SingleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleStatement
}

func (*SingleStatementContext) IsSingleStatementContext() {}

func NewSingleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleStatementContext {
	var p = new(SingleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_singleStatement

	return p
}

func (s *SingleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleStatementContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SingleStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEMICOLON, 0)
}

func (s *SingleStatementContext) EOF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEOF, 0)
}

func (s *SingleStatementContext) EmptyStatement() IEmptyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEmptyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEmptyStatementContext)
}

func (s *SingleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleStatement(s)
	}
}

func (s *SingleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleStatement(s)
	}
}

func (p *StarRocksParser) SingleStatement() (localctx ISingleStatementContext) {
	localctx = NewSingleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, StarRocksParserRULE_singleStatement)
	var _la int

	p.SetState(1047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserADD, StarRocksParserADMIN, StarRocksParserALTER, StarRocksParserANALYZE, StarRocksParserBACKUP, StarRocksParserBEGIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCOMMIT, StarRocksParserCREATE, StarRocksParserDEALLOCATE, StarRocksParserDELETE, StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserDROP, StarRocksParserEXECUTE, StarRocksParserEXPLAIN, StarRocksParserEXPORT, StarRocksParserGRANT, StarRocksParserHELP, StarRocksParserINSTALL, StarRocksParserINSERT, StarRocksParserKILL, StarRocksParserLOAD, StarRocksParserPAUSE, StarRocksParserPREPARE, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserREVOKE, StarRocksParserROLLBACK, StarRocksParserSELECT, StarRocksParserSET, StarRocksParserSHOW, StarRocksParserSTART, StarRocksParserSTOP, StarRocksParserSUBMIT, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRUNCATE, StarRocksParserUNINSTALL, StarRocksParserUPDATE, StarRocksParserUSE, StarRocksParserWITH, StarRocksParserLOCK, StarRocksParserUNLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1043)
			p.Statement()
		}
		{
			p.SetState(1044)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserEOF || _la == StarRocksParserSEMICOLON) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case StarRocksParserSEMICOLON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1046)
			p.EmptyStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEmptyStatementContext is an interface to support dynamic dispatch.
type IEmptyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SEMICOLON() antlr.TerminalNode

	// IsEmptyStatementContext differentiates from other interfaces.
	IsEmptyStatementContext()
}

type EmptyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmptyStatementContext() *EmptyStatementContext {
	var p = new(EmptyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_emptyStatement
	return p
}

func InitEmptyEmptyStatementContext(p *EmptyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_emptyStatement
}

func (*EmptyStatementContext) IsEmptyStatementContext() {}

func NewEmptyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EmptyStatementContext {
	var p = new(EmptyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_emptyStatement

	return p
}

func (s *EmptyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EmptyStatementContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEMICOLON, 0)
}

func (s *EmptyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EmptyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EmptyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterEmptyStatement(s)
	}
}

func (s *EmptyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitEmptyStatement(s)
	}
}

func (p *StarRocksParser) EmptyStatement() (localctx IEmptyStatementContext) {
	localctx = NewEmptyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, StarRocksParserRULE_emptyStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1049)
		p.Match(StarRocksParserSEMICOLON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryStatement() IQueryStatementContext
	UseDatabaseStatement() IUseDatabaseStatementContext
	UseCatalogStatement() IUseCatalogStatementContext
	SetCatalogStatement() ISetCatalogStatementContext
	ShowDatabasesStatement() IShowDatabasesStatementContext
	AlterDbQuotaStatement() IAlterDbQuotaStatementContext
	CreateDbStatement() ICreateDbStatementContext
	DropDbStatement() IDropDbStatementContext
	ShowCreateDbStatement() IShowCreateDbStatementContext
	AlterDatabaseRenameStatement() IAlterDatabaseRenameStatementContext
	RecoverDbStmt() IRecoverDbStmtContext
	ShowDataStmt() IShowDataStmtContext
	ShowDataDistributionStmt() IShowDataDistributionStmtContext
	CreateTableStatement() ICreateTableStatementContext
	CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext
	CreateTableLikeStatement() ICreateTableLikeStatementContext
	ShowCreateTableStatement() IShowCreateTableStatementContext
	DropTableStatement() IDropTableStatementContext
	CleanTemporaryTableStatement() ICleanTemporaryTableStatementContext
	RecoverTableStatement() IRecoverTableStatementContext
	TruncateTableStatement() ITruncateTableStatementContext
	ShowTableStatement() IShowTableStatementContext
	DescTableStatement() IDescTableStatementContext
	ShowTableStatusStatement() IShowTableStatusStatementContext
	ShowColumnStatement() IShowColumnStatementContext
	RefreshTableStatement() IRefreshTableStatementContext
	AlterTableStatement() IAlterTableStatementContext
	CancelAlterTableStatement() ICancelAlterTableStatementContext
	ShowAlterStatement() IShowAlterStatementContext
	ShowTemporaryTablesStatement() IShowTemporaryTablesStatementContext
	CreateViewStatement() ICreateViewStatementContext
	AlterViewStatement() IAlterViewStatementContext
	DropViewStatement() IDropViewStatementContext
	ShowPartitionsStatement() IShowPartitionsStatementContext
	RecoverPartitionStatement() IRecoverPartitionStatementContext
	CreateIndexStatement() ICreateIndexStatementContext
	DropIndexStatement() IDropIndexStatementContext
	ShowIndexStatement() IShowIndexStatementContext
	SubmitTaskStatement() ISubmitTaskStatementContext
	DropTaskStatement() IDropTaskStatementContext
	CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext
	ShowMaterializedViewsStatement() IShowMaterializedViewsStatementContext
	DropMaterializedViewStatement() IDropMaterializedViewStatementContext
	AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext
	RefreshMaterializedViewStatement() IRefreshMaterializedViewStatementContext
	CancelRefreshMaterializedViewStatement() ICancelRefreshMaterializedViewStatementContext
	CreateExternalCatalogStatement() ICreateExternalCatalogStatementContext
	DropExternalCatalogStatement() IDropExternalCatalogStatementContext
	ShowCatalogsStatement() IShowCatalogsStatementContext
	ShowCreateExternalCatalogStatement() IShowCreateExternalCatalogStatementContext
	AlterCatalogStatement() IAlterCatalogStatementContext
	InsertStatement() IInsertStatementContext
	UpdateStatement() IUpdateStatementContext
	DeleteStatement() IDeleteStatementContext
	CreateRoutineLoadStatement() ICreateRoutineLoadStatementContext
	AlterRoutineLoadStatement() IAlterRoutineLoadStatementContext
	StopRoutineLoadStatement() IStopRoutineLoadStatementContext
	ResumeRoutineLoadStatement() IResumeRoutineLoadStatementContext
	PauseRoutineLoadStatement() IPauseRoutineLoadStatementContext
	ShowRoutineLoadStatement() IShowRoutineLoadStatementContext
	ShowRoutineLoadTaskStatement() IShowRoutineLoadTaskStatementContext
	ShowCreateRoutineLoadStatement() IShowCreateRoutineLoadStatementContext
	ShowStreamLoadStatement() IShowStreamLoadStatementContext
	AdminSetConfigStatement() IAdminSetConfigStatementContext
	AdminSetReplicaStatusStatement() IAdminSetReplicaStatusStatementContext
	AdminShowConfigStatement() IAdminShowConfigStatementContext
	AdminShowReplicaDistributionStatement() IAdminShowReplicaDistributionStatementContext
	AdminShowReplicaStatusStatement() IAdminShowReplicaStatusStatementContext
	AdminRepairTableStatement() IAdminRepairTableStatementContext
	AdminCancelRepairTableStatement() IAdminCancelRepairTableStatementContext
	AdminCheckTabletsStatement() IAdminCheckTabletsStatementContext
	AdminSetPartitionVersion() IAdminSetPartitionVersionContext
	KillStatement() IKillStatementContext
	SyncStatement() ISyncStatementContext
	ExecuteScriptStatement() IExecuteScriptStatementContext
	AdminSetAutomatedSnapshotOnStatement() IAdminSetAutomatedSnapshotOnStatementContext
	AdminSetAutomatedSnapshotOffStatement() IAdminSetAutomatedSnapshotOffStatementContext
	AlterSystemStatement() IAlterSystemStatementContext
	CancelAlterSystemStatement() ICancelAlterSystemStatementContext
	ShowComputeNodesStatement() IShowComputeNodesStatementContext
	AnalyzeStatement() IAnalyzeStatementContext
	DropStatsStatement() IDropStatsStatementContext
	CreateAnalyzeStatement() ICreateAnalyzeStatementContext
	DropAnalyzeJobStatement() IDropAnalyzeJobStatementContext
	AnalyzeHistogramStatement() IAnalyzeHistogramStatementContext
	DropHistogramStatement() IDropHistogramStatementContext
	ShowAnalyzeStatement() IShowAnalyzeStatementContext
	ShowStatsMetaStatement() IShowStatsMetaStatementContext
	ShowHistogramMetaStatement() IShowHistogramMetaStatementContext
	KillAnalyzeStatement() IKillAnalyzeStatementContext
	AnalyzeProfileStatement() IAnalyzeProfileStatementContext
	CreateResourceGroupStatement() ICreateResourceGroupStatementContext
	DropResourceGroupStatement() IDropResourceGroupStatementContext
	AlterResourceGroupStatement() IAlterResourceGroupStatementContext
	ShowResourceGroupStatement() IShowResourceGroupStatementContext
	ShowResourceGroupUsageStatement() IShowResourceGroupUsageStatementContext
	CreateResourceStatement() ICreateResourceStatementContext
	AlterResourceStatement() IAlterResourceStatementContext
	DropResourceStatement() IDropResourceStatementContext
	ShowResourceStatement() IShowResourceStatementContext
	ShowFunctionsStatement() IShowFunctionsStatementContext
	DropFunctionStatement() IDropFunctionStatementContext
	CreateFunctionStatement() ICreateFunctionStatementContext
	LoadStatement() ILoadStatementContext
	ShowLoadStatement() IShowLoadStatementContext
	ShowLoadWarningsStatement() IShowLoadWarningsStatementContext
	CancelLoadStatement() ICancelLoadStatementContext
	AlterLoadStatement() IAlterLoadStatementContext
	ShowAuthorStatement() IShowAuthorStatementContext
	ShowBackendsStatement() IShowBackendsStatementContext
	ShowBrokerStatement() IShowBrokerStatementContext
	ShowCharsetStatement() IShowCharsetStatementContext
	ShowCollationStatement() IShowCollationStatementContext
	ShowDeleteStatement() IShowDeleteStatementContext
	ShowDynamicPartitionStatement() IShowDynamicPartitionStatementContext
	ShowEventsStatement() IShowEventsStatementContext
	ShowEnginesStatement() IShowEnginesStatementContext
	ShowFrontendsStatement() IShowFrontendsStatementContext
	ShowPluginsStatement() IShowPluginsStatementContext
	ShowRepositoriesStatement() IShowRepositoriesStatementContext
	ShowOpenTableStatement() IShowOpenTableStatementContext
	ShowPrivilegesStatement() IShowPrivilegesStatementContext
	ShowProcedureStatement() IShowProcedureStatementContext
	ShowProcStatement() IShowProcStatementContext
	ShowProcesslistStatement() IShowProcesslistStatementContext
	ShowProfilelistStatement() IShowProfilelistStatementContext
	ShowRunningQueriesStatement() IShowRunningQueriesStatementContext
	ShowStatusStatement() IShowStatusStatementContext
	ShowTabletStatement() IShowTabletStatementContext
	ShowTransactionStatement() IShowTransactionStatementContext
	ShowTriggersStatement() IShowTriggersStatementContext
	ShowUserPropertyStatement() IShowUserPropertyStatementContext
	ShowVariablesStatement() IShowVariablesStatementContext
	ShowWarningStatement() IShowWarningStatementContext
	HelpStatement() IHelpStatementContext
	CreateUserStatement() ICreateUserStatementContext
	DropUserStatement() IDropUserStatementContext
	AlterUserStatement() IAlterUserStatementContext
	ShowUserStatement() IShowUserStatementContext
	ShowAuthenticationStatement() IShowAuthenticationStatementContext
	ExecuteAsStatement() IExecuteAsStatementContext
	CreateRoleStatement() ICreateRoleStatementContext
	AlterRoleStatement() IAlterRoleStatementContext
	DropRoleStatement() IDropRoleStatementContext
	ShowRolesStatement() IShowRolesStatementContext
	GrantRoleStatement() IGrantRoleStatementContext
	RevokeRoleStatement() IRevokeRoleStatementContext
	SetRoleStatement() ISetRoleStatementContext
	SetDefaultRoleStatement() ISetDefaultRoleStatementContext
	GrantPrivilegeStatement() IGrantPrivilegeStatementContext
	RevokePrivilegeStatement() IRevokePrivilegeStatementContext
	ShowGrantsStatement() IShowGrantsStatementContext
	CreateSecurityIntegrationStatement() ICreateSecurityIntegrationStatementContext
	AlterSecurityIntegrationStatement() IAlterSecurityIntegrationStatementContext
	DropSecurityIntegrationStatement() IDropSecurityIntegrationStatementContext
	ShowSecurityIntegrationStatement() IShowSecurityIntegrationStatementContext
	ShowCreateSecurityIntegrationStatement() IShowCreateSecurityIntegrationStatementContext
	CreateGroupProviderStatement() ICreateGroupProviderStatementContext
	DropGroupProviderStatement() IDropGroupProviderStatementContext
	ShowGroupProvidersStatement() IShowGroupProvidersStatementContext
	ShowCreateGroupProviderStatement() IShowCreateGroupProviderStatementContext
	BackupStatement() IBackupStatementContext
	CancelBackupStatement() ICancelBackupStatementContext
	ShowBackupStatement() IShowBackupStatementContext
	RestoreStatement() IRestoreStatementContext
	CancelRestoreStatement() ICancelRestoreStatementContext
	ShowRestoreStatement() IShowRestoreStatementContext
	ShowSnapshotStatement() IShowSnapshotStatementContext
	CreateRepositoryStatement() ICreateRepositoryStatementContext
	DropRepositoryStatement() IDropRepositoryStatementContext
	AddSqlBlackListStatement() IAddSqlBlackListStatementContext
	DelSqlBlackListStatement() IDelSqlBlackListStatementContext
	ShowSqlBlackListStatement() IShowSqlBlackListStatementContext
	ShowWhiteListStatement() IShowWhiteListStatementContext
	AddBackendBlackListStatement() IAddBackendBlackListStatementContext
	DelBackendBlackListStatement() IDelBackendBlackListStatementContext
	ShowBackendBlackListStatement() IShowBackendBlackListStatementContext
	CreateDataCacheRuleStatement() ICreateDataCacheRuleStatementContext
	ShowDataCacheRulesStatement() IShowDataCacheRulesStatementContext
	DropDataCacheRuleStatement() IDropDataCacheRuleStatementContext
	ClearDataCacheRulesStatement() IClearDataCacheRulesStatementContext
	DataCacheSelectStatement() IDataCacheSelectStatementContext
	ExportStatement() IExportStatementContext
	CancelExportStatement() ICancelExportStatementContext
	ShowExportStatement() IShowExportStatementContext
	InstallPluginStatement() IInstallPluginStatementContext
	UninstallPluginStatement() IUninstallPluginStatementContext
	CreateFileStatement() ICreateFileStatementContext
	DropFileStatement() IDropFileStatementContext
	ShowSmallFilesStatement() IShowSmallFilesStatementContext
	SetStatement() ISetStatementContext
	SetUserPropertyStatement() ISetUserPropertyStatementContext
	CreateStorageVolumeStatement() ICreateStorageVolumeStatementContext
	AlterStorageVolumeStatement() IAlterStorageVolumeStatementContext
	DropStorageVolumeStatement() IDropStorageVolumeStatementContext
	ShowStorageVolumesStatement() IShowStorageVolumesStatementContext
	DescStorageVolumeStatement() IDescStorageVolumeStatementContext
	SetDefaultStorageVolumeStatement() ISetDefaultStorageVolumeStatementContext
	CreatePipeStatement() ICreatePipeStatementContext
	DropPipeStatement() IDropPipeStatementContext
	AlterPipeStatement() IAlterPipeStatementContext
	ShowPipeStatement() IShowPipeStatementContext
	DescPipeStatement() IDescPipeStatementContext
	CancelCompactionStatement() ICancelCompactionStatementContext
	UpdateFailPointStatusStatement() IUpdateFailPointStatusStatementContext
	ShowFailPointStatement() IShowFailPointStatementContext
	PrepareStatement() IPrepareStatementContext
	ExecuteStatement() IExecuteStatementContext
	DeallocateStatement() IDeallocateStatementContext
	CreateDictionaryStatement() ICreateDictionaryStatementContext
	DropDictionaryStatement() IDropDictionaryStatementContext
	RefreshDictionaryStatement() IRefreshDictionaryStatementContext
	ShowDictionaryStatement() IShowDictionaryStatementContext
	CancelRefreshDictionaryStatement() ICancelRefreshDictionaryStatementContext
	AlterPlanAdvisorAddStatement() IAlterPlanAdvisorAddStatementContext
	TruncatePlanAdvisorStatement() ITruncatePlanAdvisorStatementContext
	AlterPlanAdvisorDropStatement() IAlterPlanAdvisorDropStatementContext
	ShowPlanAdvisorStatement() IShowPlanAdvisorStatementContext
	CreateWarehouseStatement() ICreateWarehouseStatementContext
	DropWarehouseStatement() IDropWarehouseStatementContext
	SuspendWarehouseStatement() ISuspendWarehouseStatementContext
	ResumeWarehouseStatement() IResumeWarehouseStatementContext
	SetWarehouseStatement() ISetWarehouseStatementContext
	ShowWarehousesStatement() IShowWarehousesStatementContext
	ShowClustersStatement() IShowClustersStatementContext
	ShowNodesStatement() IShowNodesStatementContext
	AlterWarehouseStatement() IAlterWarehouseStatementContext
	BeginStatement() IBeginStatementContext
	CommitStatement() ICommitStatementContext
	RollbackStatement() IRollbackStatementContext
	TranslateStatement() ITranslateStatementContext
	CreateBaselinePlanStatement() ICreateBaselinePlanStatementContext
	DropBaselinePlanStatement() IDropBaselinePlanStatementContext
	ShowBaselinePlanStatement() IShowBaselinePlanStatementContext
	UnsupportedStatement() IUnsupportedStatementContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func InitEmptyStatementContext(p *StatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *StatementContext) UseDatabaseStatement() IUseDatabaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDatabaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDatabaseStatementContext)
}

func (s *StatementContext) UseCatalogStatement() IUseCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseCatalogStatementContext)
}

func (s *StatementContext) SetCatalogStatement() ISetCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetCatalogStatementContext)
}

func (s *StatementContext) ShowDatabasesStatement() IShowDatabasesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDatabasesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDatabasesStatementContext)
}

func (s *StatementContext) AlterDbQuotaStatement() IAlterDbQuotaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDbQuotaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDbQuotaStatementContext)
}

func (s *StatementContext) CreateDbStatement() ICreateDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDbStatementContext)
}

func (s *StatementContext) DropDbStatement() IDropDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDbStatementContext)
}

func (s *StatementContext) ShowCreateDbStatement() IShowCreateDbStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateDbStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateDbStatementContext)
}

func (s *StatementContext) AlterDatabaseRenameStatement() IAlterDatabaseRenameStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterDatabaseRenameStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterDatabaseRenameStatementContext)
}

func (s *StatementContext) RecoverDbStmt() IRecoverDbStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverDbStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverDbStmtContext)
}

func (s *StatementContext) ShowDataStmt() IShowDataStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataStmtContext)
}

func (s *StatementContext) ShowDataDistributionStmt() IShowDataDistributionStmtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataDistributionStmtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataDistributionStmtContext)
}

func (s *StatementContext) CreateTableStatement() ICreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableStatementContext)
}

func (s *StatementContext) CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableAsSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectStatementContext)
}

func (s *StatementContext) CreateTableLikeStatement() ICreateTableLikeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableLikeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableLikeStatementContext)
}

func (s *StatementContext) ShowCreateTableStatement() IShowCreateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateTableStatementContext)
}

func (s *StatementContext) DropTableStatement() IDropTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTableStatementContext)
}

func (s *StatementContext) CleanTemporaryTableStatement() ICleanTemporaryTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICleanTemporaryTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICleanTemporaryTableStatementContext)
}

func (s *StatementContext) RecoverTableStatement() IRecoverTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverTableStatementContext)
}

func (s *StatementContext) TruncateTableStatement() ITruncateTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncateTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncateTableStatementContext)
}

func (s *StatementContext) ShowTableStatement() IShowTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTableStatementContext)
}

func (s *StatementContext) DescTableStatement() IDescTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescTableStatementContext)
}

func (s *StatementContext) ShowTableStatusStatement() IShowTableStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTableStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTableStatusStatementContext)
}

func (s *StatementContext) ShowColumnStatement() IShowColumnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowColumnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowColumnStatementContext)
}

func (s *StatementContext) RefreshTableStatement() IRefreshTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshTableStatementContext)
}

func (s *StatementContext) AlterTableStatement() IAlterTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableStatementContext)
}

func (s *StatementContext) CancelAlterTableStatement() ICancelAlterTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelAlterTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelAlterTableStatementContext)
}

func (s *StatementContext) ShowAlterStatement() IShowAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAlterStatementContext)
}

func (s *StatementContext) ShowTemporaryTablesStatement() IShowTemporaryTablesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTemporaryTablesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTemporaryTablesStatementContext)
}

func (s *StatementContext) CreateViewStatement() ICreateViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateViewStatementContext)
}

func (s *StatementContext) AlterViewStatement() IAlterViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterViewStatementContext)
}

func (s *StatementContext) DropViewStatement() IDropViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropViewStatementContext)
}

func (s *StatementContext) ShowPartitionsStatement() IShowPartitionsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPartitionsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPartitionsStatementContext)
}

func (s *StatementContext) RecoverPartitionStatement() IRecoverPartitionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecoverPartitionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecoverPartitionStatementContext)
}

func (s *StatementContext) CreateIndexStatement() ICreateIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexStatementContext)
}

func (s *StatementContext) DropIndexStatement() IDropIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexStatementContext)
}

func (s *StatementContext) ShowIndexStatement() IShowIndexStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowIndexStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowIndexStatementContext)
}

func (s *StatementContext) SubmitTaskStatement() ISubmitTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubmitTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubmitTaskStatementContext)
}

func (s *StatementContext) DropTaskStatement() IDropTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTaskStatementContext)
}

func (s *StatementContext) CreateMaterializedViewStatement() ICreateMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateMaterializedViewStatementContext)
}

func (s *StatementContext) ShowMaterializedViewsStatement() IShowMaterializedViewsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowMaterializedViewsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowMaterializedViewsStatementContext)
}

func (s *StatementContext) DropMaterializedViewStatement() IDropMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropMaterializedViewStatementContext)
}

func (s *StatementContext) AlterMaterializedViewStatement() IAlterMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterMaterializedViewStatementContext)
}

func (s *StatementContext) RefreshMaterializedViewStatement() IRefreshMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshMaterializedViewStatementContext)
}

func (s *StatementContext) CancelRefreshMaterializedViewStatement() ICancelRefreshMaterializedViewStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRefreshMaterializedViewStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRefreshMaterializedViewStatementContext)
}

func (s *StatementContext) CreateExternalCatalogStatement() ICreateExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateExternalCatalogStatementContext)
}

func (s *StatementContext) DropExternalCatalogStatement() IDropExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropExternalCatalogStatementContext)
}

func (s *StatementContext) ShowCatalogsStatement() IShowCatalogsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCatalogsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCatalogsStatementContext)
}

func (s *StatementContext) ShowCreateExternalCatalogStatement() IShowCreateExternalCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateExternalCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateExternalCatalogStatementContext)
}

func (s *StatementContext) AlterCatalogStatement() IAlterCatalogStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterCatalogStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterCatalogStatementContext)
}

func (s *StatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *StatementContext) UpdateStatement() IUpdateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) CreateRoutineLoadStatement() ICreateRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoutineLoadStatementContext)
}

func (s *StatementContext) AlterRoutineLoadStatement() IAlterRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoutineLoadStatementContext)
}

func (s *StatementContext) StopRoutineLoadStatement() IStopRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopRoutineLoadStatementContext)
}

func (s *StatementContext) ResumeRoutineLoadStatement() IResumeRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResumeRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResumeRoutineLoadStatementContext)
}

func (s *StatementContext) PauseRoutineLoadStatement() IPauseRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPauseRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPauseRoutineLoadStatementContext)
}

func (s *StatementContext) ShowRoutineLoadStatement() IShowRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRoutineLoadStatementContext)
}

func (s *StatementContext) ShowRoutineLoadTaskStatement() IShowRoutineLoadTaskStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRoutineLoadTaskStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRoutineLoadTaskStatementContext)
}

func (s *StatementContext) ShowCreateRoutineLoadStatement() IShowCreateRoutineLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateRoutineLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateRoutineLoadStatementContext)
}

func (s *StatementContext) ShowStreamLoadStatement() IShowStreamLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStreamLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStreamLoadStatementContext)
}

func (s *StatementContext) AdminSetConfigStatement() IAdminSetConfigStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetConfigStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetConfigStatementContext)
}

func (s *StatementContext) AdminSetReplicaStatusStatement() IAdminSetReplicaStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetReplicaStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetReplicaStatusStatementContext)
}

func (s *StatementContext) AdminShowConfigStatement() IAdminShowConfigStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowConfigStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowConfigStatementContext)
}

func (s *StatementContext) AdminShowReplicaDistributionStatement() IAdminShowReplicaDistributionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowReplicaDistributionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowReplicaDistributionStatementContext)
}

func (s *StatementContext) AdminShowReplicaStatusStatement() IAdminShowReplicaStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminShowReplicaStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminShowReplicaStatusStatementContext)
}

func (s *StatementContext) AdminRepairTableStatement() IAdminRepairTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminRepairTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminRepairTableStatementContext)
}

func (s *StatementContext) AdminCancelRepairTableStatement() IAdminCancelRepairTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminCancelRepairTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminCancelRepairTableStatementContext)
}

func (s *StatementContext) AdminCheckTabletsStatement() IAdminCheckTabletsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminCheckTabletsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminCheckTabletsStatementContext)
}

func (s *StatementContext) AdminSetPartitionVersion() IAdminSetPartitionVersionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetPartitionVersionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetPartitionVersionContext)
}

func (s *StatementContext) KillStatement() IKillStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillStatementContext)
}

func (s *StatementContext) SyncStatement() ISyncStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISyncStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISyncStatementContext)
}

func (s *StatementContext) ExecuteScriptStatement() IExecuteScriptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteScriptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteScriptStatementContext)
}

func (s *StatementContext) AdminSetAutomatedSnapshotOnStatement() IAdminSetAutomatedSnapshotOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetAutomatedSnapshotOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetAutomatedSnapshotOnStatementContext)
}

func (s *StatementContext) AdminSetAutomatedSnapshotOffStatement() IAdminSetAutomatedSnapshotOffStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAdminSetAutomatedSnapshotOffStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAdminSetAutomatedSnapshotOffStatementContext)
}

func (s *StatementContext) AlterSystemStatement() IAlterSystemStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSystemStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSystemStatementContext)
}

func (s *StatementContext) CancelAlterSystemStatement() ICancelAlterSystemStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelAlterSystemStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelAlterSystemStatementContext)
}

func (s *StatementContext) ShowComputeNodesStatement() IShowComputeNodesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowComputeNodesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowComputeNodesStatementContext)
}

func (s *StatementContext) AnalyzeStatement() IAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeStatementContext)
}

func (s *StatementContext) DropStatsStatement() IDropStatsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStatsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStatsStatementContext)
}

func (s *StatementContext) CreateAnalyzeStatement() ICreateAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateAnalyzeStatementContext)
}

func (s *StatementContext) DropAnalyzeJobStatement() IDropAnalyzeJobStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropAnalyzeJobStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropAnalyzeJobStatementContext)
}

func (s *StatementContext) AnalyzeHistogramStatement() IAnalyzeHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeHistogramStatementContext)
}

func (s *StatementContext) DropHistogramStatement() IDropHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropHistogramStatementContext)
}

func (s *StatementContext) ShowAnalyzeStatement() IShowAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAnalyzeStatementContext)
}

func (s *StatementContext) ShowStatsMetaStatement() IShowStatsMetaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatsMetaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatsMetaStatementContext)
}

func (s *StatementContext) ShowHistogramMetaStatement() IShowHistogramMetaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowHistogramMetaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowHistogramMetaStatementContext)
}

func (s *StatementContext) KillAnalyzeStatement() IKillAnalyzeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKillAnalyzeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKillAnalyzeStatementContext)
}

func (s *StatementContext) AnalyzeProfileStatement() IAnalyzeProfileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeProfileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeProfileStatementContext)
}

func (s *StatementContext) CreateResourceGroupStatement() ICreateResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceGroupStatementContext)
}

func (s *StatementContext) DropResourceGroupStatement() IDropResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceGroupStatementContext)
}

func (s *StatementContext) AlterResourceGroupStatement() IAlterResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceGroupStatementContext)
}

func (s *StatementContext) ShowResourceGroupStatement() IShowResourceGroupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceGroupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceGroupStatementContext)
}

func (s *StatementContext) ShowResourceGroupUsageStatement() IShowResourceGroupUsageStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceGroupUsageStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceGroupUsageStatementContext)
}

func (s *StatementContext) CreateResourceStatement() ICreateResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceStatementContext)
}

func (s *StatementContext) AlterResourceStatement() IAlterResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceStatementContext)
}

func (s *StatementContext) DropResourceStatement() IDropResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceStatementContext)
}

func (s *StatementContext) ShowResourceStatement() IShowResourceStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowResourceStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowResourceStatementContext)
}

func (s *StatementContext) ShowFunctionsStatement() IShowFunctionsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFunctionsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFunctionsStatementContext)
}

func (s *StatementContext) DropFunctionStatement() IDropFunctionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFunctionStatementContext)
}

func (s *StatementContext) CreateFunctionStatement() ICreateFunctionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFunctionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFunctionStatementContext)
}

func (s *StatementContext) LoadStatement() ILoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadStatementContext)
}

func (s *StatementContext) ShowLoadStatement() IShowLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowLoadStatementContext)
}

func (s *StatementContext) ShowLoadWarningsStatement() IShowLoadWarningsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowLoadWarningsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowLoadWarningsStatementContext)
}

func (s *StatementContext) CancelLoadStatement() ICancelLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelLoadStatementContext)
}

func (s *StatementContext) AlterLoadStatement() IAlterLoadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLoadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLoadStatementContext)
}

func (s *StatementContext) ShowAuthorStatement() IShowAuthorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAuthorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAuthorStatementContext)
}

func (s *StatementContext) ShowBackendsStatement() IShowBackendsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackendsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackendsStatementContext)
}

func (s *StatementContext) ShowBrokerStatement() IShowBrokerStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBrokerStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBrokerStatementContext)
}

func (s *StatementContext) ShowCharsetStatement() IShowCharsetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCharsetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCharsetStatementContext)
}

func (s *StatementContext) ShowCollationStatement() IShowCollationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCollationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCollationStatementContext)
}

func (s *StatementContext) ShowDeleteStatement() IShowDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDeleteStatementContext)
}

func (s *StatementContext) ShowDynamicPartitionStatement() IShowDynamicPartitionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDynamicPartitionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDynamicPartitionStatementContext)
}

func (s *StatementContext) ShowEventsStatement() IShowEventsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowEventsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowEventsStatementContext)
}

func (s *StatementContext) ShowEnginesStatement() IShowEnginesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowEnginesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowEnginesStatementContext)
}

func (s *StatementContext) ShowFrontendsStatement() IShowFrontendsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFrontendsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFrontendsStatementContext)
}

func (s *StatementContext) ShowPluginsStatement() IShowPluginsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPluginsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPluginsStatementContext)
}

func (s *StatementContext) ShowRepositoriesStatement() IShowRepositoriesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRepositoriesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRepositoriesStatementContext)
}

func (s *StatementContext) ShowOpenTableStatement() IShowOpenTableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowOpenTableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowOpenTableStatementContext)
}

func (s *StatementContext) ShowPrivilegesStatement() IShowPrivilegesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPrivilegesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPrivilegesStatementContext)
}

func (s *StatementContext) ShowProcedureStatement() IShowProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcedureStatementContext)
}

func (s *StatementContext) ShowProcStatement() IShowProcStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcStatementContext)
}

func (s *StatementContext) ShowProcesslistStatement() IShowProcesslistStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProcesslistStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProcesslistStatementContext)
}

func (s *StatementContext) ShowProfilelistStatement() IShowProfilelistStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowProfilelistStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowProfilelistStatementContext)
}

func (s *StatementContext) ShowRunningQueriesStatement() IShowRunningQueriesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRunningQueriesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRunningQueriesStatementContext)
}

func (s *StatementContext) ShowStatusStatement() IShowStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStatusStatementContext)
}

func (s *StatementContext) ShowTabletStatement() IShowTabletStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTabletStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTabletStatementContext)
}

func (s *StatementContext) ShowTransactionStatement() IShowTransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTransactionStatementContext)
}

func (s *StatementContext) ShowTriggersStatement() IShowTriggersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowTriggersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowTriggersStatementContext)
}

func (s *StatementContext) ShowUserPropertyStatement() IShowUserPropertyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowUserPropertyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowUserPropertyStatementContext)
}

func (s *StatementContext) ShowVariablesStatement() IShowVariablesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowVariablesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowVariablesStatementContext)
}

func (s *StatementContext) ShowWarningStatement() IShowWarningStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWarningStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWarningStatementContext)
}

func (s *StatementContext) HelpStatement() IHelpStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHelpStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHelpStatementContext)
}

func (s *StatementContext) CreateUserStatement() ICreateUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserStatementContext)
}

func (s *StatementContext) DropUserStatement() IDropUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserStatementContext)
}

func (s *StatementContext) AlterUserStatement() IAlterUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserStatementContext)
}

func (s *StatementContext) ShowUserStatement() IShowUserStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowUserStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowUserStatementContext)
}

func (s *StatementContext) ShowAuthenticationStatement() IShowAuthenticationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowAuthenticationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowAuthenticationStatementContext)
}

func (s *StatementContext) ExecuteAsStatement() IExecuteAsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteAsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteAsStatementContext)
}

func (s *StatementContext) CreateRoleStatement() ICreateRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRoleStatementContext)
}

func (s *StatementContext) AlterRoleStatement() IAlterRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterRoleStatementContext)
}

func (s *StatementContext) DropRoleStatement() IDropRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRoleStatementContext)
}

func (s *StatementContext) ShowRolesStatement() IShowRolesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRolesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRolesStatementContext)
}

func (s *StatementContext) GrantRoleStatement() IGrantRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRoleStatementContext)
}

func (s *StatementContext) RevokeRoleStatement() IRevokeRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeRoleStatementContext)
}

func (s *StatementContext) SetRoleStatement() ISetRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleStatementContext)
}

func (s *StatementContext) SetDefaultRoleStatement() ISetDefaultRoleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetDefaultRoleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetDefaultRoleStatementContext)
}

func (s *StatementContext) GrantPrivilegeStatement() IGrantPrivilegeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantPrivilegeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantPrivilegeStatementContext)
}

func (s *StatementContext) RevokePrivilegeStatement() IRevokePrivilegeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokePrivilegeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokePrivilegeStatementContext)
}

func (s *StatementContext) ShowGrantsStatement() IShowGrantsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGrantsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGrantsStatementContext)
}

func (s *StatementContext) CreateSecurityIntegrationStatement() ICreateSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateSecurityIntegrationStatementContext)
}

func (s *StatementContext) AlterSecurityIntegrationStatement() IAlterSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterSecurityIntegrationStatementContext)
}

func (s *StatementContext) DropSecurityIntegrationStatement() IDropSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropSecurityIntegrationStatementContext)
}

func (s *StatementContext) ShowSecurityIntegrationStatement() IShowSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSecurityIntegrationStatementContext)
}

func (s *StatementContext) ShowCreateSecurityIntegrationStatement() IShowCreateSecurityIntegrationStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateSecurityIntegrationStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateSecurityIntegrationStatementContext)
}

func (s *StatementContext) CreateGroupProviderStatement() ICreateGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateGroupProviderStatementContext)
}

func (s *StatementContext) DropGroupProviderStatement() IDropGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropGroupProviderStatementContext)
}

func (s *StatementContext) ShowGroupProvidersStatement() IShowGroupProvidersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowGroupProvidersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowGroupProvidersStatementContext)
}

func (s *StatementContext) ShowCreateGroupProviderStatement() IShowCreateGroupProviderStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCreateGroupProviderStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCreateGroupProviderStatementContext)
}

func (s *StatementContext) BackupStatement() IBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupStatementContext)
}

func (s *StatementContext) CancelBackupStatement() ICancelBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelBackupStatementContext)
}

func (s *StatementContext) ShowBackupStatement() IShowBackupStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackupStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackupStatementContext)
}

func (s *StatementContext) RestoreStatement() IRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRestoreStatementContext)
}

func (s *StatementContext) CancelRestoreStatement() ICancelRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRestoreStatementContext)
}

func (s *StatementContext) ShowRestoreStatement() IShowRestoreStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowRestoreStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowRestoreStatementContext)
}

func (s *StatementContext) ShowSnapshotStatement() IShowSnapshotStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSnapshotStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSnapshotStatementContext)
}

func (s *StatementContext) CreateRepositoryStatement() ICreateRepositoryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateRepositoryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateRepositoryStatementContext)
}

func (s *StatementContext) DropRepositoryStatement() IDropRepositoryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropRepositoryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropRepositoryStatementContext)
}

func (s *StatementContext) AddSqlBlackListStatement() IAddSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddSqlBlackListStatementContext)
}

func (s *StatementContext) DelSqlBlackListStatement() IDelSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelSqlBlackListStatementContext)
}

func (s *StatementContext) ShowSqlBlackListStatement() IShowSqlBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSqlBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSqlBlackListStatementContext)
}

func (s *StatementContext) ShowWhiteListStatement() IShowWhiteListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWhiteListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWhiteListStatementContext)
}

func (s *StatementContext) AddBackendBlackListStatement() IAddBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddBackendBlackListStatementContext)
}

func (s *StatementContext) DelBackendBlackListStatement() IDelBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDelBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDelBackendBlackListStatementContext)
}

func (s *StatementContext) ShowBackendBlackListStatement() IShowBackendBlackListStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBackendBlackListStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBackendBlackListStatementContext)
}

func (s *StatementContext) CreateDataCacheRuleStatement() ICreateDataCacheRuleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDataCacheRuleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDataCacheRuleStatementContext)
}

func (s *StatementContext) ShowDataCacheRulesStatement() IShowDataCacheRulesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDataCacheRulesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDataCacheRulesStatementContext)
}

func (s *StatementContext) DropDataCacheRuleStatement() IDropDataCacheRuleStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDataCacheRuleStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDataCacheRuleStatementContext)
}

func (s *StatementContext) ClearDataCacheRulesStatement() IClearDataCacheRulesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClearDataCacheRulesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClearDataCacheRulesStatementContext)
}

func (s *StatementContext) DataCacheSelectStatement() IDataCacheSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheSelectStatementContext)
}

func (s *StatementContext) ExportStatement() IExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExportStatementContext)
}

func (s *StatementContext) CancelExportStatement() ICancelExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelExportStatementContext)
}

func (s *StatementContext) ShowExportStatement() IShowExportStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowExportStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowExportStatementContext)
}

func (s *StatementContext) InstallPluginStatement() IInstallPluginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallPluginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallPluginStatementContext)
}

func (s *StatementContext) UninstallPluginStatement() IUninstallPluginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUninstallPluginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUninstallPluginStatementContext)
}

func (s *StatementContext) CreateFileStatement() ICreateFileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateFileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateFileStatementContext)
}

func (s *StatementContext) DropFileStatement() IDropFileStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFileStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFileStatementContext)
}

func (s *StatementContext) ShowSmallFilesStatement() IShowSmallFilesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowSmallFilesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowSmallFilesStatementContext)
}

func (s *StatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *StatementContext) SetUserPropertyStatement() ISetUserPropertyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetUserPropertyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetUserPropertyStatementContext)
}

func (s *StatementContext) CreateStorageVolumeStatement() ICreateStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateStorageVolumeStatementContext)
}

func (s *StatementContext) AlterStorageVolumeStatement() IAlterStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStorageVolumeStatementContext)
}

func (s *StatementContext) DropStorageVolumeStatement() IDropStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropStorageVolumeStatementContext)
}

func (s *StatementContext) ShowStorageVolumesStatement() IShowStorageVolumesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowStorageVolumesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowStorageVolumesStatementContext)
}

func (s *StatementContext) DescStorageVolumeStatement() IDescStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescStorageVolumeStatementContext)
}

func (s *StatementContext) SetDefaultStorageVolumeStatement() ISetDefaultStorageVolumeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetDefaultStorageVolumeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetDefaultStorageVolumeStatementContext)
}

func (s *StatementContext) CreatePipeStatement() ICreatePipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreatePipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreatePipeStatementContext)
}

func (s *StatementContext) DropPipeStatement() IDropPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPipeStatementContext)
}

func (s *StatementContext) AlterPipeStatement() IAlterPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPipeStatementContext)
}

func (s *StatementContext) ShowPipeStatement() IShowPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPipeStatementContext)
}

func (s *StatementContext) DescPipeStatement() IDescPipeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDescPipeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDescPipeStatementContext)
}

func (s *StatementContext) CancelCompactionStatement() ICancelCompactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelCompactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelCompactionStatementContext)
}

func (s *StatementContext) UpdateFailPointStatusStatement() IUpdateFailPointStatusStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateFailPointStatusStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateFailPointStatusStatementContext)
}

func (s *StatementContext) ShowFailPointStatement() IShowFailPointStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowFailPointStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowFailPointStatementContext)
}

func (s *StatementContext) PrepareStatement() IPrepareStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareStatementContext)
}

func (s *StatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *StatementContext) DeallocateStatement() IDeallocateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeallocateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeallocateStatementContext)
}

func (s *StatementContext) CreateDictionaryStatement() ICreateDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateDictionaryStatementContext)
}

func (s *StatementContext) DropDictionaryStatement() IDropDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropDictionaryStatementContext)
}

func (s *StatementContext) RefreshDictionaryStatement() IRefreshDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshDictionaryStatementContext)
}

func (s *StatementContext) ShowDictionaryStatement() IShowDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowDictionaryStatementContext)
}

func (s *StatementContext) CancelRefreshDictionaryStatement() ICancelRefreshDictionaryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelRefreshDictionaryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelRefreshDictionaryStatementContext)
}

func (s *StatementContext) AlterPlanAdvisorAddStatement() IAlterPlanAdvisorAddStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPlanAdvisorAddStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPlanAdvisorAddStatementContext)
}

func (s *StatementContext) TruncatePlanAdvisorStatement() ITruncatePlanAdvisorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncatePlanAdvisorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncatePlanAdvisorStatementContext)
}

func (s *StatementContext) AlterPlanAdvisorDropStatement() IAlterPlanAdvisorDropStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPlanAdvisorDropStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPlanAdvisorDropStatementContext)
}

func (s *StatementContext) ShowPlanAdvisorStatement() IShowPlanAdvisorStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowPlanAdvisorStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowPlanAdvisorStatementContext)
}

func (s *StatementContext) CreateWarehouseStatement() ICreateWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateWarehouseStatementContext)
}

func (s *StatementContext) DropWarehouseStatement() IDropWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropWarehouseStatementContext)
}

func (s *StatementContext) SuspendWarehouseStatement() ISuspendWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISuspendWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISuspendWarehouseStatementContext)
}

func (s *StatementContext) ResumeWarehouseStatement() IResumeWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResumeWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResumeWarehouseStatementContext)
}

func (s *StatementContext) SetWarehouseStatement() ISetWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetWarehouseStatementContext)
}

func (s *StatementContext) ShowWarehousesStatement() IShowWarehousesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowWarehousesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowWarehousesStatementContext)
}

func (s *StatementContext) ShowClustersStatement() IShowClustersStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowClustersStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowClustersStatementContext)
}

func (s *StatementContext) ShowNodesStatement() IShowNodesStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowNodesStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowNodesStatementContext)
}

func (s *StatementContext) AlterWarehouseStatement() IAlterWarehouseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterWarehouseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterWarehouseStatementContext)
}

func (s *StatementContext) BeginStatement() IBeginStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBeginStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBeginStatementContext)
}

func (s *StatementContext) CommitStatement() ICommitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitStatementContext)
}

func (s *StatementContext) RollbackStatement() IRollbackStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollbackStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollbackStatementContext)
}

func (s *StatementContext) TranslateStatement() ITranslateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslateStatementContext)
}

func (s *StatementContext) CreateBaselinePlanStatement() ICreateBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateBaselinePlanStatementContext)
}

func (s *StatementContext) DropBaselinePlanStatement() IDropBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBaselinePlanStatementContext)
}

func (s *StatementContext) ShowBaselinePlanStatement() IShowBaselinePlanStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowBaselinePlanStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowBaselinePlanStatementContext)
}

func (s *StatementContext) UnsupportedStatement() IUnsupportedStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnsupportedStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnsupportedStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *StarRocksParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, StarRocksParserRULE_statement)
	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1051)
			p.QueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1052)
			p.UseDatabaseStatement()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1053)
			p.UseCatalogStatement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1054)
			p.SetCatalogStatement()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1055)
			p.ShowDatabasesStatement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1056)
			p.AlterDbQuotaStatement()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1057)
			p.CreateDbStatement()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1058)
			p.DropDbStatement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1059)
			p.ShowCreateDbStatement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1060)
			p.AlterDatabaseRenameStatement()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1061)
			p.RecoverDbStmt()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1062)
			p.ShowDataStmt()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1063)
			p.ShowDataDistributionStmt()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1064)
			p.CreateTableStatement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1065)
			p.CreateTableAsSelectStatement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1066)
			p.CreateTableLikeStatement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1067)
			p.ShowCreateTableStatement()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1068)
			p.DropTableStatement()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1069)
			p.CleanTemporaryTableStatement()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1070)
			p.RecoverTableStatement()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1071)
			p.TruncateTableStatement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1072)
			p.ShowTableStatement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1073)
			p.DescTableStatement()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1074)
			p.ShowTableStatusStatement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1075)
			p.ShowColumnStatement()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1076)
			p.RefreshTableStatement()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1077)
			p.AlterTableStatement()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1078)
			p.CancelAlterTableStatement()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1079)
			p.ShowAlterStatement()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1080)
			p.ShowTemporaryTablesStatement()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1081)
			p.CreateViewStatement()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(1082)
			p.AlterViewStatement()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(1083)
			p.DropViewStatement()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(1084)
			p.ShowPartitionsStatement()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(1085)
			p.RecoverPartitionStatement()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(1086)
			p.CreateIndexStatement()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(1087)
			p.DropIndexStatement()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(1088)
			p.ShowIndexStatement()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(1089)
			p.SubmitTaskStatement()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(1090)
			p.DropTaskStatement()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(1091)
			p.CreateMaterializedViewStatement()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(1092)
			p.ShowMaterializedViewsStatement()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(1093)
			p.DropMaterializedViewStatement()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(1094)
			p.AlterMaterializedViewStatement()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(1095)
			p.RefreshMaterializedViewStatement()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(1096)
			p.CancelRefreshMaterializedViewStatement()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(1097)
			p.CreateExternalCatalogStatement()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(1098)
			p.DropExternalCatalogStatement()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(1099)
			p.ShowCatalogsStatement()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(1100)
			p.ShowCreateExternalCatalogStatement()
		}

	case 51:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(1101)
			p.AlterCatalogStatement()
		}

	case 52:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(1102)
			p.InsertStatement()
		}

	case 53:
		p.EnterOuterAlt(localctx, 53)
		{
			p.SetState(1103)
			p.UpdateStatement()
		}

	case 54:
		p.EnterOuterAlt(localctx, 54)
		{
			p.SetState(1104)
			p.DeleteStatement()
		}

	case 55:
		p.EnterOuterAlt(localctx, 55)
		{
			p.SetState(1105)
			p.CreateRoutineLoadStatement()
		}

	case 56:
		p.EnterOuterAlt(localctx, 56)
		{
			p.SetState(1106)
			p.AlterRoutineLoadStatement()
		}

	case 57:
		p.EnterOuterAlt(localctx, 57)
		{
			p.SetState(1107)
			p.StopRoutineLoadStatement()
		}

	case 58:
		p.EnterOuterAlt(localctx, 58)
		{
			p.SetState(1108)
			p.ResumeRoutineLoadStatement()
		}

	case 59:
		p.EnterOuterAlt(localctx, 59)
		{
			p.SetState(1109)
			p.PauseRoutineLoadStatement()
		}

	case 60:
		p.EnterOuterAlt(localctx, 60)
		{
			p.SetState(1110)
			p.ShowRoutineLoadStatement()
		}

	case 61:
		p.EnterOuterAlt(localctx, 61)
		{
			p.SetState(1111)
			p.ShowRoutineLoadTaskStatement()
		}

	case 62:
		p.EnterOuterAlt(localctx, 62)
		{
			p.SetState(1112)
			p.ShowCreateRoutineLoadStatement()
		}

	case 63:
		p.EnterOuterAlt(localctx, 63)
		{
			p.SetState(1113)
			p.ShowStreamLoadStatement()
		}

	case 64:
		p.EnterOuterAlt(localctx, 64)
		{
			p.SetState(1114)
			p.AdminSetConfigStatement()
		}

	case 65:
		p.EnterOuterAlt(localctx, 65)
		{
			p.SetState(1115)
			p.AdminSetReplicaStatusStatement()
		}

	case 66:
		p.EnterOuterAlt(localctx, 66)
		{
			p.SetState(1116)
			p.AdminShowConfigStatement()
		}

	case 67:
		p.EnterOuterAlt(localctx, 67)
		{
			p.SetState(1117)
			p.AdminShowReplicaDistributionStatement()
		}

	case 68:
		p.EnterOuterAlt(localctx, 68)
		{
			p.SetState(1118)
			p.AdminShowReplicaStatusStatement()
		}

	case 69:
		p.EnterOuterAlt(localctx, 69)
		{
			p.SetState(1119)
			p.AdminRepairTableStatement()
		}

	case 70:
		p.EnterOuterAlt(localctx, 70)
		{
			p.SetState(1120)
			p.AdminCancelRepairTableStatement()
		}

	case 71:
		p.EnterOuterAlt(localctx, 71)
		{
			p.SetState(1121)
			p.AdminCheckTabletsStatement()
		}

	case 72:
		p.EnterOuterAlt(localctx, 72)
		{
			p.SetState(1122)
			p.AdminSetPartitionVersion()
		}

	case 73:
		p.EnterOuterAlt(localctx, 73)
		{
			p.SetState(1123)
			p.KillStatement()
		}

	case 74:
		p.EnterOuterAlt(localctx, 74)
		{
			p.SetState(1124)
			p.SyncStatement()
		}

	case 75:
		p.EnterOuterAlt(localctx, 75)
		{
			p.SetState(1125)
			p.ExecuteScriptStatement()
		}

	case 76:
		p.EnterOuterAlt(localctx, 76)
		{
			p.SetState(1126)
			p.AdminSetAutomatedSnapshotOnStatement()
		}

	case 77:
		p.EnterOuterAlt(localctx, 77)
		{
			p.SetState(1127)
			p.AdminSetAutomatedSnapshotOffStatement()
		}

	case 78:
		p.EnterOuterAlt(localctx, 78)
		{
			p.SetState(1128)
			p.AlterSystemStatement()
		}

	case 79:
		p.EnterOuterAlt(localctx, 79)
		{
			p.SetState(1129)
			p.CancelAlterSystemStatement()
		}

	case 80:
		p.EnterOuterAlt(localctx, 80)
		{
			p.SetState(1130)
			p.ShowComputeNodesStatement()
		}

	case 81:
		p.EnterOuterAlt(localctx, 81)
		{
			p.SetState(1131)
			p.AnalyzeStatement()
		}

	case 82:
		p.EnterOuterAlt(localctx, 82)
		{
			p.SetState(1132)
			p.DropStatsStatement()
		}

	case 83:
		p.EnterOuterAlt(localctx, 83)
		{
			p.SetState(1133)
			p.CreateAnalyzeStatement()
		}

	case 84:
		p.EnterOuterAlt(localctx, 84)
		{
			p.SetState(1134)
			p.DropAnalyzeJobStatement()
		}

	case 85:
		p.EnterOuterAlt(localctx, 85)
		{
			p.SetState(1135)
			p.AnalyzeHistogramStatement()
		}

	case 86:
		p.EnterOuterAlt(localctx, 86)
		{
			p.SetState(1136)
			p.DropHistogramStatement()
		}

	case 87:
		p.EnterOuterAlt(localctx, 87)
		{
			p.SetState(1137)
			p.ShowAnalyzeStatement()
		}

	case 88:
		p.EnterOuterAlt(localctx, 88)
		{
			p.SetState(1138)
			p.ShowStatsMetaStatement()
		}

	case 89:
		p.EnterOuterAlt(localctx, 89)
		{
			p.SetState(1139)
			p.ShowHistogramMetaStatement()
		}

	case 90:
		p.EnterOuterAlt(localctx, 90)
		{
			p.SetState(1140)
			p.KillAnalyzeStatement()
		}

	case 91:
		p.EnterOuterAlt(localctx, 91)
		{
			p.SetState(1141)
			p.AnalyzeProfileStatement()
		}

	case 92:
		p.EnterOuterAlt(localctx, 92)
		{
			p.SetState(1142)
			p.CreateResourceGroupStatement()
		}

	case 93:
		p.EnterOuterAlt(localctx, 93)
		{
			p.SetState(1143)
			p.DropResourceGroupStatement()
		}

	case 94:
		p.EnterOuterAlt(localctx, 94)
		{
			p.SetState(1144)
			p.AlterResourceGroupStatement()
		}

	case 95:
		p.EnterOuterAlt(localctx, 95)
		{
			p.SetState(1145)
			p.ShowResourceGroupStatement()
		}

	case 96:
		p.EnterOuterAlt(localctx, 96)
		{
			p.SetState(1146)
			p.ShowResourceGroupUsageStatement()
		}

	case 97:
		p.EnterOuterAlt(localctx, 97)
		{
			p.SetState(1147)
			p.CreateResourceStatement()
		}

	case 98:
		p.EnterOuterAlt(localctx, 98)
		{
			p.SetState(1148)
			p.AlterResourceStatement()
		}

	case 99:
		p.EnterOuterAlt(localctx, 99)
		{
			p.SetState(1149)
			p.DropResourceStatement()
		}

	case 100:
		p.EnterOuterAlt(localctx, 100)
		{
			p.SetState(1150)
			p.ShowResourceStatement()
		}

	case 101:
		p.EnterOuterAlt(localctx, 101)
		{
			p.SetState(1151)
			p.ShowFunctionsStatement()
		}

	case 102:
		p.EnterOuterAlt(localctx, 102)
		{
			p.SetState(1152)
			p.DropFunctionStatement()
		}

	case 103:
		p.EnterOuterAlt(localctx, 103)
		{
			p.SetState(1153)
			p.CreateFunctionStatement()
		}

	case 104:
		p.EnterOuterAlt(localctx, 104)
		{
			p.SetState(1154)
			p.LoadStatement()
		}

	case 105:
		p.EnterOuterAlt(localctx, 105)
		{
			p.SetState(1155)
			p.ShowLoadStatement()
		}

	case 106:
		p.EnterOuterAlt(localctx, 106)
		{
			p.SetState(1156)
			p.ShowLoadWarningsStatement()
		}

	case 107:
		p.EnterOuterAlt(localctx, 107)
		{
			p.SetState(1157)
			p.CancelLoadStatement()
		}

	case 108:
		p.EnterOuterAlt(localctx, 108)
		{
			p.SetState(1158)
			p.AlterLoadStatement()
		}

	case 109:
		p.EnterOuterAlt(localctx, 109)
		{
			p.SetState(1159)
			p.ShowAuthorStatement()
		}

	case 110:
		p.EnterOuterAlt(localctx, 110)
		{
			p.SetState(1160)
			p.ShowBackendsStatement()
		}

	case 111:
		p.EnterOuterAlt(localctx, 111)
		{
			p.SetState(1161)
			p.ShowBrokerStatement()
		}

	case 112:
		p.EnterOuterAlt(localctx, 112)
		{
			p.SetState(1162)
			p.ShowCharsetStatement()
		}

	case 113:
		p.EnterOuterAlt(localctx, 113)
		{
			p.SetState(1163)
			p.ShowCollationStatement()
		}

	case 114:
		p.EnterOuterAlt(localctx, 114)
		{
			p.SetState(1164)
			p.ShowDeleteStatement()
		}

	case 115:
		p.EnterOuterAlt(localctx, 115)
		{
			p.SetState(1165)
			p.ShowDynamicPartitionStatement()
		}

	case 116:
		p.EnterOuterAlt(localctx, 116)
		{
			p.SetState(1166)
			p.ShowEventsStatement()
		}

	case 117:
		p.EnterOuterAlt(localctx, 117)
		{
			p.SetState(1167)
			p.ShowEnginesStatement()
		}

	case 118:
		p.EnterOuterAlt(localctx, 118)
		{
			p.SetState(1168)
			p.ShowFrontendsStatement()
		}

	case 119:
		p.EnterOuterAlt(localctx, 119)
		{
			p.SetState(1169)
			p.ShowPluginsStatement()
		}

	case 120:
		p.EnterOuterAlt(localctx, 120)
		{
			p.SetState(1170)
			p.ShowRepositoriesStatement()
		}

	case 121:
		p.EnterOuterAlt(localctx, 121)
		{
			p.SetState(1171)
			p.ShowOpenTableStatement()
		}

	case 122:
		p.EnterOuterAlt(localctx, 122)
		{
			p.SetState(1172)
			p.ShowPrivilegesStatement()
		}

	case 123:
		p.EnterOuterAlt(localctx, 123)
		{
			p.SetState(1173)
			p.ShowProcedureStatement()
		}

	case 124:
		p.EnterOuterAlt(localctx, 124)
		{
			p.SetState(1174)
			p.ShowProcStatement()
		}

	case 125:
		p.EnterOuterAlt(localctx, 125)
		{
			p.SetState(1175)
			p.ShowProcesslistStatement()
		}

	case 126:
		p.EnterOuterAlt(localctx, 126)
		{
			p.SetState(1176)
			p.ShowProfilelistStatement()
		}

	case 127:
		p.EnterOuterAlt(localctx, 127)
		{
			p.SetState(1177)
			p.ShowRunningQueriesStatement()
		}

	case 128:
		p.EnterOuterAlt(localctx, 128)
		{
			p.SetState(1178)
			p.ShowStatusStatement()
		}

	case 129:
		p.EnterOuterAlt(localctx, 129)
		{
			p.SetState(1179)
			p.ShowTabletStatement()
		}

	case 130:
		p.EnterOuterAlt(localctx, 130)
		{
			p.SetState(1180)
			p.ShowTransactionStatement()
		}

	case 131:
		p.EnterOuterAlt(localctx, 131)
		{
			p.SetState(1181)
			p.ShowTriggersStatement()
		}

	case 132:
		p.EnterOuterAlt(localctx, 132)
		{
			p.SetState(1182)
			p.ShowUserPropertyStatement()
		}

	case 133:
		p.EnterOuterAlt(localctx, 133)
		{
			p.SetState(1183)
			p.ShowVariablesStatement()
		}

	case 134:
		p.EnterOuterAlt(localctx, 134)
		{
			p.SetState(1184)
			p.ShowWarningStatement()
		}

	case 135:
		p.EnterOuterAlt(localctx, 135)
		{
			p.SetState(1185)
			p.HelpStatement()
		}

	case 136:
		p.EnterOuterAlt(localctx, 136)
		{
			p.SetState(1186)
			p.CreateUserStatement()
		}

	case 137:
		p.EnterOuterAlt(localctx, 137)
		{
			p.SetState(1187)
			p.DropUserStatement()
		}

	case 138:
		p.EnterOuterAlt(localctx, 138)
		{
			p.SetState(1188)
			p.AlterUserStatement()
		}

	case 139:
		p.EnterOuterAlt(localctx, 139)
		{
			p.SetState(1189)
			p.ShowUserStatement()
		}

	case 140:
		p.EnterOuterAlt(localctx, 140)
		{
			p.SetState(1190)
			p.ShowAuthenticationStatement()
		}

	case 141:
		p.EnterOuterAlt(localctx, 141)
		{
			p.SetState(1191)
			p.ExecuteAsStatement()
		}

	case 142:
		p.EnterOuterAlt(localctx, 142)
		{
			p.SetState(1192)
			p.CreateRoleStatement()
		}

	case 143:
		p.EnterOuterAlt(localctx, 143)
		{
			p.SetState(1193)
			p.AlterRoleStatement()
		}

	case 144:
		p.EnterOuterAlt(localctx, 144)
		{
			p.SetState(1194)
			p.DropRoleStatement()
		}

	case 145:
		p.EnterOuterAlt(localctx, 145)
		{
			p.SetState(1195)
			p.ShowRolesStatement()
		}

	case 146:
		p.EnterOuterAlt(localctx, 146)
		{
			p.SetState(1196)
			p.GrantRoleStatement()
		}

	case 147:
		p.EnterOuterAlt(localctx, 147)
		{
			p.SetState(1197)
			p.RevokeRoleStatement()
		}

	case 148:
		p.EnterOuterAlt(localctx, 148)
		{
			p.SetState(1198)
			p.SetRoleStatement()
		}

	case 149:
		p.EnterOuterAlt(localctx, 149)
		{
			p.SetState(1199)
			p.SetDefaultRoleStatement()
		}

	case 150:
		p.EnterOuterAlt(localctx, 150)
		{
			p.SetState(1200)
			p.GrantPrivilegeStatement()
		}

	case 151:
		p.EnterOuterAlt(localctx, 151)
		{
			p.SetState(1201)
			p.RevokePrivilegeStatement()
		}

	case 152:
		p.EnterOuterAlt(localctx, 152)
		{
			p.SetState(1202)
			p.ShowGrantsStatement()
		}

	case 153:
		p.EnterOuterAlt(localctx, 153)
		{
			p.SetState(1203)
			p.CreateSecurityIntegrationStatement()
		}

	case 154:
		p.EnterOuterAlt(localctx, 154)
		{
			p.SetState(1204)
			p.AlterSecurityIntegrationStatement()
		}

	case 155:
		p.EnterOuterAlt(localctx, 155)
		{
			p.SetState(1205)
			p.DropSecurityIntegrationStatement()
		}

	case 156:
		p.EnterOuterAlt(localctx, 156)
		{
			p.SetState(1206)
			p.ShowSecurityIntegrationStatement()
		}

	case 157:
		p.EnterOuterAlt(localctx, 157)
		{
			p.SetState(1207)
			p.ShowCreateSecurityIntegrationStatement()
		}

	case 158:
		p.EnterOuterAlt(localctx, 158)
		{
			p.SetState(1208)
			p.CreateGroupProviderStatement()
		}

	case 159:
		p.EnterOuterAlt(localctx, 159)
		{
			p.SetState(1209)
			p.DropGroupProviderStatement()
		}

	case 160:
		p.EnterOuterAlt(localctx, 160)
		{
			p.SetState(1210)
			p.ShowGroupProvidersStatement()
		}

	case 161:
		p.EnterOuterAlt(localctx, 161)
		{
			p.SetState(1211)
			p.ShowCreateGroupProviderStatement()
		}

	case 162:
		p.EnterOuterAlt(localctx, 162)
		{
			p.SetState(1212)
			p.BackupStatement()
		}

	case 163:
		p.EnterOuterAlt(localctx, 163)
		{
			p.SetState(1213)
			p.CancelBackupStatement()
		}

	case 164:
		p.EnterOuterAlt(localctx, 164)
		{
			p.SetState(1214)
			p.ShowBackupStatement()
		}

	case 165:
		p.EnterOuterAlt(localctx, 165)
		{
			p.SetState(1215)
			p.RestoreStatement()
		}

	case 166:
		p.EnterOuterAlt(localctx, 166)
		{
			p.SetState(1216)
			p.CancelRestoreStatement()
		}

	case 167:
		p.EnterOuterAlt(localctx, 167)
		{
			p.SetState(1217)
			p.ShowRestoreStatement()
		}

	case 168:
		p.EnterOuterAlt(localctx, 168)
		{
			p.SetState(1218)
			p.ShowSnapshotStatement()
		}

	case 169:
		p.EnterOuterAlt(localctx, 169)
		{
			p.SetState(1219)
			p.CreateRepositoryStatement()
		}

	case 170:
		p.EnterOuterAlt(localctx, 170)
		{
			p.SetState(1220)
			p.DropRepositoryStatement()
		}

	case 171:
		p.EnterOuterAlt(localctx, 171)
		{
			p.SetState(1221)
			p.AddSqlBlackListStatement()
		}

	case 172:
		p.EnterOuterAlt(localctx, 172)
		{
			p.SetState(1222)
			p.DelSqlBlackListStatement()
		}

	case 173:
		p.EnterOuterAlt(localctx, 173)
		{
			p.SetState(1223)
			p.ShowSqlBlackListStatement()
		}

	case 174:
		p.EnterOuterAlt(localctx, 174)
		{
			p.SetState(1224)
			p.ShowWhiteListStatement()
		}

	case 175:
		p.EnterOuterAlt(localctx, 175)
		{
			p.SetState(1225)
			p.AddBackendBlackListStatement()
		}

	case 176:
		p.EnterOuterAlt(localctx, 176)
		{
			p.SetState(1226)
			p.DelBackendBlackListStatement()
		}

	case 177:
		p.EnterOuterAlt(localctx, 177)
		{
			p.SetState(1227)
			p.ShowBackendBlackListStatement()
		}

	case 178:
		p.EnterOuterAlt(localctx, 178)
		{
			p.SetState(1228)
			p.CreateDataCacheRuleStatement()
		}

	case 179:
		p.EnterOuterAlt(localctx, 179)
		{
			p.SetState(1229)
			p.ShowDataCacheRulesStatement()
		}

	case 180:
		p.EnterOuterAlt(localctx, 180)
		{
			p.SetState(1230)
			p.DropDataCacheRuleStatement()
		}

	case 181:
		p.EnterOuterAlt(localctx, 181)
		{
			p.SetState(1231)
			p.ClearDataCacheRulesStatement()
		}

	case 182:
		p.EnterOuterAlt(localctx, 182)
		{
			p.SetState(1232)
			p.DataCacheSelectStatement()
		}

	case 183:
		p.EnterOuterAlt(localctx, 183)
		{
			p.SetState(1233)
			p.ExportStatement()
		}

	case 184:
		p.EnterOuterAlt(localctx, 184)
		{
			p.SetState(1234)
			p.CancelExportStatement()
		}

	case 185:
		p.EnterOuterAlt(localctx, 185)
		{
			p.SetState(1235)
			p.ShowExportStatement()
		}

	case 186:
		p.EnterOuterAlt(localctx, 186)
		{
			p.SetState(1236)
			p.InstallPluginStatement()
		}

	case 187:
		p.EnterOuterAlt(localctx, 187)
		{
			p.SetState(1237)
			p.UninstallPluginStatement()
		}

	case 188:
		p.EnterOuterAlt(localctx, 188)
		{
			p.SetState(1238)
			p.CreateFileStatement()
		}

	case 189:
		p.EnterOuterAlt(localctx, 189)
		{
			p.SetState(1239)
			p.DropFileStatement()
		}

	case 190:
		p.EnterOuterAlt(localctx, 190)
		{
			p.SetState(1240)
			p.ShowSmallFilesStatement()
		}

	case 191:
		p.EnterOuterAlt(localctx, 191)
		{
			p.SetState(1241)
			p.SetStatement()
		}

	case 192:
		p.EnterOuterAlt(localctx, 192)
		{
			p.SetState(1242)
			p.SetUserPropertyStatement()
		}

	case 193:
		p.EnterOuterAlt(localctx, 193)
		{
			p.SetState(1243)
			p.CreateStorageVolumeStatement()
		}

	case 194:
		p.EnterOuterAlt(localctx, 194)
		{
			p.SetState(1244)
			p.AlterStorageVolumeStatement()
		}

	case 195:
		p.EnterOuterAlt(localctx, 195)
		{
			p.SetState(1245)
			p.DropStorageVolumeStatement()
		}

	case 196:
		p.EnterOuterAlt(localctx, 196)
		{
			p.SetState(1246)
			p.ShowStorageVolumesStatement()
		}

	case 197:
		p.EnterOuterAlt(localctx, 197)
		{
			p.SetState(1247)
			p.DescStorageVolumeStatement()
		}

	case 198:
		p.EnterOuterAlt(localctx, 198)
		{
			p.SetState(1248)
			p.SetDefaultStorageVolumeStatement()
		}

	case 199:
		p.EnterOuterAlt(localctx, 199)
		{
			p.SetState(1249)
			p.CreatePipeStatement()
		}

	case 200:
		p.EnterOuterAlt(localctx, 200)
		{
			p.SetState(1250)
			p.DropPipeStatement()
		}

	case 201:
		p.EnterOuterAlt(localctx, 201)
		{
			p.SetState(1251)
			p.AlterPipeStatement()
		}

	case 202:
		p.EnterOuterAlt(localctx, 202)
		{
			p.SetState(1252)
			p.ShowPipeStatement()
		}

	case 203:
		p.EnterOuterAlt(localctx, 203)
		{
			p.SetState(1253)
			p.DescPipeStatement()
		}

	case 204:
		p.EnterOuterAlt(localctx, 204)
		{
			p.SetState(1254)
			p.CancelCompactionStatement()
		}

	case 205:
		p.EnterOuterAlt(localctx, 205)
		{
			p.SetState(1255)
			p.UpdateFailPointStatusStatement()
		}

	case 206:
		p.EnterOuterAlt(localctx, 206)
		{
			p.SetState(1256)
			p.ShowFailPointStatement()
		}

	case 207:
		p.EnterOuterAlt(localctx, 207)
		{
			p.SetState(1257)
			p.PrepareStatement()
		}

	case 208:
		p.EnterOuterAlt(localctx, 208)
		{
			p.SetState(1258)
			p.ExecuteStatement()
		}

	case 209:
		p.EnterOuterAlt(localctx, 209)
		{
			p.SetState(1259)
			p.DeallocateStatement()
		}

	case 210:
		p.EnterOuterAlt(localctx, 210)
		{
			p.SetState(1260)
			p.CreateDictionaryStatement()
		}

	case 211:
		p.EnterOuterAlt(localctx, 211)
		{
			p.SetState(1261)
			p.DropDictionaryStatement()
		}

	case 212:
		p.EnterOuterAlt(localctx, 212)
		{
			p.SetState(1262)
			p.RefreshDictionaryStatement()
		}

	case 213:
		p.EnterOuterAlt(localctx, 213)
		{
			p.SetState(1263)
			p.ShowDictionaryStatement()
		}

	case 214:
		p.EnterOuterAlt(localctx, 214)
		{
			p.SetState(1264)
			p.CancelRefreshDictionaryStatement()
		}

	case 215:
		p.EnterOuterAlt(localctx, 215)
		{
			p.SetState(1265)
			p.AlterPlanAdvisorAddStatement()
		}

	case 216:
		p.EnterOuterAlt(localctx, 216)
		{
			p.SetState(1266)
			p.TruncatePlanAdvisorStatement()
		}

	case 217:
		p.EnterOuterAlt(localctx, 217)
		{
			p.SetState(1267)
			p.AlterPlanAdvisorDropStatement()
		}

	case 218:
		p.EnterOuterAlt(localctx, 218)
		{
			p.SetState(1268)
			p.ShowPlanAdvisorStatement()
		}

	case 219:
		p.EnterOuterAlt(localctx, 219)
		{
			p.SetState(1269)
			p.CreateWarehouseStatement()
		}

	case 220:
		p.EnterOuterAlt(localctx, 220)
		{
			p.SetState(1270)
			p.DropWarehouseStatement()
		}

	case 221:
		p.EnterOuterAlt(localctx, 221)
		{
			p.SetState(1271)
			p.SuspendWarehouseStatement()
		}

	case 222:
		p.EnterOuterAlt(localctx, 222)
		{
			p.SetState(1272)
			p.ResumeWarehouseStatement()
		}

	case 223:
		p.EnterOuterAlt(localctx, 223)
		{
			p.SetState(1273)
			p.SetWarehouseStatement()
		}

	case 224:
		p.EnterOuterAlt(localctx, 224)
		{
			p.SetState(1274)
			p.ShowWarehousesStatement()
		}

	case 225:
		p.EnterOuterAlt(localctx, 225)
		{
			p.SetState(1275)
			p.ShowClustersStatement()
		}

	case 226:
		p.EnterOuterAlt(localctx, 226)
		{
			p.SetState(1276)
			p.ShowNodesStatement()
		}

	case 227:
		p.EnterOuterAlt(localctx, 227)
		{
			p.SetState(1277)
			p.AlterWarehouseStatement()
		}

	case 228:
		p.EnterOuterAlt(localctx, 228)
		{
			p.SetState(1278)
			p.BeginStatement()
		}

	case 229:
		p.EnterOuterAlt(localctx, 229)
		{
			p.SetState(1279)
			p.CommitStatement()
		}

	case 230:
		p.EnterOuterAlt(localctx, 230)
		{
			p.SetState(1280)
			p.RollbackStatement()
		}

	case 231:
		p.EnterOuterAlt(localctx, 231)
		{
			p.SetState(1281)
			p.TranslateStatement()
		}

	case 232:
		p.EnterOuterAlt(localctx, 232)
		{
			p.SetState(1282)
			p.CreateBaselinePlanStatement()
		}

	case 233:
		p.EnterOuterAlt(localctx, 233)
		{
			p.SetState(1283)
			p.DropBaselinePlanStatement()
		}

	case 234:
		p.EnterOuterAlt(localctx, 234)
		{
			p.SetState(1284)
			p.ShowBaselinePlanStatement()
		}

	case 235:
		p.EnterOuterAlt(localctx, 235)
		{
			p.SetState(1285)
			p.UnsupportedStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseDatabaseStatementContext is an interface to support dynamic dispatch.
type IUseDatabaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsUseDatabaseStatementContext differentiates from other interfaces.
	IsUseDatabaseStatementContext()
}

type UseDatabaseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDatabaseStatementContext() *UseDatabaseStatementContext {
	var p = new(UseDatabaseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_useDatabaseStatement
	return p
}

func InitEmptyUseDatabaseStatementContext(p *UseDatabaseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_useDatabaseStatement
}

func (*UseDatabaseStatementContext) IsUseDatabaseStatementContext() {}

func NewUseDatabaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDatabaseStatementContext {
	var p = new(UseDatabaseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_useDatabaseStatement

	return p
}

func (s *UseDatabaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDatabaseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSE, 0)
}

func (s *UseDatabaseStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UseDatabaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDatabaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDatabaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUseDatabaseStatement(s)
	}
}

func (s *UseDatabaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUseDatabaseStatement(s)
	}
}

func (p *StarRocksParser) UseDatabaseStatement() (localctx IUseDatabaseStatementContext) {
	localctx = NewUseDatabaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, StarRocksParserRULE_useDatabaseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.Match(StarRocksParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1289)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUseCatalogStatementContext is an interface to support dynamic dispatch.
type IUseCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USE() antlr.TerminalNode
	String_() IStringContext

	// IsUseCatalogStatementContext differentiates from other interfaces.
	IsUseCatalogStatementContext()
}

type UseCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseCatalogStatementContext() *UseCatalogStatementContext {
	var p = new(UseCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_useCatalogStatement
	return p
}

func InitEmptyUseCatalogStatementContext(p *UseCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_useCatalogStatement
}

func (*UseCatalogStatementContext) IsUseCatalogStatementContext() {}

func NewUseCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseCatalogStatementContext {
	var p = new(UseCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_useCatalogStatement

	return p
}

func (s *UseCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseCatalogStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSE, 0)
}

func (s *UseCatalogStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UseCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUseCatalogStatement(s)
	}
}

func (s *UseCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUseCatalogStatement(s)
	}
}

func (p *StarRocksParser) UseCatalogStatement() (localctx IUseCatalogStatementContext) {
	localctx = NewUseCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, StarRocksParserRULE_useCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1291)
		p.Match(StarRocksParserUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1292)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetCatalogStatementContext is an interface to support dynamic dispatch.
type ISetCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsSetCatalogStatementContext differentiates from other interfaces.
	IsSetCatalogStatementContext()
}

type SetCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetCatalogStatementContext() *SetCatalogStatementContext {
	var p = new(SetCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setCatalogStatement
	return p
}

func InitEmptySetCatalogStatementContext(p *SetCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setCatalogStatement
}

func (*SetCatalogStatementContext) IsSetCatalogStatementContext() {}

func NewSetCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetCatalogStatementContext {
	var p = new(SetCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setCatalogStatement

	return p
}

func (s *SetCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetCatalogStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *SetCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetCatalogStatement(s)
	}
}

func (s *SetCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetCatalogStatement(s)
	}
}

func (p *StarRocksParser) SetCatalogStatement() (localctx ISetCatalogStatementContext) {
	localctx = NewSetCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, StarRocksParserRULE_setCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1294)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1295)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1296)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDatabasesStatementContext is an interface to support dynamic dispatch.
type IShowDatabasesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext
	SCHEMAS() antlr.TerminalNode

	// IsShowDatabasesStatementContext differentiates from other interfaces.
	IsShowDatabasesStatementContext()
}

type ShowDatabasesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowDatabasesStatementContext() *ShowDatabasesStatementContext {
	var p = new(ShowDatabasesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDatabasesStatement
	return p
}

func InitEmptyShowDatabasesStatementContext(p *ShowDatabasesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDatabasesStatement
}

func (*ShowDatabasesStatementContext) IsShowDatabasesStatementContext() {}

func NewShowDatabasesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDatabasesStatementContext {
	var p = new(ShowDatabasesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDatabasesStatement

	return p
}

func (s *ShowDatabasesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDatabasesStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowDatabasesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowDatabasesStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowDatabasesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowDatabasesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDatabasesStatementContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASES, 0)
}

func (s *ShowDatabasesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDatabasesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowDatabasesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDatabasesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowDatabasesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowDatabasesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowDatabasesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowDatabasesStatementContext) SCHEMAS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMAS, 0)
}

func (s *ShowDatabasesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDatabasesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDatabasesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDatabasesStatement(s)
	}
}

func (s *ShowDatabasesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDatabasesStatement(s)
	}
}

func (p *StarRocksParser) ShowDatabasesStatement() (localctx IShowDatabasesStatementContext) {
	localctx = NewShowDatabasesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, StarRocksParserRULE_showDatabasesStatement)
	var _la int

	p.SetState(1318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 6, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1298)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1299)
			p.Match(StarRocksParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1302)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFROM || _la == StarRocksParserIN {
			{
				p.SetState(1300)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1301)

				var _x = p.QualifiedName()

				localctx.(*ShowDatabasesStatementContext).catalog = _x
			}

		}
		p.SetState(1308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case StarRocksParserLIKE:
			{
				p.SetState(1304)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1305)

				var _x = p.String_()

				localctx.(*ShowDatabasesStatementContext).pattern = _x
			}

		case StarRocksParserWHERE:
			{
				p.SetState(1306)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1307)
				p.expression(0)
			}

		case StarRocksParserEOF, StarRocksParserSEMICOLON:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1310)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1311)
			p.Match(StarRocksParserSCHEMAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case StarRocksParserLIKE:
			{
				p.SetState(1312)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1313)

				var _x = p.String_()

				localctx.(*ShowDatabasesStatementContext).pattern = _x
			}

		case StarRocksParserWHERE:
			{
				p.SetState(1314)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1315)
				p.expression(0)
			}

		case StarRocksParserEOF, StarRocksParserSEMICOLON:

		default:
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDbQuotaStatementContext is an interface to support dynamic dispatch.
type IAlterDbQuotaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	SET() antlr.TerminalNode
	DATA() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsAlterDbQuotaStatementContext differentiates from other interfaces.
	IsAlterDbQuotaStatementContext()
}

type AlterDbQuotaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDbQuotaStatementContext() *AlterDbQuotaStatementContext {
	var p = new(AlterDbQuotaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterDbQuotaStatement
	return p
}

func InitEmptyAlterDbQuotaStatementContext(p *AlterDbQuotaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterDbQuotaStatement
}

func (*AlterDbQuotaStatementContext) IsAlterDbQuotaStatementContext() {}

func NewAlterDbQuotaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDbQuotaStatementContext {
	var p = new(AlterDbQuotaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterDbQuotaStatement

	return p
}

func (s *AlterDbQuotaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDbQuotaStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterDbQuotaStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *AlterDbQuotaStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDbQuotaStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDbQuotaStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterDbQuotaStatementContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *AlterDbQuotaStatementContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUOTA, 0)
}

func (s *AlterDbQuotaStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *AlterDbQuotaStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *AlterDbQuotaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDbQuotaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDbQuotaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterDbQuotaStatement(s)
	}
}

func (s *AlterDbQuotaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterDbQuotaStatement(s)
	}
}

func (p *StarRocksParser) AlterDbQuotaStatement() (localctx IAlterDbQuotaStatementContext) {
	localctx = NewAlterDbQuotaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, StarRocksParserRULE_alterDbQuotaStatement)
	p.SetState(1336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1320)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1321)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1322)
			p.Identifier()
		}
		{
			p.SetState(1323)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1324)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1325)
			p.Match(StarRocksParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1326)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1328)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1329)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1330)
			p.Identifier()
		}
		{
			p.SetState(1331)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1332)
			p.Match(StarRocksParserREPLICA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1333)
			p.Match(StarRocksParserQUOTA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1334)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDbStatementContext is an interface to support dynamic dispatch.
type ICreateDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IIdentifierContext

	// GetDatabase returns the database rule contexts.
	GetDatabase() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IIdentifierContext)

	// SetDatabase sets the database rule contexts.
	SetDatabase(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	CharsetDesc() ICharsetDescContext
	CollateDesc() ICollateDescContext
	Properties() IPropertiesContext
	Identifier() IIdentifierContext

	// IsCreateDbStatementContext differentiates from other interfaces.
	IsCreateDbStatementContext()
}

type CreateDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	catalog  IIdentifierContext
	database IQualifiedNameContext
}

func NewEmptyCreateDbStatementContext() *CreateDbStatementContext {
	var p = new(CreateDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDbStatement
	return p
}

func InitEmptyCreateDbStatementContext(p *CreateDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDbStatement
}

func (*CreateDbStatementContext) IsCreateDbStatementContext() {}

func NewCreateDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDbStatementContext {
	var p = new(CreateDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createDbStatement

	return p
}

func (s *CreateDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDbStatementContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *CreateDbStatementContext) GetDatabase() IQualifiedNameContext { return s.database }

func (s *CreateDbStatementContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *CreateDbStatementContext) SetDatabase(v IQualifiedNameContext) { s.database = v }

func (s *CreateDbStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *CreateDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *CreateDbStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateDbStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateDbStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateDbStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateDbStatementContext) CharsetDesc() ICharsetDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetDescContext)
}

func (s *CreateDbStatementContext) CollateDesc() ICollateDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateDescContext)
}

func (s *CreateDbStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateDbStatement(s)
	}
}

func (s *CreateDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateDbStatement(s)
	}
}

func (p *StarRocksParser) CreateDbStatement() (localctx ICreateDbStatementContext) {
	localctx = NewCreateDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, StarRocksParserRULE_createDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1338)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1339)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDATABASE || _la == StarRocksParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1340)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1341)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1342)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1348)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 9, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1345)

			var _x = p.Identifier()

			localctx.(*CreateDbStatementContext).catalog = _x
		}
		{
			p.SetState(1346)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1350)

		var _x = p.QualifiedName()

		localctx.(*CreateDbStatementContext).database = _x
	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1351)
			p.CharsetDesc()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOLLATE || _la == StarRocksParserDEFAULT {
		{
			p.SetState(1354)
			p.CollateDesc()
		}

	}
	p.SetState(1358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1357)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDbStatementContext is an interface to support dynamic dispatch.
type IDropDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IIdentifierContext

	// GetDatabase returns the database rule contexts.
	GetDatabase() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IIdentifierContext)

	// SetDatabase sets the database rule contexts.
	SetDatabase(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropDbStatementContext differentiates from other interfaces.
	IsDropDbStatementContext()
}

type DropDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	catalog  IIdentifierContext
	database IQualifiedNameContext
}

func NewEmptyDropDbStatementContext() *DropDbStatementContext {
	var p = new(DropDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDbStatement
	return p
}

func InitEmptyDropDbStatementContext(p *DropDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDbStatement
}

func (*DropDbStatementContext) IsDropDbStatementContext() {}

func NewDropDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDbStatementContext {
	var p = new(DropDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropDbStatement

	return p
}

func (s *DropDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDbStatementContext) GetCatalog() IIdentifierContext { return s.catalog }

func (s *DropDbStatementContext) GetDatabase() IQualifiedNameContext { return s.database }

func (s *DropDbStatementContext) SetCatalog(v IIdentifierContext) { s.catalog = v }

func (s *DropDbStatementContext) SetDatabase(v IQualifiedNameContext) { s.database = v }

func (s *DropDbStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *DropDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *DropDbStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropDbStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropDbStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropDbStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropDbStatement(s)
	}
}

func (s *DropDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropDbStatement(s)
	}
}

func (p *StarRocksParser) DropDbStatement() (localctx IDropDbStatementContext) {
	localctx = NewDropDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, StarRocksParserRULE_dropDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1360)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1361)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDATABASE || _la == StarRocksParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1364)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1362)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1363)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 14, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1366)

			var _x = p.Identifier()

			localctx.(*DropDbStatementContext).catalog = _x
		}
		{
			p.SetState(1367)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(1371)

		var _x = p.QualifiedName()

		localctx.(*DropDbStatementContext).database = _x
	}
	p.SetState(1373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(1372)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateDbStatementContext is an interface to support dynamic dispatch.
type IShowCreateDbStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsShowCreateDbStatementContext differentiates from other interfaces.
	IsShowCreateDbStatementContext()
}

type ShowCreateDbStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateDbStatementContext() *ShowCreateDbStatementContext {
	var p = new(ShowCreateDbStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateDbStatement
	return p
}

func InitEmptyShowCreateDbStatementContext(p *ShowCreateDbStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateDbStatement
}

func (*ShowCreateDbStatementContext) IsShowCreateDbStatementContext() {}

func NewShowCreateDbStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateDbStatementContext {
	var p = new(ShowCreateDbStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateDbStatement

	return p
}

func (s *ShowCreateDbStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateDbStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateDbStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateDbStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateDbStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *ShowCreateDbStatementContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *ShowCreateDbStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateDbStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateDbStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateDbStatement(s)
	}
}

func (s *ShowCreateDbStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateDbStatement(s)
	}
}

func (p *StarRocksParser) ShowCreateDbStatement() (localctx IShowCreateDbStatementContext) {
	localctx = NewShowCreateDbStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, StarRocksParserRULE_showCreateDbStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1375)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1376)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1377)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDATABASE || _la == StarRocksParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1378)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterDatabaseRenameStatementContext is an interface to support dynamic dispatch.
type IAlterDatabaseRenameStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	RENAME() antlr.TerminalNode

	// IsAlterDatabaseRenameStatementContext differentiates from other interfaces.
	IsAlterDatabaseRenameStatementContext()
}

type AlterDatabaseRenameStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterDatabaseRenameStatementContext() *AlterDatabaseRenameStatementContext {
	var p = new(AlterDatabaseRenameStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterDatabaseRenameStatement
	return p
}

func InitEmptyAlterDatabaseRenameStatementContext(p *AlterDatabaseRenameStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterDatabaseRenameStatement
}

func (*AlterDatabaseRenameStatementContext) IsAlterDatabaseRenameStatementContext() {}

func NewAlterDatabaseRenameStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterDatabaseRenameStatementContext {
	var p = new(AlterDatabaseRenameStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterDatabaseRenameStatement

	return p
}

func (s *AlterDatabaseRenameStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterDatabaseRenameStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterDatabaseRenameStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *AlterDatabaseRenameStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterDatabaseRenameStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterDatabaseRenameStatementContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *AlterDatabaseRenameStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterDatabaseRenameStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterDatabaseRenameStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterDatabaseRenameStatement(s)
	}
}

func (s *AlterDatabaseRenameStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterDatabaseRenameStatement(s)
	}
}

func (p *StarRocksParser) AlterDatabaseRenameStatement() (localctx IAlterDatabaseRenameStatementContext) {
	localctx = NewAlterDatabaseRenameStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, StarRocksParserRULE_alterDatabaseRenameStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1380)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1381)
		p.Match(StarRocksParserDATABASE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1382)
		p.Identifier()
	}
	{
		p.SetState(1383)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1384)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverDbStmtContext is an interface to support dynamic dispatch.
type IRecoverDbStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECOVER() antlr.TerminalNode
	Identifier() IIdentifierContext
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode

	// IsRecoverDbStmtContext differentiates from other interfaces.
	IsRecoverDbStmtContext()
}

type RecoverDbStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecoverDbStmtContext() *RecoverDbStmtContext {
	var p = new(RecoverDbStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverDbStmt
	return p
}

func InitEmptyRecoverDbStmtContext(p *RecoverDbStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverDbStmt
}

func (*RecoverDbStmtContext) IsRecoverDbStmtContext() {}

func NewRecoverDbStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverDbStmtContext {
	var p = new(RecoverDbStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_recoverDbStmt

	return p
}

func (s *RecoverDbStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverDbStmtContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRECOVER, 0)
}

func (s *RecoverDbStmtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverDbStmtContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *RecoverDbStmtContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *RecoverDbStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverDbStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverDbStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRecoverDbStmt(s)
	}
}

func (s *RecoverDbStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRecoverDbStmt(s)
	}
}

func (p *StarRocksParser) RecoverDbStmt() (localctx IRecoverDbStmtContext) {
	localctx = NewRecoverDbStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, StarRocksParserRULE_recoverDbStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1386)
		p.Match(StarRocksParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1387)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDATABASE || _la == StarRocksParserSCHEMA) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1388)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataStmtContext is an interface to support dynamic dispatch.
type IShowDataStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATA() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDataStmtContext differentiates from other interfaces.
	IsShowDataStmtContext()
}

type ShowDataStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataStmtContext() *ShowDataStmtContext {
	var p = new(ShowDataStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataStmt
	return p
}

func InitEmptyShowDataStmtContext(p *ShowDataStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataStmt
}

func (*ShowDataStmtContext) IsShowDataStmtContext() {}

func NewShowDataStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataStmtContext {
	var p = new(ShowDataStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDataStmt

	return p
}

func (s *ShowDataStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDataStmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *ShowDataStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDataStmtContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDataStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDataStmt(s)
	}
}

func (s *ShowDataStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDataStmt(s)
	}
}

func (p *StarRocksParser) ShowDataStmt() (localctx IShowDataStmtContext) {
	localctx = NewShowDataStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, StarRocksParserRULE_showDataStmt)
	p.SetState(1396)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 16, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1390)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1391)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1392)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1393)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1394)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1395)
			p.QualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataDistributionStmtContext is an interface to support dynamic dispatch.
type IShowDataDistributionStmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsShowDataDistributionStmtContext differentiates from other interfaces.
	IsShowDataDistributionStmtContext()
}

type ShowDataDistributionStmtContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataDistributionStmtContext() *ShowDataDistributionStmtContext {
	var p = new(ShowDataDistributionStmtContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataDistributionStmt
	return p
}

func InitEmptyShowDataDistributionStmtContext(p *ShowDataDistributionStmtContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataDistributionStmt
}

func (*ShowDataDistributionStmtContext) IsShowDataDistributionStmtContext() {}

func NewShowDataDistributionStmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataDistributionStmtContext {
	var p = new(ShowDataDistributionStmtContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDataDistributionStmt

	return p
}

func (s *ShowDataDistributionStmtContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataDistributionStmtContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDataDistributionStmtContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *ShowDataDistributionStmtContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTION, 0)
}

func (s *ShowDataDistributionStmtContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDataDistributionStmtContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDataDistributionStmtContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ShowDataDistributionStmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataDistributionStmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataDistributionStmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDataDistributionStmt(s)
	}
}

func (s *ShowDataDistributionStmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDataDistributionStmt(s)
	}
}

func (p *StarRocksParser) ShowDataDistributionStmt() (localctx IShowDataDistributionStmtContext) {
	localctx = NewShowDataDistributionStmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, StarRocksParserRULE_showDataDistributionStmt)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1398)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1399)
		p.Match(StarRocksParserDATA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1400)
		p.Match(StarRocksParserDISTRIBUTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1401)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1402)
		p.QualifiedName()
	}
	p.SetState(1404)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1403)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableStatementContext is an interface to support dynamic dispatch.
type ICreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllColumnDesc() []IColumnDescContext
	ColumnDesc(i int) IColumnDescContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext
	EngineDesc() IEngineDescContext
	CharsetDesc() ICharsetDescContext
	KeyDesc() IKeyDescContext
	Comment() ICommentContext
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	RollupDesc() IRollupDescContext
	Properties() IPropertiesContext
	ExtProperties() IExtPropertiesContext
	TEMPORARY() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode

	// IsCreateTableStatementContext differentiates from other interfaces.
	IsCreateTableStatementContext()
}

type CreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableStatementContext() *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableStatement
	return p
}

func InitEmptyCreateTableStatementContext(p *CreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableStatement
}

func (*CreateTableStatementContext) IsCreateTableStatementContext() {}

func NewCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableStatementContext {
	var p = new(CreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createTableStatement

	return p
}

func (s *CreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableStatementContext) AllColumnDesc() []IColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDescContext); ok {
			tst[i] = t.(IColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableStatementContext) ColumnDesc(i int) IColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *CreateTableStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateTableStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateTableStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateTableStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateTableStatementContext) EngineDesc() IEngineDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineDescContext)
}

func (s *CreateTableStatementContext) CharsetDesc() ICharsetDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetDescContext)
}

func (s *CreateTableStatementContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *CreateTableStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateTableStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableStatementContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *CreateTableStatementContext) RollupDesc() IRollupDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupDescContext)
}

func (s *CreateTableStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableStatementContext) ExtProperties() IExtPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExtPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExtPropertiesContext)
}

func (s *CreateTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *CreateTableStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateTableStatement(s)
	}
}

func (s *CreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateTableStatement(s)
	}
}

func (p *StarRocksParser) CreateTableStatement() (localctx ICreateTableStatementContext) {
	localctx = NewCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, StarRocksParserRULE_createTableStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1406)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEXTERNAL || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1407)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserEXTERNAL || _la == StarRocksParserTEMPORARY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1410)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1411)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1412)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1413)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1416)
		p.QualifiedName()
	}
	{
		p.SetState(1417)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1418)
		p.ColumnDesc()
	}
	p.SetState(1423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1419)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1420)
				p.ColumnDesc()
			}

		}
		p.SetState(1425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(1430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(1426)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1427)
			p.IndexDesc()
		}

		p.SetState(1432)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1433)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserENGINE {
		{
			p.SetState(1434)
			p.EngineDesc()
		}

	}
	p.SetState(1438)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&2251799813685255) != 0 {
		{
			p.SetState(1437)
			p.CharsetDesc()
		}

	}
	p.SetState(1441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAGGREGATE || _la == StarRocksParserDUPLICATE || _la == StarRocksParserPRIMARY || _la == StarRocksParserUNIQUE {
		{
			p.SetState(1440)
			p.KeyDesc()
		}

	}
	p.SetState(1444)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1443)
			p.Comment()
		}

	}
	p.SetState(1447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(1446)
			p.PartitionDesc()
		}

	}
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDISTRIBUTED {
		{
			p.SetState(1449)
			p.DistributionDesc()
		}

	}
	p.SetState(1453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(1452)
			p.OrderByDesc()
		}

	}
	p.SetState(1456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserROLLUP {
		{
			p.SetState(1455)
			p.RollupDesc()
		}

	}
	p.SetState(1459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1458)
			p.Properties()
		}

	}
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserBROKER {
		{
			p.SetState(1461)
			p.ExtProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDescContext is an interface to support dynamic dispatch.
type IColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Type_() ITypeContext
	CharsetName() ICharsetNameContext
	KEY() antlr.TerminalNode
	AggDesc() IAggDescContext
	ColumnNullable() IColumnNullableContext
	DefaultDesc() IDefaultDescContext
	AUTO_INCREMENT() antlr.TerminalNode
	GeneratedColumnDesc() IGeneratedColumnDescContext
	Comment() ICommentContext

	// IsColumnDescContext differentiates from other interfaces.
	IsColumnDescContext()
}

type ColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDescContext() *ColumnDescContext {
	var p = new(ColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnDesc
	return p
}

func InitEmptyColumnDescContext(p *ColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnDesc
}

func (*ColumnDescContext) IsColumnDescContext() {}

func NewColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDescContext {
	var p = new(ColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnDesc

	return p
}

func (s *ColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnDescContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ColumnDescContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *ColumnDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *ColumnDescContext) AggDesc() IAggDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggDescContext)
}

func (s *ColumnDescContext) ColumnNullable() IColumnNullableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNullableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNullableContext)
}

func (s *ColumnDescContext) DefaultDesc() IDefaultDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultDescContext)
}

func (s *ColumnDescContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTO_INCREMENT, 0)
}

func (s *ColumnDescContext) GeneratedColumnDesc() IGeneratedColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeneratedColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeneratedColumnDescContext)
}

func (s *ColumnDescContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnDesc(s)
	}
}

func (s *ColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnDesc(s)
	}
}

func (p *StarRocksParser) ColumnDesc() (localctx IColumnDescContext) {
	localctx = NewColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, StarRocksParserRULE_columnDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1464)
		p.Identifier()
	}
	p.SetState(1466)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 32, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1465)
			p.Type_()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1469)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1468)
			p.CharsetName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1472)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserKEY {
		{
			p.SetState(1471)
			p.Match(StarRocksParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1475)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1474)
			p.AggDesc()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1478)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNOT || _la == StarRocksParserNULL {
		{
			p.SetState(1477)
			p.ColumnNullable()
		}

	}
	p.SetState(1483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserDEFAULT:
		{
			p.SetState(1480)
			p.DefaultDesc()
		}

	case StarRocksParserAUTO_INCREMENT:
		{
			p.SetState(1481)
			p.Match(StarRocksParserAUTO_INCREMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAS:
		{
			p.SetState(1482)
			p.GeneratedColumnDesc()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserT__3, StarRocksParserAFTER, StarRocksParserCOMMENT, StarRocksParserFIRST, StarRocksParserFROM, StarRocksParserIN, StarRocksParserPROPERTIES, StarRocksParserTO, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(1486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1485)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	Identifier() IIdentifierContext
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *CharsetNameContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *CharsetNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CharsetNameContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *CharsetNameContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARACTER, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (p *StarRocksParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, StarRocksParserRULE_charsetName)
	p.SetState(1496)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1488)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1489)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1490)
			p.Identifier()
		}

	case StarRocksParserCHARSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1491)
			p.Match(StarRocksParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1492)
			p.Identifier()
		}

	case StarRocksParserCHARACTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1493)
			p.Match(StarRocksParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1494)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1495)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultDescContext is an interface to support dynamic dispatch.
type IDefaultDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	String_() IStringContext
	NULL() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsDefaultDescContext differentiates from other interfaces.
	IsDefaultDescContext()
}

type DefaultDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDescContext() *DefaultDescContext {
	var p = new(DefaultDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_defaultDesc
	return p
}

func InitEmptyDefaultDescContext(p *DefaultDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_defaultDesc
}

func (*DefaultDescContext) IsDefaultDescContext() {}

func NewDefaultDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDescContext {
	var p = new(DefaultDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_defaultDesc

	return p
}

func (s *DefaultDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *DefaultDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DefaultDescContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *DefaultDescContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_TIMESTAMP, 0)
}

func (s *DefaultDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DefaultDescContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DefaultDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDefaultDesc(s)
	}
}

func (s *DefaultDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDefaultDesc(s)
	}
}

func (p *StarRocksParser) DefaultDesc() (localctx IDefaultDescContext) {
	localctx = NewDefaultDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, StarRocksParserRULE_defaultDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1498)
		p.Match(StarRocksParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(1499)
			p.String_()
		}

	case StarRocksParserNULL:
		{
			p.SetState(1500)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCURRENT_TIMESTAMP:
		{
			p.SetState(1501)
			p.Match(StarRocksParserCURRENT_TIMESTAMP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(1502)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1504)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserINTEGER_VALUE {
				{
					p.SetState(1503)
					p.Match(StarRocksParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1506)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserT__1:
		{
			p.SetState(1509)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1510)
			p.QualifiedName()
		}
		{
			p.SetState(1511)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1512)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1513)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeneratedColumnDescContext is an interface to support dynamic dispatch.
type IGeneratedColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	Expression() IExpressionContext

	// IsGeneratedColumnDescContext differentiates from other interfaces.
	IsGeneratedColumnDescContext()
}

type GeneratedColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGeneratedColumnDescContext() *GeneratedColumnDescContext {
	var p = new(GeneratedColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_generatedColumnDesc
	return p
}

func InitEmptyGeneratedColumnDescContext(p *GeneratedColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_generatedColumnDesc
}

func (*GeneratedColumnDescContext) IsGeneratedColumnDescContext() {}

func NewGeneratedColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeneratedColumnDescContext {
	var p = new(GeneratedColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_generatedColumnDesc

	return p
}

func (s *GeneratedColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *GeneratedColumnDescContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *GeneratedColumnDescContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GeneratedColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeneratedColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeneratedColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGeneratedColumnDesc(s)
	}
}

func (s *GeneratedColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGeneratedColumnDesc(s)
	}
}

func (p *StarRocksParser) GeneratedColumnDesc() (localctx IGeneratedColumnDescContext) {
	localctx = NewGeneratedColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, StarRocksParserRULE_generatedColumnDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1518)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexDescContext is an interface to support dynamic dispatch.
type IIndexDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	INDEX() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsIndexDescContext differentiates from other interfaces.
	IsIndexDescContext()
}

type IndexDescContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyIndexDescContext() *IndexDescContext {
	var p = new(IndexDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_indexDesc
	return p
}

func InitEmptyIndexDescContext(p *IndexDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_indexDesc
}

func (*IndexDescContext) IsIndexDescContext() {}

func NewIndexDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexDescContext {
	var p = new(IndexDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_indexDesc

	return p
}

func (s *IndexDescContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexDescContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *IndexDescContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *IndexDescContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *IndexDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IndexDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexDescContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexDescContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *IndexDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *IndexDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIndexDesc(s)
	}
}

func (s *IndexDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIndexDesc(s)
	}
}

func (p *StarRocksParser) IndexDesc() (localctx IIndexDescContext) {
	localctx = NewIndexDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, StarRocksParserRULE_indexDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1520)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1521)

		var _x = p.Identifier()

		localctx.(*IndexDescContext).indexName = _x
	}
	{
		p.SetState(1522)
		p.IdentifierList()
	}
	p.SetState(1527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(1523)
			p.IndexType()
		}
		p.SetState(1525)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(1524)
				p.PropertyList()
			}

		}

	}
	p.SetState(1530)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1529)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineDescContext is an interface to support dynamic dispatch.
type IEngineDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENGINE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsEngineDescContext differentiates from other interfaces.
	IsEngineDescContext()
}

type EngineDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineDescContext() *EngineDescContext {
	var p = new(EngineDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_engineDesc
	return p
}

func InitEmptyEngineDescContext(p *EngineDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_engineDesc
}

func (*EngineDescContext) IsEngineDescContext() {}

func NewEngineDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineDescContext {
	var p = new(EngineDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_engineDesc

	return p
}

func (s *EngineDescContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineDescContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENGINE, 0)
}

func (s *EngineDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *EngineDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EngineDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterEngineDesc(s)
	}
}

func (s *EngineDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitEngineDesc(s)
	}
}

func (p *StarRocksParser) EngineDesc() (localctx IEngineDescContext) {
	localctx = NewEngineDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, StarRocksParserRULE_engineDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1532)
		p.Match(StarRocksParserENGINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1533)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1534)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetDescContext is an interface to support dynamic dispatch.
type ICharsetDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrString() IIdentifierOrStringContext
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCharsetDescContext differentiates from other interfaces.
	IsCharsetDescContext()
}

type CharsetDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetDescContext() *CharsetDescContext {
	var p = new(CharsetDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_charsetDesc
	return p
}

func InitEmptyCharsetDescContext(p *CharsetDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_charsetDesc
}

func (*CharsetDescContext) IsCharsetDescContext() {}

func NewCharsetDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetDescContext {
	var p = new(CharsetDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_charsetDesc

	return p
}

func (s *CharsetDescContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CharsetDescContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *CharsetDescContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *CharsetDescContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *CharsetDescContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARACTER, 0)
}

func (s *CharsetDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *CharsetDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *CharsetDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCharsetDesc(s)
	}
}

func (s *CharsetDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCharsetDesc(s)
	}
}

func (p *StarRocksParser) CharsetDesc() (localctx ICharsetDescContext) {
	localctx = NewCharsetDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, StarRocksParserRULE_charsetDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDEFAULT {
		{
			p.SetState(1536)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCHAR:
		{
			p.SetState(1539)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1540)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCHARSET:
		{
			p.SetState(1541)
			p.Match(StarRocksParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCHARACTER:
		{
			p.SetState(1542)
			p.Match(StarRocksParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1543)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1547)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEQ {
		{
			p.SetState(1546)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1549)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollateDescContext is an interface to support dynamic dispatch.
type ICollateDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	DEFAULT() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsCollateDescContext differentiates from other interfaces.
	IsCollateDescContext()
}

type CollateDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollateDescContext() *CollateDescContext {
	var p = new(CollateDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_collateDesc
	return p
}

func InitEmptyCollateDescContext(p *CollateDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_collateDesc
}

func (*CollateDescContext) IsCollateDescContext() {}

func NewCollateDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollateDescContext {
	var p = new(CollateDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_collateDesc

	return p
}

func (s *CollateDescContext) GetParser() antlr.Parser { return s.parser }

func (s *CollateDescContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATE, 0)
}

func (s *CollateDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CollateDescContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *CollateDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *CollateDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollateDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCollateDesc(s)
	}
}

func (s *CollateDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCollateDesc(s)
	}
}

func (p *StarRocksParser) CollateDesc() (localctx ICollateDescContext) {
	localctx = NewCollateDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, StarRocksParserRULE_collateDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDEFAULT {
		{
			p.SetState(1551)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1554)
		p.Match(StarRocksParserCOLLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEQ {
		{
			p.SetState(1555)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1558)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyDescContext is an interface to support dynamic dispatch.
type IKeyDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	AGGREGATE() antlr.TerminalNode
	UNIQUE() antlr.TerminalNode
	PRIMARY() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode

	// IsKeyDescContext differentiates from other interfaces.
	IsKeyDescContext()
}

type KeyDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyDescContext() *KeyDescContext {
	var p = new(KeyDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyDesc
	return p
}

func InitEmptyKeyDescContext(p *KeyDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyDesc
}

func (*KeyDescContext) IsKeyDescContext() {}

func NewKeyDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyDescContext {
	var p = new(KeyDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_keyDesc

	return p
}

func (s *KeyDescContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *KeyDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *KeyDescContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAGGREGATE, 0)
}

func (s *KeyDescContext) UNIQUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNIQUE, 0)
}

func (s *KeyDescContext) PRIMARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIMARY, 0)
}

func (s *KeyDescContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDUPLICATE, 0)
}

func (s *KeyDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKeyDesc(s)
	}
}

func (s *KeyDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKeyDesc(s)
	}
}

func (p *StarRocksParser) KeyDesc() (localctx IKeyDescContext) {
	localctx = NewKeyDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, StarRocksParserRULE_keyDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1560)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserAGGREGATE || _la == StarRocksParserDUPLICATE || _la == StarRocksParserPRIMARY || _la == StarRocksParserUNIQUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1561)
		p.Match(StarRocksParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1562)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderByDescContext is an interface to support dynamic dispatch.
type IOrderByDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsOrderByDescContext differentiates from other interfaces.
	IsOrderByDescContext()
}

type OrderByDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderByDescContext() *OrderByDescContext {
	var p = new(OrderByDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_orderByDesc
	return p
}

func InitEmptyOrderByDescContext(p *OrderByDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_orderByDesc
}

func (*OrderByDescContext) IsOrderByDescContext() {}

func NewOrderByDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderByDescContext {
	var p = new(OrderByDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_orderByDesc

	return p
}

func (s *OrderByDescContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderByDescContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *OrderByDescContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *OrderByDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *OrderByDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderByDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderByDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOrderByDesc(s)
	}
}

func (s *OrderByDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOrderByDesc(s)
	}
}

func (p *StarRocksParser) OrderByDesc() (localctx IOrderByDescContext) {
	localctx = NewOrderByDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, StarRocksParserRULE_orderByDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1564)
		p.Match(StarRocksParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1565)
		p.Match(StarRocksParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1566)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNullableContext is an interface to support dynamic dispatch.
type IColumnNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	NOT() antlr.TerminalNode

	// IsColumnNullableContext differentiates from other interfaces.
	IsColumnNullableContext()
}

type ColumnNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNullableContext() *ColumnNullableContext {
	var p = new(ColumnNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnNullable
	return p
}

func InitEmptyColumnNullableContext(p *ColumnNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnNullable
}

func (*ColumnNullableContext) IsColumnNullableContext() {}

func NewColumnNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNullableContext {
	var p = new(ColumnNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnNullable

	return p
}

func (s *ColumnNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNullableContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *ColumnNullableContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *ColumnNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnNullable(s)
	}
}

func (s *ColumnNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnNullable(s)
	}
}

func (p *StarRocksParser) ColumnNullable() (localctx IColumnNullableContext) {
	localctx = NewColumnNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, StarRocksParserRULE_columnNullable)
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1568)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserNOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1569)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1570)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeWithNullableContext is an interface to support dynamic dispatch.
type ITypeWithNullableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	ColumnNullable() IColumnNullableContext

	// IsTypeWithNullableContext differentiates from other interfaces.
	IsTypeWithNullableContext()
}

type TypeWithNullableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeWithNullableContext() *TypeWithNullableContext {
	var p = new(TypeWithNullableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeWithNullable
	return p
}

func InitEmptyTypeWithNullableContext(p *TypeWithNullableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeWithNullable
}

func (*TypeWithNullableContext) IsTypeWithNullableContext() {}

func NewTypeWithNullableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeWithNullableContext {
	var p = new(TypeWithNullableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_typeWithNullable

	return p
}

func (s *TypeWithNullableContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeWithNullableContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeWithNullableContext) ColumnNullable() IColumnNullableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNullableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNullableContext)
}

func (s *TypeWithNullableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeWithNullableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeWithNullableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTypeWithNullable(s)
	}
}

func (s *TypeWithNullableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTypeWithNullable(s)
	}
}

func (p *StarRocksParser) TypeWithNullable() (localctx ITypeWithNullableContext) {
	localctx = NewTypeWithNullableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, StarRocksParserRULE_typeWithNullable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1573)
		p.Type_()
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNOT || _la == StarRocksParserNULL {
		{
			p.SetState(1574)
			p.ColumnNullable()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggStateDescContext is an interface to support dynamic dispatch.
type IAggStateDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllTypeWithNullable() []ITypeWithNullableContext
	TypeWithNullable(i int) ITypeWithNullableContext

	// IsAggStateDescContext differentiates from other interfaces.
	IsAggStateDescContext()
}

type AggStateDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggStateDescContext() *AggStateDescContext {
	var p = new(AggStateDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggStateDesc
	return p
}

func InitEmptyAggStateDescContext(p *AggStateDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggStateDesc
}

func (*AggStateDescContext) IsAggStateDescContext() {}

func NewAggStateDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggStateDescContext {
	var p = new(AggStateDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_aggStateDesc

	return p
}

func (s *AggStateDescContext) GetParser() antlr.Parser { return s.parser }

func (s *AggStateDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AggStateDescContext) AllTypeWithNullable() []ITypeWithNullableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeWithNullableContext); ok {
			len++
		}
	}

	tst := make([]ITypeWithNullableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeWithNullableContext); ok {
			tst[i] = t.(ITypeWithNullableContext)
			i++
		}
	}

	return tst
}

func (s *AggStateDescContext) TypeWithNullable(i int) ITypeWithNullableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeWithNullableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeWithNullableContext)
}

func (s *AggStateDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggStateDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggStateDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAggStateDesc(s)
	}
}

func (s *AggStateDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAggStateDesc(s)
	}
}

func (p *StarRocksParser) AggStateDesc() (localctx IAggStateDescContext) {
	localctx = NewAggStateDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, StarRocksParserRULE_aggStateDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1577)
		p.Identifier()
	}
	{
		p.SetState(1578)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1579)
		p.TypeWithNullable()
	}
	p.SetState(1584)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(1580)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1581)
			p.TypeWithNullable()
		}

		p.SetState(1586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1587)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggDescContext is an interface to support dynamic dispatch.
type IAggDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUM() antlr.TerminalNode
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	PERCENTILE_UNION() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	AggStateDesc() IAggStateDescContext

	// IsAggDescContext differentiates from other interfaces.
	IsAggDescContext()
}

type AggDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggDescContext() *AggDescContext {
	var p = new(AggDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggDesc
	return p
}

func InitEmptyAggDescContext(p *AggDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggDesc
}

func (*AggDescContext) IsAggDescContext() {}

func NewAggDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggDescContext {
	var p = new(AggDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_aggDesc

	return p
}

func (s *AggDescContext) GetParser() antlr.Parser { return s.parser }

func (s *AggDescContext) SUM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUM, 0)
}

func (s *AggDescContext) MAX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAX, 0)
}

func (s *AggDescContext) MIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMIN, 0)
}

func (s *AggDescContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *AggDescContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHLL_UNION, 0)
}

func (s *AggDescContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITMAP_UNION, 0)
}

func (s *AggDescContext) PERCENTILE_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENTILE_UNION, 0)
}

func (s *AggDescContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE_IF_NOT_NULL, 0)
}

func (s *AggDescContext) AggStateDesc() IAggStateDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggStateDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggStateDescContext)
}

func (s *AggDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAggDesc(s)
	}
}

func (s *AggDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAggDesc(s)
	}
}

func (p *StarRocksParser) AggDesc() (localctx IAggDescContext) {
	localctx = NewAggDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, StarRocksParserRULE_aggDesc)
	p.SetState(1598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1589)
			p.Match(StarRocksParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1590)
			p.Match(StarRocksParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1591)
			p.Match(StarRocksParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1592)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1593)
			p.Match(StarRocksParserHLL_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1594)
			p.Match(StarRocksParserBITMAP_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1595)
			p.Match(StarRocksParserPERCENTILE_UNION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1596)
			p.Match(StarRocksParserREPLACE_IF_NOT_NULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1597)
			p.AggStateDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupDescContext is an interface to support dynamic dispatch.
type IRollupDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLUP() antlr.TerminalNode
	AllRollupItem() []IRollupItemContext
	RollupItem(i int) IRollupItemContext

	// IsRollupDescContext differentiates from other interfaces.
	IsRollupDescContext()
}

type RollupDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollupDescContext() *RollupDescContext {
	var p = new(RollupDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupDesc
	return p
}

func InitEmptyRollupDescContext(p *RollupDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupDesc
}

func (*RollupDescContext) IsRollupDescContext() {}

func NewRollupDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupDescContext {
	var p = new(RollupDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rollupDesc

	return p
}

func (s *RollupDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupDescContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *RollupDescContext) AllRollupItem() []IRollupItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupItemContext); ok {
			len++
		}
	}

	tst := make([]IRollupItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupItemContext); ok {
			tst[i] = t.(IRollupItemContext)
			i++
		}
	}

	return tst
}

func (s *RollupDescContext) RollupItem(i int) IRollupItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupItemContext)
}

func (s *RollupDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollupDesc(s)
	}
}

func (s *RollupDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollupDesc(s)
	}
}

func (p *StarRocksParser) RollupDesc() (localctx IRollupDescContext) {
	localctx = NewRollupDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, StarRocksParserRULE_rollupDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1600)
		p.Match(StarRocksParserROLLUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1601)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1602)
		p.RollupItem()
	}
	p.SetState(1607)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(1603)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1604)
			p.RollupItem()
		}

		p.SetState(1609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1610)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupItemContext is an interface to support dynamic dispatch.
type IRollupItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	DupKeys() IDupKeysContext
	FromRollup() IFromRollupContext
	Properties() IPropertiesContext

	// IsRollupItemContext differentiates from other interfaces.
	IsRollupItemContext()
}

type RollupItemContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyRollupItemContext() *RollupItemContext {
	var p = new(RollupItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupItem
	return p
}

func InitEmptyRollupItemContext(p *RollupItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupItem
}

func (*RollupItemContext) IsRollupItemContext() {}

func NewRollupItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupItemContext {
	var p = new(RollupItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rollupItem

	return p
}

func (s *RollupItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupItemContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupItemContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupItemContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *RollupItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupItemContext) DupKeys() IDupKeysContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDupKeysContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDupKeysContext)
}

func (s *RollupItemContext) FromRollup() IFromRollupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromRollupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromRollupContext)
}

func (s *RollupItemContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *RollupItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollupItem(s)
	}
}

func (s *RollupItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollupItem(s)
	}
}

func (p *StarRocksParser) RollupItem() (localctx IRollupItemContext) {
	localctx = NewRollupItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, StarRocksParserRULE_rollupItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1612)

		var _x = p.Identifier()

		localctx.(*RollupItemContext).rollupName = _x
	}
	{
		p.SetState(1613)
		p.IdentifierList()
	}
	p.SetState(1615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDUPLICATE {
		{
			p.SetState(1614)
			p.DupKeys()
		}

	}
	p.SetState(1618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(1617)
			p.FromRollup()
		}

	}
	p.SetState(1621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1620)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDupKeysContext is an interface to support dynamic dispatch.
type IDupKeysContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DUPLICATE() antlr.TerminalNode
	KEY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext

	// IsDupKeysContext differentiates from other interfaces.
	IsDupKeysContext()
}

type DupKeysContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDupKeysContext() *DupKeysContext {
	var p = new(DupKeysContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dupKeys
	return p
}

func InitEmptyDupKeysContext(p *DupKeysContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dupKeys
}

func (*DupKeysContext) IsDupKeysContext() {}

func NewDupKeysContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DupKeysContext {
	var p = new(DupKeysContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dupKeys

	return p
}

func (s *DupKeysContext) GetParser() antlr.Parser { return s.parser }

func (s *DupKeysContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDUPLICATE, 0)
}

func (s *DupKeysContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *DupKeysContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DupKeysContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DupKeysContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DupKeysContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDupKeys(s)
	}
}

func (s *DupKeysContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDupKeys(s)
	}
}

func (p *StarRocksParser) DupKeys() (localctx IDupKeysContext) {
	localctx = NewDupKeysContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, StarRocksParserRULE_dupKeys)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1623)
		p.Match(StarRocksParserDUPLICATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1624)
		p.Match(StarRocksParserKEY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1625)
		p.IdentifierList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromRollupContext is an interface to support dynamic dispatch.
type IFromRollupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFromRollupContext differentiates from other interfaces.
	IsFromRollupContext()
}

type FromRollupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromRollupContext() *FromRollupContext {
	var p = new(FromRollupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fromRollup
	return p
}

func InitEmptyFromRollupContext(p *FromRollupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fromRollup
}

func (*FromRollupContext) IsFromRollupContext() {}

func NewFromRollupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromRollupContext {
	var p = new(FromRollupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_fromRollup

	return p
}

func (s *FromRollupContext) GetParser() antlr.Parser { return s.parser }

func (s *FromRollupContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *FromRollupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FromRollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromRollupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromRollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFromRollup(s)
	}
}

func (s *FromRollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFromRollup(s)
	}
}

func (p *StarRocksParser) FromRollup() (localctx IFromRollupContext) {
	localctx = NewFromRollupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, StarRocksParserRULE_fromRollup)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1627)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1628)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrReplaceContext is an interface to support dynamic dispatch.
type IOrReplaceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode

	// IsOrReplaceContext differentiates from other interfaces.
	IsOrReplaceContext()
}

type OrReplaceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrReplaceContext() *OrReplaceContext {
	var p = new(OrReplaceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_orReplace
	return p
}

func InitEmptyOrReplaceContext(p *OrReplaceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_orReplace
}

func (*OrReplaceContext) IsOrReplaceContext() {}

func NewOrReplaceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrReplaceContext {
	var p = new(OrReplaceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_orReplace

	return p
}

func (s *OrReplaceContext) GetParser() antlr.Parser { return s.parser }

func (s *OrReplaceContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *OrReplaceContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *OrReplaceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrReplaceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrReplaceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOrReplace(s)
	}
}

func (s *OrReplaceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOrReplace(s)
	}
}

func (p *StarRocksParser) OrReplace() (localctx IOrReplaceContext) {
	localctx = NewOrReplaceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, StarRocksParserRULE_orReplace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserOR {
		{
			p.SetState(1630)
			p.Match(StarRocksParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1631)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *IfNotExistsContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *IfNotExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (p *StarRocksParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, StarRocksParserRULE_ifNotExists)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1634)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1635)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1636)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableAsSelectStatementContext is an interface to support dynamic dispatch.
type ICreateTableAsSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	TEMPORARY() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	KeyDesc() IKeyDescContext
	Comment() ICommentContext
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	Properties() IPropertiesContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext

	// IsCreateTableAsSelectStatementContext differentiates from other interfaces.
	IsCreateTableAsSelectStatementContext()
}

type CreateTableAsSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableAsSelectStatementContext() *CreateTableAsSelectStatementContext {
	var p = new(CreateTableAsSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableAsSelectStatement
	return p
}

func InitEmptyCreateTableAsSelectStatementContext(p *CreateTableAsSelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableAsSelectStatement
}

func (*CreateTableAsSelectStatementContext) IsCreateTableAsSelectStatementContext() {}

func NewCreateTableAsSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableAsSelectStatementContext {
	var p = new(CreateTableAsSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createTableAsSelectStatement

	return p
}

func (s *CreateTableAsSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableAsSelectStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateTableAsSelectStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateTableAsSelectStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableAsSelectStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CreateTableAsSelectStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateTableAsSelectStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *CreateTableAsSelectStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateTableAsSelectStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateTableAsSelectStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateTableAsSelectStatementContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *CreateTableAsSelectStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateTableAsSelectStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableAsSelectStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableAsSelectStatementContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *CreateTableAsSelectStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableAsSelectStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableAsSelectStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableAsSelectStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableAsSelectStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateTableAsSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableAsSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableAsSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateTableAsSelectStatement(s)
	}
}

func (s *CreateTableAsSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateTableAsSelectStatement(s)
	}
}

func (p *StarRocksParser) CreateTableAsSelectStatement() (localctx ICreateTableAsSelectStatementContext) {
	localctx = NewCreateTableAsSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, StarRocksParserRULE_createTableAsSelectStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1639)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1640)
			p.Match(StarRocksParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1643)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1644)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1645)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1646)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1649)
		p.QualifiedName()
	}
	p.SetState(1678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(1650)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1674)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(1651)
				p.Identifier()
			}
			p.SetState(1656)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
			for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				if _alt == 1 {
					{
						p.SetState(1652)
						p.Match(StarRocksParserT__2)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(1653)
						p.Identifier()
					}

				}
				p.SetState(1658)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext())
				if p.HasError() {
					goto errorExit
				}
			}
			p.SetState(1663)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1659)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1660)
					p.IndexDesc()
				}

				p.SetState(1665)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		case StarRocksParserINDEX:
			{
				p.SetState(1666)
				p.IndexDesc()
			}
			p.SetState(1671)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1667)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1668)
					p.IndexDesc()
				}

				p.SetState(1673)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(1676)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAGGREGATE || _la == StarRocksParserDUPLICATE || _la == StarRocksParserPRIMARY || _la == StarRocksParserUNIQUE {
		{
			p.SetState(1680)
			p.KeyDesc()
		}

	}
	p.SetState(1684)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1683)
			p.Comment()
		}

	}
	p.SetState(1687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(1686)
			p.PartitionDesc()
		}

	}
	p.SetState(1690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDISTRIBUTED {
		{
			p.SetState(1689)
			p.DistributionDesc()
		}

	}
	p.SetState(1693)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(1692)
			p.OrderByDesc()
		}

	}
	p.SetState(1696)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1695)
			p.Properties()
		}

	}
	{
		p.SetState(1698)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1699)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTableStatementContext is an interface to support dynamic dispatch.
type IDropTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TEMPORARY() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsDropTableStatementContext differentiates from other interfaces.
	IsDropTableStatementContext()
}

type DropTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTableStatementContext() *DropTableStatementContext {
	var p = new(DropTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTableStatement
	return p
}

func InitEmptyDropTableStatementContext(p *DropTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTableStatement
}

func (*DropTableStatementContext) IsDropTableStatementContext() {}

func NewDropTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTableStatementContext {
	var p = new(DropTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropTableStatement

	return p
}

func (s *DropTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTableStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *DropTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *DropTableStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropTableStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropTableStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropTableStatement(s)
	}
}

func (s *DropTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropTableStatement(s)
	}
}

func (p *StarRocksParser) DropTableStatement() (localctx IDropTableStatementContext) {
	localctx = NewDropTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, StarRocksParserRULE_dropTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1701)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1703)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1702)
			p.Match(StarRocksParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1705)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1706)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1707)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1710)
		p.QualifiedName()
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(1711)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICleanTemporaryTableStatementContext is an interface to support dynamic dispatch.
type ICleanTemporaryTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAN() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	ON() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	String_() IStringContext

	// IsCleanTemporaryTableStatementContext differentiates from other interfaces.
	IsCleanTemporaryTableStatementContext()
}

type CleanTemporaryTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCleanTemporaryTableStatementContext() *CleanTemporaryTableStatementContext {
	var p = new(CleanTemporaryTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cleanTemporaryTableStatement
	return p
}

func InitEmptyCleanTemporaryTableStatementContext(p *CleanTemporaryTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cleanTemporaryTableStatement
}

func (*CleanTemporaryTableStatementContext) IsCleanTemporaryTableStatementContext() {}

func NewCleanTemporaryTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CleanTemporaryTableStatementContext {
	var p = new(CleanTemporaryTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cleanTemporaryTableStatement

	return p
}

func (s *CleanTemporaryTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CleanTemporaryTableStatementContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAN, 0)
}

func (s *CleanTemporaryTableStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *CleanTemporaryTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CleanTemporaryTableStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CleanTemporaryTableStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSESSION, 0)
}

func (s *CleanTemporaryTableStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CleanTemporaryTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanTemporaryTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CleanTemporaryTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCleanTemporaryTableStatement(s)
	}
}

func (s *CleanTemporaryTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCleanTemporaryTableStatement(s)
	}
}

func (p *StarRocksParser) CleanTemporaryTableStatement() (localctx ICleanTemporaryTableStatementContext) {
	localctx = NewCleanTemporaryTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, StarRocksParserRULE_cleanTemporaryTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1714)
		p.Match(StarRocksParserCLEAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1715)
		p.Match(StarRocksParserTEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1716)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1717)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1718)
		p.Match(StarRocksParserSESSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1719)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableStatementContext is an interface to support dynamic dispatch.
type IAlterTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllAlterClause() []IAlterClauseContext
	AlterClause(i int) IAlterClauseContext
	ADD() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	AllRollupItem() []IRollupItemContext
	RollupItem(i int) IRollupItemContext
	DROP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsAlterTableStatementContext differentiates from other interfaces.
	IsAlterTableStatementContext()
}

type AlterTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableStatementContext() *AlterTableStatementContext {
	var p = new(AlterTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterTableStatement
	return p
}

func InitEmptyAlterTableStatementContext(p *AlterTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterTableStatement
}

func (*AlterTableStatementContext) IsAlterTableStatementContext() {}

func NewAlterTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableStatementContext {
	var p = new(AlterTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterTableStatement

	return p
}

func (s *AlterTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AlterTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterTableStatementContext) AllAlterClause() []IAlterClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterClauseContext); ok {
			tst[i] = t.(IAlterClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) AlterClause(i int) IAlterClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterClauseContext)
}

func (s *AlterTableStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AlterTableStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *AlterTableStatementContext) AllRollupItem() []IRollupItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRollupItemContext); ok {
			len++
		}
	}

	tst := make([]IRollupItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRollupItemContext); ok {
			tst[i] = t.(IRollupItemContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) RollupItem(i int) IRollupItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupItemContext)
}

func (s *AlterTableStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *AlterTableStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterTableStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterTableStatement(s)
	}
}

func (s *AlterTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterTableStatement(s)
	}
}

func (p *StarRocksParser) AlterTableStatement() (localctx IAlterTableStatementContext) {
	localctx = NewAlterTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, StarRocksParserRULE_alterTableStatement)
	var _la int

	p.SetState(1758)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 80, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1721)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1722)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1723)
			p.QualifiedName()
		}
		{
			p.SetState(1724)
			p.AlterClause()
		}
		p.SetState(1729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(1725)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1726)
				p.AlterClause()
			}

			p.SetState(1731)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1732)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1733)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1734)
			p.QualifiedName()
		}
		{
			p.SetState(1735)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1736)
			p.Match(StarRocksParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1737)
			p.RollupItem()
		}
		p.SetState(1742)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(1738)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1739)
				p.RollupItem()
			}

			p.SetState(1744)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1745)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1746)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1747)
			p.QualifiedName()
		}
		{
			p.SetState(1748)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1749)
			p.Match(StarRocksParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1750)
			p.Identifier()
		}
		p.SetState(1755)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(1751)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1752)
				p.Identifier()
			}

			p.SetState(1757)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexStatementContext is an interface to support dynamic dispatch.
type ICreateIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsCreateIndexStatementContext differentiates from other interfaces.
	IsCreateIndexStatementContext()
}

type CreateIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyCreateIndexStatementContext() *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createIndexStatement
	return p
}

func InitEmptyCreateIndexStatementContext(p *CreateIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createIndexStatement
}

func (*CreateIndexStatementContext) IsCreateIndexStatementContext() {}

func NewCreateIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexStatementContext {
	var p = new(CreateIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createIndexStatement

	return p
}

func (s *CreateIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexStatementContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *CreateIndexStatementContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *CreateIndexStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *CreateIndexStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CreateIndexStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateIndexStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexStatementContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateIndexStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateIndexStatement(s)
	}
}

func (s *CreateIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateIndexStatement(s)
	}
}

func (p *StarRocksParser) CreateIndexStatement() (localctx ICreateIndexStatementContext) {
	localctx = NewCreateIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, StarRocksParserRULE_createIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1760)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1761)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1762)

		var _x = p.Identifier()

		localctx.(*CreateIndexStatementContext).indexName = _x
	}
	{
		p.SetState(1763)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1764)
		p.QualifiedName()
	}
	{
		p.SetState(1765)
		p.IdentifierList()
	}
	p.SetState(1770)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(1766)
			p.IndexType()
		}
		p.SetState(1768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(1767)
				p.PropertyList()
			}

		}

	}
	p.SetState(1773)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(1772)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexStatementContext is an interface to support dynamic dispatch.
type IDropIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	Identifier() IIdentifierContext

	// IsDropIndexStatementContext differentiates from other interfaces.
	IsDropIndexStatementContext()
}

type DropIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyDropIndexStatementContext() *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropIndexStatement
	return p
}

func InitEmptyDropIndexStatementContext(p *DropIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropIndexStatement
}

func (*DropIndexStatementContext) IsDropIndexStatementContext() {}

func NewDropIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexStatementContext {
	var p = new(DropIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropIndexStatement

	return p
}

func (s *DropIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexStatementContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropIndexStatementContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropIndexStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *DropIndexStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DropIndexStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropIndexStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropIndexStatement(s)
	}
}

func (s *DropIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropIndexStatement(s)
	}
}

func (p *StarRocksParser) DropIndexStatement() (localctx IDropIndexStatementContext) {
	localctx = NewDropIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, StarRocksParserRULE_dropIndexStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1775)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1776)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1777)

		var _x = p.Identifier()

		localctx.(*DropIndexStatementContext).indexName = _x
	}
	{
		p.SetState(1778)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1779)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USING() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	GIN() antlr.TerminalNode
	NGRAMBF() antlr.TerminalNode
	VECTOR() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *IndexTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITMAP, 0)
}

func (s *IndexTypeContext) GIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGIN, 0)
}

func (s *IndexTypeContext) NGRAMBF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNGRAMBF, 0)
}

func (s *IndexTypeContext) VECTOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVECTOR, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (p *StarRocksParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, StarRocksParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1781)
		p.Match(StarRocksParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1782)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserBITMAP || _la == StarRocksParserGIN || _la == StarRocksParserNGRAMBF || _la == StarRocksParserVECTOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTableStatementContext is an interface to support dynamic dispatch.
type IShowTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTableStatementContext differentiates from other interfaces.
	IsShowTableStatementContext()
}

type ShowTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTableStatementContext() *ShowTableStatementContext {
	var p = new(ShowTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTableStatement
	return p
}

func InitEmptyShowTableStatementContext(p *ShowTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTableStatement
}

func (*ShowTableStatementContext) IsShowTableStatementContext() {}

func NewShowTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTableStatementContext {
	var p = new(ShowTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTableStatement

	return p
}

func (s *ShowTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTableStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTableStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTableStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTableStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTableStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *ShowTableStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowTableStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTableStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTableStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowTableStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTableStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTableStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTableStatement(s)
	}
}

func (s *ShowTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTableStatement(s)
	}
}

func (p *StarRocksParser) ShowTableStatement() (localctx IShowTableStatementContext) {
	localctx = NewShowTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, StarRocksParserRULE_showTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1784)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1786)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(1785)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1788)
		p.Match(StarRocksParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1789)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1790)

			var _x = p.QualifiedName()

			localctx.(*ShowTableStatementContext).db = _x
		}

	}
	p.SetState(1797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(1793)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1794)

			var _x = p.String_()

			localctx.(*ShowTableStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(1795)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1796)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTemporaryTablesStatementContext is an interface to support dynamic dispatch.
type IShowTemporaryTablesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTemporaryTablesStatementContext differentiates from other interfaces.
	IsShowTemporaryTablesStatementContext()
}

type ShowTemporaryTablesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTemporaryTablesStatementContext() *ShowTemporaryTablesStatementContext {
	var p = new(ShowTemporaryTablesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTemporaryTablesStatement
	return p
}

func InitEmptyShowTemporaryTablesStatementContext(p *ShowTemporaryTablesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTemporaryTablesStatement
}

func (*ShowTemporaryTablesStatementContext) IsShowTemporaryTablesStatementContext() {}

func NewShowTemporaryTablesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTemporaryTablesStatementContext {
	var p = new(ShowTemporaryTablesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTemporaryTablesStatement

	return p
}

func (s *ShowTemporaryTablesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTemporaryTablesStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTemporaryTablesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTemporaryTablesStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTemporaryTablesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTemporaryTablesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTemporaryTablesStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *ShowTemporaryTablesStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *ShowTemporaryTablesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTemporaryTablesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTemporaryTablesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTemporaryTablesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowTemporaryTablesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTemporaryTablesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTemporaryTablesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTemporaryTablesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTemporaryTablesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTemporaryTablesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTemporaryTablesStatement(s)
	}
}

func (s *ShowTemporaryTablesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTemporaryTablesStatement(s)
	}
}

func (p *StarRocksParser) ShowTemporaryTablesStatement() (localctx IShowTemporaryTablesStatementContext) {
	localctx = NewShowTemporaryTablesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, StarRocksParserRULE_showTemporaryTablesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1799)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1800)
		p.Match(StarRocksParserTEMPORARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1801)
		p.Match(StarRocksParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1802)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1803)

			var _x = p.QualifiedName()

			localctx.(*ShowTemporaryTablesStatementContext).db = _x
		}

	}
	p.SetState(1810)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(1806)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1807)

			var _x = p.String_()

			localctx.(*ShowTemporaryTablesStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(1808)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1809)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateTableStatementContext is an interface to support dynamic dispatch.
type IShowCreateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TABLE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode

	// IsShowCreateTableStatementContext differentiates from other interfaces.
	IsShowCreateTableStatementContext()
}

type ShowCreateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyShowCreateTableStatementContext() *ShowCreateTableStatementContext {
	var p = new(ShowCreateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateTableStatement
	return p
}

func InitEmptyShowCreateTableStatementContext(p *ShowCreateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateTableStatement
}

func (*ShowCreateTableStatementContext) IsShowCreateTableStatementContext() {}

func NewShowCreateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateTableStatementContext {
	var p = new(ShowCreateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateTableStatement

	return p
}

func (s *ShowCreateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateTableStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowCreateTableStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowCreateTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateTableStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *ShowCreateTableStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *ShowCreateTableStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *ShowCreateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateTableStatement(s)
	}
}

func (s *ShowCreateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateTableStatement(s)
	}
}

func (p *StarRocksParser) ShowCreateTableStatement() (localctx IShowCreateTableStatementContext) {
	localctx = NewShowCreateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, StarRocksParserRULE_showCreateTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1812)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1813)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserTABLE:
		{
			p.SetState(1814)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserVIEW:
		{
			p.SetState(1815)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMATERIALIZED:
		{
			p.SetState(1816)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1817)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1820)

		var _x = p.QualifiedName()

		localctx.(*ShowCreateTableStatementContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowColumnStatementContext is an interface to support dynamic dispatch.
type IShowColumnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllIN() []antlr.TerminalNode
	IN(i int) antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowColumnStatementContext differentiates from other interfaces.
	IsShowColumnStatementContext()
}

type ShowColumnStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	table   IQualifiedNameContext
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowColumnStatementContext() *ShowColumnStatementContext {
	var p = new(ShowColumnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showColumnStatement
	return p
}

func InitEmptyShowColumnStatementContext(p *ShowColumnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showColumnStatement
}

func (*ShowColumnStatementContext) IsShowColumnStatementContext() {}

func NewShowColumnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowColumnStatementContext {
	var p = new(ShowColumnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showColumnStatement

	return p
}

func (s *ShowColumnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowColumnStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowColumnStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowColumnStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowColumnStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowColumnStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowColumnStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowColumnStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowColumnStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *ShowColumnStatementContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELDS, 0)
}

func (s *ShowColumnStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowColumnStatementContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserFROM)
}

func (s *ShowColumnStatementContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, i)
}

func (s *ShowColumnStatementContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserIN)
}

func (s *ShowColumnStatementContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, i)
}

func (s *ShowColumnStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowColumnStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowColumnStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowColumnStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowColumnStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowColumnStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowColumnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowColumnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowColumnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowColumnStatement(s)
	}
}

func (s *ShowColumnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowColumnStatement(s)
	}
}

func (p *StarRocksParser) ShowColumnStatement() (localctx IShowColumnStatementContext) {
	localctx = NewShowColumnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, StarRocksParserRULE_showColumnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1822)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1824)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(1823)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1826)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserCOLUMNS || _la == StarRocksParserFIELDS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	{
		p.SetState(1827)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1828)

		var _x = p.QualifiedName()

		localctx.(*ShowColumnStatementContext).table = _x
	}

	p.SetState(1832)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1830)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1831)

			var _x = p.QualifiedName()

			localctx.(*ShowColumnStatementContext).db = _x
		}

	}
	p.SetState(1838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(1834)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1835)

			var _x = p.String_()

			localctx.(*ShowColumnStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(1836)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1837)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTableStatusStatementContext is an interface to support dynamic dispatch.
type IShowTableStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTableStatusStatementContext differentiates from other interfaces.
	IsShowTableStatusStatementContext()
}

type ShowTableStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTableStatusStatementContext() *ShowTableStatusStatementContext {
	var p = new(ShowTableStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTableStatusStatement
	return p
}

func InitEmptyShowTableStatusStatementContext(p *ShowTableStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTableStatusStatement
}

func (*ShowTableStatusStatementContext) IsShowTableStatusStatementContext() {}

func NewShowTableStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTableStatusStatementContext {
	var p = new(ShowTableStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTableStatusStatement

	return p
}

func (s *ShowTableStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTableStatusStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTableStatusStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTableStatusStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTableStatusStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTableStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTableStatusStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *ShowTableStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *ShowTableStatusStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTableStatusStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTableStatusStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTableStatusStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowTableStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTableStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTableStatusStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTableStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTableStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTableStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTableStatusStatement(s)
	}
}

func (s *ShowTableStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTableStatusStatement(s)
	}
}

func (p *StarRocksParser) ShowTableStatusStatement() (localctx IShowTableStatusStatementContext) {
	localctx = NewShowTableStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, StarRocksParserRULE_showTableStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1840)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1841)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1842)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1843)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1844)

			var _x = p.QualifiedName()

			localctx.(*ShowTableStatusStatementContext).db = _x
		}

	}
	p.SetState(1851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(1847)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1848)

			var _x = p.String_()

			localctx.(*ShowTableStatusStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(1849)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1850)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshTableStatementContext is an interface to support dynamic dispatch.
type IRefreshTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsRefreshTableStatementContext differentiates from other interfaces.
	IsRefreshTableStatementContext()
}

type RefreshTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshTableStatementContext() *RefreshTableStatementContext {
	var p = new(RefreshTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshTableStatement
	return p
}

func InitEmptyRefreshTableStatementContext(p *RefreshTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshTableStatement
}

func (*RefreshTableStatementContext) IsRefreshTableStatementContext() {}

func NewRefreshTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshTableStatementContext {
	var p = new(RefreshTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refreshTableStatement

	return p
}

func (s *RefreshTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshTableStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *RefreshTableStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *RefreshTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *RefreshTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshTableStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *RefreshTableStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *RefreshTableStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RefreshTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefreshTableStatement(s)
	}
}

func (s *RefreshTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefreshTableStatement(s)
	}
}

func (p *StarRocksParser) RefreshTableStatement() (localctx IRefreshTableStatementContext) {
	localctx = NewRefreshTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, StarRocksParserRULE_refreshTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1853)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1854)
		p.Match(StarRocksParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1855)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1856)
		p.QualifiedName()
	}
	p.SetState(1869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(1857)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1858)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1859)
			p.String_()
		}
		p.SetState(1864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(1860)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1861)
				p.String_()
			}

			p.SetState(1866)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1867)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAlterStatementContext is an interface to support dynamic dispatch.
type IShowAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode

	// IsShowAlterStatementContext differentiates from other interfaces.
	IsShowAlterStatementContext()
}

type ShowAlterStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowAlterStatementContext() *ShowAlterStatementContext {
	var p = new(ShowAlterStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAlterStatement
	return p
}

func InitEmptyShowAlterStatementContext(p *ShowAlterStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAlterStatement
}

func (*ShowAlterStatementContext) IsShowAlterStatementContext() {}

func NewShowAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAlterStatementContext {
	var p = new(ShowAlterStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showAlterStatement

	return p
}

func (s *ShowAlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAlterStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowAlterStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowAlterStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAlterStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *ShowAlterStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *ShowAlterStatementContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *ShowAlterStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *ShowAlterStatementContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTIMIZE, 0)
}

func (s *ShowAlterStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowAlterStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowAlterStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowAlterStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowAlterStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowAlterStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowAlterStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowAlterStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowAlterStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowAlterStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowAlterStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *ShowAlterStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *ShowAlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAlterStatement(s)
	}
}

func (s *ShowAlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAlterStatement(s)
	}
}

func (p *StarRocksParser) ShowAlterStatement() (localctx IShowAlterStatementContext) {
	localctx = NewShowAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, StarRocksParserRULE_showAlterStatement)
	var _la int

	p.SetState(1925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1871)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1872)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1873)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1874)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserCOLUMN || _la == StarRocksParserOPTIMIZE || _la == StarRocksParserROLLUP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1877)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFROM || _la == StarRocksParserIN {
			{
				p.SetState(1875)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1876)

				var _x = p.QualifiedName()

				localctx.(*ShowAlterStatementContext).db = _x
			}

		}
		p.SetState(1881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(1879)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1880)
				p.expression(0)
			}

		}
		p.SetState(1893)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(1883)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1884)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1885)
				p.SortItem()
			}
			p.SetState(1890)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1886)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1887)
					p.SortItem()
				}

				p.SetState(1892)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIMIT {
			{
				p.SetState(1895)
				p.LimitElement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1898)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1899)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1900)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1901)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFROM || _la == StarRocksParserIN {
			{
				p.SetState(1902)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(1903)

				var _x = p.QualifiedName()

				localctx.(*ShowAlterStatementContext).db = _x
			}

		}
		p.SetState(1908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(1906)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1907)
				p.expression(0)
			}

		}
		p.SetState(1920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(1910)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1911)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1912)
				p.SortItem()
			}
			p.SetState(1917)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1913)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1914)
					p.SortItem()
				}

				p.SetState(1919)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(1923)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIMIT {
			{
				p.SetState(1922)
				p.LimitElement()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescTableStatementContext is an interface to support dynamic dispatch.
type IDescTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	FILES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	QualifiedName() IQualifiedNameContext
	ALL() antlr.TerminalNode

	// IsDescTableStatementContext differentiates from other interfaces.
	IsDescTableStatementContext()
}

type DescTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyDescTableStatementContext() *DescTableStatementContext {
	var p = new(DescTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descTableStatement
	return p
}

func InitEmptyDescTableStatementContext(p *DescTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descTableStatement
}

func (*DescTableStatementContext) IsDescTableStatementContext() {}

func NewDescTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescTableStatementContext {
	var p = new(DescTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_descTableStatement

	return p
}

func (s *DescTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescTableStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *DescTableStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *DescTableStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *DescTableStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESCRIBE, 0)
}

func (s *DescTableStatementContext) FILES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILES, 0)
}

func (s *DescTableStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *DescTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DescTableStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *DescTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDescTableStatement(s)
	}
}

func (s *DescTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDescTableStatement(s)
	}
}

func (p *StarRocksParser) DescTableStatement() (localctx IDescTableStatementContext) {
	localctx = NewDescTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, StarRocksParserRULE_descTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1927)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDESC || _la == StarRocksParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(1928)

			var _x = p.QualifiedName()

			localctx.(*DescTableStatementContext).table = _x
		}
		p.SetState(1930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL {
			{
				p.SetState(1929)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserFILES:
		{
			p.SetState(1932)
			p.Match(StarRocksParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1933)
			p.PropertyList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableLikeStatementContext is an interface to support dynamic dispatch.
type ICreateTableLikeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	LIKE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PartitionDesc() IPartitionDescContext
	DistributionDesc() IDistributionDescContext
	Properties() IPropertiesContext
	TEMPORARY() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode

	// IsCreateTableLikeStatementContext differentiates from other interfaces.
	IsCreateTableLikeStatementContext()
}

type CreateTableLikeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableLikeStatementContext() *CreateTableLikeStatementContext {
	var p = new(CreateTableLikeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableLikeStatement
	return p
}

func InitEmptyCreateTableLikeStatementContext(p *CreateTableLikeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createTableLikeStatement
}

func (*CreateTableLikeStatementContext) IsCreateTableLikeStatementContext() {}

func NewCreateTableLikeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableLikeStatementContext {
	var p = new(CreateTableLikeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createTableLikeStatement

	return p
}

func (s *CreateTableLikeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableLikeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateTableLikeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateTableLikeStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableLikeStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateTableLikeStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *CreateTableLikeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateTableLikeStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateTableLikeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateTableLikeStatementContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *CreateTableLikeStatementContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *CreateTableLikeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateTableLikeStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *CreateTableLikeStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CreateTableLikeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableLikeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableLikeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateTableLikeStatement(s)
	}
}

func (s *CreateTableLikeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateTableLikeStatement(s)
	}
}

func (p *StarRocksParser) CreateTableLikeStatement() (localctx ICreateTableLikeStatementContext) {
	localctx = NewCreateTableLikeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, StarRocksParserRULE_createTableLikeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1936)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEXTERNAL || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1937)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserEXTERNAL || _la == StarRocksParserTEMPORARY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1940)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1944)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(1941)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1942)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1943)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1946)
		p.QualifiedName()
	}
	p.SetState(1948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(1947)
			p.PartitionDesc()
		}

	}
	p.SetState(1951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDISTRIBUTED {
		{
			p.SetState(1950)
			p.DistributionDesc()
		}

	}
	p.SetState(1954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(1953)
			p.Properties()
		}

	}
	{
		p.SetState(1956)
		p.Match(StarRocksParserLIKE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1957)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowIndexStatementContext is an interface to support dynamic dispatch.
type IShowIndexStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	KEY() antlr.TerminalNode
	KEYS() antlr.TerminalNode
	AllFROM() []antlr.TerminalNode
	FROM(i int) antlr.TerminalNode
	AllIN() []antlr.TerminalNode
	IN(i int) antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowIndexStatementContext differentiates from other interfaces.
	IsShowIndexStatementContext()
}

type ShowIndexStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
	db     IQualifiedNameContext
}

func NewEmptyShowIndexStatementContext() *ShowIndexStatementContext {
	var p = new(ShowIndexStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showIndexStatement
	return p
}

func InitEmptyShowIndexStatementContext(p *ShowIndexStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showIndexStatement
}

func (*ShowIndexStatementContext) IsShowIndexStatementContext() {}

func NewShowIndexStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowIndexStatementContext {
	var p = new(ShowIndexStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showIndexStatement

	return p
}

func (s *ShowIndexStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowIndexStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowIndexStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowIndexStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowIndexStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowIndexStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowIndexStatementContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *ShowIndexStatementContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEXES, 0)
}

func (s *ShowIndexStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *ShowIndexStatementContext) KEYS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEYS, 0)
}

func (s *ShowIndexStatementContext) AllFROM() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserFROM)
}

func (s *ShowIndexStatementContext) FROM(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, i)
}

func (s *ShowIndexStatementContext) AllIN() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserIN)
}

func (s *ShowIndexStatementContext) IN(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, i)
}

func (s *ShowIndexStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowIndexStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowIndexStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowIndexStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowIndexStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowIndexStatement(s)
	}
}

func (s *ShowIndexStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowIndexStatement(s)
	}
}

func (p *StarRocksParser) ShowIndexStatement() (localctx IShowIndexStatementContext) {
	localctx = NewShowIndexStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, StarRocksParserRULE_showIndexStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1959)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1960)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&12582915) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	{
		p.SetState(1961)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1962)

		var _x = p.QualifiedName()

		localctx.(*ShowIndexStatementContext).table = _x
	}

	p.SetState(1966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(1964)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1965)

			var _x = p.QualifiedName()

			localctx.(*ShowIndexStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverTableStatementContext is an interface to support dynamic dispatch.
type IRecoverTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RECOVER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRecoverTableStatementContext differentiates from other interfaces.
	IsRecoverTableStatementContext()
}

type RecoverTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecoverTableStatementContext() *RecoverTableStatementContext {
	var p = new(RecoverTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverTableStatement
	return p
}

func InitEmptyRecoverTableStatementContext(p *RecoverTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverTableStatement
}

func (*RecoverTableStatementContext) IsRecoverTableStatementContext() {}

func NewRecoverTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverTableStatementContext {
	var p = new(RecoverTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_recoverTableStatement

	return p
}

func (s *RecoverTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverTableStatementContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRECOVER, 0)
}

func (s *RecoverTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *RecoverTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RecoverTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRecoverTableStatement(s)
	}
}

func (s *RecoverTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRecoverTableStatement(s)
	}
}

func (p *StarRocksParser) RecoverTableStatement() (localctx IRecoverTableStatementContext) {
	localctx = NewRecoverTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, StarRocksParserRULE_recoverTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1968)
		p.Match(StarRocksParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1969)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1970)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncateTableStatementContext is an interface to support dynamic dispatch.
type ITruncateTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsTruncateTableStatementContext differentiates from other interfaces.
	IsTruncateTableStatementContext()
}

type TruncateTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncateTableStatementContext() *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncateTableStatement
	return p
}

func InitEmptyTruncateTableStatementContext(p *TruncateTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncateTableStatement
}

func (*TruncateTableStatementContext) IsTruncateTableStatementContext() {}

func NewTruncateTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncateTableStatementContext {
	var p = new(TruncateTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_truncateTableStatement

	return p
}

func (s *TruncateTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncateTableStatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUNCATE, 0)
}

func (s *TruncateTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *TruncateTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TruncateTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TruncateTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncateTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncateTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTruncateTableStatement(s)
	}
}

func (s *TruncateTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTruncateTableStatement(s)
	}
}

func (p *StarRocksParser) TruncateTableStatement() (localctx ITruncateTableStatementContext) {
	localctx = NewTruncateTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, StarRocksParserRULE_truncateTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1972)
		p.Match(StarRocksParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1973)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1974)
		p.QualifiedName()
	}
	p.SetState(1976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(1975)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelAlterTableStatementContext is an interface to support dynamic dispatch.
type ICancelAlterTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	OPTIMIZE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode

	// IsCancelAlterTableStatementContext differentiates from other interfaces.
	IsCancelAlterTableStatementContext()
}

type CancelAlterTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelAlterTableStatementContext() *CancelAlterTableStatementContext {
	var p = new(CancelAlterTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelAlterTableStatement
	return p
}

func InitEmptyCancelAlterTableStatementContext(p *CancelAlterTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelAlterTableStatement
}

func (*CancelAlterTableStatementContext) IsCancelAlterTableStatementContext() {}

func NewCancelAlterTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelAlterTableStatementContext {
	var p = new(CancelAlterTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelAlterTableStatement

	return p
}

func (s *CancelAlterTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelAlterTableStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelAlterTableStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *CancelAlterTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CancelAlterTableStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelAlterTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelAlterTableStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *CancelAlterTableStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *CancelAlterTableStatementContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *CancelAlterTableStatementContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *CancelAlterTableStatementContext) OPTIMIZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTIMIZE, 0)
}

func (s *CancelAlterTableStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *CancelAlterTableStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *CancelAlterTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelAlterTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelAlterTableStatement(s)
	}
}

func (s *CancelAlterTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelAlterTableStatement(s)
	}
}

func (p *StarRocksParser) CancelAlterTableStatement() (localctx ICancelAlterTableStatementContext) {
	localctx = NewCancelAlterTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, StarRocksParserRULE_cancelAlterTableStatement)
	var _la int

	p.SetState(2004)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1978)
			p.Match(StarRocksParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1979)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1980)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1982)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCOLUMN || _la == StarRocksParserOPTIMIZE || _la == StarRocksParserROLLUP {
			{
				p.SetState(1981)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserCOLUMN || _la == StarRocksParserOPTIMIZE || _la == StarRocksParserROLLUP) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1984)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1985)
			p.QualifiedName()
		}
		p.SetState(1996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(1986)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1987)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1992)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(1988)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1989)
					p.Match(StarRocksParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

				p.SetState(1994)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(1995)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1998)
			p.Match(StarRocksParserCANCEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1999)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2000)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2001)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2002)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2003)
			p.QualifiedName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPartitionsStatementContext is an interface to support dynamic dispatch.
type IShowPartitionsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TEMPORARY() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowPartitionsStatementContext differentiates from other interfaces.
	IsShowPartitionsStatementContext()
}

type ShowPartitionsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyShowPartitionsStatementContext() *ShowPartitionsStatementContext {
	var p = new(ShowPartitionsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPartitionsStatement
	return p
}

func InitEmptyShowPartitionsStatementContext(p *ShowPartitionsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPartitionsStatement
}

func (*ShowPartitionsStatementContext) IsShowPartitionsStatementContext() {}

func NewShowPartitionsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPartitionsStatementContext {
	var p = new(ShowPartitionsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPartitionsStatement

	return p
}

func (s *ShowPartitionsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPartitionsStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *ShowPartitionsStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *ShowPartitionsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPartitionsStatementContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *ShowPartitionsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowPartitionsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowPartitionsStatementContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *ShowPartitionsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowPartitionsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowPartitionsStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowPartitionsStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowPartitionsStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowPartitionsStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowPartitionsStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowPartitionsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPartitionsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPartitionsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPartitionsStatement(s)
	}
}

func (s *ShowPartitionsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPartitionsStatement(s)
	}
}

func (p *StarRocksParser) ShowPartitionsStatement() (localctx IShowPartitionsStatementContext) {
	localctx = NewShowPartitionsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, StarRocksParserRULE_showPartitionsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2006)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2008)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2007)
			p.Match(StarRocksParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2010)
		p.Match(StarRocksParserPARTITIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2011)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2012)

		var _x = p.QualifiedName()

		localctx.(*ShowPartitionsStatementContext).table = _x
	}
	p.SetState(2015)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(2013)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2014)
			p.expression(0)
		}

	}
	p.SetState(2027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(2017)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2018)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2019)
			p.SortItem()
		}
		p.SetState(2024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(2020)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2021)
				p.SortItem()
			}

			p.SetState(2026)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(2030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(2029)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRecoverPartitionStatementContext is an interface to support dynamic dispatch.
type IRecoverPartitionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// Getter signatures
	RECOVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRecoverPartitionStatementContext differentiates from other interfaces.
	IsRecoverPartitionStatementContext()
}

type RecoverPartitionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	table  IQualifiedNameContext
}

func NewEmptyRecoverPartitionStatementContext() *RecoverPartitionStatementContext {
	var p = new(RecoverPartitionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverPartitionStatement
	return p
}

func InitEmptyRecoverPartitionStatementContext(p *RecoverPartitionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_recoverPartitionStatement
}

func (*RecoverPartitionStatementContext) IsRecoverPartitionStatementContext() {}

func NewRecoverPartitionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecoverPartitionStatementContext {
	var p = new(RecoverPartitionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_recoverPartitionStatement

	return p
}

func (s *RecoverPartitionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RecoverPartitionStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *RecoverPartitionStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *RecoverPartitionStatementContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRECOVER, 0)
}

func (s *RecoverPartitionStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *RecoverPartitionStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RecoverPartitionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RecoverPartitionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RecoverPartitionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecoverPartitionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecoverPartitionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRecoverPartitionStatement(s)
	}
}

func (s *RecoverPartitionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRecoverPartitionStatement(s)
	}
}

func (p *StarRocksParser) RecoverPartitionStatement() (localctx IRecoverPartitionStatementContext) {
	localctx = NewRecoverPartitionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, StarRocksParserRULE_recoverPartitionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2032)
		p.Match(StarRocksParserRECOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2033)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2034)
		p.Identifier()
	}
	{
		p.SetState(2035)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2036)

		var _x = p.QualifiedName()

		localctx.(*RecoverPartitionStatementContext).table = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateViewStatementContext is an interface to support dynamic dispatch.
type ICreateViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	Comment() ICommentContext
	SECURITY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode

	// IsCreateViewStatementContext differentiates from other interfaces.
	IsCreateViewStatementContext()
}

type CreateViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateViewStatementContext() *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createViewStatement
	return p
}

func InitEmptyCreateViewStatementContext(p *CreateViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createViewStatement
}

func (*CreateViewStatementContext) IsCreateViewStatementContext() {}

func NewCreateViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateViewStatementContext {
	var p = new(CreateViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createViewStatement

	return p
}

func (s *CreateViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateViewStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *CreateViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CreateViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateViewStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *CreateViewStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *CreateViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateViewStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *CreateViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *CreateViewStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateViewStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *CreateViewStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *CreateViewStatementContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINVOKER, 0)
}

func (s *CreateViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateViewStatement(s)
	}
}

func (s *CreateViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateViewStatement(s)
	}
}

func (p *StarRocksParser) CreateViewStatement() (localctx ICreateViewStatementContext) {
	localctx = NewCreateViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, StarRocksParserRULE_createViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2038)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2041)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserOR {
		{
			p.SetState(2039)
			p.Match(StarRocksParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2040)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2043)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2044)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2045)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2046)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2049)
		p.QualifiedName()
	}
	p.SetState(2061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(2050)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2051)
			p.ColumnNameWithComment()
		}
		p.SetState(2056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(2052)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2053)
				p.ColumnNameWithComment()
			}

			p.SetState(2058)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2059)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2064)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2063)
			p.Comment()
		}

	}
	p.SetState(2068)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSECURITY {
		{
			p.SetState(2066)
			p.Match(StarRocksParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2067)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserINVOKER || _la == StarRocksParserNONE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(2070)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2071)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterViewStatementContext is an interface to support dynamic dispatch.
type IAlterViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	SET() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	NONE() antlr.TerminalNode
	INVOKER() antlr.TerminalNode
	Properties() IPropertiesContext
	DIALECT() antlr.TerminalNode
	ADD() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	STARROCKS() antlr.TerminalNode

	// IsAlterViewStatementContext differentiates from other interfaces.
	IsAlterViewStatementContext()
}

type AlterViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterViewStatementContext() *AlterViewStatementContext {
	var p = new(AlterViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterViewStatement
	return p
}

func InitEmptyAlterViewStatementContext(p *AlterViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterViewStatement
}

func (*AlterViewStatementContext) IsAlterViewStatementContext() {}

func NewAlterViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterViewStatementContext {
	var p = new(AlterViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterViewStatement

	return p
}

func (s *AlterViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterViewStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *AlterViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *AlterViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *AlterViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *AlterViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *AlterViewStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterViewStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *AlterViewStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *AlterViewStatementContext) INVOKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINVOKER, 0)
}

func (s *AlterViewStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterViewStatementContext) DIALECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDIALECT, 0)
}

func (s *AlterViewStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AlterViewStatementContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *AlterViewStatementContext) STARROCKS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTARROCKS, 0)
}

func (s *AlterViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterViewStatement(s)
	}
}

func (s *AlterViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterViewStatement(s)
	}
}

func (p *StarRocksParser) AlterViewStatement() (localctx IAlterViewStatementContext) {
	localctx = NewAlterViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, StarRocksParserRULE_alterViewStatement)
	var _la int

	p.SetState(2115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 135, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2073)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2074)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2075)
			p.QualifiedName()
		}
		p.SetState(2087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(2076)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2077)
				p.ColumnNameWithComment()
			}
			p.SetState(2082)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(2078)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2079)
					p.ColumnNameWithComment()
				}

				p.SetState(2084)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(2085)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2089)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2090)
			p.QueryStatement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2092)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2093)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2094)
			p.QualifiedName()
		}
		{
			p.SetState(2095)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2096)
			p.Match(StarRocksParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2097)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserINVOKER || _la == StarRocksParserNONE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2099)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2100)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2101)
			p.QualifiedName()
		}
		{
			p.SetState(2102)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2103)
			p.Properties()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2105)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2106)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2107)
			p.QualifiedName()
		}
		{
			p.SetState(2108)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserADD || _la == StarRocksParserMODIFY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2109)
			p.Match(StarRocksParserDIALECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSTARROCKS {
			{
				p.SetState(2110)
				p.Match(StarRocksParserSTARROCKS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2113)
			p.QueryStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropViewStatementContext is an interface to support dynamic dispatch.
type IDropViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropViewStatementContext differentiates from other interfaces.
	IsDropViewStatementContext()
}

type DropViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropViewStatementContext() *DropViewStatementContext {
	var p = new(DropViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropViewStatement
	return p
}

func InitEmptyDropViewStatementContext(p *DropViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropViewStatement
}

func (*DropViewStatementContext) IsDropViewStatementContext() {}

func NewDropViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropViewStatementContext {
	var p = new(DropViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropViewStatement

	return p
}

func (s *DropViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropViewStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *DropViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropViewStatement(s)
	}
}

func (s *DropViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropViewStatement(s)
	}
}

func (p *StarRocksParser) DropViewStatement() (localctx IDropViewStatementContext) {
	localctx = NewDropViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, StarRocksParserRULE_dropViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2117)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2118)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2119)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2120)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2123)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameWithCommentContext is an interface to support dynamic dispatch.
type IColumnNameWithCommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetColumnName returns the columnName rule contexts.
	GetColumnName() IIdentifierContext

	// SetColumnName sets the columnName rule contexts.
	SetColumnName(IIdentifierContext)

	// Getter signatures
	Identifier() IIdentifierContext
	Comment() ICommentContext

	// IsColumnNameWithCommentContext differentiates from other interfaces.
	IsColumnNameWithCommentContext()
}

type ColumnNameWithCommentContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	columnName IIdentifierContext
}

func NewEmptyColumnNameWithCommentContext() *ColumnNameWithCommentContext {
	var p = new(ColumnNameWithCommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnNameWithComment
	return p
}

func InitEmptyColumnNameWithCommentContext(p *ColumnNameWithCommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnNameWithComment
}

func (*ColumnNameWithCommentContext) IsColumnNameWithCommentContext() {}

func NewColumnNameWithCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameWithCommentContext {
	var p = new(ColumnNameWithCommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnNameWithComment

	return p
}

func (s *ColumnNameWithCommentContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameWithCommentContext) GetColumnName() IIdentifierContext { return s.columnName }

func (s *ColumnNameWithCommentContext) SetColumnName(v IIdentifierContext) { s.columnName = v }

func (s *ColumnNameWithCommentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnNameWithCommentContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ColumnNameWithCommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameWithCommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameWithCommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnNameWithComment(s)
	}
}

func (s *ColumnNameWithCommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnNameWithComment(s)
	}
}

func (p *StarRocksParser) ColumnNameWithComment() (localctx IColumnNameWithCommentContext) {
	localctx = NewColumnNameWithCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, StarRocksParserRULE_columnNameWithComment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2125)

		var _x = p.Identifier()

		localctx.(*ColumnNameWithCommentContext).columnName = _x
	}
	p.SetState(2127)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2126)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubmitTaskStatementContext is an interface to support dynamic dispatch.
type ISubmitTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBMIT() antlr.TerminalNode
	TASK() antlr.TerminalNode
	AS() antlr.TerminalNode
	CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext
	InsertStatement() IInsertStatementContext
	DataCacheSelectStatement() IDataCacheSelectStatementContext
	QualifiedName() IQualifiedNameContext
	AllTaskClause() []ITaskClauseContext
	TaskClause(i int) ITaskClauseContext

	// IsSubmitTaskStatementContext differentiates from other interfaces.
	IsSubmitTaskStatementContext()
}

type SubmitTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubmitTaskStatementContext() *SubmitTaskStatementContext {
	var p = new(SubmitTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_submitTaskStatement
	return p
}

func InitEmptySubmitTaskStatementContext(p *SubmitTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_submitTaskStatement
}

func (*SubmitTaskStatementContext) IsSubmitTaskStatementContext() {}

func NewSubmitTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubmitTaskStatementContext {
	var p = new(SubmitTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_submitTaskStatement

	return p
}

func (s *SubmitTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubmitTaskStatementContext) SUBMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUBMIT, 0)
}

func (s *SubmitTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTASK, 0)
}

func (s *SubmitTaskStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *SubmitTaskStatementContext) CreateTableAsSelectStatement() ICreateTableAsSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableAsSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableAsSelectStatementContext)
}

func (s *SubmitTaskStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *SubmitTaskStatementContext) DataCacheSelectStatement() IDataCacheSelectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheSelectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheSelectStatementContext)
}

func (s *SubmitTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SubmitTaskStatementContext) AllTaskClause() []ITaskClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITaskClauseContext); ok {
			len++
		}
	}

	tst := make([]ITaskClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITaskClauseContext); ok {
			tst[i] = t.(ITaskClauseContext)
			i++
		}
	}

	return tst
}

func (s *SubmitTaskStatementContext) TaskClause(i int) ITaskClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskClauseContext)
}

func (s *SubmitTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubmitTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubmitTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubmitTaskStatement(s)
	}
}

func (s *SubmitTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubmitTaskStatement(s)
	}
}

func (p *StarRocksParser) SubmitTaskStatement() (localctx ISubmitTaskStatementContext) {
	localctx = NewSubmitTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, StarRocksParserRULE_submitTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2129)
		p.Match(StarRocksParserSUBMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2130)
		p.Match(StarRocksParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2132)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 138, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2131)
			p.QualifiedName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserPROPERTIES || _la == StarRocksParserSCHEDULE {
		{
			p.SetState(2134)
			p.TaskClause()
		}

		p.SetState(2139)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2140)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2144)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCREATE:
		{
			p.SetState(2141)
			p.CreateTableAsSelectStatement()
		}

	case StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserEXPLAIN, StarRocksParserINSERT:
		{
			p.SetState(2142)
			p.InsertStatement()
		}

	case StarRocksParserCACHE:
		{
			p.SetState(2143)
			p.DataCacheSelectStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskClauseContext is an interface to support dynamic dispatch.
type ITaskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Properties() IPropertiesContext
	TaskScheduleDesc() ITaskScheduleDescContext

	// IsTaskClauseContext differentiates from other interfaces.
	IsTaskClauseContext()
}

type TaskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskClauseContext() *TaskClauseContext {
	var p = new(TaskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskClause
	return p
}

func InitEmptyTaskClauseContext(p *TaskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskClause
}

func (*TaskClauseContext) IsTaskClauseContext() {}

func NewTaskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskClauseContext {
	var p = new(TaskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_taskClause

	return p
}

func (s *TaskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *TaskClauseContext) TaskScheduleDesc() ITaskScheduleDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskScheduleDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskScheduleDescContext)
}

func (s *TaskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTaskClause(s)
	}
}

func (s *TaskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTaskClause(s)
	}
}

func (p *StarRocksParser) TaskClause() (localctx ITaskClauseContext) {
	localctx = NewTaskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, StarRocksParserRULE_taskClause)
	p.SetState(2148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserPROPERTIES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2146)
			p.Properties()
		}

	case StarRocksParserSCHEDULE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2147)
			p.TaskScheduleDesc()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTaskStatementContext is an interface to support dynamic dispatch.
type IDropTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TASK() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	FORCE() antlr.TerminalNode

	// IsDropTaskStatementContext differentiates from other interfaces.
	IsDropTaskStatementContext()
}

type DropTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTaskStatementContext() *DropTaskStatementContext {
	var p = new(DropTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTaskStatement
	return p
}

func InitEmptyDropTaskStatementContext(p *DropTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTaskStatement
}

func (*DropTaskStatementContext) IsDropTaskStatementContext() {}

func NewDropTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTaskStatementContext {
	var p = new(DropTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropTaskStatement

	return p
}

func (s *DropTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTaskStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTASK, 0)
}

func (s *DropTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropTaskStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropTaskStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropTaskStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropTaskStatement(s)
	}
}

func (s *DropTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropTaskStatement(s)
	}
}

func (p *StarRocksParser) DropTaskStatement() (localctx IDropTaskStatementContext) {
	localctx = NewDropTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, StarRocksParserRULE_dropTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2150)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2151)
		p.Match(StarRocksParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2152)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2153)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2156)
		p.QualifiedName()
	}
	p.SetState(2158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(2157)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskScheduleDescContext is an interface to support dynamic dispatch.
type ITaskScheduleDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SCHEDULE() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	TaskInterval() ITaskIntervalContext
	START() antlr.TerminalNode
	String_() IStringContext

	// IsTaskScheduleDescContext differentiates from other interfaces.
	IsTaskScheduleDescContext()
}

type TaskScheduleDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskScheduleDescContext() *TaskScheduleDescContext {
	var p = new(TaskScheduleDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskScheduleDesc
	return p
}

func InitEmptyTaskScheduleDescContext(p *TaskScheduleDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskScheduleDesc
}

func (*TaskScheduleDescContext) IsTaskScheduleDescContext() {}

func NewTaskScheduleDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskScheduleDescContext {
	var p = new(TaskScheduleDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_taskScheduleDesc

	return p
}

func (s *TaskScheduleDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskScheduleDescContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULE, 0)
}

func (s *TaskScheduleDescContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVERY, 0)
}

func (s *TaskScheduleDescContext) TaskInterval() ITaskIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskIntervalContext)
}

func (s *TaskScheduleDescContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *TaskScheduleDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TaskScheduleDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskScheduleDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskScheduleDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTaskScheduleDesc(s)
	}
}

func (s *TaskScheduleDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTaskScheduleDesc(s)
	}
}

func (p *StarRocksParser) TaskScheduleDesc() (localctx ITaskScheduleDescContext) {
	localctx = NewTaskScheduleDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, StarRocksParserRULE_taskScheduleDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2160)
		p.Match(StarRocksParserSCHEDULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSTART {
		{
			p.SetState(2161)
			p.Match(StarRocksParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2162)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2163)
			p.String_()
		}
		{
			p.SetState(2164)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2168)
		p.Match(StarRocksParserEVERY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2169)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2170)
		p.TaskInterval()
	}
	{
		p.SetState(2171)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICreateMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	AS() antlr.TerminalNode
	QueryStatement() IQueryStatementContext
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AllColumnNameWithComment() []IColumnNameWithCommentContext
	ColumnNameWithComment(i int) IColumnNameWithCommentContext
	Comment() ICommentContext
	AllMaterializedViewDesc() []IMaterializedViewDescContext
	MaterializedViewDesc(i int) IMaterializedViewDescContext
	AllIndexDesc() []IIndexDescContext
	IndexDesc(i int) IIndexDescContext

	// IsCreateMaterializedViewStatementContext differentiates from other interfaces.
	IsCreateMaterializedViewStatementContext()
}

type CreateMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyCreateMaterializedViewStatementContext() *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createMaterializedViewStatement
	return p
}

func InitEmptyCreateMaterializedViewStatementContext(p *CreateMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createMaterializedViewStatement
}

func (*CreateMaterializedViewStatementContext) IsCreateMaterializedViewStatementContext() {}

func NewCreateMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateMaterializedViewStatementContext {
	var p = new(CreateMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createMaterializedViewStatement

	return p
}

func (s *CreateMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *CreateMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *CreateMaterializedViewStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *CreateMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *CreateMaterializedViewStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CreateMaterializedViewStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *CreateMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateMaterializedViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateMaterializedViewStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateMaterializedViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateMaterializedViewStatementContext) AllColumnNameWithComment() []IColumnNameWithCommentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			len++
		}
	}

	tst := make([]IColumnNameWithCommentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnNameWithCommentContext); ok {
			tst[i] = t.(IColumnNameWithCommentContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) ColumnNameWithComment(i int) IColumnNameWithCommentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameWithCommentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameWithCommentContext)
}

func (s *CreateMaterializedViewStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateMaterializedViewStatementContext) AllMaterializedViewDesc() []IMaterializedViewDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMaterializedViewDescContext); ok {
			len++
		}
	}

	tst := make([]IMaterializedViewDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMaterializedViewDescContext); ok {
			tst[i] = t.(IMaterializedViewDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) MaterializedViewDesc(i int) IMaterializedViewDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaterializedViewDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaterializedViewDescContext)
}

func (s *CreateMaterializedViewStatementContext) AllIndexDesc() []IIndexDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexDescContext); ok {
			len++
		}
	}

	tst := make([]IIndexDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexDescContext); ok {
			tst[i] = t.(IIndexDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateMaterializedViewStatementContext) IndexDesc(i int) IIndexDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexDescContext)
}

func (s *CreateMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateMaterializedViewStatement(s)
	}
}

func (s *CreateMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateMaterializedViewStatement(s)
	}
}

func (p *StarRocksParser) CreateMaterializedViewStatement() (localctx ICreateMaterializedViewStatementContext) {
	localctx = NewCreateMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, StarRocksParserRULE_createMaterializedViewStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2173)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2174)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2175)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2176)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2177)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2178)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2181)

		var _x = p.QualifiedName()

		localctx.(*CreateMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(2182)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2183)
			p.ColumnNameWithComment()
		}
		p.SetState(2188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2184)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2185)
					p.ColumnNameWithComment()
				}

			}
			p.SetState(2190)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 146, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}
		p.SetState(2195)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(2191)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2192)
				p.IndexDesc()
			}

			p.SetState(2197)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2198)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2202)
			p.Comment()
		}

	}
	p.SetState(2208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserDISTRIBUTED || ((int64((_la-295)) & ^0x3f) == 0 && ((int64(1)<<(_la-295))&1125917086711841) != 0) {
		{
			p.SetState(2205)
			p.MaterializedViewDesc()
		}

		p.SetState(2210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2211)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2212)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMvPartitionExprsContext is an interface to support dynamic dispatch.
type IMvPartitionExprsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrimaryExpression() []IPrimaryExpressionContext
	PrimaryExpression(i int) IPrimaryExpressionContext

	// IsMvPartitionExprsContext differentiates from other interfaces.
	IsMvPartitionExprsContext()
}

type MvPartitionExprsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMvPartitionExprsContext() *MvPartitionExprsContext {
	var p = new(MvPartitionExprsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mvPartitionExprs
	return p
}

func InitEmptyMvPartitionExprsContext(p *MvPartitionExprsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mvPartitionExprs
}

func (*MvPartitionExprsContext) IsMvPartitionExprsContext() {}

func NewMvPartitionExprsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MvPartitionExprsContext {
	var p = new(MvPartitionExprsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_mvPartitionExprs

	return p
}

func (s *MvPartitionExprsContext) GetParser() antlr.Parser { return s.parser }

func (s *MvPartitionExprsContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MvPartitionExprsContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *MvPartitionExprsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MvPartitionExprsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MvPartitionExprsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMvPartitionExprs(s)
	}
}

func (s *MvPartitionExprsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMvPartitionExprs(s)
	}
}

func (p *StarRocksParser) MvPartitionExprs() (localctx IMvPartitionExprsContext) {
	localctx = NewMvPartitionExprsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, StarRocksParserRULE_mvPartitionExprs)
	var _la int

	p.SetState(2226)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2214)
			p.primaryExpression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2215)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2216)
			p.primaryExpression(0)
		}
		p.SetState(2221)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(2217)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2218)
				p.primaryExpression(0)
			}

			p.SetState(2223)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(2224)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaterializedViewDescContext is an interface to support dynamic dispatch.
type IMaterializedViewDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	MvPartitionExprs() IMvPartitionExprsContext
	DistributionDesc() IDistributionDescContext
	OrderByDesc() IOrderByDescContext
	RefreshSchemeDesc() IRefreshSchemeDescContext
	Properties() IPropertiesContext

	// IsMaterializedViewDescContext differentiates from other interfaces.
	IsMaterializedViewDescContext()
}

type MaterializedViewDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaterializedViewDescContext() *MaterializedViewDescContext {
	var p = new(MaterializedViewDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_materializedViewDesc
	return p
}

func InitEmptyMaterializedViewDescContext(p *MaterializedViewDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_materializedViewDesc
}

func (*MaterializedViewDescContext) IsMaterializedViewDescContext() {}

func NewMaterializedViewDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaterializedViewDescContext {
	var p = new(MaterializedViewDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_materializedViewDesc

	return p
}

func (s *MaterializedViewDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MaterializedViewDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *MaterializedViewDescContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *MaterializedViewDescContext) MvPartitionExprs() IMvPartitionExprsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMvPartitionExprsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMvPartitionExprsContext)
}

func (s *MaterializedViewDescContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *MaterializedViewDescContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *MaterializedViewDescContext) RefreshSchemeDesc() IRefreshSchemeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshSchemeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshSchemeDescContext)
}

func (s *MaterializedViewDescContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *MaterializedViewDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaterializedViewDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaterializedViewDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMaterializedViewDesc(s)
	}
}

func (s *MaterializedViewDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMaterializedViewDesc(s)
	}
}

func (p *StarRocksParser) MaterializedViewDesc() (localctx IMaterializedViewDescContext) {
	localctx = NewMaterializedViewDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, StarRocksParserRULE_materializedViewDesc)
	p.SetState(2235)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserPARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2228)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2229)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2230)
			p.MvPartitionExprs()
		}

	case StarRocksParserDISTRIBUTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2231)
			p.DistributionDesc()
		}

	case StarRocksParserORDER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2232)
			p.OrderByDesc()
		}

	case StarRocksParserREFRESH:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2233)
			p.RefreshSchemeDesc()
		}

	case StarRocksParserPROPERTIES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2234)
			p.Properties()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowMaterializedViewsStatementContext is an interface to support dynamic dispatch.
type IShowMaterializedViewsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowMaterializedViewsStatementContext differentiates from other interfaces.
	IsShowMaterializedViewsStatementContext()
}

type ShowMaterializedViewsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowMaterializedViewsStatementContext() *ShowMaterializedViewsStatementContext {
	var p = new(ShowMaterializedViewsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showMaterializedViewsStatement
	return p
}

func InitEmptyShowMaterializedViewsStatementContext(p *ShowMaterializedViewsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showMaterializedViewsStatement
}

func (*ShowMaterializedViewsStatementContext) IsShowMaterializedViewsStatementContext() {}

func NewShowMaterializedViewsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowMaterializedViewsStatementContext {
	var p = new(ShowMaterializedViewsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showMaterializedViewsStatement

	return p
}

func (s *ShowMaterializedViewsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowMaterializedViewsStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowMaterializedViewsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowMaterializedViewsStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowMaterializedViewsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowMaterializedViewsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowMaterializedViewsStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *ShowMaterializedViewsStatementContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEWS, 0)
}

func (s *ShowMaterializedViewsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowMaterializedViewsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowMaterializedViewsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowMaterializedViewsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowMaterializedViewsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowMaterializedViewsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowMaterializedViewsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowMaterializedViewsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowMaterializedViewsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowMaterializedViewsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowMaterializedViewsStatement(s)
	}
}

func (s *ShowMaterializedViewsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowMaterializedViewsStatement(s)
	}
}

func (p *StarRocksParser) ShowMaterializedViewsStatement() (localctx IShowMaterializedViewsStatementContext) {
	localctx = NewShowMaterializedViewsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, StarRocksParserRULE_showMaterializedViewsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2237)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2238)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2239)
		p.Match(StarRocksParserVIEWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(2240)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2241)

			var _x = p.QualifiedName()

			localctx.(*ShowMaterializedViewsStatementContext).db = _x
		}

	}
	p.SetState(2248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(2244)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2245)

			var _x = p.String_()

			localctx.(*ShowMaterializedViewsStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(2246)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2247)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IDropMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropMaterializedViewStatementContext differentiates from other interfaces.
	IsDropMaterializedViewStatementContext()
}

type DropMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyDropMaterializedViewStatementContext() *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropMaterializedViewStatement
	return p
}

func InitEmptyDropMaterializedViewStatementContext(p *DropMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropMaterializedViewStatement
}

func (*DropMaterializedViewStatementContext) IsDropMaterializedViewStatementContext() {}

func NewDropMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropMaterializedViewStatementContext {
	var p = new(DropMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropMaterializedViewStatement

	return p
}

func (s *DropMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *DropMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *DropMaterializedViewStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *DropMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *DropMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropMaterializedViewStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropMaterializedViewStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropMaterializedViewStatement(s)
	}
}

func (s *DropMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropMaterializedViewStatement(s)
	}
}

func (p *StarRocksParser) DropMaterializedViewStatement() (localctx IDropMaterializedViewStatementContext) {
	localctx = NewDropMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, StarRocksParserRULE_dropMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2250)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2251)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2252)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2253)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2254)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2257)

		var _x = p.QualifiedName()

		localctx.(*DropMaterializedViewStatementContext).mvName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IAlterMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	RefreshSchemeDesc() IRefreshSchemeDescContext
	TableRenameClause() ITableRenameClauseContext
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	SwapTableClause() ISwapTableClauseContext
	StatusDesc() IStatusDescContext

	// IsAlterMaterializedViewStatementContext differentiates from other interfaces.
	IsAlterMaterializedViewStatementContext()
}

type AlterMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyAlterMaterializedViewStatementContext() *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterMaterializedViewStatement
	return p
}

func InitEmptyAlterMaterializedViewStatementContext(p *AlterMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterMaterializedViewStatement
}

func (*AlterMaterializedViewStatementContext) IsAlterMaterializedViewStatementContext() {}

func NewAlterMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterMaterializedViewStatementContext {
	var p = new(AlterMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterMaterializedViewStatement

	return p
}

func (s *AlterMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *AlterMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *AlterMaterializedViewStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *AlterMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *AlterMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterMaterializedViewStatementContext) RefreshSchemeDesc() IRefreshSchemeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefreshSchemeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefreshSchemeDescContext)
}

func (s *AlterMaterializedViewStatementContext) TableRenameClause() ITableRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRenameClauseContext)
}

func (s *AlterMaterializedViewStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterMaterializedViewStatementContext) SwapTableClause() ISwapTableClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwapTableClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwapTableClauseContext)
}

func (s *AlterMaterializedViewStatementContext) StatusDesc() IStatusDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatusDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatusDescContext)
}

func (s *AlterMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterMaterializedViewStatement(s)
	}
}

func (s *AlterMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterMaterializedViewStatement(s)
	}
}

func (p *StarRocksParser) AlterMaterializedViewStatement() (localctx IAlterMaterializedViewStatementContext) {
	localctx = NewAlterMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, StarRocksParserRULE_alterMaterializedViewStatement)
	p.SetState(2275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 158, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2259)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2260)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2261)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2262)

			var _x = p.QualifiedName()

			localctx.(*AlterMaterializedViewStatementContext).mvName = _x
		}
		p.SetState(2267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserREFRESH:
			{
				p.SetState(2263)
				p.RefreshSchemeDesc()
			}

		case StarRocksParserRENAME:
			{
				p.SetState(2264)
				p.TableRenameClause()
			}

		case StarRocksParserSET:
			{
				p.SetState(2265)
				p.ModifyPropertiesClause()
			}

		case StarRocksParserSWAP:
			{
				p.SetState(2266)
				p.SwapTableClause()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2269)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2270)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2271)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2272)

			var _x = p.QualifiedName()

			localctx.(*AlterMaterializedViewStatementContext).mvName = _x
		}
		{
			p.SetState(2273)
			p.StatusDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshMaterializedViewStatementContext is an interface to support dynamic dispatch.
type IRefreshMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPriority returns the priority token.
	GetPriority() antlr.Token

	// SetPriority sets the priority token.
	SetPriority(antlr.Token)

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	REFRESH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	AllWITH() []antlr.TerminalNode
	WITH(i int) antlr.TerminalNode
	MODE() antlr.TerminalNode
	PRIORITY() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	PartitionRangeDesc() IPartitionRangeDescContext
	ListPartitionValues() IListPartitionValuesContext

	// IsRefreshMaterializedViewStatementContext differentiates from other interfaces.
	IsRefreshMaterializedViewStatementContext()
}

type RefreshMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	mvName   IQualifiedNameContext
	priority antlr.Token
}

func NewEmptyRefreshMaterializedViewStatementContext() *RefreshMaterializedViewStatementContext {
	var p = new(RefreshMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshMaterializedViewStatement
	return p
}

func InitEmptyRefreshMaterializedViewStatementContext(p *RefreshMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshMaterializedViewStatement
}

func (*RefreshMaterializedViewStatementContext) IsRefreshMaterializedViewStatementContext() {}

func NewRefreshMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshMaterializedViewStatementContext {
	var p = new(RefreshMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refreshMaterializedViewStatement

	return p
}

func (s *RefreshMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshMaterializedViewStatementContext) GetPriority() antlr.Token { return s.priority }

func (s *RefreshMaterializedViewStatementContext) SetPriority(v antlr.Token) { s.priority = v }

func (s *RefreshMaterializedViewStatementContext) GetMvName() IQualifiedNameContext { return s.mvName }

func (s *RefreshMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) { s.mvName = v }

func (s *RefreshMaterializedViewStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *RefreshMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *RefreshMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *RefreshMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshMaterializedViewStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *RefreshMaterializedViewStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *RefreshMaterializedViewStatementContext) AllWITH() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserWITH)
}

func (s *RefreshMaterializedViewStatementContext) WITH(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, i)
}

func (s *RefreshMaterializedViewStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *RefreshMaterializedViewStatementContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIORITY, 0)
}

func (s *RefreshMaterializedViewStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *RefreshMaterializedViewStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *RefreshMaterializedViewStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *RefreshMaterializedViewStatementContext) PartitionRangeDesc() IPartitionRangeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionRangeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionRangeDescContext)
}

func (s *RefreshMaterializedViewStatementContext) ListPartitionValues() IListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionValuesContext)
}

func (s *RefreshMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefreshMaterializedViewStatement(s)
	}
}

func (s *RefreshMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefreshMaterializedViewStatement(s)
	}
}

func (p *StarRocksParser) RefreshMaterializedViewStatement() (localctx IRefreshMaterializedViewStatementContext) {
	localctx = NewRefreshMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, StarRocksParserRULE_refreshMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2277)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2278)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2279)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2280)

		var _x = p.QualifiedName()

		localctx.(*RefreshMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(2281)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2284)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserSTART:
			{
				p.SetState(2282)
				p.PartitionRangeDesc()
			}

		case StarRocksParserT__1:
			{
				p.SetState(2283)
				p.ListPartitionValues()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}
	p.SetState(2289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(2288)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(2294)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 162, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2291)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2292)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASYNC || _la == StarRocksParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2293)
			p.Match(StarRocksParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(2296)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2297)
			p.Match(StarRocksParserPRIORITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2298)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*RefreshMaterializedViewStatementContext).priority = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRefreshMaterializedViewStatementContext is an interface to support dynamic dispatch.
type ICancelRefreshMaterializedViewStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMvName returns the mvName rule contexts.
	GetMvName() IQualifiedNameContext

	// SetMvName sets the mvName rule contexts.
	SetMvName(IQualifiedNameContext)

	// Getter signatures
	CANCEL() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FORCE() antlr.TerminalNode

	// IsCancelRefreshMaterializedViewStatementContext differentiates from other interfaces.
	IsCancelRefreshMaterializedViewStatementContext()
}

type CancelRefreshMaterializedViewStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	mvName IQualifiedNameContext
}

func NewEmptyCancelRefreshMaterializedViewStatementContext() *CancelRefreshMaterializedViewStatementContext {
	var p = new(CancelRefreshMaterializedViewStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRefreshMaterializedViewStatement
	return p
}

func InitEmptyCancelRefreshMaterializedViewStatementContext(p *CancelRefreshMaterializedViewStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRefreshMaterializedViewStatement
}

func (*CancelRefreshMaterializedViewStatementContext) IsCancelRefreshMaterializedViewStatementContext() {
}

func NewCancelRefreshMaterializedViewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRefreshMaterializedViewStatementContext {
	var p = new(CancelRefreshMaterializedViewStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelRefreshMaterializedViewStatement

	return p
}

func (s *CancelRefreshMaterializedViewStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRefreshMaterializedViewStatementContext) GetMvName() IQualifiedNameContext {
	return s.mvName
}

func (s *CancelRefreshMaterializedViewStatementContext) SetMvName(v IQualifiedNameContext) {
	s.mvName = v
}

func (s *CancelRefreshMaterializedViewStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelRefreshMaterializedViewStatementContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *CancelRefreshMaterializedViewStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRefreshMaterializedViewStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRefreshMaterializedViewStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelRefreshMaterializedViewStatement(s)
	}
}

func (s *CancelRefreshMaterializedViewStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelRefreshMaterializedViewStatement(s)
	}
}

func (p *StarRocksParser) CancelRefreshMaterializedViewStatement() (localctx ICancelRefreshMaterializedViewStatementContext) {
	localctx = NewCancelRefreshMaterializedViewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, StarRocksParserRULE_cancelRefreshMaterializedViewStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2301)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2302)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2303)
		p.Match(StarRocksParserMATERIALIZED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2304)
		p.Match(StarRocksParserVIEW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2305)

		var _x = p.QualifiedName()

		localctx.(*CancelRefreshMaterializedViewStatementContext).mvName = _x
	}
	p.SetState(2307)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(2306)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetConfigStatementContext is an interface to support dynamic dispatch.
type IAdminSetConfigStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	Property() IPropertyContext
	WITH() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode

	// IsAdminSetConfigStatementContext differentiates from other interfaces.
	IsAdminSetConfigStatementContext()
}

type AdminSetConfigStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetConfigStatementContext() *AdminSetConfigStatementContext {
	var p = new(AdminSetConfigStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetConfigStatement
	return p
}

func InitEmptyAdminSetConfigStatementContext(p *AdminSetConfigStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetConfigStatement
}

func (*AdminSetConfigStatementContext) IsAdminSetConfigStatementContext() {}

func NewAdminSetConfigStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetConfigStatementContext {
	var p = new(AdminSetConfigStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetConfigStatement

	return p
}

func (s *AdminSetConfigStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetConfigStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetConfigStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetConfigStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *AdminSetConfigStatementContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONFIG, 0)
}

func (s *AdminSetConfigStatementContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AdminSetConfigStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AdminSetConfigStatementContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERSISTENT, 0)
}

func (s *AdminSetConfigStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetConfigStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetConfigStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetConfigStatement(s)
	}
}

func (s *AdminSetConfigStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetConfigStatement(s)
	}
}

func (p *StarRocksParser) AdminSetConfigStatement() (localctx IAdminSetConfigStatementContext) {
	localctx = NewAdminSetConfigStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, StarRocksParserRULE_adminSetConfigStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2309)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2310)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2311)
		p.Match(StarRocksParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2312)
		p.Match(StarRocksParserCONFIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2313)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2314)
		p.Property()
	}
	{
		p.SetState(2315)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2318)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(2316)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2317)
			p.Match(StarRocksParserPERSISTENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetReplicaStatusStatementContext is an interface to support dynamic dispatch.
type IAdminSetReplicaStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAdminSetReplicaStatusStatementContext differentiates from other interfaces.
	IsAdminSetReplicaStatusStatementContext()
}

type AdminSetReplicaStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetReplicaStatusStatementContext() *AdminSetReplicaStatusStatementContext {
	var p = new(AdminSetReplicaStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetReplicaStatusStatement
	return p
}

func InitEmptyAdminSetReplicaStatusStatementContext(p *AdminSetReplicaStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetReplicaStatusStatement
}

func (*AdminSetReplicaStatusStatementContext) IsAdminSetReplicaStatusStatementContext() {}

func NewAdminSetReplicaStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetReplicaStatusStatementContext {
	var p = new(AdminSetReplicaStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetReplicaStatusStatement

	return p
}

func (s *AdminSetReplicaStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetReplicaStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetReplicaStatusStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetReplicaStatusStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *AdminSetReplicaStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *AdminSetReplicaStatusStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AdminSetReplicaStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetReplicaStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetReplicaStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetReplicaStatusStatement(s)
	}
}

func (s *AdminSetReplicaStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetReplicaStatusStatement(s)
	}
}

func (p *StarRocksParser) AdminSetReplicaStatusStatement() (localctx IAdminSetReplicaStatusStatementContext) {
	localctx = NewAdminSetReplicaStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, StarRocksParserRULE_adminSetReplicaStatusStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2320)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2321)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2322)
		p.Match(StarRocksParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2323)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2324)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowConfigStatementContext is an interface to support dynamic dispatch.
type IAdminShowConfigStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsAdminShowConfigStatementContext differentiates from other interfaces.
	IsAdminShowConfigStatementContext()
}

type AdminShowConfigStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyAdminShowConfigStatementContext() *AdminShowConfigStatementContext {
	var p = new(AdminShowConfigStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowConfigStatement
	return p
}

func InitEmptyAdminShowConfigStatementContext(p *AdminShowConfigStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowConfigStatement
}

func (*AdminShowConfigStatementContext) IsAdminShowConfigStatementContext() {}

func NewAdminShowConfigStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowConfigStatementContext {
	var p = new(AdminShowConfigStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminShowConfigStatement

	return p
}

func (s *AdminShowConfigStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowConfigStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *AdminShowConfigStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *AdminShowConfigStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminShowConfigStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *AdminShowConfigStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *AdminShowConfigStatementContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONFIG, 0)
}

func (s *AdminShowConfigStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *AdminShowConfigStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AdminShowConfigStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowConfigStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowConfigStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminShowConfigStatement(s)
	}
}

func (s *AdminShowConfigStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminShowConfigStatement(s)
	}
}

func (p *StarRocksParser) AdminShowConfigStatement() (localctx IAdminShowConfigStatementContext) {
	localctx = NewAdminShowConfigStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, StarRocksParserRULE_adminShowConfigStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2326)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2327)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2328)
		p.Match(StarRocksParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2329)
		p.Match(StarRocksParserCONFIG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(2330)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2331)

			var _x = p.String_()

			localctx.(*AdminShowConfigStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowReplicaDistributionStatementContext is an interface to support dynamic dispatch.
type IAdminShowReplicaDistributionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminShowReplicaDistributionStatementContext differentiates from other interfaces.
	IsAdminShowReplicaDistributionStatementContext()
}

type AdminShowReplicaDistributionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminShowReplicaDistributionStatementContext() *AdminShowReplicaDistributionStatementContext {
	var p = new(AdminShowReplicaDistributionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaDistributionStatement
	return p
}

func InitEmptyAdminShowReplicaDistributionStatementContext(p *AdminShowReplicaDistributionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaDistributionStatement
}

func (*AdminShowReplicaDistributionStatementContext) IsAdminShowReplicaDistributionStatementContext() {
}

func NewAdminShowReplicaDistributionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowReplicaDistributionStatementContext {
	var p = new(AdminShowReplicaDistributionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaDistributionStatement

	return p
}

func (s *AdminShowReplicaDistributionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowReplicaDistributionStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTION, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *AdminShowReplicaDistributionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminShowReplicaDistributionStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminShowReplicaDistributionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaDistributionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowReplicaDistributionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminShowReplicaDistributionStatement(s)
	}
}

func (s *AdminShowReplicaDistributionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminShowReplicaDistributionStatement(s)
	}
}

func (p *StarRocksParser) AdminShowReplicaDistributionStatement() (localctx IAdminShowReplicaDistributionStatementContext) {
	localctx = NewAdminShowReplicaDistributionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, StarRocksParserRULE_adminShowReplicaDistributionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2334)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2335)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2336)
		p.Match(StarRocksParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2337)
		p.Match(StarRocksParserDISTRIBUTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2338)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2339)
		p.QualifiedName()
	}
	p.SetState(2341)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2340)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminShowReplicaStatusStatementContext is an interface to support dynamic dispatch.
type IAdminShowReplicaStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SHOW() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsAdminShowReplicaStatusStatementContext differentiates from other interfaces.
	IsAdminShowReplicaStatusStatementContext()
}

type AdminShowReplicaStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyAdminShowReplicaStatusStatementContext() *AdminShowReplicaStatusStatementContext {
	var p = new(AdminShowReplicaStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaStatusStatement
	return p
}

func InitEmptyAdminShowReplicaStatusStatementContext(p *AdminShowReplicaStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaStatusStatement
}

func (*AdminShowReplicaStatusStatementContext) IsAdminShowReplicaStatusStatementContext() {}

func NewAdminShowReplicaStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminShowReplicaStatusStatementContext {
	var p = new(AdminShowReplicaStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminShowReplicaStatusStatement

	return p
}

func (s *AdminShowReplicaStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminShowReplicaStatusStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *AdminShowReplicaStatusStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *AdminShowReplicaStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminShowReplicaStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *AdminShowReplicaStatusStatementContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *AdminShowReplicaStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *AdminShowReplicaStatusStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *AdminShowReplicaStatusStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminShowReplicaStatusStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminShowReplicaStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *AdminShowReplicaStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AdminShowReplicaStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminShowReplicaStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminShowReplicaStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminShowReplicaStatusStatement(s)
	}
}

func (s *AdminShowReplicaStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminShowReplicaStatusStatement(s)
	}
}

func (p *StarRocksParser) AdminShowReplicaStatusStatement() (localctx IAdminShowReplicaStatusStatementContext) {
	localctx = NewAdminShowReplicaStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, StarRocksParserRULE_adminShowReplicaStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2343)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2344)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2345)
		p.Match(StarRocksParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2346)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2347)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2348)
		p.QualifiedName()
	}
	p.SetState(2350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2349)
			p.PartitionNames()
		}

	}
	p.SetState(2354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(2352)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2353)

			var _x = p.expression(0)

			localctx.(*AdminShowReplicaStatusStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminRepairTableStatementContext is an interface to support dynamic dispatch.
type IAdminRepairTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminRepairTableStatementContext differentiates from other interfaces.
	IsAdminRepairTableStatementContext()
}

type AdminRepairTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminRepairTableStatementContext() *AdminRepairTableStatementContext {
	var p = new(AdminRepairTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminRepairTableStatement
	return p
}

func InitEmptyAdminRepairTableStatementContext(p *AdminRepairTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminRepairTableStatement
}

func (*AdminRepairTableStatementContext) IsAdminRepairTableStatementContext() {}

func NewAdminRepairTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminRepairTableStatementContext {
	var p = new(AdminRepairTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminRepairTableStatement

	return p
}

func (s *AdminRepairTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminRepairTableStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminRepairTableStatementContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPAIR, 0)
}

func (s *AdminRepairTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AdminRepairTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminRepairTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminRepairTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminRepairTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminRepairTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminRepairTableStatement(s)
	}
}

func (s *AdminRepairTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminRepairTableStatement(s)
	}
}

func (p *StarRocksParser) AdminRepairTableStatement() (localctx IAdminRepairTableStatementContext) {
	localctx = NewAdminRepairTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, StarRocksParserRULE_adminRepairTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2356)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2357)
		p.Match(StarRocksParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2358)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2359)
		p.QualifiedName()
	}
	p.SetState(2361)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2360)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminCancelRepairTableStatementContext is an interface to support dynamic dispatch.
type IAdminCancelRepairTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsAdminCancelRepairTableStatementContext differentiates from other interfaces.
	IsAdminCancelRepairTableStatementContext()
}

type AdminCancelRepairTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminCancelRepairTableStatementContext() *AdminCancelRepairTableStatementContext {
	var p = new(AdminCancelRepairTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminCancelRepairTableStatement
	return p
}

func InitEmptyAdminCancelRepairTableStatementContext(p *AdminCancelRepairTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminCancelRepairTableStatement
}

func (*AdminCancelRepairTableStatementContext) IsAdminCancelRepairTableStatementContext() {}

func NewAdminCancelRepairTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminCancelRepairTableStatementContext {
	var p = new(AdminCancelRepairTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminCancelRepairTableStatement

	return p
}

func (s *AdminCancelRepairTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminCancelRepairTableStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminCancelRepairTableStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *AdminCancelRepairTableStatementContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPAIR, 0)
}

func (s *AdminCancelRepairTableStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AdminCancelRepairTableStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminCancelRepairTableStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AdminCancelRepairTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCancelRepairTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminCancelRepairTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminCancelRepairTableStatement(s)
	}
}

func (s *AdminCancelRepairTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminCancelRepairTableStatement(s)
	}
}

func (p *StarRocksParser) AdminCancelRepairTableStatement() (localctx IAdminCancelRepairTableStatementContext) {
	localctx = NewAdminCancelRepairTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, StarRocksParserRULE_adminCancelRepairTableStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2363)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2364)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2365)
		p.Match(StarRocksParserREPAIR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2366)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2367)
		p.QualifiedName()
	}
	p.SetState(2369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(2368)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminCheckTabletsStatementContext is an interface to support dynamic dispatch.
type IAdminCheckTabletsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	CHECK() antlr.TerminalNode
	TabletList() ITabletListContext
	PROPERTIES() antlr.TerminalNode
	Property() IPropertyContext

	// IsAdminCheckTabletsStatementContext differentiates from other interfaces.
	IsAdminCheckTabletsStatementContext()
}

type AdminCheckTabletsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminCheckTabletsStatementContext() *AdminCheckTabletsStatementContext {
	var p = new(AdminCheckTabletsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminCheckTabletsStatement
	return p
}

func InitEmptyAdminCheckTabletsStatementContext(p *AdminCheckTabletsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminCheckTabletsStatement
}

func (*AdminCheckTabletsStatementContext) IsAdminCheckTabletsStatementContext() {}

func NewAdminCheckTabletsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminCheckTabletsStatementContext {
	var p = new(AdminCheckTabletsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminCheckTabletsStatement

	return p
}

func (s *AdminCheckTabletsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminCheckTabletsStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminCheckTabletsStatementContext) CHECK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHECK, 0)
}

func (s *AdminCheckTabletsStatementContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *AdminCheckTabletsStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *AdminCheckTabletsStatementContext) Property() IPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AdminCheckTabletsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminCheckTabletsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminCheckTabletsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminCheckTabletsStatement(s)
	}
}

func (s *AdminCheckTabletsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminCheckTabletsStatement(s)
	}
}

func (p *StarRocksParser) AdminCheckTabletsStatement() (localctx IAdminCheckTabletsStatementContext) {
	localctx = NewAdminCheckTabletsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, StarRocksParserRULE_adminCheckTabletsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2371)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2372)
		p.Match(StarRocksParserCHECK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2373)
		p.TabletList()
	}
	{
		p.SetState(2374)
		p.Match(StarRocksParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2375)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2376)
		p.Property()
	}
	{
		p.SetState(2377)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetPartitionVersionContext is an interface to support dynamic dispatch.
type IAdminSetPartitionVersionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionId returns the partitionId token.
	GetPartitionId() antlr.Token

	// GetVersion returns the version token.
	GetVersion() antlr.Token

	// SetPartitionId sets the partitionId token.
	SetPartitionId(antlr.Token)

	// SetVersion sets the version token.
	SetVersion(antlr.Token)

	// GetPartitionName returns the partitionName rule contexts.
	GetPartitionName() IIdentifierOrStringContext

	// SetPartitionName sets the partitionName rule contexts.
	SetPartitionName(IIdentifierOrStringContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	PARTITION() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsAdminSetPartitionVersionContext differentiates from other interfaces.
	IsAdminSetPartitionVersionContext()
}

type AdminSetPartitionVersionContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	partitionName IIdentifierOrStringContext
	partitionId   antlr.Token
	version       antlr.Token
}

func NewEmptyAdminSetPartitionVersionContext() *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetPartitionVersion
	return p
}

func InitEmptyAdminSetPartitionVersionContext(p *AdminSetPartitionVersionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetPartitionVersion
}

func (*AdminSetPartitionVersionContext) IsAdminSetPartitionVersionContext() {}

func NewAdminSetPartitionVersionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetPartitionVersionContext {
	var p = new(AdminSetPartitionVersionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetPartitionVersion

	return p
}

func (s *AdminSetPartitionVersionContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetPartitionVersionContext) GetPartitionId() antlr.Token { return s.partitionId }

func (s *AdminSetPartitionVersionContext) GetVersion() antlr.Token { return s.version }

func (s *AdminSetPartitionVersionContext) SetPartitionId(v antlr.Token) { s.partitionId = v }

func (s *AdminSetPartitionVersionContext) SetVersion(v antlr.Token) { s.version = v }

func (s *AdminSetPartitionVersionContext) GetPartitionName() IIdentifierOrStringContext {
	return s.partitionName
}

func (s *AdminSetPartitionVersionContext) SetPartitionName(v IIdentifierOrStringContext) {
	s.partitionName = v
}

func (s *AdminSetPartitionVersionContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetPartitionVersionContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetPartitionVersionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AdminSetPartitionVersionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AdminSetPartitionVersionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *AdminSetPartitionVersionContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *AdminSetPartitionVersionContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *AdminSetPartitionVersionContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *AdminSetPartitionVersionContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *AdminSetPartitionVersionContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AdminSetPartitionVersionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetPartitionVersionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetPartitionVersionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetPartitionVersion(s)
	}
}

func (s *AdminSetPartitionVersionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetPartitionVersion(s)
	}
}

func (p *StarRocksParser) AdminSetPartitionVersion() (localctx IAdminSetPartitionVersionContext) {
	localctx = NewAdminSetPartitionVersionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, StarRocksParserRULE_adminSetPartitionVersion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2379)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2380)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2381)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2382)
		p.QualifiedName()
	}
	{
		p.SetState(2383)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2384)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2387)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(2385)

			var _x = p.IdentifierOrString()

			localctx.(*AdminSetPartitionVersionContext).partitionName = _x
		}

	case StarRocksParserINTEGER_VALUE:
		{
			p.SetState(2386)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*AdminSetPartitionVersionContext).partitionId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2389)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2390)
		p.Match(StarRocksParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2391)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2392)

		var _m = p.Match(StarRocksParserINTEGER_VALUE)

		localctx.(*AdminSetPartitionVersionContext).version = _m
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillStatementContext is an interface to support dynamic dispatch.
type IKillStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetConnId returns the connId token.
	GetConnId() antlr.Token

	// SetConnId sets the connId token.
	SetConnId(antlr.Token)

	// GetQueryId returns the queryId rule contexts.
	GetQueryId() IStringContext

	// SetQueryId sets the queryId rule contexts.
	SetQueryId(IStringContext)

	// Getter signatures
	KILL() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	String_() IStringContext
	CONNECTION() antlr.TerminalNode

	// IsKillStatementContext differentiates from other interfaces.
	IsKillStatementContext()
}

type KillStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	connId  antlr.Token
	queryId IStringContext
}

func NewEmptyKillStatementContext() *KillStatementContext {
	var p = new(KillStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_killStatement
	return p
}

func InitEmptyKillStatementContext(p *KillStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_killStatement
}

func (*KillStatementContext) IsKillStatementContext() {}

func NewKillStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillStatementContext {
	var p = new(KillStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_killStatement

	return p
}

func (s *KillStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillStatementContext) GetConnId() antlr.Token { return s.connId }

func (s *KillStatementContext) SetConnId(v antlr.Token) { s.connId = v }

func (s *KillStatementContext) GetQueryId() IStringContext { return s.queryId }

func (s *KillStatementContext) SetQueryId(v IStringContext) { s.queryId = v }

func (s *KillStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKILL, 0)
}

func (s *KillStatementContext) QUERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUERY, 0)
}

func (s *KillStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *KillStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *KillStatementContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONNECTION, 0)
}

func (s *KillStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKillStatement(s)
	}
}

func (s *KillStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKillStatement(s)
	}
}

func (p *StarRocksParser) KillStatement() (localctx IKillStatementContext) {
	localctx = NewKillStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, StarRocksParserRULE_killStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2394)
		p.Match(StarRocksParserKILL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCONNECTION, StarRocksParserINTEGER_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.SetState(2396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCONNECTION {
			{
				p.SetState(2395)
				p.Match(StarRocksParserCONNECTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserQUERY:
		{
			p.SetState(2398)
			p.Match(StarRocksParserQUERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserINTEGER_VALUE:
		{
			p.SetState(2401)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*KillStatementContext).connId = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(2402)

			var _x = p.String_()

			localctx.(*KillStatementContext).queryId = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISyncStatementContext is an interface to support dynamic dispatch.
type ISyncStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYNC() antlr.TerminalNode

	// IsSyncStatementContext differentiates from other interfaces.
	IsSyncStatementContext()
}

type SyncStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySyncStatementContext() *SyncStatementContext {
	var p = new(SyncStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_syncStatement
	return p
}

func InitEmptySyncStatementContext(p *SyncStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_syncStatement
}

func (*SyncStatementContext) IsSyncStatementContext() {}

func NewSyncStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SyncStatementContext {
	var p = new(SyncStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_syncStatement

	return p
}

func (s *SyncStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SyncStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *SyncStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SyncStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SyncStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSyncStatement(s)
	}
}

func (s *SyncStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSyncStatement(s)
	}
}

func (p *StarRocksParser) SyncStatement() (localctx ISyncStatementContext) {
	localctx = NewSyncStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, StarRocksParserRULE_syncStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2405)
		p.Match(StarRocksParserSYNC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetAutomatedSnapshotOnStatementContext is an interface to support dynamic dispatch.
type IAdminSetAutomatedSnapshotOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSvName returns the svName rule contexts.
	GetSvName() IIdentifierContext

	// SetSvName sets the svName rule contexts.
	SetSvName(IIdentifierContext)

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	ON() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAdminSetAutomatedSnapshotOnStatementContext differentiates from other interfaces.
	IsAdminSetAutomatedSnapshotOnStatementContext()
}

type AdminSetAutomatedSnapshotOnStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	svName IIdentifierContext
}

func NewEmptyAdminSetAutomatedSnapshotOnStatementContext() *AdminSetAutomatedSnapshotOnStatementContext {
	var p = new(AdminSetAutomatedSnapshotOnStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement
	return p
}

func InitEmptyAdminSetAutomatedSnapshotOnStatementContext(p *AdminSetAutomatedSnapshotOnStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement
}

func (*AdminSetAutomatedSnapshotOnStatementContext) IsAdminSetAutomatedSnapshotOnStatementContext() {}

func NewAdminSetAutomatedSnapshotOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetAutomatedSnapshotOnStatementContext {
	var p = new(AdminSetAutomatedSnapshotOnStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement

	return p
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetSvName() IIdentifierContext { return s.svName }

func (s *AdminSetAutomatedSnapshotOnStatementContext) SetSvName(v IIdentifierContext) { s.svName = v }

func (s *AdminSetAutomatedSnapshotOnStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTOMATED, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTER, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetAutomatedSnapshotOnStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetAutomatedSnapshotOnStatement(s)
	}
}

func (p *StarRocksParser) AdminSetAutomatedSnapshotOnStatement() (localctx IAdminSetAutomatedSnapshotOnStatementContext) {
	localctx = NewAdminSetAutomatedSnapshotOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, StarRocksParserRULE_adminSetAutomatedSnapshotOnStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2407)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2408)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2409)
		p.Match(StarRocksParserAUTOMATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2410)
		p.Match(StarRocksParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2411)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2412)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSTORAGE {
		{
			p.SetState(2413)
			p.Match(StarRocksParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2414)
			p.Match(StarRocksParserVOLUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2415)

			var _x = p.Identifier()

			localctx.(*AdminSetAutomatedSnapshotOnStatementContext).svName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAdminSetAutomatedSnapshotOffStatementContext is an interface to support dynamic dispatch.
type IAdminSetAutomatedSnapshotOffStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	SET() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	OFF() antlr.TerminalNode

	// IsAdminSetAutomatedSnapshotOffStatementContext differentiates from other interfaces.
	IsAdminSetAutomatedSnapshotOffStatementContext()
}

type AdminSetAutomatedSnapshotOffStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdminSetAutomatedSnapshotOffStatementContext() *AdminSetAutomatedSnapshotOffStatementContext {
	var p = new(AdminSetAutomatedSnapshotOffStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement
	return p
}

func InitEmptyAdminSetAutomatedSnapshotOffStatementContext(p *AdminSetAutomatedSnapshotOffStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement
}

func (*AdminSetAutomatedSnapshotOffStatementContext) IsAdminSetAutomatedSnapshotOffStatementContext() {
}

func NewAdminSetAutomatedSnapshotOffStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AdminSetAutomatedSnapshotOffStatementContext {
	var p = new(AdminSetAutomatedSnapshotOffStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement

	return p
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AdminSetAutomatedSnapshotOffStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTOMATED, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTER, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) OFF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOFF, 0)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAdminSetAutomatedSnapshotOffStatement(s)
	}
}

func (s *AdminSetAutomatedSnapshotOffStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAdminSetAutomatedSnapshotOffStatement(s)
	}
}

func (p *StarRocksParser) AdminSetAutomatedSnapshotOffStatement() (localctx IAdminSetAutomatedSnapshotOffStatementContext) {
	localctx = NewAdminSetAutomatedSnapshotOffStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, StarRocksParserRULE_adminSetAutomatedSnapshotOffStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2418)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2419)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2420)
		p.Match(StarRocksParserAUTOMATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2421)
		p.Match(StarRocksParserCLUSTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2422)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2423)
		p.Match(StarRocksParserOFF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSystemStatementContext is an interface to support dynamic dispatch.
type IAlterSystemStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	AlterClause() IAlterClauseContext

	// IsAlterSystemStatementContext differentiates from other interfaces.
	IsAlterSystemStatementContext()
}

type AlterSystemStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSystemStatementContext() *AlterSystemStatementContext {
	var p = new(AlterSystemStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterSystemStatement
	return p
}

func InitEmptyAlterSystemStatementContext(p *AlterSystemStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterSystemStatement
}

func (*AlterSystemStatementContext) IsAlterSystemStatementContext() {}

func NewAlterSystemStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSystemStatementContext {
	var p = new(AlterSystemStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterSystemStatement

	return p
}

func (s *AlterSystemStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSystemStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterSystemStatementContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM, 0)
}

func (s *AlterSystemStatementContext) AlterClause() IAlterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterClauseContext)
}

func (s *AlterSystemStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSystemStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSystemStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterSystemStatement(s)
	}
}

func (s *AlterSystemStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterSystemStatement(s)
	}
}

func (p *StarRocksParser) AlterSystemStatement() (localctx IAlterSystemStatementContext) {
	localctx = NewAlterSystemStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, StarRocksParserRULE_alterSystemStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2425)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2426)
		p.Match(StarRocksParserSYSTEM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2427)
		p.AlterClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelAlterSystemStatementContext is an interface to support dynamic dispatch.
type ICancelAlterSystemStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsCancelAlterSystemStatementContext differentiates from other interfaces.
	IsCancelAlterSystemStatementContext()
}

type CancelAlterSystemStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelAlterSystemStatementContext() *CancelAlterSystemStatementContext {
	var p = new(CancelAlterSystemStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelAlterSystemStatement
	return p
}

func InitEmptyCancelAlterSystemStatementContext(p *CancelAlterSystemStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelAlterSystemStatement
}

func (*CancelAlterSystemStatementContext) IsCancelAlterSystemStatementContext() {}

func NewCancelAlterSystemStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelAlterSystemStatementContext {
	var p = new(CancelAlterSystemStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelAlterSystemStatement

	return p
}

func (s *CancelAlterSystemStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelAlterSystemStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelAlterSystemStatementContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *CancelAlterSystemStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *CancelAlterSystemStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelAlterSystemStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelAlterSystemStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelAlterSystemStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelAlterSystemStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelAlterSystemStatement(s)
	}
}

func (s *CancelAlterSystemStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelAlterSystemStatement(s)
	}
}

func (p *StarRocksParser) CancelAlterSystemStatement() (localctx ICancelAlterSystemStatementContext) {
	localctx = NewCancelAlterSystemStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, StarRocksParserRULE_cancelAlterSystemStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2429)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2430)
		p.Match(StarRocksParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2431)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2432)
		p.String_()
	}
	p.SetState(2437)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2433)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2434)
			p.String_()
		}

		p.SetState(2439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowComputeNodesStatementContext is an interface to support dynamic dispatch.
type IShowComputeNodesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODES() antlr.TerminalNode

	// IsShowComputeNodesStatementContext differentiates from other interfaces.
	IsShowComputeNodesStatementContext()
}

type ShowComputeNodesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowComputeNodesStatementContext() *ShowComputeNodesStatementContext {
	var p = new(ShowComputeNodesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showComputeNodesStatement
	return p
}

func InitEmptyShowComputeNodesStatementContext(p *ShowComputeNodesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showComputeNodesStatement
}

func (*ShowComputeNodesStatementContext) IsShowComputeNodesStatementContext() {}

func NewShowComputeNodesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowComputeNodesStatementContext {
	var p = new(ShowComputeNodesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showComputeNodesStatement

	return p
}

func (s *ShowComputeNodesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowComputeNodesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowComputeNodesStatementContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPUTE, 0)
}

func (s *ShowComputeNodesStatementContext) NODES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODES, 0)
}

func (s *ShowComputeNodesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowComputeNodesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowComputeNodesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowComputeNodesStatement(s)
	}
}

func (s *ShowComputeNodesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowComputeNodesStatement(s)
	}
}

func (p *StarRocksParser) ShowComputeNodesStatement() (localctx IShowComputeNodesStatementContext) {
	localctx = NewShowComputeNodesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, StarRocksParserRULE_showComputeNodesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2440)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2441)
		p.Match(StarRocksParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2442)
		p.Match(StarRocksParserNODES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateExternalCatalogStatementContext is an interface to support dynamic dispatch.
type ICreateExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	Properties() IPropertiesContext
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext

	// IsCreateExternalCatalogStatementContext differentiates from other interfaces.
	IsCreateExternalCatalogStatementContext()
}

type CreateExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyCreateExternalCatalogStatementContext() *CreateExternalCatalogStatementContext {
	var p = new(CreateExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createExternalCatalogStatement
	return p
}

func InitEmptyCreateExternalCatalogStatementContext(p *CreateExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createExternalCatalogStatement
}

func (*CreateExternalCatalogStatementContext) IsCreateExternalCatalogStatementContext() {}

func NewCreateExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateExternalCatalogStatementContext {
	var p = new(CreateExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createExternalCatalogStatement

	return p
}

func (s *CreateExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *CreateExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *CreateExternalCatalogStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateExternalCatalogStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CreateExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *CreateExternalCatalogStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateExternalCatalogStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateExternalCatalogStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateExternalCatalogStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateExternalCatalogStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateExternalCatalogStatement(s)
	}
}

func (s *CreateExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateExternalCatalogStatement(s)
	}
}

func (p *StarRocksParser) CreateExternalCatalogStatement() (localctx ICreateExternalCatalogStatementContext) {
	localctx = NewCreateExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, StarRocksParserRULE_createExternalCatalogStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2444)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2445)
		p.Match(StarRocksParserEXTERNAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2446)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2447)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2448)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2449)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2452)

		var _x = p.IdentifierOrString()

		localctx.(*CreateExternalCatalogStatementContext).catalogName = _x
	}
	p.SetState(2454)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2453)
			p.Comment()
		}

	}
	{
		p.SetState(2456)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateExternalCatalogStatementContext is an interface to support dynamic dispatch.
type IShowCreateExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowCreateExternalCatalogStatementContext differentiates from other interfaces.
	IsShowCreateExternalCatalogStatementContext()
}

type ShowCreateExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyShowCreateExternalCatalogStatementContext() *ShowCreateExternalCatalogStatementContext {
	var p = new(ShowCreateExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateExternalCatalogStatement
	return p
}

func InitEmptyShowCreateExternalCatalogStatementContext(p *ShowCreateExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateExternalCatalogStatement
}

func (*ShowCreateExternalCatalogStatementContext) IsShowCreateExternalCatalogStatementContext() {}

func NewShowCreateExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateExternalCatalogStatementContext {
	var p = new(ShowCreateExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateExternalCatalogStatement

	return p
}

func (s *ShowCreateExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *ShowCreateExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *ShowCreateExternalCatalogStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *ShowCreateExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowCreateExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateExternalCatalogStatement(s)
	}
}

func (s *ShowCreateExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateExternalCatalogStatement(s)
	}
}

func (p *StarRocksParser) ShowCreateExternalCatalogStatement() (localctx IShowCreateExternalCatalogStatementContext) {
	localctx = NewShowCreateExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, StarRocksParserRULE_showCreateExternalCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2458)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2459)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2460)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2461)

		var _x = p.IdentifierOrString()

		localctx.(*ShowCreateExternalCatalogStatementContext).catalogName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropExternalCatalogStatementContext is an interface to support dynamic dispatch.
type IDropExternalCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropExternalCatalogStatementContext differentiates from other interfaces.
	IsDropExternalCatalogStatementContext()
}

type DropExternalCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyDropExternalCatalogStatementContext() *DropExternalCatalogStatementContext {
	var p = new(DropExternalCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropExternalCatalogStatement
	return p
}

func InitEmptyDropExternalCatalogStatementContext(p *DropExternalCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropExternalCatalogStatement
}

func (*DropExternalCatalogStatementContext) IsDropExternalCatalogStatementContext() {}

func NewDropExternalCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropExternalCatalogStatementContext {
	var p = new(DropExternalCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropExternalCatalogStatement

	return p
}

func (s *DropExternalCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropExternalCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *DropExternalCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *DropExternalCatalogStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropExternalCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *DropExternalCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropExternalCatalogStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropExternalCatalogStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropExternalCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropExternalCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropExternalCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropExternalCatalogStatement(s)
	}
}

func (s *DropExternalCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropExternalCatalogStatement(s)
	}
}

func (p *StarRocksParser) DropExternalCatalogStatement() (localctx IDropExternalCatalogStatementContext) {
	localctx = NewDropExternalCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, StarRocksParserRULE_dropExternalCatalogStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2463)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2464)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2465)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2466)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2469)

		var _x = p.IdentifierOrString()

		localctx.(*DropExternalCatalogStatementContext).catalogName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCatalogsStatementContext is an interface to support dynamic dispatch.
type IShowCatalogsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowCatalogsStatementContext differentiates from other interfaces.
	IsShowCatalogsStatementContext()
}

type ShowCatalogsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCatalogsStatementContext() *ShowCatalogsStatementContext {
	var p = new(ShowCatalogsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCatalogsStatement
	return p
}

func InitEmptyShowCatalogsStatementContext(p *ShowCatalogsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCatalogsStatement
}

func (*ShowCatalogsStatementContext) IsShowCatalogsStatementContext() {}

func NewShowCatalogsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCatalogsStatementContext {
	var p = new(ShowCatalogsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCatalogsStatement

	return p
}

func (s *ShowCatalogsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCatalogsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCatalogsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCatalogsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCatalogsStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *ShowCatalogsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowCatalogsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCatalogsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCatalogsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCatalogsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCatalogsStatement(s)
	}
}

func (s *ShowCatalogsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCatalogsStatement(s)
	}
}

func (p *StarRocksParser) ShowCatalogsStatement() (localctx IShowCatalogsStatementContext) {
	localctx = NewShowCatalogsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, StarRocksParserRULE_showCatalogsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2471)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2472)
		p.Match(StarRocksParserCATALOGS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(2473)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2474)

			var _x = p.String_()

			localctx.(*ShowCatalogsStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterCatalogStatementContext is an interface to support dynamic dispatch.
type IAlterCatalogStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalogName returns the catalogName rule contexts.
	GetCatalogName() IIdentifierOrStringContext

	// SetCatalogName sets the catalogName rule contexts.
	SetCatalogName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterCatalogStatementContext differentiates from other interfaces.
	IsAlterCatalogStatementContext()
}

type AlterCatalogStatementContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	catalogName IIdentifierOrStringContext
}

func NewEmptyAlterCatalogStatementContext() *AlterCatalogStatementContext {
	var p = new(AlterCatalogStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterCatalogStatement
	return p
}

func InitEmptyAlterCatalogStatementContext(p *AlterCatalogStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterCatalogStatement
}

func (*AlterCatalogStatementContext) IsAlterCatalogStatementContext() {}

func NewAlterCatalogStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterCatalogStatementContext {
	var p = new(AlterCatalogStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterCatalogStatement

	return p
}

func (s *AlterCatalogStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterCatalogStatementContext) GetCatalogName() IIdentifierOrStringContext {
	return s.catalogName
}

func (s *AlterCatalogStatementContext) SetCatalogName(v IIdentifierOrStringContext) {
	s.catalogName = v
}

func (s *AlterCatalogStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterCatalogStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *AlterCatalogStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterCatalogStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterCatalogStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterCatalogStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterCatalogStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterCatalogStatement(s)
	}
}

func (s *AlterCatalogStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterCatalogStatement(s)
	}
}

func (p *StarRocksParser) AlterCatalogStatement() (localctx IAlterCatalogStatementContext) {
	localctx = NewAlterCatalogStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, StarRocksParserRULE_alterCatalogStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2477)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2478)
		p.Match(StarRocksParserCATALOG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2479)

		var _x = p.IdentifierOrString()

		localctx.(*AlterCatalogStatementContext).catalogName = _x
	}
	{
		p.SetState(2480)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateStorageVolumeStatementContext is an interface to support dynamic dispatch.
type ICreateStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStorageVolumeName returns the storageVolumeName rule contexts.
	GetStorageVolumeName() IIdentifierOrStringContext

	// SetStorageVolumeName sets the storageVolumeName rule contexts.
	SetStorageVolumeName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	TypeDesc() ITypeDescContext
	LocationsDesc() ILocationsDescContext
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateStorageVolumeStatementContext differentiates from other interfaces.
	IsCreateStorageVolumeStatementContext()
}

type CreateStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	storageVolumeName IIdentifierOrStringContext
}

func NewEmptyCreateStorageVolumeStatementContext() *CreateStorageVolumeStatementContext {
	var p = new(CreateStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createStorageVolumeStatement
	return p
}

func InitEmptyCreateStorageVolumeStatementContext(p *CreateStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createStorageVolumeStatement
}

func (*CreateStorageVolumeStatementContext) IsCreateStorageVolumeStatementContext() {}

func NewCreateStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateStorageVolumeStatementContext {
	var p = new(CreateStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createStorageVolumeStatement

	return p
}

func (s *CreateStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateStorageVolumeStatementContext) GetStorageVolumeName() IIdentifierOrStringContext {
	return s.storageVolumeName
}

func (s *CreateStorageVolumeStatementContext) SetStorageVolumeName(v IIdentifierOrStringContext) {
	s.storageVolumeName = v
}

func (s *CreateStorageVolumeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *CreateStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *CreateStorageVolumeStatementContext) TypeDesc() ITypeDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDescContext)
}

func (s *CreateStorageVolumeStatementContext) LocationsDesc() ILocationsDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocationsDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocationsDescContext)
}

func (s *CreateStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateStorageVolumeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateStorageVolumeStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateStorageVolumeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateStorageVolumeStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateStorageVolumeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateStorageVolumeStatement(s)
	}
}

func (s *CreateStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateStorageVolumeStatement(s)
	}
}

func (p *StarRocksParser) CreateStorageVolumeStatement() (localctx ICreateStorageVolumeStatementContext) {
	localctx = NewCreateStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, StarRocksParserRULE_createStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2482)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2483)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2484)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2488)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2485)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2486)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2487)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2490)

		var _x = p.IdentifierOrString()

		localctx.(*CreateStorageVolumeStatementContext).storageVolumeName = _x
	}
	{
		p.SetState(2491)
		p.TypeDesc()
	}
	{
		p.SetState(2492)
		p.LocationsDesc()
	}
	p.SetState(2494)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2493)
			p.Comment()
		}

	}
	p.SetState(2497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2496)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDescContext is an interface to support dynamic dispatch.
type ITypeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TYPE() antlr.TerminalNode
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTypeDescContext differentiates from other interfaces.
	IsTypeDescContext()
}

type TypeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDescContext() *TypeDescContext {
	var p = new(TypeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeDesc
	return p
}

func InitEmptyTypeDescContext(p *TypeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeDesc
}

func (*TypeDescContext) IsTypeDescContext() {}

func NewTypeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDescContext {
	var p = new(TypeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_typeDesc

	return p
}

func (s *TypeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDescContext) TYPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTYPE, 0)
}

func (s *TypeDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *TypeDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TypeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTypeDesc(s)
	}
}

func (s *TypeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTypeDesc(s)
	}
}

func (p *StarRocksParser) TypeDesc() (localctx ITypeDescContext) {
	localctx = NewTypeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, StarRocksParserRULE_typeDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2499)
		p.Match(StarRocksParserTYPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2500)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2501)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILocationsDescContext is an interface to support dynamic dispatch.
type ILocationsDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCATIONS() antlr.TerminalNode
	EQ() antlr.TerminalNode
	StringList() IStringListContext

	// IsLocationsDescContext differentiates from other interfaces.
	IsLocationsDescContext()
}

type LocationsDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocationsDescContext() *LocationsDescContext {
	var p = new(LocationsDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_locationsDesc
	return p
}

func InitEmptyLocationsDescContext(p *LocationsDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_locationsDesc
}

func (*LocationsDescContext) IsLocationsDescContext() {}

func NewLocationsDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocationsDescContext {
	var p = new(LocationsDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_locationsDesc

	return p
}

func (s *LocationsDescContext) GetParser() antlr.Parser { return s.parser }

func (s *LocationsDescContext) LOCATIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCATIONS, 0)
}

func (s *LocationsDescContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *LocationsDescContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *LocationsDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocationsDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocationsDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLocationsDesc(s)
	}
}

func (s *LocationsDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLocationsDesc(s)
	}
}

func (p *StarRocksParser) LocationsDesc() (localctx ILocationsDescContext) {
	localctx = NewLocationsDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, StarRocksParserRULE_locationsDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2503)
		p.Match(StarRocksParserLOCATIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2504)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2505)
		p.StringList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStorageVolumesStatementContext is an interface to support dynamic dispatch.
type IShowStorageVolumesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowStorageVolumesStatementContext differentiates from other interfaces.
	IsShowStorageVolumesStatementContext()
}

type ShowStorageVolumesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowStorageVolumesStatementContext() *ShowStorageVolumesStatementContext {
	var p = new(ShowStorageVolumesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStorageVolumesStatement
	return p
}

func InitEmptyShowStorageVolumesStatementContext(p *ShowStorageVolumesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStorageVolumesStatement
}

func (*ShowStorageVolumesStatementContext) IsShowStorageVolumesStatementContext() {}

func NewShowStorageVolumesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStorageVolumesStatementContext {
	var p = new(ShowStorageVolumesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showStorageVolumesStatement

	return p
}

func (s *ShowStorageVolumesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStorageVolumesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowStorageVolumesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowStorageVolumesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowStorageVolumesStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *ShowStorageVolumesStatementContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUMES, 0)
}

func (s *ShowStorageVolumesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowStorageVolumesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowStorageVolumesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStorageVolumesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStorageVolumesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowStorageVolumesStatement(s)
	}
}

func (s *ShowStorageVolumesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowStorageVolumesStatement(s)
	}
}

func (p *StarRocksParser) ShowStorageVolumesStatement() (localctx IShowStorageVolumesStatementContext) {
	localctx = NewShowStorageVolumesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, StarRocksParserRULE_showStorageVolumesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2507)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2508)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2509)
		p.Match(StarRocksParserVOLUMES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(2510)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2511)

			var _x = p.String_()

			localctx.(*ShowStorageVolumesStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IDropStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStorageVolumeName returns the storageVolumeName rule contexts.
	GetStorageVolumeName() IIdentifierOrStringContext

	// SetStorageVolumeName sets the storageVolumeName rule contexts.
	SetStorageVolumeName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropStorageVolumeStatementContext differentiates from other interfaces.
	IsDropStorageVolumeStatementContext()
}

type DropStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	storageVolumeName IIdentifierOrStringContext
}

func NewEmptyDropStorageVolumeStatementContext() *DropStorageVolumeStatementContext {
	var p = new(DropStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropStorageVolumeStatement
	return p
}

func InitEmptyDropStorageVolumeStatementContext(p *DropStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropStorageVolumeStatement
}

func (*DropStorageVolumeStatementContext) IsDropStorageVolumeStatementContext() {}

func NewDropStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStorageVolumeStatementContext {
	var p = new(DropStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropStorageVolumeStatement

	return p
}

func (s *DropStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStorageVolumeStatementContext) GetStorageVolumeName() IIdentifierOrStringContext {
	return s.storageVolumeName
}

func (s *DropStorageVolumeStatementContext) SetStorageVolumeName(v IIdentifierOrStringContext) {
	s.storageVolumeName = v
}

func (s *DropStorageVolumeStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *DropStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *DropStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropStorageVolumeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropStorageVolumeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropStorageVolumeStatement(s)
	}
}

func (s *DropStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropStorageVolumeStatement(s)
	}
}

func (p *StarRocksParser) DropStorageVolumeStatement() (localctx IDropStorageVolumeStatementContext) {
	localctx = NewDropStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, StarRocksParserRULE_dropStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2514)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2515)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2516)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(2517)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2518)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2521)

		var _x = p.IdentifierOrString()

		localctx.(*DropStorageVolumeStatementContext).storageVolumeName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IAlterStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AllAlterStorageVolumeClause() []IAlterStorageVolumeClauseContext
	AlterStorageVolumeClause(i int) IAlterStorageVolumeClauseContext

	// IsAlterStorageVolumeStatementContext differentiates from other interfaces.
	IsAlterStorageVolumeStatementContext()
}

type AlterStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStorageVolumeStatementContext() *AlterStorageVolumeStatementContext {
	var p = new(AlterStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeStatement
	return p
}

func InitEmptyAlterStorageVolumeStatementContext(p *AlterStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeStatement
}

func (*AlterStorageVolumeStatementContext) IsAlterStorageVolumeStatementContext() {}

func NewAlterStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStorageVolumeStatementContext {
	var p = new(AlterStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeStatement

	return p
}

func (s *AlterStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStorageVolumeStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *AlterStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *AlterStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterStorageVolumeStatementContext) AllAlterStorageVolumeClause() []IAlterStorageVolumeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			len++
		}
	}

	tst := make([]IAlterStorageVolumeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			tst[i] = t.(IAlterStorageVolumeClauseContext)
			i++
		}
	}

	return tst
}

func (s *AlterStorageVolumeStatementContext) AlterStorageVolumeClause(i int) IAlterStorageVolumeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStorageVolumeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStorageVolumeClauseContext)
}

func (s *AlterStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterStorageVolumeStatement(s)
	}
}

func (s *AlterStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterStorageVolumeStatement(s)
	}
}

func (p *StarRocksParser) AlterStorageVolumeStatement() (localctx IAlterStorageVolumeStatementContext) {
	localctx = NewAlterStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, StarRocksParserRULE_alterStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2523)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2524)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2525)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2526)
		p.IdentifierOrString()
	}
	{
		p.SetState(2527)
		p.AlterStorageVolumeClause()
	}
	p.SetState(2532)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2528)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2529)
			p.AlterStorageVolumeClause()
		}

		p.SetState(2534)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterStorageVolumeClauseContext is an interface to support dynamic dispatch.
type IAlterStorageVolumeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ModifyStorageVolumeCommentClause() IModifyStorageVolumeCommentClauseContext
	ModifyStorageVolumePropertiesClause() IModifyStorageVolumePropertiesClauseContext

	// IsAlterStorageVolumeClauseContext differentiates from other interfaces.
	IsAlterStorageVolumeClauseContext()
}

type AlterStorageVolumeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStorageVolumeClauseContext() *AlterStorageVolumeClauseContext {
	var p = new(AlterStorageVolumeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeClause
	return p
}

func InitEmptyAlterStorageVolumeClauseContext(p *AlterStorageVolumeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeClause
}

func (*AlterStorageVolumeClauseContext) IsAlterStorageVolumeClauseContext() {}

func NewAlterStorageVolumeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStorageVolumeClauseContext {
	var p = new(AlterStorageVolumeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterStorageVolumeClause

	return p
}

func (s *AlterStorageVolumeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStorageVolumeClauseContext) ModifyStorageVolumeCommentClause() IModifyStorageVolumeCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyStorageVolumeCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyStorageVolumeCommentClauseContext)
}

func (s *AlterStorageVolumeClauseContext) ModifyStorageVolumePropertiesClause() IModifyStorageVolumePropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyStorageVolumePropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyStorageVolumePropertiesClauseContext)
}

func (s *AlterStorageVolumeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStorageVolumeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStorageVolumeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterStorageVolumeClause(s)
	}
}

func (s *AlterStorageVolumeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterStorageVolumeClause(s)
	}
}

func (p *StarRocksParser) AlterStorageVolumeClause() (localctx IAlterStorageVolumeClauseContext) {
	localctx = NewAlterStorageVolumeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, StarRocksParserRULE_alterStorageVolumeClause)
	p.SetState(2537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCOMMENT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2535)
			p.ModifyStorageVolumeCommentClause()
		}

	case StarRocksParserSET:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2536)
			p.ModifyStorageVolumePropertiesClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyStorageVolumePropertiesClauseContext is an interface to support dynamic dispatch.
type IModifyStorageVolumePropertiesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyStorageVolumePropertiesClauseContext differentiates from other interfaces.
	IsModifyStorageVolumePropertiesClauseContext()
}

type ModifyStorageVolumePropertiesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyStorageVolumePropertiesClauseContext() *ModifyStorageVolumePropertiesClauseContext {
	var p = new(ModifyStorageVolumePropertiesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumePropertiesClause
	return p
}

func InitEmptyModifyStorageVolumePropertiesClauseContext(p *ModifyStorageVolumePropertiesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumePropertiesClause
}

func (*ModifyStorageVolumePropertiesClauseContext) IsModifyStorageVolumePropertiesClauseContext() {}

func NewModifyStorageVolumePropertiesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyStorageVolumePropertiesClauseContext {
	var p = new(ModifyStorageVolumePropertiesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumePropertiesClause

	return p
}

func (s *ModifyStorageVolumePropertiesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyStorageVolumePropertiesClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ModifyStorageVolumePropertiesClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyStorageVolumePropertiesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyStorageVolumePropertiesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyStorageVolumePropertiesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyStorageVolumePropertiesClause(s)
	}
}

func (s *ModifyStorageVolumePropertiesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyStorageVolumePropertiesClause(s)
	}
}

func (p *StarRocksParser) ModifyStorageVolumePropertiesClause() (localctx IModifyStorageVolumePropertiesClauseContext) {
	localctx = NewModifyStorageVolumePropertiesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, StarRocksParserRULE_modifyStorageVolumePropertiesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2539)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2540)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyStorageVolumeCommentClauseContext is an interface to support dynamic dispatch.
type IModifyStorageVolumeCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext

	// IsModifyStorageVolumeCommentClauseContext differentiates from other interfaces.
	IsModifyStorageVolumeCommentClauseContext()
}

type ModifyStorageVolumeCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyStorageVolumeCommentClauseContext() *ModifyStorageVolumeCommentClauseContext {
	var p = new(ModifyStorageVolumeCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumeCommentClause
	return p
}

func InitEmptyModifyStorageVolumeCommentClauseContext(p *ModifyStorageVolumeCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumeCommentClause
}

func (*ModifyStorageVolumeCommentClauseContext) IsModifyStorageVolumeCommentClauseContext() {}

func NewModifyStorageVolumeCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyStorageVolumeCommentClauseContext {
	var p = new(ModifyStorageVolumeCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyStorageVolumeCommentClause

	return p
}

func (s *ModifyStorageVolumeCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyStorageVolumeCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *ModifyStorageVolumeCommentClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *ModifyStorageVolumeCommentClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyStorageVolumeCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyStorageVolumeCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyStorageVolumeCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyStorageVolumeCommentClause(s)
	}
}

func (s *ModifyStorageVolumeCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyStorageVolumeCommentClause(s)
	}
}

func (p *StarRocksParser) ModifyStorageVolumeCommentClause() (localctx IModifyStorageVolumeCommentClauseContext) {
	localctx = NewModifyStorageVolumeCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, StarRocksParserRULE_modifyStorageVolumeCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2542)
		p.Match(StarRocksParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2543)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2544)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescStorageVolumeStatementContext is an interface to support dynamic dispatch.
type IDescStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsDescStorageVolumeStatementContext differentiates from other interfaces.
	IsDescStorageVolumeStatementContext()
}

type DescStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescStorageVolumeStatementContext() *DescStorageVolumeStatementContext {
	var p = new(DescStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descStorageVolumeStatement
	return p
}

func InitEmptyDescStorageVolumeStatementContext(p *DescStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descStorageVolumeStatement
}

func (*DescStorageVolumeStatementContext) IsDescStorageVolumeStatementContext() {}

func NewDescStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescStorageVolumeStatementContext {
	var p = new(DescStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_descStorageVolumeStatement

	return p
}

func (s *DescStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *DescStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *DescStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DescStorageVolumeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *DescStorageVolumeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESCRIBE, 0)
}

func (s *DescStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDescStorageVolumeStatement(s)
	}
}

func (s *DescStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDescStorageVolumeStatement(s)
	}
}

func (p *StarRocksParser) DescStorageVolumeStatement() (localctx IDescStorageVolumeStatementContext) {
	localctx = NewDescStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, StarRocksParserRULE_descStorageVolumeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2546)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDESC || _la == StarRocksParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2547)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2548)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2549)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetDefaultStorageVolumeStatementContext is an interface to support dynamic dispatch.
type ISetDefaultStorageVolumeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AS() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode

	// IsSetDefaultStorageVolumeStatementContext differentiates from other interfaces.
	IsSetDefaultStorageVolumeStatementContext()
}

type SetDefaultStorageVolumeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetDefaultStorageVolumeStatementContext() *SetDefaultStorageVolumeStatementContext {
	var p = new(SetDefaultStorageVolumeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setDefaultStorageVolumeStatement
	return p
}

func InitEmptySetDefaultStorageVolumeStatementContext(p *SetDefaultStorageVolumeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setDefaultStorageVolumeStatement
}

func (*SetDefaultStorageVolumeStatementContext) IsSetDefaultStorageVolumeStatementContext() {}

func NewSetDefaultStorageVolumeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetDefaultStorageVolumeStatementContext {
	var p = new(SetDefaultStorageVolumeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setDefaultStorageVolumeStatement

	return p
}

func (s *SetDefaultStorageVolumeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetDefaultStorageVolumeStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetDefaultStorageVolumeStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *SetDefaultStorageVolumeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultStorageVolumeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetDefaultStorageVolumeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetDefaultStorageVolumeStatement(s)
	}
}

func (s *SetDefaultStorageVolumeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetDefaultStorageVolumeStatement(s)
	}
}

func (p *StarRocksParser) SetDefaultStorageVolumeStatement() (localctx ISetDefaultStorageVolumeStatementContext) {
	localctx = NewSetDefaultStorageVolumeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, StarRocksParserRULE_setDefaultStorageVolumeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2551)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2552)
		p.IdentifierOrString()
	}
	{
		p.SetState(2553)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2554)
		p.Match(StarRocksParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2555)
		p.Match(StarRocksParserSTORAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2556)
		p.Match(StarRocksParserVOLUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateFailPointStatusStatementContext is an interface to support dynamic dispatch.
type IUpdateFailPointStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	FAILPOINT() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	DECIMAL_VALUE() antlr.TerminalNode
	PROBABILITY() antlr.TerminalNode

	// IsUpdateFailPointStatusStatementContext differentiates from other interfaces.
	IsUpdateFailPointStatusStatementContext()
}

type UpdateFailPointStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateFailPointStatusStatementContext() *UpdateFailPointStatusStatementContext {
	var p = new(UpdateFailPointStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_updateFailPointStatusStatement
	return p
}

func InitEmptyUpdateFailPointStatusStatementContext(p *UpdateFailPointStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_updateFailPointStatusStatement
}

func (*UpdateFailPointStatusStatementContext) IsUpdateFailPointStatusStatementContext() {}

func NewUpdateFailPointStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateFailPointStatusStatementContext {
	var p = new(UpdateFailPointStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_updateFailPointStatusStatement

	return p
}

func (s *UpdateFailPointStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateFailPointStatusStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *UpdateFailPointStatusStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISABLE, 0)
}

func (s *UpdateFailPointStatusStatementContext) FAILPOINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFAILPOINT, 0)
}

func (s *UpdateFailPointStatusStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *UpdateFailPointStatusStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *UpdateFailPointStatusStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *UpdateFailPointStatusStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *UpdateFailPointStatusStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENABLE, 0)
}

func (s *UpdateFailPointStatusStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *UpdateFailPointStatusStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *UpdateFailPointStatusStatementContext) TIMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMES, 0)
}

func (s *UpdateFailPointStatusStatementContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL_VALUE, 0)
}

func (s *UpdateFailPointStatusStatementContext) PROBABILITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROBABILITY, 0)
}

func (s *UpdateFailPointStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateFailPointStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateFailPointStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUpdateFailPointStatusStatement(s)
	}
}

func (s *UpdateFailPointStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUpdateFailPointStatusStatement(s)
	}
}

func (p *StarRocksParser) UpdateFailPointStatusStatement() (localctx IUpdateFailPointStatusStatementContext) {
	localctx = NewUpdateFailPointStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, StarRocksParserRULE_updateFailPointStatusStatement)
	var _la int

	p.SetState(2595)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 194, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2558)
			p.Match(StarRocksParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2559)
			p.Match(StarRocksParserDISABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2560)
			p.Match(StarRocksParserFAILPOINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2561)
			p.String_()
		}
		p.SetState(2565)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserON {
			{
				p.SetState(2562)
				p.Match(StarRocksParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2563)
				p.Match(StarRocksParserBACKEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2564)
				p.String_()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2567)
			p.Match(StarRocksParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2568)
			p.Match(StarRocksParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2569)
			p.Match(StarRocksParserFAILPOINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2570)
			p.String_()
		}
		p.SetState(2574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(2571)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2572)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2573)
				p.Match(StarRocksParserTIMES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserON {
			{
				p.SetState(2576)
				p.Match(StarRocksParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2577)
				p.Match(StarRocksParserBACKEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2578)
				p.String_()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2581)
			p.Match(StarRocksParserADMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2582)
			p.Match(StarRocksParserENABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2583)
			p.Match(StarRocksParserFAILPOINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2584)
			p.String_()
		}
		p.SetState(2588)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(2585)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2586)
				p.Match(StarRocksParserDECIMAL_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2587)
				p.Match(StarRocksParserPROBABILITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserON {
			{
				p.SetState(2590)
				p.Match(StarRocksParserON)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2591)
				p.Match(StarRocksParserBACKEND)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2592)
				p.String_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFailPointStatementContext is an interface to support dynamic dispatch.
type IShowFailPointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FAILPOINTS() antlr.TerminalNode
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	LIKE() antlr.TerminalNode

	// IsShowFailPointStatementContext differentiates from other interfaces.
	IsShowFailPointStatementContext()
}

type ShowFailPointStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowFailPointStatementContext() *ShowFailPointStatementContext {
	var p = new(ShowFailPointStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFailPointStatement
	return p
}

func InitEmptyShowFailPointStatementContext(p *ShowFailPointStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFailPointStatement
}

func (*ShowFailPointStatementContext) IsShowFailPointStatementContext() {}

func NewShowFailPointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFailPointStatementContext {
	var p = new(ShowFailPointStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showFailPointStatement

	return p
}

func (s *ShowFailPointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFailPointStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowFailPointStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowFailPointStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowFailPointStatementContext) FAILPOINTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFAILPOINTS, 0)
}

func (s *ShowFailPointStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *ShowFailPointStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *ShowFailPointStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowFailPointStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowFailPointStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowFailPointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFailPointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFailPointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowFailPointStatement(s)
	}
}

func (s *ShowFailPointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowFailPointStatement(s)
	}
}

func (p *StarRocksParser) ShowFailPointStatement() (localctx IShowFailPointStatementContext) {
	localctx = NewShowFailPointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, StarRocksParserRULE_showFailPointStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2597)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2598)
		p.Match(StarRocksParserFAILPOINTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2601)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(2599)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2600)

			var _x = p.String_()

			localctx.(*ShowFailPointStatementContext).pattern = _x
		}

	}
	p.SetState(2606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserON {
		{
			p.SetState(2603)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2604)
			p.Match(StarRocksParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2605)
			p.String_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDictionaryStatementContext is an interface to support dynamic dispatch.
type ICreateDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DictionaryName() IDictionaryNameContext
	USING() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AllDictionaryColumnDesc() []IDictionaryColumnDescContext
	DictionaryColumnDesc(i int) IDictionaryColumnDescContext
	Properties() IPropertiesContext

	// IsCreateDictionaryStatementContext differentiates from other interfaces.
	IsCreateDictionaryStatementContext()
}

type CreateDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDictionaryStatementContext() *CreateDictionaryStatementContext {
	var p = new(CreateDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDictionaryStatement
	return p
}

func InitEmptyCreateDictionaryStatementContext(p *CreateDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDictionaryStatement
}

func (*CreateDictionaryStatementContext) IsCreateDictionaryStatementContext() {}

func NewCreateDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDictionaryStatementContext {
	var p = new(CreateDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createDictionaryStatement

	return p
}

func (s *CreateDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDictionaryStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *CreateDictionaryStatementContext) DictionaryName() IDictionaryNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryNameContext)
}

func (s *CreateDictionaryStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *CreateDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateDictionaryStatementContext) AllDictionaryColumnDesc() []IDictionaryColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDictionaryColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IDictionaryColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDictionaryColumnDescContext); ok {
			tst[i] = t.(IDictionaryColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *CreateDictionaryStatementContext) DictionaryColumnDesc(i int) IDictionaryColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDictionaryColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDictionaryColumnDescContext)
}

func (s *CreateDictionaryStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateDictionaryStatement(s)
	}
}

func (s *CreateDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateDictionaryStatement(s)
	}
}

func (p *StarRocksParser) CreateDictionaryStatement() (localctx ICreateDictionaryStatementContext) {
	localctx = NewCreateDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, StarRocksParserRULE_createDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2608)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2609)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2610)
		p.DictionaryName()
	}
	{
		p.SetState(2611)
		p.Match(StarRocksParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2612)
		p.QualifiedName()
	}
	{
		p.SetState(2613)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2614)
		p.DictionaryColumnDesc()
	}
	p.SetState(2619)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2615)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2616)
			p.DictionaryColumnDesc()
		}

		p.SetState(2621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2622)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2624)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2623)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDictionaryStatementContext is an interface to support dynamic dispatch.
type IDropDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	CACHE() antlr.TerminalNode

	// IsDropDictionaryStatementContext differentiates from other interfaces.
	IsDropDictionaryStatementContext()
}

type DropDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDictionaryStatementContext() *DropDictionaryStatementContext {
	var p = new(DropDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDictionaryStatement
	return p
}

func InitEmptyDropDictionaryStatementContext(p *DropDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDictionaryStatement
}

func (*DropDictionaryStatementContext) IsDropDictionaryStatementContext() {}

func NewDropDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDictionaryStatementContext {
	var p = new(DropDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropDictionaryStatement

	return p
}

func (s *DropDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDictionaryStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *DropDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropDictionaryStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCACHE, 0)
}

func (s *DropDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropDictionaryStatement(s)
	}
}

func (s *DropDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropDictionaryStatement(s)
	}
}

func (p *StarRocksParser) DropDictionaryStatement() (localctx IDropDictionaryStatementContext) {
	localctx = NewDropDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, StarRocksParserRULE_dropDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2626)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2627)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2628)
		p.QualifiedName()
	}
	p.SetState(2630)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCACHE {
		{
			p.SetState(2629)
			p.Match(StarRocksParserCACHE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshDictionaryStatementContext is an interface to support dynamic dispatch.
type IRefreshDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsRefreshDictionaryStatementContext differentiates from other interfaces.
	IsRefreshDictionaryStatementContext()
}

type RefreshDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshDictionaryStatementContext() *RefreshDictionaryStatementContext {
	var p = new(RefreshDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshDictionaryStatement
	return p
}

func InitEmptyRefreshDictionaryStatementContext(p *RefreshDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshDictionaryStatement
}

func (*RefreshDictionaryStatementContext) IsRefreshDictionaryStatementContext() {}

func NewRefreshDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshDictionaryStatementContext {
	var p = new(RefreshDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refreshDictionaryStatement

	return p
}

func (s *RefreshDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshDictionaryStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *RefreshDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *RefreshDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RefreshDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefreshDictionaryStatement(s)
	}
}

func (s *RefreshDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefreshDictionaryStatement(s)
	}
}

func (p *StarRocksParser) RefreshDictionaryStatement() (localctx IRefreshDictionaryStatementContext) {
	localctx = NewRefreshDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, StarRocksParserRULE_refreshDictionaryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2632)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2633)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2634)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDictionaryStatementContext is an interface to support dynamic dispatch.
type IShowDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDictionaryStatementContext differentiates from other interfaces.
	IsShowDictionaryStatementContext()
}

type ShowDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDictionaryStatementContext() *ShowDictionaryStatementContext {
	var p = new(ShowDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDictionaryStatement
	return p
}

func InitEmptyShowDictionaryStatementContext(p *ShowDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDictionaryStatement
}

func (*ShowDictionaryStatementContext) IsShowDictionaryStatementContext() {}

func NewShowDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDictionaryStatementContext {
	var p = new(ShowDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDictionaryStatement

	return p
}

func (s *ShowDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDictionaryStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *ShowDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDictionaryStatement(s)
	}
}

func (s *ShowDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDictionaryStatement(s)
	}
}

func (p *StarRocksParser) ShowDictionaryStatement() (localctx IShowDictionaryStatementContext) {
	localctx = NewShowDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, StarRocksParserRULE_showDictionaryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2636)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2637)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2639)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&7557330222697660093) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-4653295000587626501) != 0) || ((int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&-3747053846437727955) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&8790990742223650807) != 0) || ((int64((_la-326)) & ^0x3f) == 0 && ((int64(1)<<(_la-326))&-5479769140411580417) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&3742173942658366679) != 0) || ((int64((_la-454)) & ^0x3f) == 0 && ((int64(1)<<(_la-454))&8856199495341) != 0) || ((int64((_la-523)) & ^0x3f) == 0 && ((int64(1)<<(_la-523))&263) != 0) {
		{
			p.SetState(2638)
			p.QualifiedName()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRefreshDictionaryStatementContext is an interface to support dynamic dispatch.
type ICancelRefreshDictionaryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsCancelRefreshDictionaryStatementContext differentiates from other interfaces.
	IsCancelRefreshDictionaryStatementContext()
}

type CancelRefreshDictionaryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelRefreshDictionaryStatementContext() *CancelRefreshDictionaryStatementContext {
	var p = new(CancelRefreshDictionaryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRefreshDictionaryStatement
	return p
}

func InitEmptyCancelRefreshDictionaryStatementContext(p *CancelRefreshDictionaryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRefreshDictionaryStatement
}

func (*CancelRefreshDictionaryStatementContext) IsCancelRefreshDictionaryStatementContext() {}

func NewCancelRefreshDictionaryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRefreshDictionaryStatementContext {
	var p = new(CancelRefreshDictionaryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelRefreshDictionaryStatement

	return p
}

func (s *CancelRefreshDictionaryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRefreshDictionaryStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelRefreshDictionaryStatementContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *CancelRefreshDictionaryStatementContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *CancelRefreshDictionaryStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelRefreshDictionaryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRefreshDictionaryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRefreshDictionaryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelRefreshDictionaryStatement(s)
	}
}

func (s *CancelRefreshDictionaryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelRefreshDictionaryStatement(s)
	}
}

func (p *StarRocksParser) CancelRefreshDictionaryStatement() (localctx ICancelRefreshDictionaryStatementContext) {
	localctx = NewCancelRefreshDictionaryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, StarRocksParserRULE_cancelRefreshDictionaryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2641)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2642)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2643)
		p.Match(StarRocksParserDICTIONARY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2644)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryColumnDescContext is an interface to support dynamic dispatch.
type IDictionaryColumnDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	KEY() antlr.TerminalNode
	VALUE() antlr.TerminalNode

	// IsDictionaryColumnDescContext differentiates from other interfaces.
	IsDictionaryColumnDescContext()
}

type DictionaryColumnDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryColumnDescContext() *DictionaryColumnDescContext {
	var p = new(DictionaryColumnDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dictionaryColumnDesc
	return p
}

func InitEmptyDictionaryColumnDescContext(p *DictionaryColumnDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dictionaryColumnDesc
}

func (*DictionaryColumnDescContext) IsDictionaryColumnDescContext() {}

func NewDictionaryColumnDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryColumnDescContext {
	var p = new(DictionaryColumnDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dictionaryColumnDesc

	return p
}

func (s *DictionaryColumnDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryColumnDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DictionaryColumnDescContext) KEY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKEY, 0)
}

func (s *DictionaryColumnDescContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUE, 0)
}

func (s *DictionaryColumnDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryColumnDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryColumnDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDictionaryColumnDesc(s)
	}
}

func (s *DictionaryColumnDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDictionaryColumnDesc(s)
	}
}

func (p *StarRocksParser) DictionaryColumnDesc() (localctx IDictionaryColumnDescContext) {
	localctx = NewDictionaryColumnDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, StarRocksParserRULE_dictionaryColumnDesc)
	p.SetState(2652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 201, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2646)
			p.QualifiedName()
		}
		{
			p.SetState(2647)
			p.Match(StarRocksParserKEY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2649)
			p.QualifiedName()
		}
		{
			p.SetState(2650)
			p.Match(StarRocksParserVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDictionaryNameContext is an interface to support dynamic dispatch.
type IDictionaryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext

	// IsDictionaryNameContext differentiates from other interfaces.
	IsDictionaryNameContext()
}

type DictionaryNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDictionaryNameContext() *DictionaryNameContext {
	var p = new(DictionaryNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dictionaryName
	return p
}

func InitEmptyDictionaryNameContext(p *DictionaryNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dictionaryName
}

func (*DictionaryNameContext) IsDictionaryNameContext() {}

func NewDictionaryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DictionaryNameContext {
	var p = new(DictionaryNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dictionaryName

	return p
}

func (s *DictionaryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DictionaryNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DictionaryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DictionaryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDictionaryName(s)
	}
}

func (s *DictionaryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDictionaryName(s)
	}
}

func (p *StarRocksParser) DictionaryName() (localctx IDictionaryNameContext) {
	localctx = NewDictionaryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, StarRocksParserRULE_dictionaryName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2654)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterClauseContext is an interface to support dynamic dispatch.
type IAlterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AddFrontendClause() IAddFrontendClauseContext
	DropFrontendClause() IDropFrontendClauseContext
	ModifyFrontendHostClause() IModifyFrontendHostClauseContext
	AddBackendClause() IAddBackendClauseContext
	DropBackendClause() IDropBackendClauseContext
	DecommissionBackendClause() IDecommissionBackendClauseContext
	ModifyBackendClause() IModifyBackendClauseContext
	AddComputeNodeClause() IAddComputeNodeClauseContext
	DropComputeNodeClause() IDropComputeNodeClauseContext
	ModifyBrokerClause() IModifyBrokerClauseContext
	AlterLoadErrorUrlClause() IAlterLoadErrorUrlClauseContext
	CreateImageClause() ICreateImageClauseContext
	CleanTabletSchedQClause() ICleanTabletSchedQClauseContext
	DecommissionDiskClause() IDecommissionDiskClauseContext
	CancelDecommissionDiskClause() ICancelDecommissionDiskClauseContext
	DisableDiskClause() IDisableDiskClauseContext
	CancelDisableDiskClause() ICancelDisableDiskClauseContext
	CreateIndexClause() ICreateIndexClauseContext
	DropIndexClause() IDropIndexClauseContext
	TableRenameClause() ITableRenameClauseContext
	SwapTableClause() ISwapTableClauseContext
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	AddColumnClause() IAddColumnClauseContext
	AddColumnsClause() IAddColumnsClauseContext
	DropColumnClause() IDropColumnClauseContext
	ModifyColumnCommentClause() IModifyColumnCommentClauseContext
	ModifyColumnClause() IModifyColumnClauseContext
	ColumnRenameClause() IColumnRenameClauseContext
	ReorderColumnsClause() IReorderColumnsClauseContext
	RollupRenameClause() IRollupRenameClauseContext
	CompactionClause() ICompactionClauseContext
	ModifyCommentClause() IModifyCommentClauseContext
	OptimizeClause() IOptimizeClauseContext
	AddFieldClause() IAddFieldClauseContext
	DropFieldClause() IDropFieldClauseContext
	CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext
	CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext
	DropBranchClause() IDropBranchClauseContext
	DropTagClause() IDropTagClauseContext
	TableOperationClause() ITableOperationClauseContext
	DropPersistentIndexClause() IDropPersistentIndexClauseContext
	AlterTableAutoIncrementClause() IAlterTableAutoIncrementClauseContext
	AddPartitionClause() IAddPartitionClauseContext
	DropPartitionClause() IDropPartitionClauseContext
	DistributionClause() IDistributionClauseContext
	AlterModifyDefaultBuckets() IAlterModifyDefaultBucketsContext
	TruncatePartitionClause() ITruncatePartitionClauseContext
	ModifyPartitionClause() IModifyPartitionClauseContext
	ReplacePartitionClause() IReplacePartitionClauseContext
	PartitionRenameClause() IPartitionRenameClauseContext

	// IsAlterClauseContext differentiates from other interfaces.
	IsAlterClauseContext()
}

type AlterClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterClauseContext() *AlterClauseContext {
	var p = new(AlterClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterClause
	return p
}

func InitEmptyAlterClauseContext(p *AlterClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterClause
}

func (*AlterClauseContext) IsAlterClauseContext() {}

func NewAlterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterClauseContext {
	var p = new(AlterClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterClause

	return p
}

func (s *AlterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterClauseContext) AddFrontendClause() IAddFrontendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFrontendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFrontendClauseContext)
}

func (s *AlterClauseContext) DropFrontendClause() IDropFrontendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFrontendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFrontendClauseContext)
}

func (s *AlterClauseContext) ModifyFrontendHostClause() IModifyFrontendHostClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyFrontendHostClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyFrontendHostClauseContext)
}

func (s *AlterClauseContext) AddBackendClause() IAddBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddBackendClauseContext)
}

func (s *AlterClauseContext) DropBackendClause() IDropBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBackendClauseContext)
}

func (s *AlterClauseContext) DecommissionBackendClause() IDecommissionBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecommissionBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecommissionBackendClauseContext)
}

func (s *AlterClauseContext) ModifyBackendClause() IModifyBackendClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyBackendClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyBackendClauseContext)
}

func (s *AlterClauseContext) AddComputeNodeClause() IAddComputeNodeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddComputeNodeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddComputeNodeClauseContext)
}

func (s *AlterClauseContext) DropComputeNodeClause() IDropComputeNodeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropComputeNodeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropComputeNodeClauseContext)
}

func (s *AlterClauseContext) ModifyBrokerClause() IModifyBrokerClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyBrokerClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyBrokerClauseContext)
}

func (s *AlterClauseContext) AlterLoadErrorUrlClause() IAlterLoadErrorUrlClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterLoadErrorUrlClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterLoadErrorUrlClauseContext)
}

func (s *AlterClauseContext) CreateImageClause() ICreateImageClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateImageClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateImageClauseContext)
}

func (s *AlterClauseContext) CleanTabletSchedQClause() ICleanTabletSchedQClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICleanTabletSchedQClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICleanTabletSchedQClauseContext)
}

func (s *AlterClauseContext) DecommissionDiskClause() IDecommissionDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecommissionDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecommissionDiskClauseContext)
}

func (s *AlterClauseContext) CancelDecommissionDiskClause() ICancelDecommissionDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelDecommissionDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelDecommissionDiskClauseContext)
}

func (s *AlterClauseContext) DisableDiskClause() IDisableDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisableDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisableDiskClauseContext)
}

func (s *AlterClauseContext) CancelDisableDiskClause() ICancelDisableDiskClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelDisableDiskClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelDisableDiskClauseContext)
}

func (s *AlterClauseContext) CreateIndexClause() ICreateIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateIndexClauseContext)
}

func (s *AlterClauseContext) DropIndexClause() IDropIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropIndexClauseContext)
}

func (s *AlterClauseContext) TableRenameClause() ITableRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRenameClauseContext)
}

func (s *AlterClauseContext) SwapTableClause() ISwapTableClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISwapTableClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISwapTableClauseContext)
}

func (s *AlterClauseContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterClauseContext) AddColumnClause() IAddColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddColumnClauseContext)
}

func (s *AlterClauseContext) AddColumnsClause() IAddColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddColumnsClauseContext)
}

func (s *AlterClauseContext) DropColumnClause() IDropColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropColumnClauseContext)
}

func (s *AlterClauseContext) ModifyColumnCommentClause() IModifyColumnCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyColumnCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyColumnCommentClauseContext)
}

func (s *AlterClauseContext) ModifyColumnClause() IModifyColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyColumnClauseContext)
}

func (s *AlterClauseContext) ColumnRenameClause() IColumnRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRenameClauseContext)
}

func (s *AlterClauseContext) ReorderColumnsClause() IReorderColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReorderColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReorderColumnsClauseContext)
}

func (s *AlterClauseContext) RollupRenameClause() IRollupRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRollupRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRollupRenameClauseContext)
}

func (s *AlterClauseContext) CompactionClause() ICompactionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompactionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompactionClauseContext)
}

func (s *AlterClauseContext) ModifyCommentClause() IModifyCommentClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyCommentClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyCommentClauseContext)
}

func (s *AlterClauseContext) OptimizeClause() IOptimizeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeClauseContext)
}

func (s *AlterClauseContext) AddFieldClause() IAddFieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFieldClauseContext)
}

func (s *AlterClauseContext) DropFieldClause() IDropFieldClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropFieldClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropFieldClauseContext)
}

func (s *AlterClauseContext) CreateOrReplaceBranchClause() ICreateOrReplaceBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceBranchClauseContext)
}

func (s *AlterClauseContext) CreateOrReplaceTagClause() ICreateOrReplaceTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateOrReplaceTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateOrReplaceTagClauseContext)
}

func (s *AlterClauseContext) DropBranchClause() IDropBranchClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropBranchClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropBranchClauseContext)
}

func (s *AlterClauseContext) DropTagClause() IDropTagClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropTagClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropTagClauseContext)
}

func (s *AlterClauseContext) TableOperationClause() ITableOperationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableOperationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableOperationClauseContext)
}

func (s *AlterClauseContext) DropPersistentIndexClause() IDropPersistentIndexClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPersistentIndexClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPersistentIndexClauseContext)
}

func (s *AlterClauseContext) AlterTableAutoIncrementClause() IAlterTableAutoIncrementClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterTableAutoIncrementClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterTableAutoIncrementClauseContext)
}

func (s *AlterClauseContext) AddPartitionClause() IAddPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddPartitionClauseContext)
}

func (s *AlterClauseContext) DropPartitionClause() IDropPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropPartitionClauseContext)
}

func (s *AlterClauseContext) DistributionClause() IDistributionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionClauseContext)
}

func (s *AlterClauseContext) AlterModifyDefaultBuckets() IAlterModifyDefaultBucketsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterModifyDefaultBucketsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterModifyDefaultBucketsContext)
}

func (s *AlterClauseContext) TruncatePartitionClause() ITruncatePartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITruncatePartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITruncatePartitionClauseContext)
}

func (s *AlterClauseContext) ModifyPartitionClause() IModifyPartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPartitionClauseContext)
}

func (s *AlterClauseContext) ReplacePartitionClause() IReplacePartitionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePartitionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePartitionClauseContext)
}

func (s *AlterClauseContext) PartitionRenameClause() IPartitionRenameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionRenameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionRenameClauseContext)
}

func (s *AlterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterClause(s)
	}
}

func (s *AlterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterClause(s)
	}
}

func (p *StarRocksParser) AlterClause() (localctx IAlterClauseContext) {
	localctx = NewAlterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, StarRocksParserRULE_alterClause)
	p.SetState(2706)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 202, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2656)
			p.AddFrontendClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2657)
			p.DropFrontendClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2658)
			p.ModifyFrontendHostClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2659)
			p.AddBackendClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2660)
			p.DropBackendClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2661)
			p.DecommissionBackendClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2662)
			p.ModifyBackendClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2663)
			p.AddComputeNodeClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2664)
			p.DropComputeNodeClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2665)
			p.ModifyBrokerClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2666)
			p.AlterLoadErrorUrlClause()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2667)
			p.CreateImageClause()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2668)
			p.CleanTabletSchedQClause()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2669)
			p.DecommissionDiskClause()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(2670)
			p.CancelDecommissionDiskClause()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(2671)
			p.DisableDiskClause()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(2672)
			p.CancelDisableDiskClause()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(2673)
			p.CreateIndexClause()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(2674)
			p.DropIndexClause()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(2675)
			p.TableRenameClause()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(2676)
			p.SwapTableClause()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(2677)
			p.ModifyPropertiesClause()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(2678)
			p.AddColumnClause()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(2679)
			p.AddColumnsClause()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(2680)
			p.DropColumnClause()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(2681)
			p.ModifyColumnCommentClause()
		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(2682)
			p.ModifyColumnClause()
		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(2683)
			p.ColumnRenameClause()
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(2684)
			p.ReorderColumnsClause()
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(2685)
			p.RollupRenameClause()
		}

	case 31:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(2686)
			p.CompactionClause()
		}

	case 32:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(2687)
			p.ModifyCommentClause()
		}

	case 33:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(2688)
			p.OptimizeClause()
		}

	case 34:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(2689)
			p.AddFieldClause()
		}

	case 35:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(2690)
			p.DropFieldClause()
		}

	case 36:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(2691)
			p.CreateOrReplaceBranchClause()
		}

	case 37:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(2692)
			p.CreateOrReplaceTagClause()
		}

	case 38:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(2693)
			p.DropBranchClause()
		}

	case 39:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(2694)
			p.DropTagClause()
		}

	case 40:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(2695)
			p.TableOperationClause()
		}

	case 41:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(2696)
			p.DropPersistentIndexClause()
		}

	case 42:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(2697)
			p.AlterTableAutoIncrementClause()
		}

	case 43:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(2698)
			p.AddPartitionClause()
		}

	case 44:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(2699)
			p.DropPartitionClause()
		}

	case 45:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(2700)
			p.DistributionClause()
		}

	case 46:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(2701)
			p.AlterModifyDefaultBuckets()
		}

	case 47:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(2702)
			p.TruncatePartitionClause()
		}

	case 48:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(2703)
			p.ModifyPartitionClause()
		}

	case 49:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(2704)
			p.ReplacePartitionClause()
		}

	case 50:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(2705)
			p.PartitionRenameClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddFrontendClauseContext is an interface to support dynamic dispatch.
type IAddFrontendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	String_() IStringContext
	FOLLOWER() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode

	// IsAddFrontendClauseContext differentiates from other interfaces.
	IsAddFrontendClauseContext()
}

type AddFrontendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFrontendClauseContext() *AddFrontendClauseContext {
	var p = new(AddFrontendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addFrontendClause
	return p
}

func InitEmptyAddFrontendClauseContext(p *AddFrontendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addFrontendClause
}

func (*AddFrontendClauseContext) IsAddFrontendClauseContext() {}

func NewAddFrontendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFrontendClauseContext {
	var p = new(AddFrontendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addFrontendClause

	return p
}

func (s *AddFrontendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFrontendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddFrontendClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddFrontendClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWER, 0)
}

func (s *AddFrontendClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOBSERVER, 0)
}

func (s *AddFrontendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFrontendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFrontendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddFrontendClause(s)
	}
}

func (s *AddFrontendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddFrontendClause(s)
	}
}

func (p *StarRocksParser) AddFrontendClause() (localctx IAddFrontendClauseContext) {
	localctx = NewAddFrontendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, StarRocksParserRULE_addFrontendClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2708)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2709)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFOLLOWER || _la == StarRocksParserOBSERVER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2710)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFrontendClauseContext is an interface to support dynamic dispatch.
type IDropFrontendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	String_() IStringContext
	FOLLOWER() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode

	// IsDropFrontendClauseContext differentiates from other interfaces.
	IsDropFrontendClauseContext()
}

type DropFrontendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFrontendClauseContext() *DropFrontendClauseContext {
	var p = new(DropFrontendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFrontendClause
	return p
}

func InitEmptyDropFrontendClauseContext(p *DropFrontendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFrontendClause
}

func (*DropFrontendClauseContext) IsDropFrontendClauseContext() {}

func NewDropFrontendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFrontendClauseContext {
	var p = new(DropFrontendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropFrontendClause

	return p
}

func (s *DropFrontendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFrontendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropFrontendClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropFrontendClauseContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWER, 0)
}

func (s *DropFrontendClauseContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOBSERVER, 0)
}

func (s *DropFrontendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFrontendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFrontendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropFrontendClause(s)
	}
}

func (s *DropFrontendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropFrontendClause(s)
	}
}

func (p *StarRocksParser) DropFrontendClause() (localctx IDropFrontendClauseContext) {
	localctx = NewDropFrontendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, StarRocksParserRULE_dropFrontendClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2712)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2713)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFOLLOWER || _la == StarRocksParserOBSERVER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2714)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyFrontendHostClauseContext is an interface to support dynamic dispatch.
type IModifyFrontendHostClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	HOST() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	TO() antlr.TerminalNode

	// IsModifyFrontendHostClauseContext differentiates from other interfaces.
	IsModifyFrontendHostClauseContext()
}

type ModifyFrontendHostClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyFrontendHostClauseContext() *ModifyFrontendHostClauseContext {
	var p = new(ModifyFrontendHostClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyFrontendHostClause
	return p
}

func InitEmptyModifyFrontendHostClauseContext(p *ModifyFrontendHostClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyFrontendHostClause
}

func (*ModifyFrontendHostClauseContext) IsModifyFrontendHostClauseContext() {}

func NewModifyFrontendHostClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyFrontendHostClauseContext {
	var p = new(ModifyFrontendHostClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyFrontendHostClause

	return p
}

func (s *ModifyFrontendHostClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyFrontendHostClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *ModifyFrontendHostClauseContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *ModifyFrontendHostClauseContext) HOST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOST, 0)
}

func (s *ModifyFrontendHostClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyFrontendHostClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyFrontendHostClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *ModifyFrontendHostClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyFrontendHostClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyFrontendHostClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyFrontendHostClause(s)
	}
}

func (s *ModifyFrontendHostClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyFrontendHostClause(s)
	}
}

func (p *StarRocksParser) ModifyFrontendHostClause() (localctx IModifyFrontendHostClauseContext) {
	localctx = NewModifyFrontendHostClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, StarRocksParserRULE_modifyFrontendHostClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2716)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2717)
		p.Match(StarRocksParserFRONTEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2718)
		p.Match(StarRocksParserHOST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2719)
		p.String_()
	}
	{
		p.SetState(2720)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2721)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddBackendClauseContext is an interface to support dynamic dispatch.
type IAddBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	INTO() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsAddBackendClauseContext differentiates from other interfaces.
	IsAddBackendClauseContext()
}

type AddBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyAddBackendClauseContext() *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addBackendClause
	return p
}

func InitEmptyAddBackendClauseContext(p *AddBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addBackendClause
}

func (*AddBackendClauseContext) IsAddBackendClauseContext() {}

func NewAddBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddBackendClauseContext {
	var p = new(AddBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addBackendClause

	return p
}

func (s *AddBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddBackendClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AddBackendClauseContext) SetWarehouseName(v IIdentifierOrStringContext) { s.warehouseName = v }

func (s *AddBackendClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *AddBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *AddBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddBackendClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *AddBackendClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *AddBackendClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AddBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddBackendClause(s)
	}
}

func (s *AddBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddBackendClause(s)
	}
}

func (p *StarRocksParser) AddBackendClause() (localctx IAddBackendClauseContext) {
	localctx = NewAddBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, StarRocksParserRULE_addBackendClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2723)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2724)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2725)
		p.String_()
	}
	p.SetState(2730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2726)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2727)
				p.String_()
			}

		}
		p.SetState(2732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 203, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2736)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserINTO {
		{
			p.SetState(2733)
			p.Match(StarRocksParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2734)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2735)

			var _x = p.IdentifierOrString()

			localctx.(*AddBackendClauseContext).warehouseName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBackendClauseContext is an interface to support dynamic dispatch.
type IDropBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsDropBackendClauseContext differentiates from other interfaces.
	IsDropBackendClauseContext()
}

type DropBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyDropBackendClauseContext() *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBackendClause
	return p
}

func InitEmptyDropBackendClauseContext(p *DropBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBackendClause
}

func (*DropBackendClauseContext) IsDropBackendClauseContext() {}

func NewDropBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBackendClauseContext {
	var p = new(DropBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropBackendClause

	return p
}

func (s *DropBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBackendClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropBackendClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropBackendClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DropBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DropBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropBackendClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DropBackendClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *DropBackendClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropBackendClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropBackendClause(s)
	}
}

func (s *DropBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropBackendClause(s)
	}
}

func (p *StarRocksParser) DropBackendClause() (localctx IDropBackendClauseContext) {
	localctx = NewDropBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, StarRocksParserRULE_dropBackendClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2738)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2739)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2740)
		p.String_()
	}
	p.SetState(2745)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2741)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2742)
				p.String_()
			}

		}
		p.SetState(2747)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 205, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2751)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(2748)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2749)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2750)

			var _x = p.IdentifierOrString()

			localctx.(*DropBackendClauseContext).warehouseName = _x
		}

	}
	p.SetState(2754)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORCE {
		{
			p.SetState(2753)
			p.Match(StarRocksParserFORCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecommissionBackendClauseContext is an interface to support dynamic dispatch.
type IDecommissionBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECOMMISSION() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsDecommissionBackendClauseContext differentiates from other interfaces.
	IsDecommissionBackendClauseContext()
}

type DecommissionBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecommissionBackendClauseContext() *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decommissionBackendClause
	return p
}

func InitEmptyDecommissionBackendClauseContext(p *DecommissionBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decommissionBackendClause
}

func (*DecommissionBackendClauseContext) IsDecommissionBackendClauseContext() {}

func NewDecommissionBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecommissionBackendClauseContext {
	var p = new(DecommissionBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_decommissionBackendClause

	return p
}

func (s *DecommissionBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecommissionBackendClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *DecommissionBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DecommissionBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DecommissionBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DecommissionBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecommissionBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDecommissionBackendClause(s)
	}
}

func (s *DecommissionBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDecommissionBackendClause(s)
	}
}

func (p *StarRocksParser) DecommissionBackendClause() (localctx IDecommissionBackendClauseContext) {
	localctx = NewDecommissionBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, StarRocksParserRULE_decommissionBackendClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2756)
		p.Match(StarRocksParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2757)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2758)
		p.String_()
	}
	p.SetState(2763)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2759)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2760)
				p.String_()
			}

		}
		p.SetState(2765)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 208, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyBackendClauseContext is an interface to support dynamic dispatch.
type IModifyBackendClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	HOST() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	TO() antlr.TerminalNode
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyBackendClauseContext differentiates from other interfaces.
	IsModifyBackendClauseContext()
}

type ModifyBackendClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyBackendClauseContext() *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyBackendClause
	return p
}

func InitEmptyModifyBackendClauseContext(p *ModifyBackendClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyBackendClause
}

func (*ModifyBackendClauseContext) IsModifyBackendClauseContext() {}

func NewModifyBackendClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyBackendClauseContext {
	var p = new(ModifyBackendClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyBackendClause

	return p
}

func (s *ModifyBackendClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyBackendClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *ModifyBackendClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *ModifyBackendClauseContext) HOST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOST, 0)
}

func (s *ModifyBackendClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyBackendClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyBackendClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *ModifyBackendClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ModifyBackendClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyBackendClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBackendClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyBackendClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyBackendClause(s)
	}
}

func (s *ModifyBackendClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyBackendClause(s)
	}
}

func (p *StarRocksParser) ModifyBackendClause() (localctx IModifyBackendClauseContext) {
	localctx = NewModifyBackendClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, StarRocksParserRULE_modifyBackendClause)
	p.SetState(2779)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 209, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2766)
			p.Match(StarRocksParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2767)
			p.Match(StarRocksParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2768)
			p.Match(StarRocksParserHOST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2769)
			p.String_()
		}
		{
			p.SetState(2770)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2771)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2773)
			p.Match(StarRocksParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2774)
			p.Match(StarRocksParserBACKEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2775)
			p.String_()
		}
		{
			p.SetState(2776)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2777)
			p.PropertyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddComputeNodeClauseContext is an interface to support dynamic dispatch.
type IAddComputeNodeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	INTO() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsAddComputeNodeClauseContext differentiates from other interfaces.
	IsAddComputeNodeClauseContext()
}

type AddComputeNodeClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyAddComputeNodeClauseContext() *AddComputeNodeClauseContext {
	var p = new(AddComputeNodeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addComputeNodeClause
	return p
}

func InitEmptyAddComputeNodeClauseContext(p *AddComputeNodeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addComputeNodeClause
}

func (*AddComputeNodeClauseContext) IsAddComputeNodeClauseContext() {}

func NewAddComputeNodeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddComputeNodeClauseContext {
	var p = new(AddComputeNodeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addComputeNodeClause

	return p
}

func (s *AddComputeNodeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddComputeNodeClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AddComputeNodeClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AddComputeNodeClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddComputeNodeClauseContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPUTE, 0)
}

func (s *AddComputeNodeClauseContext) NODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODE, 0)
}

func (s *AddComputeNodeClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *AddComputeNodeClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddComputeNodeClauseContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *AddComputeNodeClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *AddComputeNodeClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AddComputeNodeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddComputeNodeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddComputeNodeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddComputeNodeClause(s)
	}
}

func (s *AddComputeNodeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddComputeNodeClause(s)
	}
}

func (p *StarRocksParser) AddComputeNodeClause() (localctx IAddComputeNodeClauseContext) {
	localctx = NewAddComputeNodeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, StarRocksParserRULE_addComputeNodeClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2781)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2782)
		p.Match(StarRocksParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2783)
		p.Match(StarRocksParserNODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2784)
		p.String_()
	}
	p.SetState(2789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2785)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2786)
				p.String_()
			}

		}
		p.SetState(2791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 210, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2795)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserINTO {
		{
			p.SetState(2792)
			p.Match(StarRocksParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2793)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2794)

			var _x = p.IdentifierOrString()

			localctx.(*AddComputeNodeClauseContext).warehouseName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropComputeNodeClauseContext is an interface to support dynamic dispatch.
type IDropComputeNodeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	NODE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsDropComputeNodeClauseContext differentiates from other interfaces.
	IsDropComputeNodeClauseContext()
}

type DropComputeNodeClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyDropComputeNodeClauseContext() *DropComputeNodeClauseContext {
	var p = new(DropComputeNodeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropComputeNodeClause
	return p
}

func InitEmptyDropComputeNodeClauseContext(p *DropComputeNodeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropComputeNodeClause
}

func (*DropComputeNodeClauseContext) IsDropComputeNodeClauseContext() {}

func NewDropComputeNodeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropComputeNodeClauseContext {
	var p = new(DropComputeNodeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropComputeNodeClause

	return p
}

func (s *DropComputeNodeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropComputeNodeClauseContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropComputeNodeClauseContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropComputeNodeClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropComputeNodeClauseContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPUTE, 0)
}

func (s *DropComputeNodeClauseContext) NODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODE, 0)
}

func (s *DropComputeNodeClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DropComputeNodeClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropComputeNodeClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DropComputeNodeClauseContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *DropComputeNodeClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropComputeNodeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropComputeNodeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropComputeNodeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropComputeNodeClause(s)
	}
}

func (s *DropComputeNodeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropComputeNodeClause(s)
	}
}

func (p *StarRocksParser) DropComputeNodeClause() (localctx IDropComputeNodeClauseContext) {
	localctx = NewDropComputeNodeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, StarRocksParserRULE_dropComputeNodeClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2797)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2798)
		p.Match(StarRocksParserCOMPUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2799)
		p.Match(StarRocksParserNODE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2800)
		p.String_()
	}
	p.SetState(2805)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(2801)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2802)
				p.String_()
			}

		}
		p.SetState(2807)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 212, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(2811)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(2808)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2809)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2810)

			var _x = p.IdentifierOrString()

			localctx.(*DropComputeNodeClauseContext).warehouseName = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyBrokerClauseContext is an interface to support dynamic dispatch.
type IModifyBrokerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	AllString_() []IStringContext
	String_(i int) IStringContext
	DROP() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsModifyBrokerClauseContext differentiates from other interfaces.
	IsModifyBrokerClauseContext()
}

type ModifyBrokerClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyBrokerClauseContext() *ModifyBrokerClauseContext {
	var p = new(ModifyBrokerClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyBrokerClause
	return p
}

func InitEmptyModifyBrokerClauseContext(p *ModifyBrokerClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyBrokerClause
}

func (*ModifyBrokerClauseContext) IsModifyBrokerClauseContext() {}

func NewModifyBrokerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyBrokerClauseContext {
	var p = new(ModifyBrokerClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyBrokerClause

	return p
}

func (s *ModifyBrokerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyBrokerClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *ModifyBrokerClauseContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *ModifyBrokerClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ModifyBrokerClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ModifyBrokerClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyBrokerClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *ModifyBrokerClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ModifyBrokerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyBrokerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyBrokerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyBrokerClause(s)
	}
}

func (s *ModifyBrokerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyBrokerClause(s)
	}
}

func (p *StarRocksParser) ModifyBrokerClause() (localctx IModifyBrokerClauseContext) {
	localctx = NewModifyBrokerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, StarRocksParserRULE_modifyBrokerClause)
	var _alt int

	p.SetState(2839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 216, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2813)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2814)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2815)
			p.IdentifierOrString()
		}
		{
			p.SetState(2816)
			p.String_()
		}
		p.SetState(2821)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2817)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2818)
					p.String_()
				}

			}
			p.SetState(2823)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 214, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2824)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2825)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2826)
			p.IdentifierOrString()
		}
		{
			p.SetState(2827)
			p.String_()
		}
		p.SetState(2832)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(2828)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2829)
					p.String_()
				}

			}
			p.SetState(2834)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 215, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2835)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2836)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2837)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2838)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLoadErrorUrlClauseContext is an interface to support dynamic dispatch.
type IAlterLoadErrorUrlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAlterLoadErrorUrlClauseContext differentiates from other interfaces.
	IsAlterLoadErrorUrlClauseContext()
}

type AlterLoadErrorUrlClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterLoadErrorUrlClauseContext() *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterLoadErrorUrlClause
	return p
}

func InitEmptyAlterLoadErrorUrlClauseContext(p *AlterLoadErrorUrlClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterLoadErrorUrlClause
}

func (*AlterLoadErrorUrlClauseContext) IsAlterLoadErrorUrlClauseContext() {}

func NewAlterLoadErrorUrlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLoadErrorUrlClauseContext {
	var p = new(AlterLoadErrorUrlClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterLoadErrorUrlClause

	return p
}

func (s *AlterLoadErrorUrlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLoadErrorUrlClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterLoadErrorUrlClauseContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *AlterLoadErrorUrlClauseContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserERRORS, 0)
}

func (s *AlterLoadErrorUrlClauseContext) HUB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHUB, 0)
}

func (s *AlterLoadErrorUrlClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterLoadErrorUrlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadErrorUrlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLoadErrorUrlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterLoadErrorUrlClause(s)
	}
}

func (s *AlterLoadErrorUrlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterLoadErrorUrlClause(s)
	}
}

func (p *StarRocksParser) AlterLoadErrorUrlClause() (localctx IAlterLoadErrorUrlClauseContext) {
	localctx = NewAlterLoadErrorUrlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, StarRocksParserRULE_alterLoadErrorUrlClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2841)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2842)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2843)
		p.Match(StarRocksParserERRORS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2844)
		p.Match(StarRocksParserHUB)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2845)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateImageClauseContext is an interface to support dynamic dispatch.
type ICreateImageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	IMAGE() antlr.TerminalNode

	// IsCreateImageClauseContext differentiates from other interfaces.
	IsCreateImageClauseContext()
}

type CreateImageClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateImageClauseContext() *CreateImageClauseContext {
	var p = new(CreateImageClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createImageClause
	return p
}

func InitEmptyCreateImageClauseContext(p *CreateImageClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createImageClause
}

func (*CreateImageClauseContext) IsCreateImageClauseContext() {}

func NewCreateImageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateImageClauseContext {
	var p = new(CreateImageClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createImageClause

	return p
}

func (s *CreateImageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateImageClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateImageClauseContext) IMAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMAGE, 0)
}

func (s *CreateImageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateImageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateImageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateImageClause(s)
	}
}

func (s *CreateImageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateImageClause(s)
	}
}

func (p *StarRocksParser) CreateImageClause() (localctx ICreateImageClauseContext) {
	localctx = NewCreateImageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, StarRocksParserRULE_createImageClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2848)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2849)
		p.Match(StarRocksParserIMAGE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICleanTabletSchedQClauseContext is an interface to support dynamic dispatch.
type ICleanTabletSchedQClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAN() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	QUEUE() antlr.TerminalNode

	// IsCleanTabletSchedQClauseContext differentiates from other interfaces.
	IsCleanTabletSchedQClauseContext()
}

type CleanTabletSchedQClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCleanTabletSchedQClauseContext() *CleanTabletSchedQClauseContext {
	var p = new(CleanTabletSchedQClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cleanTabletSchedQClause
	return p
}

func InitEmptyCleanTabletSchedQClauseContext(p *CleanTabletSchedQClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cleanTabletSchedQClause
}

func (*CleanTabletSchedQClauseContext) IsCleanTabletSchedQClauseContext() {}

func NewCleanTabletSchedQClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CleanTabletSchedQClauseContext {
	var p = new(CleanTabletSchedQClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cleanTabletSchedQClause

	return p
}

func (s *CleanTabletSchedQClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CleanTabletSchedQClauseContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAN, 0)
}

func (s *CleanTabletSchedQClauseContext) TABLET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLET, 0)
}

func (s *CleanTabletSchedQClauseContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULER, 0)
}

func (s *CleanTabletSchedQClauseContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUEUE, 0)
}

func (s *CleanTabletSchedQClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CleanTabletSchedQClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CleanTabletSchedQClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCleanTabletSchedQClause(s)
	}
}

func (s *CleanTabletSchedQClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCleanTabletSchedQClause(s)
	}
}

func (p *StarRocksParser) CleanTabletSchedQClause() (localctx ICleanTabletSchedQClauseContext) {
	localctx = NewCleanTabletSchedQClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, StarRocksParserRULE_cleanTabletSchedQClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2851)
		p.Match(StarRocksParserCLEAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2852)
		p.Match(StarRocksParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2853)
		p.Match(StarRocksParserSCHEDULER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2854)
		p.Match(StarRocksParserQUEUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecommissionDiskClauseContext is an interface to support dynamic dispatch.
type IDecommissionDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DECOMMISSION() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsDecommissionDiskClauseContext differentiates from other interfaces.
	IsDecommissionDiskClauseContext()
}

type DecommissionDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecommissionDiskClauseContext() *DecommissionDiskClauseContext {
	var p = new(DecommissionDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decommissionDiskClause
	return p
}

func InitEmptyDecommissionDiskClauseContext(p *DecommissionDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decommissionDiskClause
}

func (*DecommissionDiskClauseContext) IsDecommissionDiskClauseContext() {}

func NewDecommissionDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecommissionDiskClauseContext {
	var p = new(DecommissionDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_decommissionDiskClause

	return p
}

func (s *DecommissionDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecommissionDiskClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *DecommissionDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *DecommissionDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DecommissionDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DecommissionDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DecommissionDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DecommissionDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecommissionDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecommissionDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDecommissionDiskClause(s)
	}
}

func (s *DecommissionDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDecommissionDiskClause(s)
	}
}

func (p *StarRocksParser) DecommissionDiskClause() (localctx IDecommissionDiskClauseContext) {
	localctx = NewDecommissionDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, StarRocksParserRULE_decommissionDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2856)
		p.Match(StarRocksParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2857)
		p.Match(StarRocksParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2858)
		p.String_()
	}
	p.SetState(2863)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2859)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2860)
			p.String_()
		}

		p.SetState(2865)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2866)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2867)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2868)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelDecommissionDiskClauseContext is an interface to support dynamic dispatch.
type ICancelDecommissionDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsCancelDecommissionDiskClauseContext differentiates from other interfaces.
	IsCancelDecommissionDiskClauseContext()
}

type CancelDecommissionDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelDecommissionDiskClauseContext() *CancelDecommissionDiskClauseContext {
	var p = new(CancelDecommissionDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelDecommissionDiskClause
	return p
}

func InitEmptyCancelDecommissionDiskClauseContext(p *CancelDecommissionDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelDecommissionDiskClause
}

func (*CancelDecommissionDiskClauseContext) IsCancelDecommissionDiskClauseContext() {}

func NewCancelDecommissionDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelDecommissionDiskClauseContext {
	var p = new(CancelDecommissionDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelDecommissionDiskClause

	return p
}

func (s *CancelDecommissionDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelDecommissionDiskClauseContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelDecommissionDiskClauseContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *CancelDecommissionDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *CancelDecommissionDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelDecommissionDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelDecommissionDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CancelDecommissionDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *CancelDecommissionDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDecommissionDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelDecommissionDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelDecommissionDiskClause(s)
	}
}

func (s *CancelDecommissionDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelDecommissionDiskClause(s)
	}
}

func (p *StarRocksParser) CancelDecommissionDiskClause() (localctx ICancelDecommissionDiskClauseContext) {
	localctx = NewCancelDecommissionDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, StarRocksParserRULE_cancelDecommissionDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2870)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2871)
		p.Match(StarRocksParserDECOMMISSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2872)
		p.Match(StarRocksParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2873)
		p.String_()
	}
	p.SetState(2878)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2874)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2875)
			p.String_()
		}

		p.SetState(2880)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2881)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2882)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2883)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDisableDiskClauseContext is an interface to support dynamic dispatch.
type IDisableDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsDisableDiskClauseContext differentiates from other interfaces.
	IsDisableDiskClauseContext()
}

type DisableDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisableDiskClauseContext() *DisableDiskClauseContext {
	var p = new(DisableDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_disableDiskClause
	return p
}

func InitEmptyDisableDiskClauseContext(p *DisableDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_disableDiskClause
}

func (*DisableDiskClauseContext) IsDisableDiskClauseContext() {}

func NewDisableDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableDiskClauseContext {
	var p = new(DisableDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_disableDiskClause

	return p
}

func (s *DisableDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableDiskClauseContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISABLE, 0)
}

func (s *DisableDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *DisableDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DisableDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DisableDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DisableDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DisableDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDisableDiskClause(s)
	}
}

func (s *DisableDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDisableDiskClause(s)
	}
}

func (p *StarRocksParser) DisableDiskClause() (localctx IDisableDiskClauseContext) {
	localctx = NewDisableDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, StarRocksParserRULE_disableDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2885)
		p.Match(StarRocksParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2886)
		p.Match(StarRocksParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2887)
		p.String_()
	}
	p.SetState(2892)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2888)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2889)
			p.String_()
		}

		p.SetState(2894)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2895)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2896)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2897)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelDisableDiskClauseContext is an interface to support dynamic dispatch.
type ICancelDisableDiskClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	ON() antlr.TerminalNode
	BACKEND() antlr.TerminalNode

	// IsCancelDisableDiskClauseContext differentiates from other interfaces.
	IsCancelDisableDiskClauseContext()
}

type CancelDisableDiskClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelDisableDiskClauseContext() *CancelDisableDiskClauseContext {
	var p = new(CancelDisableDiskClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelDisableDiskClause
	return p
}

func InitEmptyCancelDisableDiskClauseContext(p *CancelDisableDiskClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelDisableDiskClause
}

func (*CancelDisableDiskClauseContext) IsCancelDisableDiskClauseContext() {}

func NewCancelDisableDiskClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelDisableDiskClauseContext {
	var p = new(CancelDisableDiskClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelDisableDiskClause

	return p
}

func (s *CancelDisableDiskClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelDisableDiskClauseContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelDisableDiskClauseContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISABLE, 0)
}

func (s *CancelDisableDiskClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *CancelDisableDiskClauseContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *CancelDisableDiskClauseContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelDisableDiskClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CancelDisableDiskClauseContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *CancelDisableDiskClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelDisableDiskClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelDisableDiskClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelDisableDiskClause(s)
	}
}

func (s *CancelDisableDiskClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelDisableDiskClause(s)
	}
}

func (p *StarRocksParser) CancelDisableDiskClause() (localctx ICancelDisableDiskClauseContext) {
	localctx = NewCancelDisableDiskClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, StarRocksParserRULE_cancelDisableDiskClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2899)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2900)
		p.Match(StarRocksParserDISABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2901)
		p.Match(StarRocksParserDISK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2902)
		p.String_()
	}
	p.SetState(2907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2903)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2904)
			p.String_()
		}

		p.SetState(2909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2910)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2911)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2912)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateIndexClauseContext is an interface to support dynamic dispatch.
type ICreateIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	Identifier() IIdentifierContext
	IndexType() IIndexTypeContext
	Comment() ICommentContext
	PropertyList() IPropertyListContext

	// IsCreateIndexClauseContext differentiates from other interfaces.
	IsCreateIndexClauseContext()
}

type CreateIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyCreateIndexClauseContext() *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createIndexClause
	return p
}

func InitEmptyCreateIndexClauseContext(p *CreateIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createIndexClause
}

func (*CreateIndexClauseContext) IsCreateIndexClauseContext() {}

func NewCreateIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateIndexClauseContext {
	var p = new(CreateIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createIndexClause

	return p
}

func (s *CreateIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateIndexClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *CreateIndexClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *CreateIndexClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *CreateIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *CreateIndexClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CreateIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateIndexClauseContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *CreateIndexClauseContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateIndexClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateIndexClause(s)
	}
}

func (s *CreateIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateIndexClause(s)
	}
}

func (p *StarRocksParser) CreateIndexClause() (localctx ICreateIndexClauseContext) {
	localctx = NewCreateIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, StarRocksParserRULE_createIndexClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2914)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2915)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2916)

		var _x = p.Identifier()

		localctx.(*CreateIndexClauseContext).indexName = _x
	}
	{
		p.SetState(2917)
		p.IdentifierList()
	}
	p.SetState(2922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(2918)
			p.IndexType()
		}
		p.SetState(2920)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(2919)
				p.PropertyList()
			}

		}

	}
	p.SetState(2925)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(2924)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropIndexClauseContext is an interface to support dynamic dispatch.
type IDropIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetIndexName returns the indexName rule contexts.
	GetIndexName() IIdentifierContext

	// SetIndexName sets the indexName rule contexts.
	SetIndexName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropIndexClauseContext differentiates from other interfaces.
	IsDropIndexClauseContext()
}

type DropIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	indexName IIdentifierContext
}

func NewEmptyDropIndexClauseContext() *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropIndexClause
	return p
}

func InitEmptyDropIndexClauseContext(p *DropIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropIndexClause
}

func (*DropIndexClauseContext) IsDropIndexClauseContext() {}

func NewDropIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropIndexClauseContext {
	var p = new(DropIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropIndexClause

	return p
}

func (s *DropIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropIndexClauseContext) GetIndexName() IIdentifierContext { return s.indexName }

func (s *DropIndexClauseContext) SetIndexName(v IIdentifierContext) { s.indexName = v }

func (s *DropIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *DropIndexClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropIndexClause(s)
	}
}

func (s *DropIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropIndexClause(s)
	}
}

func (p *StarRocksParser) DropIndexClause() (localctx IDropIndexClauseContext) {
	localctx = NewDropIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, StarRocksParserRULE_dropIndexClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2927)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2928)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2929)

		var _x = p.Identifier()

		localctx.(*DropIndexClauseContext).indexName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRenameClauseContext is an interface to support dynamic dispatch.
type ITableRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsTableRenameClauseContext differentiates from other interfaces.
	IsTableRenameClauseContext()
}

type TableRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRenameClauseContext() *TableRenameClauseContext {
	var p = new(TableRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableRenameClause
	return p
}

func InitEmptyTableRenameClauseContext(p *TableRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableRenameClause
}

func (*TableRenameClauseContext) IsTableRenameClauseContext() {}

func NewTableRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRenameClauseContext {
	var p = new(TableRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tableRenameClause

	return p
}

func (s *TableRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *TableRenameClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableRenameClause(s)
	}
}

func (s *TableRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableRenameClause(s)
	}
}

func (p *StarRocksParser) TableRenameClause() (localctx ITableRenameClauseContext) {
	localctx = NewTableRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, StarRocksParserRULE_tableRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2931)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2932)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISwapTableClauseContext is an interface to support dynamic dispatch.
type ISwapTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SWAP() antlr.TerminalNode
	WITH() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsSwapTableClauseContext differentiates from other interfaces.
	IsSwapTableClauseContext()
}

type SwapTableClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwapTableClauseContext() *SwapTableClauseContext {
	var p = new(SwapTableClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_swapTableClause
	return p
}

func InitEmptySwapTableClauseContext(p *SwapTableClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_swapTableClause
}

func (*SwapTableClauseContext) IsSwapTableClauseContext() {}

func NewSwapTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SwapTableClauseContext {
	var p = new(SwapTableClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_swapTableClause

	return p
}

func (s *SwapTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SwapTableClauseContext) SWAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSWAP, 0)
}

func (s *SwapTableClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *SwapTableClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SwapTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SwapTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SwapTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSwapTableClause(s)
	}
}

func (s *SwapTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSwapTableClause(s)
	}
}

func (p *StarRocksParser) SwapTableClause() (localctx ISwapTableClauseContext) {
	localctx = NewSwapTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, StarRocksParserRULE_swapTableClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2934)
		p.Match(StarRocksParserSWAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2935)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2936)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyPropertiesClauseContext is an interface to support dynamic dispatch.
type IModifyPropertiesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsModifyPropertiesClauseContext differentiates from other interfaces.
	IsModifyPropertiesClauseContext()
}

type ModifyPropertiesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyPropertiesClauseContext() *ModifyPropertiesClauseContext {
	var p = new(ModifyPropertiesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyPropertiesClause
	return p
}

func InitEmptyModifyPropertiesClauseContext(p *ModifyPropertiesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyPropertiesClause
}

func (*ModifyPropertiesClauseContext) IsModifyPropertiesClauseContext() {}

func NewModifyPropertiesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyPropertiesClauseContext {
	var p = new(ModifyPropertiesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyPropertiesClause

	return p
}

func (s *ModifyPropertiesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyPropertiesClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ModifyPropertiesClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyPropertiesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPropertiesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyPropertiesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyPropertiesClause(s)
	}
}

func (s *ModifyPropertiesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyPropertiesClause(s)
	}
}

func (p *StarRocksParser) ModifyPropertiesClause() (localctx IModifyPropertiesClauseContext) {
	localctx = NewModifyPropertiesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, StarRocksParserRULE_modifyPropertiesClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2938)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2939)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyCommentClauseContext is an interface to support dynamic dispatch.
type IModifyCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext

	// IsModifyCommentClauseContext differentiates from other interfaces.
	IsModifyCommentClauseContext()
}

type ModifyCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyCommentClauseContext() *ModifyCommentClauseContext {
	var p = new(ModifyCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyCommentClause
	return p
}

func InitEmptyModifyCommentClauseContext(p *ModifyCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyCommentClause
}

func (*ModifyCommentClauseContext) IsModifyCommentClauseContext() {}

func NewModifyCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyCommentClauseContext {
	var p = new(ModifyCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyCommentClause

	return p
}

func (s *ModifyCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyCommentClauseContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *ModifyCommentClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *ModifyCommentClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ModifyCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyCommentClause(s)
	}
}

func (s *ModifyCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyCommentClause(s)
	}
}

func (p *StarRocksParser) ModifyCommentClause() (localctx IModifyCommentClauseContext) {
	localctx = NewModifyCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, StarRocksParserRULE_modifyCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2941)
		p.Match(StarRocksParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2942)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2943)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeRangeContext is an interface to support dynamic dispatch.
type IOptimizeRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IStringContext

	// GetEnd returns the end rule contexts.
	GetEnd() IStringContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IStringContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IStringContext)

	// Getter signatures
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsOptimizeRangeContext differentiates from other interfaces.
	IsOptimizeRangeContext()
}

type OptimizeRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	start_ IStringContext
	end    IStringContext
}

func NewEmptyOptimizeRangeContext() *OptimizeRangeContext {
	var p = new(OptimizeRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizeRange
	return p
}

func InitEmptyOptimizeRangeContext(p *OptimizeRangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizeRange
}

func (*OptimizeRangeContext) IsOptimizeRangeContext() {}

func NewOptimizeRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeRangeContext {
	var p = new(OptimizeRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_optimizeRange

	return p
}

func (s *OptimizeRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeRangeContext) GetStart_() IStringContext { return s.start_ }

func (s *OptimizeRangeContext) GetEnd() IStringContext { return s.end }

func (s *OptimizeRangeContext) SetStart_(v IStringContext) { s.start_ = v }

func (s *OptimizeRangeContext) SetEnd(v IStringContext) { s.end = v }

func (s *OptimizeRangeContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBETWEEN, 0)
}

func (s *OptimizeRangeContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *OptimizeRangeContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *OptimizeRangeContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *OptimizeRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOptimizeRange(s)
	}
}

func (s *OptimizeRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOptimizeRange(s)
	}
}

func (p *StarRocksParser) OptimizeRange() (localctx IOptimizeRangeContext) {
	localctx = NewOptimizeRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, StarRocksParserRULE_optimizeRange)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2945)
		p.Match(StarRocksParserBETWEEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2946)

		var _x = p.String_()

		localctx.(*OptimizeRangeContext).start_ = _x
	}
	{
		p.SetState(2947)
		p.Match(StarRocksParserAND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2948)

		var _x = p.String_()

		localctx.(*OptimizeRangeContext).end = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizeClauseContext is an interface to support dynamic dispatch.
type IOptimizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PartitionNames() IPartitionNamesContext
	KeyDesc() IKeyDescContext
	PartitionDesc() IPartitionDescContext
	OrderByDesc() IOrderByDescContext
	DistributionDesc() IDistributionDescContext
	OptimizeRange() IOptimizeRangeContext

	// IsOptimizeClauseContext differentiates from other interfaces.
	IsOptimizeClauseContext()
}

type OptimizeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizeClauseContext() *OptimizeClauseContext {
	var p = new(OptimizeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizeClause
	return p
}

func InitEmptyOptimizeClauseContext(p *OptimizeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizeClause
}

func (*OptimizeClauseContext) IsOptimizeClauseContext() {}

func NewOptimizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizeClauseContext {
	var p = new(OptimizeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_optimizeClause

	return p
}

func (s *OptimizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizeClauseContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *OptimizeClauseContext) KeyDesc() IKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyDescContext)
}

func (s *OptimizeClauseContext) PartitionDesc() IPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDescContext)
}

func (s *OptimizeClauseContext) OrderByDesc() IOrderByDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderByDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderByDescContext)
}

func (s *OptimizeClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *OptimizeClauseContext) OptimizeRange() IOptimizeRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizeRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizeRangeContext)
}

func (s *OptimizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOptimizeClause(s)
	}
}

func (s *OptimizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOptimizeClause(s)
	}
}

func (p *StarRocksParser) OptimizeClause() (localctx IOptimizeClauseContext) {
	localctx = NewOptimizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, StarRocksParserRULE_optimizeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2951)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 225, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2950)
			p.PartitionNames()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(2954)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAGGREGATE || _la == StarRocksParserDUPLICATE || _la == StarRocksParserPRIMARY || _la == StarRocksParserUNIQUE {
		{
			p.SetState(2953)
			p.KeyDesc()
		}

	}
	p.SetState(2957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION {
		{
			p.SetState(2956)
			p.PartitionDesc()
		}

	}
	p.SetState(2960)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(2959)
			p.OrderByDesc()
		}

	}
	p.SetState(2963)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDISTRIBUTED {
		{
			p.SetState(2962)
			p.DistributionDesc()
		}

	}
	p.SetState(2966)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserBETWEEN {
		{
			p.SetState(2965)
			p.OptimizeRange()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddColumnClauseContext is an interface to support dynamic dispatch.
type IAddColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ColumnDesc() IColumnDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Properties() IPropertiesContext
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsAddColumnClauseContext differentiates from other interfaces.
	IsAddColumnClauseContext()
}

type AddColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyAddColumnClauseContext() *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addColumnClause
	return p
}

func InitEmptyAddColumnClauseContext(p *AddColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addColumnClause
}

func (*AddColumnClauseContext) IsAddColumnClauseContext() {}

func NewAddColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnClauseContext {
	var p = new(AddColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addColumnClause

	return p
}

func (s *AddColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddColumnClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *AddColumnClauseContext) ColumnDesc() IColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *AddColumnClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *AddColumnClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAFTER, 0)
}

func (s *AddColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AddColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddColumnClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *AddColumnClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *AddColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddColumnClause(s)
	}
}

func (s *AddColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddColumnClause(s)
	}
}

func (p *StarRocksParser) AddColumnClause() (localctx IAddColumnClauseContext) {
	localctx = NewAddColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, StarRocksParserRULE_addColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2968)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2969)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2970)
		p.ColumnDesc()
	}
	p.SetState(2974)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFIRST:
		{
			p.SetState(2971)
			p.Match(StarRocksParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAFTER:
		{
			p.SetState(2972)
			p.Match(StarRocksParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2973)
			p.Identifier()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserIN, StarRocksParserPROPERTIES, StarRocksParserTO, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(2978)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIN || _la == StarRocksParserTO {
		{
			p.SetState(2976)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserIN || _la == StarRocksParserTO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2977)

			var _x = p.Identifier()

			localctx.(*AddColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(2981)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2980)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddColumnsClauseContext is an interface to support dynamic dispatch.
type IAddColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ADD() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllColumnDesc() []IColumnDescContext
	ColumnDesc(i int) IColumnDescContext
	Properties() IPropertiesContext
	TO() antlr.TerminalNode
	IN() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsAddColumnsClauseContext differentiates from other interfaces.
	IsAddColumnsClauseContext()
}

type AddColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyAddColumnsClauseContext() *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addColumnsClause
	return p
}

func InitEmptyAddColumnsClauseContext(p *AddColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addColumnsClause
}

func (*AddColumnsClauseContext) IsAddColumnsClauseContext() {}

func NewAddColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddColumnsClauseContext {
	var p = new(AddColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addColumnsClause

	return p
}

func (s *AddColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddColumnsClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *AddColumnsClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *AddColumnsClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddColumnsClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *AddColumnsClauseContext) AllColumnDesc() []IColumnDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnDescContext); ok {
			len++
		}
	}

	tst := make([]IColumnDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnDescContext); ok {
			tst[i] = t.(IColumnDescContext)
			i++
		}
	}

	return tst
}

func (s *AddColumnsClauseContext) ColumnDesc(i int) IColumnDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *AddColumnsClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddColumnsClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *AddColumnsClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *AddColumnsClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddColumnsClause(s)
	}
}

func (s *AddColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddColumnsClause(s)
	}
}

func (p *StarRocksParser) AddColumnsClause() (localctx IAddColumnsClauseContext) {
	localctx = NewAddColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, StarRocksParserRULE_addColumnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2983)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2984)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2985)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2986)
		p.ColumnDesc()
	}
	p.SetState(2991)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(2987)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2988)
			p.ColumnDesc()
		}

		p.SetState(2993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2994)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2997)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIN || _la == StarRocksParserTO {
		{
			p.SetState(2995)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserIN || _la == StarRocksParserTO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2996)

			var _x = p.Identifier()

			localctx.(*AddColumnsClauseContext).rollupName = _x
		}

	}
	p.SetState(3000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(2999)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropColumnClauseContext is an interface to support dynamic dispatch.
type IDropColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsDropColumnClauseContext differentiates from other interfaces.
	IsDropColumnClauseContext()
}

type DropColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyDropColumnClauseContext() *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropColumnClause
	return p
}

func InitEmptyDropColumnClauseContext(p *DropColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropColumnClause
}

func (*DropColumnClauseContext) IsDropColumnClauseContext() {}

func NewDropColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropColumnClauseContext {
	var p = new(DropColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropColumnClause

	return p
}

func (s *DropColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *DropColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *DropColumnClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *DropColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DropColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropColumnClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DropColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropColumnClause(s)
	}
}

func (s *DropColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropColumnClause(s)
	}
}

func (p *StarRocksParser) DropColumnClause() (localctx IDropColumnClauseContext) {
	localctx = NewDropColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, StarRocksParserRULE_dropColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3002)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3003)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3004)
		p.Identifier()
	}
	p.SetState(3007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3005)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3006)

			var _x = p.Identifier()

			localctx.(*DropColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(3010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3009)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyColumnClauseContext is an interface to support dynamic dispatch.
type IModifyColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	ColumnDesc() IColumnDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsModifyColumnClauseContext differentiates from other interfaces.
	IsModifyColumnClauseContext()
}

type ModifyColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyModifyColumnClauseContext() *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyColumnClause
	return p
}

func InitEmptyModifyColumnClauseContext(p *ModifyColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyColumnClause
}

func (*ModifyColumnClauseContext) IsModifyColumnClauseContext() {}

func NewModifyColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyColumnClauseContext {
	var p = new(ModifyColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyColumnClause

	return p
}

func (s *ModifyColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyColumnClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *ModifyColumnClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *ModifyColumnClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *ModifyColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *ModifyColumnClauseContext) ColumnDesc() IColumnDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDescContext)
}

func (s *ModifyColumnClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *ModifyColumnClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAFTER, 0)
}

func (s *ModifyColumnClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ModifyColumnClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ModifyColumnClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ModifyColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyColumnClause(s)
	}
}

func (s *ModifyColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyColumnClause(s)
	}
}

func (p *StarRocksParser) ModifyColumnClause() (localctx IModifyColumnClauseContext) {
	localctx = NewModifyColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, StarRocksParserRULE_modifyColumnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3012)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3013)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3014)
		p.ColumnDesc()
	}
	p.SetState(3018)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFIRST:
		{
			p.SetState(3015)
			p.Match(StarRocksParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAFTER:
		{
			p.SetState(3016)
			p.Match(StarRocksParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3017)
			p.Identifier()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserFROM, StarRocksParserPROPERTIES, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(3022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3020)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3021)

			var _x = p.Identifier()

			localctx.(*ModifyColumnClauseContext).rollupName = _x
		}

	}
	p.SetState(3025)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3024)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyColumnCommentClauseContext is an interface to support dynamic dispatch.
type IModifyColumnCommentClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	Identifier() IIdentifierContext
	Comment() ICommentContext

	// IsModifyColumnCommentClauseContext differentiates from other interfaces.
	IsModifyColumnCommentClauseContext()
}

type ModifyColumnCommentClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyColumnCommentClauseContext() *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyColumnCommentClause
	return p
}

func InitEmptyModifyColumnCommentClauseContext(p *ModifyColumnCommentClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyColumnCommentClause
}

func (*ModifyColumnCommentClauseContext) IsModifyColumnCommentClauseContext() {}

func NewModifyColumnCommentClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyColumnCommentClauseContext {
	var p = new(ModifyColumnCommentClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyColumnCommentClause

	return p
}

func (s *ModifyColumnCommentClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyColumnCommentClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *ModifyColumnCommentClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *ModifyColumnCommentClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyColumnCommentClauseContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *ModifyColumnCommentClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyColumnCommentClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyColumnCommentClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyColumnCommentClause(s)
	}
}

func (s *ModifyColumnCommentClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyColumnCommentClause(s)
	}
}

func (p *StarRocksParser) ModifyColumnCommentClause() (localctx IModifyColumnCommentClauseContext) {
	localctx = NewModifyColumnCommentClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, StarRocksParserRULE_modifyColumnCommentClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3027)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3028)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3029)
		p.Identifier()
	}
	{
		p.SetState(3030)
		p.Comment()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnRenameClauseContext is an interface to support dynamic dispatch.
type IColumnRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOldColumn returns the oldColumn rule contexts.
	GetOldColumn() IIdentifierContext

	// GetNewColumn returns the newColumn rule contexts.
	GetNewColumn() IIdentifierContext

	// SetOldColumn sets the oldColumn rule contexts.
	SetOldColumn(IIdentifierContext)

	// SetNewColumn sets the newColumn rule contexts.
	SetNewColumn(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnRenameClauseContext differentiates from other interfaces.
	IsColumnRenameClauseContext()
}

type ColumnRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	oldColumn IIdentifierContext
	newColumn IIdentifierContext
}

func NewEmptyColumnRenameClauseContext() *ColumnRenameClauseContext {
	var p = new(ColumnRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnRenameClause
	return p
}

func InitEmptyColumnRenameClauseContext(p *ColumnRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnRenameClause
}

func (*ColumnRenameClauseContext) IsColumnRenameClauseContext() {}

func NewColumnRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRenameClauseContext {
	var p = new(ColumnRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnRenameClause

	return p
}

func (s *ColumnRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRenameClauseContext) GetOldColumn() IIdentifierContext { return s.oldColumn }

func (s *ColumnRenameClauseContext) GetNewColumn() IIdentifierContext { return s.newColumn }

func (s *ColumnRenameClauseContext) SetOldColumn(v IIdentifierContext) { s.oldColumn = v }

func (s *ColumnRenameClauseContext) SetNewColumn(v IIdentifierContext) { s.newColumn = v }

func (s *ColumnRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *ColumnRenameClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *ColumnRenameClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *ColumnRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnRenameClause(s)
	}
}

func (s *ColumnRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnRenameClause(s)
	}
}

func (p *StarRocksParser) ColumnRenameClause() (localctx IColumnRenameClauseContext) {
	localctx = NewColumnRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, StarRocksParserRULE_columnRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3032)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3033)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3034)

		var _x = p.Identifier()

		localctx.(*ColumnRenameClauseContext).oldColumn = _x
	}
	{
		p.SetState(3035)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3036)

		var _x = p.Identifier()

		localctx.(*ColumnRenameClauseContext).newColumn = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReorderColumnsClauseContext is an interface to support dynamic dispatch.
type IReorderColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// Getter signatures
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	FROM() antlr.TerminalNode
	Properties() IPropertiesContext
	Identifier() IIdentifierContext

	// IsReorderColumnsClauseContext differentiates from other interfaces.
	IsReorderColumnsClauseContext()
}

type ReorderColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	rollupName IIdentifierContext
}

func NewEmptyReorderColumnsClauseContext() *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_reorderColumnsClause
	return p
}

func InitEmptyReorderColumnsClauseContext(p *ReorderColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_reorderColumnsClause
}

func (*ReorderColumnsClauseContext) IsReorderColumnsClauseContext() {}

func NewReorderColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReorderColumnsClauseContext {
	var p = new(ReorderColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_reorderColumnsClause

	return p
}

func (s *ReorderColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReorderColumnsClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *ReorderColumnsClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *ReorderColumnsClauseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ReorderColumnsClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ReorderColumnsClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ReorderColumnsClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ReorderColumnsClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ReorderColumnsClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReorderColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReorderColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReorderColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterReorderColumnsClause(s)
	}
}

func (s *ReorderColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitReorderColumnsClause(s)
	}
}

func (p *StarRocksParser) ReorderColumnsClause() (localctx IReorderColumnsClauseContext) {
	localctx = NewReorderColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, StarRocksParserRULE_reorderColumnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3038)
		p.Match(StarRocksParserORDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3039)
		p.Match(StarRocksParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3040)
		p.IdentifierList()
	}
	p.SetState(3043)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3041)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3042)

			var _x = p.Identifier()

			localctx.(*ReorderColumnsClauseContext).rollupName = _x
		}

	}
	p.SetState(3046)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3045)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollupRenameClauseContext is an interface to support dynamic dispatch.
type IRollupRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRollupName returns the rollupName rule contexts.
	GetRollupName() IIdentifierContext

	// GetNewRollupName returns the newRollupName rule contexts.
	GetNewRollupName() IIdentifierContext

	// SetRollupName sets the rollupName rule contexts.
	SetRollupName(IIdentifierContext)

	// SetNewRollupName sets the newRollupName rule contexts.
	SetNewRollupName(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsRollupRenameClauseContext differentiates from other interfaces.
	IsRollupRenameClauseContext()
}

type RollupRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	rollupName    IIdentifierContext
	newRollupName IIdentifierContext
}

func NewEmptyRollupRenameClauseContext() *RollupRenameClauseContext {
	var p = new(RollupRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupRenameClause
	return p
}

func InitEmptyRollupRenameClauseContext(p *RollupRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollupRenameClause
}

func (*RollupRenameClauseContext) IsRollupRenameClauseContext() {}

func NewRollupRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollupRenameClauseContext {
	var p = new(RollupRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rollupRenameClause

	return p
}

func (s *RollupRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RollupRenameClauseContext) GetRollupName() IIdentifierContext { return s.rollupName }

func (s *RollupRenameClauseContext) GetNewRollupName() IIdentifierContext { return s.newRollupName }

func (s *RollupRenameClauseContext) SetRollupName(v IIdentifierContext) { s.rollupName = v }

func (s *RollupRenameClauseContext) SetNewRollupName(v IIdentifierContext) { s.newRollupName = v }

func (s *RollupRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *RollupRenameClauseContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *RollupRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RollupRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RollupRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollupRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollupRenameClause(s)
	}
}

func (s *RollupRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollupRenameClause(s)
	}
}

func (p *StarRocksParser) RollupRenameClause() (localctx IRollupRenameClauseContext) {
	localctx = NewRollupRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, StarRocksParserRULE_rollupRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3048)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3049)
		p.Match(StarRocksParserROLLUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3050)

		var _x = p.Identifier()

		localctx.(*RollupRenameClauseContext).rollupName = _x
	}
	{
		p.SetState(3051)

		var _x = p.Identifier()

		localctx.(*RollupRenameClauseContext).newRollupName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompactionClauseContext is an interface to support dynamic dispatch.
type ICompactionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMPACT() antlr.TerminalNode
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	BASE() antlr.TerminalNode
	CUMULATIVE() antlr.TerminalNode

	// IsCompactionClauseContext differentiates from other interfaces.
	IsCompactionClauseContext()
}

type CompactionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompactionClauseContext() *CompactionClauseContext {
	var p = new(CompactionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_compactionClause
	return p
}

func InitEmptyCompactionClauseContext(p *CompactionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_compactionClause
}

func (*CompactionClauseContext) IsCompactionClauseContext() {}

func NewCompactionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompactionClauseContext {
	var p = new(CompactionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_compactionClause

	return p
}

func (s *CompactionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CompactionClauseContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPACT, 0)
}

func (s *CompactionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CompactionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *CompactionClauseContext) BASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASE, 0)
}

func (s *CompactionClauseContext) CUMULATIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUMULATIVE, 0)
}

func (s *CompactionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompactionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompactionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCompactionClause(s)
	}
}

func (s *CompactionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCompactionClause(s)
	}
}

func (p *StarRocksParser) CompactionClause() (localctx ICompactionClauseContext) {
	localctx = NewCompactionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, StarRocksParserRULE_compactionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserBASE || _la == StarRocksParserCUMULATIVE {
		{
			p.SetState(3053)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserBASE || _la == StarRocksParserCUMULATIVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3056)
		p.Match(StarRocksParserCOMPACT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3059)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(3057)
			p.Identifier()
		}

	case StarRocksParserT__1:
		{
			p.SetState(3058)
			p.IdentifierList()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldNameContext is an interface to support dynamic dispatch.
type ISubfieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ARRAY_ELEMENT() antlr.TerminalNode

	// IsSubfieldNameContext differentiates from other interfaces.
	IsSubfieldNameContext()
}

type SubfieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldNameContext() *SubfieldNameContext {
	var p = new(SubfieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldName
	return p
}

func InitEmptySubfieldNameContext(p *SubfieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldName
}

func (*SubfieldNameContext) IsSubfieldNameContext() {}

func NewSubfieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldNameContext {
	var p = new(SubfieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_subfieldName

	return p
}

func (s *SubfieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubfieldNameContext) ARRAY_ELEMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_ELEMENT, 0)
}

func (s *SubfieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubfieldName(s)
	}
}

func (s *SubfieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubfieldName(s)
	}
}

func (p *StarRocksParser) SubfieldName() (localctx ISubfieldNameContext) {
	localctx = NewSubfieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, StarRocksParserRULE_subfieldName)
	p.SetState(3063)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3061)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3062)
			p.Match(StarRocksParserARRAY_ELEMENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INestedFieldNameContext is an interface to support dynamic dispatch.
type INestedFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubfieldName() []ISubfieldNameContext
	SubfieldName(i int) ISubfieldNameContext
	AllDOT_IDENTIFIER() []antlr.TerminalNode
	DOT_IDENTIFIER(i int) antlr.TerminalNode

	// IsNestedFieldNameContext differentiates from other interfaces.
	IsNestedFieldNameContext()
}

type NestedFieldNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNestedFieldNameContext() *NestedFieldNameContext {
	var p = new(NestedFieldNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_nestedFieldName
	return p
}

func InitEmptyNestedFieldNameContext(p *NestedFieldNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_nestedFieldName
}

func (*NestedFieldNameContext) IsNestedFieldNameContext() {}

func NewNestedFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NestedFieldNameContext {
	var p = new(NestedFieldNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_nestedFieldName

	return p
}

func (s *NestedFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *NestedFieldNameContext) AllSubfieldName() []ISubfieldNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubfieldNameContext); ok {
			len++
		}
	}

	tst := make([]ISubfieldNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubfieldNameContext); ok {
			tst[i] = t.(ISubfieldNameContext)
			i++
		}
	}

	return tst
}

func (s *NestedFieldNameContext) SubfieldName(i int) ISubfieldNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldNameContext)
}

func (s *NestedFieldNameContext) AllDOT_IDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserDOT_IDENTIFIER)
}

func (s *NestedFieldNameContext) DOT_IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOT_IDENTIFIER, i)
}

func (s *NestedFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NestedFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NestedFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNestedFieldName(s)
	}
}

func (s *NestedFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNestedFieldName(s)
	}
}

func (p *StarRocksParser) NestedFieldName() (localctx INestedFieldNameContext) {
	localctx = NewNestedFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, StarRocksParserRULE_nestedFieldName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3065)
		p.SubfieldName()
	}
	p.SetState(3071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__0 || _la == StarRocksParserDOT_IDENTIFIER {
		p.SetState(3069)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserDOT_IDENTIFIER:
			{
				p.SetState(3066)
				p.Match(StarRocksParserDOT_IDENTIFIER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StarRocksParserT__0:
			{
				p.SetState(3067)
				p.Match(StarRocksParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3068)
				p.SubfieldName()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(3073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddFieldClauseContext is an interface to support dynamic dispatch.
type IAddFieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ADD() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	SubfieldDesc() ISubfieldDescContext
	FIRST() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAddFieldClauseContext differentiates from other interfaces.
	IsAddFieldClauseContext()
}

type AddFieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFieldClauseContext() *AddFieldClauseContext {
	var p = new(AddFieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addFieldClause
	return p
}

func InitEmptyAddFieldClauseContext(p *AddFieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addFieldClause
}

func (*AddFieldClauseContext) IsAddFieldClauseContext() {}

func NewAddFieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFieldClauseContext {
	var p = new(AddFieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addFieldClause

	return p
}

func (s *AddFieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFieldClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *AddFieldClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *AddFieldClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *AddFieldClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddFieldClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddFieldClauseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELD, 0)
}

func (s *AddFieldClauseContext) SubfieldDesc() ISubfieldDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescContext)
}

func (s *AddFieldClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *AddFieldClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAFTER, 0)
}

func (s *AddFieldClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddFieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddFieldClause(s)
	}
}

func (s *AddFieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddFieldClause(s)
	}
}

func (p *StarRocksParser) AddFieldClause() (localctx IAddFieldClauseContext) {
	localctx = NewAddFieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, StarRocksParserRULE_addFieldClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3074)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3075)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3076)
		p.Identifier()
	}
	{
		p.SetState(3077)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3078)
		p.Match(StarRocksParserFIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3079)
		p.SubfieldDesc()
	}
	p.SetState(3083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFIRST:
		{
			p.SetState(3080)
			p.Match(StarRocksParserFIRST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAFTER:
		{
			p.SetState(3081)
			p.Match(StarRocksParserAFTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3082)
			p.Identifier()
		}

	case StarRocksParserEOF, StarRocksParserT__2, StarRocksParserPROPERTIES, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(3086)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3085)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFieldClauseContext is an interface to support dynamic dispatch.
type IDropFieldClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	COLUMN() antlr.TerminalNode
	Identifier() IIdentifierContext
	DROP() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	NestedFieldName() INestedFieldNameContext
	Properties() IPropertiesContext

	// IsDropFieldClauseContext differentiates from other interfaces.
	IsDropFieldClauseContext()
}

type DropFieldClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFieldClauseContext() *DropFieldClauseContext {
	var p = new(DropFieldClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFieldClause
	return p
}

func InitEmptyDropFieldClauseContext(p *DropFieldClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFieldClause
}

func (*DropFieldClauseContext) IsDropFieldClauseContext() {}

func NewDropFieldClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFieldClauseContext {
	var p = new(DropFieldClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropFieldClause

	return p
}

func (s *DropFieldClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFieldClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *DropFieldClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMN, 0)
}

func (s *DropFieldClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropFieldClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropFieldClauseContext) FIELD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELD, 0)
}

func (s *DropFieldClauseContext) NestedFieldName() INestedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedFieldNameContext)
}

func (s *DropFieldClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropFieldClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFieldClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFieldClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropFieldClause(s)
	}
}

func (s *DropFieldClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropFieldClause(s)
	}
}

func (p *StarRocksParser) DropFieldClause() (localctx IDropFieldClauseContext) {
	localctx = NewDropFieldClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, StarRocksParserRULE_dropFieldClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3088)
		p.Match(StarRocksParserMODIFY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3089)
		p.Match(StarRocksParserCOLUMN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3090)
		p.Identifier()
	}
	{
		p.SetState(3091)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3092)
		p.Match(StarRocksParserFIELD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3093)
		p.NestedFieldName()
	}
	p.SetState(3095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3094)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceTagClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	TagOptions() ITagOptionsContext
	CREATE() antlr.TerminalNode
	OR() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateOrReplaceTagClauseContext differentiates from other interfaces.
	IsCreateOrReplaceTagClauseContext()
}

type CreateOrReplaceTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrReplaceTagClauseContext() *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createOrReplaceTagClause
	return p
}

func InitEmptyCreateOrReplaceTagClauseContext(p *CreateOrReplaceTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createOrReplaceTagClause
}

func (*CreateOrReplaceTagClauseContext) IsCreateOrReplaceTagClauseContext() {}

func NewCreateOrReplaceTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceTagClauseContext {
	var p = new(CreateOrReplaceTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createOrReplaceTagClause

	return p
}

func (s *CreateOrReplaceTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceTagClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *CreateOrReplaceTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTAG, 0)
}

func (s *CreateOrReplaceTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceTagClauseContext) TagOptions() ITagOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITagOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITagOptionsContext)
}

func (s *CreateOrReplaceTagClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateOrReplaceTagClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *CreateOrReplaceTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateOrReplaceTagClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateOrReplaceTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateOrReplaceTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceTagClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateOrReplaceTagClause(s)
	}
}

func (s *CreateOrReplaceTagClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateOrReplaceTagClause(s)
	}
}

func (p *StarRocksParser) CreateOrReplaceTagClause() (localctx ICreateOrReplaceTagClauseContext) {
	localctx = NewCreateOrReplaceTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, StarRocksParserRULE_createOrReplaceTagClause)
	var _la int

	p.SetState(3116)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 254, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3099)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCREATE {
			{
				p.SetState(3097)
				p.Match(StarRocksParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3098)
				p.Match(StarRocksParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3101)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3102)
			p.Match(StarRocksParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3103)
			p.Identifier()
		}
		{
			p.SetState(3104)
			p.TagOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3106)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3107)
			p.Match(StarRocksParserTAG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3111)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(3108)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3109)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3110)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3113)
			p.Identifier()
		}
		{
			p.SetState(3114)
			p.TagOptions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateOrReplaceBranchClauseContext is an interface to support dynamic dispatch.
type ICreateOrReplaceBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	BranchOptions() IBranchOptionsContext
	CREATE() antlr.TerminalNode
	OR() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateOrReplaceBranchClauseContext differentiates from other interfaces.
	IsCreateOrReplaceBranchClauseContext()
}

type CreateOrReplaceBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateOrReplaceBranchClauseContext() *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createOrReplaceBranchClause
	return p
}

func InitEmptyCreateOrReplaceBranchClauseContext(p *CreateOrReplaceBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createOrReplaceBranchClause
}

func (*CreateOrReplaceBranchClauseContext) IsCreateOrReplaceBranchClauseContext() {}

func NewCreateOrReplaceBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateOrReplaceBranchClauseContext {
	var p = new(CreateOrReplaceBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createOrReplaceBranchClause

	return p
}

func (s *CreateOrReplaceBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateOrReplaceBranchClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBRANCH, 0)
}

func (s *CreateOrReplaceBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateOrReplaceBranchClauseContext) BranchOptions() IBranchOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBranchOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBranchOptionsContext)
}

func (s *CreateOrReplaceBranchClauseContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateOrReplaceBranchClauseContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *CreateOrReplaceBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateOrReplaceBranchClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateOrReplaceBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateOrReplaceBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateOrReplaceBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateOrReplaceBranchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateOrReplaceBranchClause(s)
	}
}

func (s *CreateOrReplaceBranchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateOrReplaceBranchClause(s)
	}
}

func (p *StarRocksParser) CreateOrReplaceBranchClause() (localctx ICreateOrReplaceBranchClauseContext) {
	localctx = NewCreateOrReplaceBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, StarRocksParserRULE_createOrReplaceBranchClause)
	var _la int

	p.SetState(3137)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 257, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3120)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCREATE {
			{
				p.SetState(3118)
				p.Match(StarRocksParserCREATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3119)
				p.Match(StarRocksParserOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3122)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3123)
			p.Match(StarRocksParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3124)
			p.Identifier()
		}
		{
			p.SetState(3125)
			p.BranchOptions()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3127)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3128)
			p.Match(StarRocksParserBRANCH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3132)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(3129)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3130)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3131)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3134)
			p.Identifier()
		}
		{
			p.SetState(3135)
			p.BranchOptions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBranchClauseContext is an interface to support dynamic dispatch.
type IDropBranchClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropBranchClauseContext differentiates from other interfaces.
	IsDropBranchClauseContext()
}

type DropBranchClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropBranchClauseContext() *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBranchClause
	return p
}

func InitEmptyDropBranchClauseContext(p *DropBranchClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBranchClause
}

func (*DropBranchClauseContext) IsDropBranchClauseContext() {}

func NewDropBranchClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBranchClauseContext {
	var p = new(DropBranchClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropBranchClause

	return p
}

func (s *DropBranchClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBranchClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropBranchClauseContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBRANCH, 0)
}

func (s *DropBranchClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropBranchClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropBranchClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropBranchClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBranchClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBranchClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropBranchClause(s)
	}
}

func (s *DropBranchClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropBranchClause(s)
	}
}

func (p *StarRocksParser) DropBranchClause() (localctx IDropBranchClauseContext) {
	localctx = NewDropBranchClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, StarRocksParserRULE_dropBranchClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3139)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3140)
		p.Match(StarRocksParserBRANCH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3143)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(3141)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3142)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3145)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropTagClauseContext is an interface to support dynamic dispatch.
type IDropTagClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	TAG() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropTagClauseContext differentiates from other interfaces.
	IsDropTagClauseContext()
}

type DropTagClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropTagClauseContext() *DropTagClauseContext {
	var p = new(DropTagClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTagClause
	return p
}

func InitEmptyDropTagClauseContext(p *DropTagClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropTagClause
}

func (*DropTagClauseContext) IsDropTagClauseContext() {}

func NewDropTagClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropTagClauseContext {
	var p = new(DropTagClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropTagClause

	return p
}

func (s *DropTagClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropTagClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropTagClauseContext) TAG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTAG, 0)
}

func (s *DropTagClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropTagClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropTagClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropTagClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropTagClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropTagClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropTagClause(s)
	}
}

func (s *DropTagClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropTagClause(s)
	}
}

func (p *StarRocksParser) DropTagClause() (localctx IDropTagClauseContext) {
	localctx = NewDropTagClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, StarRocksParserRULE_dropTagClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3147)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3148)
		p.Match(StarRocksParserTAG)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3151)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(3149)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3150)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3153)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableOperationClauseContext is an interface to support dynamic dispatch.
type ITableOperationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	FunctionCall() IFunctionCallContext

	// IsTableOperationClauseContext differentiates from other interfaces.
	IsTableOperationClauseContext()
}

type TableOperationClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableOperationClauseContext() *TableOperationClauseContext {
	var p = new(TableOperationClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableOperationClause
	return p
}

func InitEmptyTableOperationClauseContext(p *TableOperationClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableOperationClause
}

func (*TableOperationClauseContext) IsTableOperationClauseContext() {}

func NewTableOperationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableOperationClauseContext {
	var p = new(TableOperationClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tableOperationClause

	return p
}

func (s *TableOperationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TableOperationClauseContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *TableOperationClauseContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *TableOperationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableOperationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableOperationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableOperationClause(s)
	}
}

func (s *TableOperationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableOperationClause(s)
	}
}

func (p *StarRocksParser) TableOperationClause() (localctx ITableOperationClauseContext) {
	localctx = NewTableOperationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, StarRocksParserRULE_tableOperationClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3155)
		p.Match(StarRocksParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3156)
		p.FunctionCall()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITagOptionsContext is an interface to support dynamic dispatch.
type ITagOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	SnapshotId() ISnapshotIdContext
	RefRetain() IRefRetainContext

	// IsTagOptionsContext differentiates from other interfaces.
	IsTagOptionsContext()
}

type TagOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTagOptionsContext() *TagOptionsContext {
	var p = new(TagOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tagOptions
	return p
}

func InitEmptyTagOptionsContext(p *TagOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tagOptions
}

func (*TagOptionsContext) IsTagOptionsContext() {}

func NewTagOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TagOptionsContext {
	var p = new(TagOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tagOptions

	return p
}

func (s *TagOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *TagOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *TagOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *TagOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *TagOptionsContext) SnapshotId() ISnapshotIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotIdContext)
}

func (s *TagOptionsContext) RefRetain() IRefRetainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefRetainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefRetainContext)
}

func (s *TagOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TagOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TagOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTagOptions(s)
	}
}

func (s *TagOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTagOptions(s)
	}
}

func (p *StarRocksParser) TagOptions() (localctx ITagOptionsContext) {
	localctx = NewTagOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, StarRocksParserRULE_tagOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3162)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(3158)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3159)
			p.Match(StarRocksParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3160)
			p.Match(StarRocksParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3161)
			p.SnapshotId()
		}

	}
	p.SetState(3165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserRETAIN {
		{
			p.SetState(3164)
			p.RefRetain()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBranchOptionsContext is an interface to support dynamic dispatch.
type IBranchOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	SnapshotId() ISnapshotIdContext
	RefRetain() IRefRetainContext
	SnapshotRetention() ISnapshotRetentionContext

	// IsBranchOptionsContext differentiates from other interfaces.
	IsBranchOptionsContext()
}

type BranchOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBranchOptionsContext() *BranchOptionsContext {
	var p = new(BranchOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_branchOptions
	return p
}

func InitEmptyBranchOptionsContext(p *BranchOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_branchOptions
}

func (*BranchOptionsContext) IsBranchOptionsContext() {}

func NewBranchOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BranchOptionsContext {
	var p = new(BranchOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_branchOptions

	return p
}

func (s *BranchOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *BranchOptionsContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *BranchOptionsContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *BranchOptionsContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *BranchOptionsContext) SnapshotId() ISnapshotIdContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotIdContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotIdContext)
}

func (s *BranchOptionsContext) RefRetain() IRefRetainContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRefRetainContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRefRetainContext)
}

func (s *BranchOptionsContext) SnapshotRetention() ISnapshotRetentionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISnapshotRetentionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISnapshotRetentionContext)
}

func (s *BranchOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BranchOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BranchOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBranchOptions(s)
	}
}

func (s *BranchOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBranchOptions(s)
	}
}

func (p *StarRocksParser) BranchOptions() (localctx IBranchOptionsContext) {
	localctx = NewBranchOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, StarRocksParserRULE_branchOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(3167)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3168)
			p.Match(StarRocksParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3169)
			p.Match(StarRocksParserVERSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3170)
			p.SnapshotId()
		}

	}
	p.SetState(3174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserRETAIN {
		{
			p.SetState(3173)
			p.RefRetain()
		}

	}
	p.SetState(3177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3176)
			p.SnapshotRetention()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISnapshotRetentionContext is an interface to support dynamic dispatch.
type ISnapshotRetentionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	MinSnapshotsToKeep() IMinSnapshotsToKeepContext
	MaxSnapshotAge() IMaxSnapshotAgeContext

	// IsSnapshotRetentionContext differentiates from other interfaces.
	IsSnapshotRetentionContext()
}

type SnapshotRetentionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySnapshotRetentionContext() *SnapshotRetentionContext {
	var p = new(SnapshotRetentionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_snapshotRetention
	return p
}

func InitEmptySnapshotRetentionContext(p *SnapshotRetentionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_snapshotRetention
}

func (*SnapshotRetentionContext) IsSnapshotRetentionContext() {}

func NewSnapshotRetentionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SnapshotRetentionContext {
	var p = new(SnapshotRetentionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_snapshotRetention

	return p
}

func (s *SnapshotRetentionContext) GetParser() antlr.Parser { return s.parser }

func (s *SnapshotRetentionContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *SnapshotRetentionContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *SnapshotRetentionContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETENTION, 0)
}

func (s *SnapshotRetentionContext) MinSnapshotsToKeep() IMinSnapshotsToKeepContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMinSnapshotsToKeepContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMinSnapshotsToKeepContext)
}

func (s *SnapshotRetentionContext) MaxSnapshotAge() IMaxSnapshotAgeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMaxSnapshotAgeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMaxSnapshotAgeContext)
}

func (s *SnapshotRetentionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SnapshotRetentionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SnapshotRetentionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSnapshotRetention(s)
	}
}

func (s *SnapshotRetentionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSnapshotRetention(s)
	}
}

func (p *StarRocksParser) SnapshotRetention() (localctx ISnapshotRetentionContext) {
	localctx = NewSnapshotRetentionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, StarRocksParserRULE_snapshotRetention)
	p.SetState(3193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 265, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3179)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3180)
			p.Match(StarRocksParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3181)
			p.Match(StarRocksParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3182)
			p.MinSnapshotsToKeep()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3183)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3184)
			p.Match(StarRocksParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3185)
			p.Match(StarRocksParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3186)
			p.MaxSnapshotAge()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3187)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3188)
			p.Match(StarRocksParserSNAPSHOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3189)
			p.Match(StarRocksParserRETENTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3190)
			p.MinSnapshotsToKeep()
		}
		{
			p.SetState(3191)
			p.MaxSnapshotAge()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefRetainContext is an interface to support dynamic dispatch.
type IRefRetainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETAIN() antlr.TerminalNode
	Number() INumberContext
	TimeUnit() ITimeUnitContext

	// IsRefRetainContext differentiates from other interfaces.
	IsRefRetainContext()
}

type RefRetainContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefRetainContext() *RefRetainContext {
	var p = new(RefRetainContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refRetain
	return p
}

func InitEmptyRefRetainContext(p *RefRetainContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refRetain
}

func (*RefRetainContext) IsRefRetainContext() {}

func NewRefRetainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefRetainContext {
	var p = new(RefRetainContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refRetain

	return p
}

func (s *RefRetainContext) GetParser() antlr.Parser { return s.parser }

func (s *RefRetainContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETAIN, 0)
}

func (s *RefRetainContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *RefRetainContext) TimeUnit() ITimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeUnitContext)
}

func (s *RefRetainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefRetainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefRetainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefRetain(s)
	}
}

func (s *RefRetainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefRetain(s)
	}
}

func (p *StarRocksParser) RefRetain() (localctx IRefRetainContext) {
	localctx = NewRefRetainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, StarRocksParserRULE_refRetain)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3195)
		p.Match(StarRocksParserRETAIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3196)
		p.Number()
	}
	{
		p.SetState(3197)
		p.TimeUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMaxSnapshotAgeContext is an interface to support dynamic dispatch.
type IMaxSnapshotAgeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	TimeUnit() ITimeUnitContext

	// IsMaxSnapshotAgeContext differentiates from other interfaces.
	IsMaxSnapshotAgeContext()
}

type MaxSnapshotAgeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMaxSnapshotAgeContext() *MaxSnapshotAgeContext {
	var p = new(MaxSnapshotAgeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_maxSnapshotAge
	return p
}

func InitEmptyMaxSnapshotAgeContext(p *MaxSnapshotAgeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_maxSnapshotAge
}

func (*MaxSnapshotAgeContext) IsMaxSnapshotAgeContext() {}

func NewMaxSnapshotAgeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MaxSnapshotAgeContext {
	var p = new(MaxSnapshotAgeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_maxSnapshotAge

	return p
}

func (s *MaxSnapshotAgeContext) GetParser() antlr.Parser { return s.parser }

func (s *MaxSnapshotAgeContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *MaxSnapshotAgeContext) TimeUnit() ITimeUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeUnitContext)
}

func (s *MaxSnapshotAgeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MaxSnapshotAgeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MaxSnapshotAgeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMaxSnapshotAge(s)
	}
}

func (s *MaxSnapshotAgeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMaxSnapshotAge(s)
	}
}

func (p *StarRocksParser) MaxSnapshotAge() (localctx IMaxSnapshotAgeContext) {
	localctx = NewMaxSnapshotAgeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, StarRocksParserRULE_maxSnapshotAge)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3199)
		p.Number()
	}
	{
		p.SetState(3200)
		p.TimeUnit()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMinSnapshotsToKeepContext is an interface to support dynamic dispatch.
type IMinSnapshotsToKeepContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext
	SNAPSHOTS() antlr.TerminalNode

	// IsMinSnapshotsToKeepContext differentiates from other interfaces.
	IsMinSnapshotsToKeepContext()
}

type MinSnapshotsToKeepContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinSnapshotsToKeepContext() *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_minSnapshotsToKeep
	return p
}

func InitEmptyMinSnapshotsToKeepContext(p *MinSnapshotsToKeepContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_minSnapshotsToKeep
}

func (*MinSnapshotsToKeepContext) IsMinSnapshotsToKeepContext() {}

func NewMinSnapshotsToKeepContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinSnapshotsToKeepContext {
	var p = new(MinSnapshotsToKeepContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_minSnapshotsToKeep

	return p
}

func (s *MinSnapshotsToKeepContext) GetParser() antlr.Parser { return s.parser }

func (s *MinSnapshotsToKeepContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *MinSnapshotsToKeepContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOTS, 0)
}

func (s *MinSnapshotsToKeepContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinSnapshotsToKeepContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinSnapshotsToKeepContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMinSnapshotsToKeep(s)
	}
}

func (s *MinSnapshotsToKeepContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMinSnapshotsToKeep(s)
	}
}

func (p *StarRocksParser) MinSnapshotsToKeep() (localctx IMinSnapshotsToKeepContext) {
	localctx = NewMinSnapshotsToKeepContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, StarRocksParserRULE_minSnapshotsToKeep)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3202)
		p.Number()
	}
	{
		p.SetState(3203)
		p.Match(StarRocksParserSNAPSHOTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISnapshotIdContext is an interface to support dynamic dispatch.
type ISnapshotIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Number() INumberContext

	// IsSnapshotIdContext differentiates from other interfaces.
	IsSnapshotIdContext()
}

type SnapshotIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySnapshotIdContext() *SnapshotIdContext {
	var p = new(SnapshotIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_snapshotId
	return p
}

func InitEmptySnapshotIdContext(p *SnapshotIdContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_snapshotId
}

func (*SnapshotIdContext) IsSnapshotIdContext() {}

func NewSnapshotIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SnapshotIdContext {
	var p = new(SnapshotIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_snapshotId

	return p
}

func (s *SnapshotIdContext) GetParser() antlr.Parser { return s.parser }

func (s *SnapshotIdContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *SnapshotIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SnapshotIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SnapshotIdContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSnapshotId(s)
	}
}

func (s *SnapshotIdContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSnapshotId(s)
	}
}

func (p *StarRocksParser) SnapshotId() (localctx ISnapshotIdContext) {
	localctx = NewSnapshotIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, StarRocksParserRULE_snapshotId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3205)
		p.Number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeUnitContext is an interface to support dynamic dispatch.
type ITimeUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAYS() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	MINUTES() antlr.TerminalNode

	// IsTimeUnitContext differentiates from other interfaces.
	IsTimeUnitContext()
}

type TimeUnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeUnitContext() *TimeUnitContext {
	var p = new(TimeUnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_timeUnit
	return p
}

func InitEmptyTimeUnitContext(p *TimeUnitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_timeUnit
}

func (*TimeUnitContext) IsTimeUnitContext() {}

func NewTimeUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeUnitContext {
	var p = new(TimeUnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_timeUnit

	return p
}

func (s *TimeUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeUnitContext) DAYS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAYS, 0)
}

func (s *TimeUnitContext) HOURS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOURS, 0)
}

func (s *TimeUnitContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTES, 0)
}

func (s *TimeUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTimeUnit(s)
	}
}

func (s *TimeUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTimeUnit(s)
	}
}

func (p *StarRocksParser) TimeUnit() (localctx ITimeUnitContext) {
	localctx = NewTimeUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, StarRocksParserRULE_timeUnit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3207)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDAYS || _la == StarRocksParserHOURS || _la == StarRocksParserMINUTES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInteger_listContext is an interface to support dynamic dispatch.
type IInteger_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsInteger_listContext differentiates from other interfaces.
	IsInteger_listContext()
}

type Integer_listContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_listContext() *Integer_listContext {
	var p = new(Integer_listContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_integer_list
	return p
}

func InitEmptyInteger_listContext(p *Integer_listContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_integer_list
}

func (*Integer_listContext) IsInteger_listContext() {}

func NewInteger_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_listContext {
	var p = new(Integer_listContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_integer_list

	return p
}

func (s *Integer_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_listContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *Integer_listContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *Integer_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInteger_list(s)
	}
}

func (s *Integer_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInteger_list(s)
	}
}

func (p *StarRocksParser) Integer_list() (localctx IInteger_listContext) {
	localctx = NewInteger_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, StarRocksParserRULE_integer_list)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3209)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3210)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(3211)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3212)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(3217)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3218)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPersistentIndexClauseContext is an interface to support dynamic dispatch.
type IDropPersistentIndexClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode
	INDEX() antlr.TerminalNode
	ON() antlr.TerminalNode
	TABLETS() antlr.TerminalNode
	Integer_list() IInteger_listContext

	// IsDropPersistentIndexClauseContext differentiates from other interfaces.
	IsDropPersistentIndexClauseContext()
}

type DropPersistentIndexClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropPersistentIndexClauseContext() *DropPersistentIndexClauseContext {
	var p = new(DropPersistentIndexClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPersistentIndexClause
	return p
}

func InitEmptyDropPersistentIndexClauseContext(p *DropPersistentIndexClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPersistentIndexClause
}

func (*DropPersistentIndexClauseContext) IsDropPersistentIndexClauseContext() {}

func NewDropPersistentIndexClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPersistentIndexClauseContext {
	var p = new(DropPersistentIndexClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropPersistentIndexClause

	return p
}

func (s *DropPersistentIndexClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPersistentIndexClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropPersistentIndexClauseContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERSISTENT, 0)
}

func (s *DropPersistentIndexClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEX, 0)
}

func (s *DropPersistentIndexClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DropPersistentIndexClauseContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLETS, 0)
}

func (s *DropPersistentIndexClauseContext) Integer_list() IInteger_listContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInteger_listContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInteger_listContext)
}

func (s *DropPersistentIndexClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPersistentIndexClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPersistentIndexClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropPersistentIndexClause(s)
	}
}

func (s *DropPersistentIndexClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropPersistentIndexClause(s)
	}
}

func (p *StarRocksParser) DropPersistentIndexClause() (localctx IDropPersistentIndexClauseContext) {
	localctx = NewDropPersistentIndexClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, StarRocksParserRULE_dropPersistentIndexClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3220)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3221)
		p.Match(StarRocksParserPERSISTENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3222)
		p.Match(StarRocksParserINDEX)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3223)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3224)
		p.Match(StarRocksParserTABLETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3225)
		p.Integer_list()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterTableAutoIncrementClauseContext is an interface to support dynamic dispatch.
type IAlterTableAutoIncrementClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AUTO_INCREMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsAlterTableAutoIncrementClauseContext differentiates from other interfaces.
	IsAlterTableAutoIncrementClauseContext()
}

type AlterTableAutoIncrementClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterTableAutoIncrementClauseContext() *AlterTableAutoIncrementClauseContext {
	var p = new(AlterTableAutoIncrementClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterTableAutoIncrementClause
	return p
}

func InitEmptyAlterTableAutoIncrementClauseContext(p *AlterTableAutoIncrementClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterTableAutoIncrementClause
}

func (*AlterTableAutoIncrementClauseContext) IsAlterTableAutoIncrementClauseContext() {}

func NewAlterTableAutoIncrementClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterTableAutoIncrementClauseContext {
	var p = new(AlterTableAutoIncrementClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterTableAutoIncrementClause

	return p
}

func (s *AlterTableAutoIncrementClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterTableAutoIncrementClauseContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTO_INCREMENT, 0)
}

func (s *AlterTableAutoIncrementClauseContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *AlterTableAutoIncrementClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *AlterTableAutoIncrementClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterTableAutoIncrementClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterTableAutoIncrementClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterTableAutoIncrementClause(s)
	}
}

func (s *AlterTableAutoIncrementClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterTableAutoIncrementClause(s)
	}
}

func (p *StarRocksParser) AlterTableAutoIncrementClause() (localctx IAlterTableAutoIncrementClauseContext) {
	localctx = NewAlterTableAutoIncrementClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, StarRocksParserRULE_alterTableAutoIncrementClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3227)
		p.Match(StarRocksParserAUTO_INCREMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3228)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3229)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddPartitionClauseContext is an interface to support dynamic dispatch.
type IAddPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SingleRangePartition() ISingleRangePartitionContext
	PARTITIONS() antlr.TerminalNode
	MultiRangePartition() IMultiRangePartitionContext
	TEMPORARY() antlr.TerminalNode
	DistributionDesc() IDistributionDescContext
	Properties() IPropertiesContext
	SingleItemListPartitionDesc() ISingleItemListPartitionDescContext
	MultiItemListPartitionDesc() IMultiItemListPartitionDescContext

	// IsAddPartitionClauseContext differentiates from other interfaces.
	IsAddPartitionClauseContext()
}

type AddPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddPartitionClauseContext() *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addPartitionClause
	return p
}

func InitEmptyAddPartitionClauseContext(p *AddPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addPartitionClause
}

func (*AddPartitionClauseContext) IsAddPartitionClauseContext() {}

func NewAddPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddPartitionClauseContext {
	var p = new(AddPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addPartitionClause

	return p
}

func (s *AddPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AddPartitionClauseContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddPartitionClauseContext) SingleRangePartition() ISingleRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleRangePartitionContext)
}

func (s *AddPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *AddPartitionClauseContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *AddPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *AddPartitionClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *AddPartitionClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AddPartitionClauseContext) SingleItemListPartitionDesc() ISingleItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleItemListPartitionDescContext)
}

func (s *AddPartitionClauseContext) MultiItemListPartitionDesc() IMultiItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiItemListPartitionDescContext)
}

func (s *AddPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddPartitionClause(s)
	}
}

func (s *AddPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddPartitionClause(s)
	}
}

func (p *StarRocksParser) AddPartitionClause() (localctx IAddPartitionClauseContext) {
	localctx = NewAddPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, StarRocksParserRULE_addPartitionClause)
	var _la int

	p.SetState(3260)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 275, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3231)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3233)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3232)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserPARTITION:
			{
				p.SetState(3235)
				p.SingleRangePartition()
			}

		case StarRocksParserPARTITIONS:
			{
				p.SetState(3236)
				p.Match(StarRocksParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3237)
				p.MultiRangePartition()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3241)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserDISTRIBUTED {
			{
				p.SetState(3240)
				p.DistributionDesc()
			}

		}
		p.SetState(3244)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3243)
				p.Properties()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3246)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3248)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3247)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3252)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 272, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3250)
				p.SingleItemListPartitionDesc()
			}

		case 2:
			{
				p.SetState(3251)
				p.MultiItemListPartitionDesc()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		p.SetState(3255)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserDISTRIBUTED {
			{
				p.SetState(3254)
				p.DistributionDesc()
			}

		}
		p.SetState(3258)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3257)
				p.Properties()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPartitionClauseContext is an interface to support dynamic dispatch.
type IDropPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	PARTITIONS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	TEMPORARY() antlr.TerminalNode
	FORCE() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	MultiRangePartition() IMultiRangePartitionContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ALL() antlr.TerminalNode

	// IsDropPartitionClauseContext differentiates from other interfaces.
	IsDropPartitionClauseContext()
}

type DropPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyDropPartitionClauseContext() *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPartitionClause
	return p
}

func InitEmptyDropPartitionClauseContext(p *DropPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPartitionClause
}

func (*DropPartitionClauseContext) IsDropPartitionClauseContext() {}

func NewDropPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPartitionClauseContext {
	var p = new(DropPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropPartitionClause

	return p
}

func (s *DropPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPartitionClauseContext) GetWhere() IExpressionContext { return s.where }

func (s *DropPartitionClauseContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DropPartitionClauseContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *DropPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropPartitionClauseContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *DropPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DropPartitionClauseContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *DropPartitionClauseContext) FORCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORCE, 0)
}

func (s *DropPartitionClauseContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropPartitionClauseContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropPartitionClauseContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *DropPartitionClauseContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *DropPartitionClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DropPartitionClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *DropPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropPartitionClause(s)
	}
}

func (s *DropPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropPartitionClause(s)
	}
}

func (p *StarRocksParser) DropPartitionClause() (localctx IDropPartitionClauseContext) {
	localctx = NewDropPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, StarRocksParserRULE_dropPartitionClause)
	var _la int

	p.SetState(3317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 288, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3262)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3264)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3263)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserPARTITION:
			{
				p.SetState(3266)
				p.Match(StarRocksParserPARTITION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3269)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIF {
				{
					p.SetState(3267)
					p.Match(StarRocksParserIF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3268)
					p.Match(StarRocksParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3271)
				p.Identifier()
			}

		case StarRocksParserPARTITIONS:
			{
				p.SetState(3272)
				p.Match(StarRocksParserPARTITIONS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3275)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIF {
				{
					p.SetState(3273)
					p.Match(StarRocksParserIF)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3274)
					p.Match(StarRocksParserEXISTS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3277)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(3281)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORCE {
			{
				p.SetState(3280)
				p.Match(StarRocksParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3283)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3285)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3284)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3287)
			p.Match(StarRocksParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3290)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(3288)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3289)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3292)
			p.MultiRangePartition()
		}
		p.SetState(3294)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORCE {
			{
				p.SetState(3293)
				p.Match(StarRocksParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3296)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3297)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3300)
			p.Match(StarRocksParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(3301)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3302)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3305)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3306)

			var _x = p.expression(0)

			localctx.(*DropPartitionClauseContext).where = _x
		}
		p.SetState(3308)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORCE {
			{
				p.SetState(3307)
				p.Match(StarRocksParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3310)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3311)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3312)
			p.Match(StarRocksParserTEMPORARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3313)
			p.Match(StarRocksParserPARTITIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3315)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORCE {
			{
				p.SetState(3314)
				p.Match(StarRocksParserFORCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncatePartitionClauseContext is an interface to support dynamic dispatch.
type ITruncatePartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext

	// IsTruncatePartitionClauseContext differentiates from other interfaces.
	IsTruncatePartitionClauseContext()
}

type TruncatePartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncatePartitionClauseContext() *TruncatePartitionClauseContext {
	var p = new(TruncatePartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncatePartitionClause
	return p
}

func InitEmptyTruncatePartitionClauseContext(p *TruncatePartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncatePartitionClause
}

func (*TruncatePartitionClauseContext) IsTruncatePartitionClauseContext() {}

func NewTruncatePartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncatePartitionClauseContext {
	var p = new(TruncatePartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_truncatePartitionClause

	return p
}

func (s *TruncatePartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncatePartitionClauseContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUNCATE, 0)
}

func (s *TruncatePartitionClauseContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TruncatePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncatePartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncatePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTruncatePartitionClause(s)
	}
}

func (s *TruncatePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTruncatePartitionClause(s)
	}
}

func (p *StarRocksParser) TruncatePartitionClause() (localctx ITruncatePartitionClauseContext) {
	localctx = NewTruncatePartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, StarRocksParserRULE_truncatePartitionClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3319)
		p.Match(StarRocksParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3320)
		p.PartitionNames()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IModifyPartitionClauseContext is an interface to support dynamic dispatch.
type IModifyPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MODIFY() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext
	ASTERISK_SYMBOL() antlr.TerminalNode
	DistributionDesc() IDistributionDescContext

	// IsModifyPartitionClauseContext differentiates from other interfaces.
	IsModifyPartitionClauseContext()
}

type ModifyPartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModifyPartitionClauseContext() *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyPartitionClause
	return p
}

func InitEmptyModifyPartitionClauseContext(p *ModifyPartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_modifyPartitionClause
}

func (*ModifyPartitionClauseContext) IsModifyPartitionClauseContext() {}

func NewModifyPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModifyPartitionClauseContext {
	var p = new(ModifyPartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_modifyPartitionClause

	return p
}

func (s *ModifyPartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ModifyPartitionClauseContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *ModifyPartitionClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *ModifyPartitionClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ModifyPartitionClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ModifyPartitionClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModifyPartitionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *ModifyPartitionClauseContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *ModifyPartitionClauseContext) DistributionDesc() IDistributionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDistributionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDistributionDescContext)
}

func (s *ModifyPartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModifyPartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModifyPartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterModifyPartitionClause(s)
	}
}

func (s *ModifyPartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitModifyPartitionClause(s)
	}
}

func (p *StarRocksParser) ModifyPartitionClause() (localctx IModifyPartitionClauseContext) {
	localctx = NewModifyPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, StarRocksParserRULE_modifyPartitionClause)
	p.SetState(3336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3322)
			p.Match(StarRocksParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3323)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3329)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 289, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3324)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(3325)
				p.IdentifierList()
			}

		case 3:
			{
				p.SetState(3326)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3327)
				p.Match(StarRocksParserASTERISK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3328)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3331)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3332)
			p.PropertyList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3333)
			p.Match(StarRocksParserMODIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3334)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3335)
			p.DistributionDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacePartitionClauseContext is an interface to support dynamic dispatch.
type IReplacePartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParName returns the parName rule contexts.
	GetParName() IPartitionNamesContext

	// GetTempParName returns the tempParName rule contexts.
	GetTempParName() IPartitionNamesContext

	// SetParName sets the parName rule contexts.
	SetParName(IPartitionNamesContext)

	// SetTempParName sets the tempParName rule contexts.
	SetTempParName(IPartitionNamesContext)

	// Getter signatures
	REPLACE() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllPartitionNames() []IPartitionNamesContext
	PartitionNames(i int) IPartitionNamesContext
	Properties() IPropertiesContext

	// IsReplacePartitionClauseContext differentiates from other interfaces.
	IsReplacePartitionClauseContext()
}

type ReplacePartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	parName     IPartitionNamesContext
	tempParName IPartitionNamesContext
}

func NewEmptyReplacePartitionClauseContext() *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_replacePartitionClause
	return p
}

func InitEmptyReplacePartitionClauseContext(p *ReplacePartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_replacePartitionClause
}

func (*ReplacePartitionClauseContext) IsReplacePartitionClauseContext() {}

func NewReplacePartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacePartitionClauseContext {
	var p = new(ReplacePartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_replacePartitionClause

	return p
}

func (s *ReplacePartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacePartitionClauseContext) GetParName() IPartitionNamesContext { return s.parName }

func (s *ReplacePartitionClauseContext) GetTempParName() IPartitionNamesContext { return s.tempParName }

func (s *ReplacePartitionClauseContext) SetParName(v IPartitionNamesContext) { s.parName = v }

func (s *ReplacePartitionClauseContext) SetTempParName(v IPartitionNamesContext) { s.tempParName = v }

func (s *ReplacePartitionClauseContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *ReplacePartitionClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *ReplacePartitionClauseContext) AllPartitionNames() []IPartitionNamesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			len++
		}
	}

	tst := make([]IPartitionNamesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionNamesContext); ok {
			tst[i] = t.(IPartitionNamesContext)
			i++
		}
	}

	return tst
}

func (s *ReplacePartitionClauseContext) PartitionNames(i int) IPartitionNamesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ReplacePartitionClauseContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ReplacePartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacePartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterReplacePartitionClause(s)
	}
}

func (s *ReplacePartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitReplacePartitionClause(s)
	}
}

func (p *StarRocksParser) ReplacePartitionClause() (localctx IReplacePartitionClauseContext) {
	localctx = NewReplacePartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, StarRocksParserRULE_replacePartitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3338)
		p.Match(StarRocksParserREPLACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3339)

		var _x = p.PartitionNames()

		localctx.(*ReplacePartitionClauseContext).parName = _x
	}
	{
		p.SetState(3340)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3341)

		var _x = p.PartitionNames()

		localctx.(*ReplacePartitionClauseContext).tempParName = _x
	}
	p.SetState(3343)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3342)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionRenameClauseContext is an interface to support dynamic dispatch.
type IPartitionRenameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetParName returns the parName rule contexts.
	GetParName() IIdentifierContext

	// GetNewParName returns the newParName rule contexts.
	GetNewParName() IIdentifierContext

	// SetParName sets the parName rule contexts.
	SetParName(IIdentifierContext)

	// SetNewParName sets the newParName rule contexts.
	SetNewParName(IIdentifierContext)

	// Getter signatures
	RENAME() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsPartitionRenameClauseContext differentiates from other interfaces.
	IsPartitionRenameClauseContext()
}

type PartitionRenameClauseContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	parName    IIdentifierContext
	newParName IIdentifierContext
}

func NewEmptyPartitionRenameClauseContext() *PartitionRenameClauseContext {
	var p = new(PartitionRenameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionRenameClause
	return p
}

func InitEmptyPartitionRenameClauseContext(p *PartitionRenameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionRenameClause
}

func (*PartitionRenameClauseContext) IsPartitionRenameClauseContext() {}

func NewPartitionRenameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionRenameClauseContext {
	var p = new(PartitionRenameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionRenameClause

	return p
}

func (s *PartitionRenameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionRenameClauseContext) GetParName() IIdentifierContext { return s.parName }

func (s *PartitionRenameClauseContext) GetNewParName() IIdentifierContext { return s.newParName }

func (s *PartitionRenameClauseContext) SetParName(v IIdentifierContext) { s.parName = v }

func (s *PartitionRenameClauseContext) SetNewParName(v IIdentifierContext) { s.newParName = v }

func (s *PartitionRenameClauseContext) RENAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRENAME, 0)
}

func (s *PartitionRenameClauseContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *PartitionRenameClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *PartitionRenameClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionRenameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionRenameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionRenameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionRenameClause(s)
	}
}

func (s *PartitionRenameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionRenameClause(s)
	}
}

func (p *StarRocksParser) PartitionRenameClause() (localctx IPartitionRenameClauseContext) {
	localctx = NewPartitionRenameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, StarRocksParserRULE_partitionRenameClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3345)
		p.Match(StarRocksParserRENAME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3346)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3347)

		var _x = p.Identifier()

		localctx.(*PartitionRenameClauseContext).parName = _x
	}
	{
		p.SetState(3348)

		var _x = p.Identifier()

		localctx.(*PartitionRenameClauseContext).newParName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertStatementContext is an interface to support dynamic dispatch.
type IInsertStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSERT() antlr.TerminalNode
	INTO() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	QueryStatement() IQueryStatementContext
	ExplainDesc() IExplainDescContext
	AllInsertLabelOrColumnAliases() []IInsertLabelOrColumnAliasesContext
	InsertLabelOrColumnAliases(i int) IInsertLabelOrColumnAliasesContext
	Properties() IPropertiesContext
	FILES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	BLACKHOLE() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	AllExpressionsWithDefault() []IExpressionsWithDefaultContext
	ExpressionsWithDefault(i int) IExpressionsWithDefaultContext
	WriteBranch() IWriteBranchContext
	PartitionNames() IPartitionNamesContext

	// IsInsertStatementContext differentiates from other interfaces.
	IsInsertStatementContext()
}

type InsertStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertStatementContext() *InsertStatementContext {
	var p = new(InsertStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_insertStatement
	return p
}

func InitEmptyInsertStatementContext(p *InsertStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_insertStatement
}

func (*InsertStatementContext) IsInsertStatementContext() {}

func NewInsertStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertStatementContext {
	var p = new(InsertStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_insertStatement

	return p
}

func (s *InsertStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertStatementContext) INSERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINSERT, 0)
}

func (s *InsertStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *InsertStatementContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOVERWRITE, 0)
}

func (s *InsertStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *InsertStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *InsertStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *InsertStatementContext) AllInsertLabelOrColumnAliases() []IInsertLabelOrColumnAliasesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			len++
		}
	}

	tst := make([]IInsertLabelOrColumnAliasesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			tst[i] = t.(IInsertLabelOrColumnAliasesContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) InsertLabelOrColumnAliases(i int) IInsertLabelOrColumnAliasesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertLabelOrColumnAliasesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertLabelOrColumnAliasesContext)
}

func (s *InsertStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *InsertStatementContext) FILES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILES, 0)
}

func (s *InsertStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *InsertStatementContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKHOLE, 0)
}

func (s *InsertStatementContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *InsertStatementContext) AllExpressionsWithDefault() []IExpressionsWithDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionsWithDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionsWithDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionsWithDefaultContext); ok {
			tst[i] = t.(IExpressionsWithDefaultContext)
			i++
		}
	}

	return tst
}

func (s *InsertStatementContext) ExpressionsWithDefault(i int) IExpressionsWithDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionsWithDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionsWithDefaultContext)
}

func (s *InsertStatementContext) WriteBranch() IWriteBranchContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteBranchContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteBranchContext)
}

func (s *InsertStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *InsertStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInsertStatement(s)
	}
}

func (s *InsertStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInsertStatement(s)
	}
}

func (p *StarRocksParser) InsertStatement() (localctx IInsertStatementContext) {
	localctx = NewInsertStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, StarRocksParserRULE_insertStatement)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-123)) & ^0x3f) == 0 && ((int64(1)<<(_la-123))&8388611) != 0 {
		{
			p.SetState(3350)
			p.ExplainDesc()
		}

	}
	{
		p.SetState(3353)
		p.Match(StarRocksParserINSERT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3354)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserINTO || _la == StarRocksParserOVERWRITE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3367)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 295, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3355)
			p.QualifiedName()
		}
		p.SetState(3357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR || _la == StarRocksParserVERSION {
			{
				p.SetState(3356)
				p.WriteBranch()
			}

		}
		p.SetState(3360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
			{
				p.SetState(3359)
				p.PartitionNames()
			}

		}

	case 2:
		{
			p.SetState(3362)
			p.Match(StarRocksParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3363)
			p.PropertyList()
		}

	case 3:
		{
			p.SetState(3364)
			p.Match(StarRocksParserBLACKHOLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3365)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3366)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3372)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3369)
				p.InsertLabelOrColumnAliases()
			}

		}
		p.SetState(3374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 296, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(3376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3375)
			p.Properties()
		}

	}
	p.SetState(3388)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserEXPLAIN, StarRocksParserSELECT, StarRocksParserTRACE, StarRocksParserWITH:
		{
			p.SetState(3378)
			p.QueryStatement()
		}

	case StarRocksParserVALUES:
		{
			p.SetState(3379)
			p.Match(StarRocksParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3380)
			p.ExpressionsWithDefault()
		}
		p.SetState(3385)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3381)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3382)
				p.ExpressionsWithDefault()
			}

			p.SetState(3387)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertLabelOrColumnAliasesContext is an interface to support dynamic dispatch.
type IInsertLabelOrColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() IIdentifierContext

	// SetLabel sets the label rule contexts.
	SetLabel(IIdentifierContext)

	// Getter signatures
	ColumnAliasesOrByName() IColumnAliasesOrByNameContext
	WITH() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsInsertLabelOrColumnAliasesContext differentiates from other interfaces.
	IsInsertLabelOrColumnAliasesContext()
}

type InsertLabelOrColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	label  IIdentifierContext
}

func NewEmptyInsertLabelOrColumnAliasesContext() *InsertLabelOrColumnAliasesContext {
	var p = new(InsertLabelOrColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_insertLabelOrColumnAliases
	return p
}

func InitEmptyInsertLabelOrColumnAliasesContext(p *InsertLabelOrColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_insertLabelOrColumnAliases
}

func (*InsertLabelOrColumnAliasesContext) IsInsertLabelOrColumnAliasesContext() {}

func NewInsertLabelOrColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertLabelOrColumnAliasesContext {
	var p = new(InsertLabelOrColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_insertLabelOrColumnAliases

	return p
}

func (s *InsertLabelOrColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertLabelOrColumnAliasesContext) GetLabel() IIdentifierContext { return s.label }

func (s *InsertLabelOrColumnAliasesContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *InsertLabelOrColumnAliasesContext) ColumnAliasesOrByName() IColumnAliasesOrByNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesOrByNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesOrByNameContext)
}

func (s *InsertLabelOrColumnAliasesContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *InsertLabelOrColumnAliasesContext) LABEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLABEL, 0)
}

func (s *InsertLabelOrColumnAliasesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InsertLabelOrColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertLabelOrColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertLabelOrColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInsertLabelOrColumnAliases(s)
	}
}

func (s *InsertLabelOrColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInsertLabelOrColumnAliases(s)
	}
}

func (p *StarRocksParser) InsertLabelOrColumnAliases() (localctx IInsertLabelOrColumnAliasesContext) {
	localctx = NewInsertLabelOrColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, StarRocksParserRULE_insertLabelOrColumnAliases)
	p.SetState(3394)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserBY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3390)
			p.ColumnAliasesOrByName()
		}

	case StarRocksParserWITH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3391)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3392)
			p.Match(StarRocksParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3393)

			var _x = p.Identifier()

			localctx.(*InsertLabelOrColumnAliasesContext).label = _x
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesOrByNameContext is an interface to support dynamic dispatch.
type IColumnAliasesOrByNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnAliases() IColumnAliasesContext
	BY() antlr.TerminalNode
	NAME() antlr.TerminalNode

	// IsColumnAliasesOrByNameContext differentiates from other interfaces.
	IsColumnAliasesOrByNameContext()
}

type ColumnAliasesOrByNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesOrByNameContext() *ColumnAliasesOrByNameContext {
	var p = new(ColumnAliasesOrByNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnAliasesOrByName
	return p
}

func InitEmptyColumnAliasesOrByNameContext(p *ColumnAliasesOrByNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnAliasesOrByName
}

func (*ColumnAliasesOrByNameContext) IsColumnAliasesOrByNameContext() {}

func NewColumnAliasesOrByNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesOrByNameContext {
	var p = new(ColumnAliasesOrByNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnAliasesOrByName

	return p
}

func (s *ColumnAliasesOrByNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesOrByNameContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *ColumnAliasesOrByNameContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ColumnAliasesOrByNameContext) NAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNAME, 0)
}

func (s *ColumnAliasesOrByNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesOrByNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesOrByNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnAliasesOrByName(s)
	}
}

func (s *ColumnAliasesOrByNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnAliasesOrByName(s)
	}
}

func (p *StarRocksParser) ColumnAliasesOrByName() (localctx IColumnAliasesOrByNameContext) {
	localctx = NewColumnAliasesOrByNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, StarRocksParserRULE_columnAliasesOrByName)
	p.SetState(3399)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3396)
			p.ColumnAliases()
		}

	case StarRocksParserBY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3397)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3398)
			p.Match(StarRocksParserNAME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	UPDATE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	SET() antlr.TerminalNode
	AssignmentList() IAssignmentListContext
	FromClause() IFromClauseContext
	ExplainDesc() IExplainDescContext
	WithClause() IWithClauseContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *UpdateStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *UpdateStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUPDATE, 0)
}

func (s *UpdateStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *UpdateStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *UpdateStatementContext) AssignmentList() IAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentListContext)
}

func (s *UpdateStatementContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *UpdateStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *UpdateStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *UpdateStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *UpdateStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (p *StarRocksParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, StarRocksParserRULE_updateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-123)) & ^0x3f) == 0 && ((int64(1)<<(_la-123))&8388611) != 0 {
		{
			p.SetState(3401)
			p.ExplainDesc()
		}

	}
	p.SetState(3405)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3404)
			p.WithClause()
		}

	}
	{
		p.SetState(3407)
		p.Match(StarRocksParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3408)
		p.QualifiedName()
	}
	{
		p.SetState(3409)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3410)
		p.AssignmentList()
	}
	{
		p.SetState(3411)
		p.FromClause()
	}
	p.SetState(3414)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3412)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3413)

			var _x = p.expression(0)

			localctx.(*UpdateStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetUsing returns the using rule contexts.
	GetUsing() IRelationsContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetUsing sets the using rule contexts.
	SetUsing(IRelationsContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	ExplainDesc() IExplainDescContext
	WithClause() IWithClauseContext
	PartitionNames() IPartitionNamesContext
	USING() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Relations() IRelationsContext
	Expression() IExpressionContext

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	using  IRelationsContext
	where  IExpressionContext
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_deleteStatement
	return p
}

func InitEmptyDeleteStatementContext(p *DeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_deleteStatement
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) GetUsing() IRelationsContext { return s.using }

func (s *DeleteStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *DeleteStatementContext) SetUsing(v IRelationsContext) { s.using = v }

func (s *DeleteStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *DeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DeleteStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DeleteStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *DeleteStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *DeleteStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *DeleteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *DeleteStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *DeleteStatementContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *DeleteStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (p *StarRocksParser) DeleteStatement() (localctx IDeleteStatementContext) {
	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, StarRocksParserRULE_deleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3417)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-123)) & ^0x3f) == 0 && ((int64(1)<<(_la-123))&8388611) != 0 {
		{
			p.SetState(3416)
			p.ExplainDesc()
		}

	}
	p.SetState(3420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3419)
			p.WithClause()
		}

	}
	{
		p.SetState(3422)
		p.Match(StarRocksParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3423)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3424)
		p.QualifiedName()
	}
	p.SetState(3426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(3425)
			p.PartitionNames()
		}

	}
	p.SetState(3430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(3428)
			p.Match(StarRocksParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3429)

			var _x = p.Relations()

			localctx.(*DeleteStatementContext).using = _x
		}

	}
	p.SetState(3434)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3432)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3433)

			var _x = p.expression(0)

			localctx.(*DeleteStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoutineLoadStatementContext is an interface to support dynamic dispatch.
type ICreateRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// GetTable returns the table rule contexts.
	GetTable() IQualifiedNameContext

	// GetSource returns the source rule contexts.
	GetSource() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// SetTable sets the table rule contexts.
	SetTable(IQualifiedNameContext)

	// SetSource sets the source rule contexts.
	SetSource(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ON() antlr.TerminalNode
	FROM() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllLoadProperties() []ILoadPropertiesContext
	LoadProperties(i int) ILoadPropertiesContext
	JobProperties() IJobPropertiesContext
	DataSourceProperties() IDataSourcePropertiesContext

	// IsCreateRoutineLoadStatementContext differentiates from other interfaces.
	IsCreateRoutineLoadStatementContext()
}

type CreateRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
	table  IQualifiedNameContext
	source IIdentifierContext
}

func NewEmptyCreateRoutineLoadStatementContext() *CreateRoutineLoadStatementContext {
	var p = new(CreateRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRoutineLoadStatement
	return p
}

func InitEmptyCreateRoutineLoadStatementContext(p *CreateRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRoutineLoadStatement
}

func (*CreateRoutineLoadStatementContext) IsCreateRoutineLoadStatementContext() {}

func NewCreateRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoutineLoadStatementContext {
	var p = new(CreateRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createRoutineLoadStatement

	return p
}

func (s *CreateRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *CreateRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *CreateRoutineLoadStatementContext) GetTable() IQualifiedNameContext { return s.table }

func (s *CreateRoutineLoadStatementContext) GetSource() IIdentifierContext { return s.source }

func (s *CreateRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *CreateRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CreateRoutineLoadStatementContext) SetTable(v IQualifiedNameContext) { s.table = v }

func (s *CreateRoutineLoadStatementContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *CreateRoutineLoadStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *CreateRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *CreateRoutineLoadStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CreateRoutineLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CreateRoutineLoadStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRoutineLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateRoutineLoadStatementContext) AllLoadProperties() []ILoadPropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertiesContext); ok {
			tst[i] = t.(ILoadPropertiesContext)
			i++
		}
	}

	return tst
}

func (s *CreateRoutineLoadStatementContext) LoadProperties(i int) ILoadPropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) DataSourceProperties() IDataSourcePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourcePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourcePropertiesContext)
}

func (s *CreateRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateRoutineLoadStatement(s)
	}
}

func (s *CreateRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateRoutineLoadStatement(s)
	}
}

func (p *StarRocksParser) CreateRoutineLoadStatement() (localctx ICreateRoutineLoadStatementContext) {
	localctx = NewCreateRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, StarRocksParserRULE_createRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3436)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3437)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3438)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3442)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 310, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3439)

			var _x = p.QualifiedName()

			localctx.(*CreateRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3440)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3444)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadStatementContext).name = _x
	}
	{
		p.SetState(3445)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3446)

		var _x = p.QualifiedName()

		localctx.(*CreateRoutineLoadStatementContext).table = _x
	}
	p.SetState(3455)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOLUMNS || _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserROWS || _la == StarRocksParserTEMPORARY || _la == StarRocksParserWHERE {
		{
			p.SetState(3447)
			p.LoadProperties()
		}
		p.SetState(3452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3448)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3449)
				p.LoadProperties()
			}

			p.SetState(3454)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3457)
			p.JobProperties()
		}

	}
	{
		p.SetState(3460)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3461)

		var _x = p.Identifier()

		localctx.(*CreateRoutineLoadStatementContext).source = _x
	}
	p.SetState(3463)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(3462)
			p.DataSourceProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IAlterRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	AllLoadProperties() []ILoadPropertiesContext
	LoadProperties(i int) ILoadPropertiesContext
	JobProperties() IJobPropertiesContext
	DataSource() IDataSourceContext
	QualifiedName() IQualifiedNameContext

	// IsAlterRoutineLoadStatementContext differentiates from other interfaces.
	IsAlterRoutineLoadStatementContext()
}

type AlterRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyAlterRoutineLoadStatementContext() *AlterRoutineLoadStatementContext {
	var p = new(AlterRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterRoutineLoadStatement
	return p
}

func InitEmptyAlterRoutineLoadStatementContext(p *AlterRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterRoutineLoadStatement
}

func (*AlterRoutineLoadStatementContext) IsAlterRoutineLoadStatementContext() {}

func NewAlterRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoutineLoadStatementContext {
	var p = new(AlterRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterRoutineLoadStatement

	return p
}

func (s *AlterRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *AlterRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *AlterRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *AlterRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterRoutineLoadStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *AlterRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *AlterRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *AlterRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterRoutineLoadStatementContext) AllLoadProperties() []ILoadPropertiesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			len++
		}
	}

	tst := make([]ILoadPropertiesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILoadPropertiesContext); ok {
			tst[i] = t.(ILoadPropertiesContext)
			i++
		}
	}

	return tst
}

func (s *AlterRoutineLoadStatementContext) LoadProperties(i int) ILoadPropertiesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILoadPropertiesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILoadPropertiesContext)
}

func (s *AlterRoutineLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *AlterRoutineLoadStatementContext) DataSource() IDataSourceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourceContext)
}

func (s *AlterRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterRoutineLoadStatement(s)
	}
}

func (s *AlterRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterRoutineLoadStatement(s)
	}
}

func (p *StarRocksParser) AlterRoutineLoadStatement() (localctx IAlterRoutineLoadStatementContext) {
	localctx = NewAlterRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, StarRocksParserRULE_alterRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3465)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3466)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3467)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3468)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3472)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3469)

			var _x = p.QualifiedName()

			localctx.(*AlterRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3470)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3474)

		var _x = p.Identifier()

		localctx.(*AlterRoutineLoadStatementContext).name = _x
	}
	p.SetState(3483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOLUMNS || _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserROWS || _la == StarRocksParserTEMPORARY || _la == StarRocksParserWHERE {
		{
			p.SetState(3475)
			p.LoadProperties()
		}
		p.SetState(3480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3476)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3477)
				p.LoadProperties()
			}

			p.SetState(3482)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3485)
			p.JobProperties()
		}

	}
	p.SetState(3489)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3488)
			p.DataSource()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataSourceContext is an interface to support dynamic dispatch.
type IDataSourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSource returns the source rule contexts.
	GetSource() IIdentifierContext

	// SetSource sets the source rule contexts.
	SetSource(IIdentifierContext)

	// Getter signatures
	FROM() antlr.TerminalNode
	DataSourceProperties() IDataSourcePropertiesContext
	Identifier() IIdentifierContext

	// IsDataSourceContext differentiates from other interfaces.
	IsDataSourceContext()
}

type DataSourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	source IIdentifierContext
}

func NewEmptyDataSourceContext() *DataSourceContext {
	var p = new(DataSourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataSource
	return p
}

func InitEmptyDataSourceContext(p *DataSourceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataSource
}

func (*DataSourceContext) IsDataSourceContext() {}

func NewDataSourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSourceContext {
	var p = new(DataSourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataSource

	return p
}

func (s *DataSourceContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSourceContext) GetSource() IIdentifierContext { return s.source }

func (s *DataSourceContext) SetSource(v IIdentifierContext) { s.source = v }

func (s *DataSourceContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DataSourceContext) DataSourceProperties() IDataSourcePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSourcePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSourcePropertiesContext)
}

func (s *DataSourceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataSourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSourceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataSource(s)
	}
}

func (s *DataSourceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataSource(s)
	}
}

func (p *StarRocksParser) DataSource() (localctx IDataSourceContext) {
	localctx = NewDataSourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, StarRocksParserRULE_dataSource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3491)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3492)

		var _x = p.Identifier()

		localctx.(*DataSourceContext).source = _x
	}
	{
		p.SetState(3493)
		p.DataSourceProperties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadPropertiesContext is an interface to support dynamic dispatch.
type ILoadPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColSeparatorProperty() IColSeparatorPropertyContext
	RowDelimiterProperty() IRowDelimiterPropertyContext
	ImportColumns() IImportColumnsContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	PartitionNames() IPartitionNamesContext

	// IsLoadPropertiesContext differentiates from other interfaces.
	IsLoadPropertiesContext()
}

type LoadPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLoadPropertiesContext() *LoadPropertiesContext {
	var p = new(LoadPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_loadProperties
	return p
}

func InitEmptyLoadPropertiesContext(p *LoadPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_loadProperties
}

func (*LoadPropertiesContext) IsLoadPropertiesContext() {}

func NewLoadPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadPropertiesContext {
	var p = new(LoadPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_loadProperties

	return p
}

func (s *LoadPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadPropertiesContext) ColSeparatorProperty() IColSeparatorPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColSeparatorPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColSeparatorPropertyContext)
}

func (s *LoadPropertiesContext) RowDelimiterProperty() IRowDelimiterPropertyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowDelimiterPropertyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowDelimiterPropertyContext)
}

func (s *LoadPropertiesContext) ImportColumns() IImportColumnsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IImportColumnsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IImportColumnsContext)
}

func (s *LoadPropertiesContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *LoadPropertiesContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LoadPropertiesContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *LoadPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLoadProperties(s)
	}
}

func (s *LoadPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLoadProperties(s)
	}
}

func (p *StarRocksParser) LoadProperties() (localctx ILoadPropertiesContext) {
	localctx = NewLoadPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, StarRocksParserRULE_loadProperties)
	p.SetState(3501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 320, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3495)
			p.ColSeparatorProperty()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3496)
			p.RowDelimiterProperty()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3497)
			p.ImportColumns()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3498)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3499)
			p.expression(0)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3500)
			p.PartitionNames()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColSeparatorPropertyContext is an interface to support dynamic dispatch.
type IColSeparatorPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	String_() IStringContext

	// IsColSeparatorPropertyContext differentiates from other interfaces.
	IsColSeparatorPropertyContext()
}

type ColSeparatorPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColSeparatorPropertyContext() *ColSeparatorPropertyContext {
	var p = new(ColSeparatorPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_colSeparatorProperty
	return p
}

func InitEmptyColSeparatorPropertyContext(p *ColSeparatorPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_colSeparatorProperty
}

func (*ColSeparatorPropertyContext) IsColSeparatorPropertyContext() {}

func NewColSeparatorPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColSeparatorPropertyContext {
	var p = new(ColSeparatorPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_colSeparatorProperty

	return p
}

func (s *ColSeparatorPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *ColSeparatorPropertyContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *ColSeparatorPropertyContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTERMINATED, 0)
}

func (s *ColSeparatorPropertyContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ColSeparatorPropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ColSeparatorPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColSeparatorPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColSeparatorPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColSeparatorProperty(s)
	}
}

func (s *ColSeparatorPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColSeparatorProperty(s)
	}
}

func (p *StarRocksParser) ColSeparatorProperty() (localctx IColSeparatorPropertyContext) {
	localctx = NewColSeparatorPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, StarRocksParserRULE_colSeparatorProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3503)
		p.Match(StarRocksParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3504)
		p.Match(StarRocksParserTERMINATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3505)
		p.Match(StarRocksParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3506)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowDelimiterPropertyContext is an interface to support dynamic dispatch.
type IRowDelimiterPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS() antlr.TerminalNode
	TERMINATED() antlr.TerminalNode
	BY() antlr.TerminalNode
	String_() IStringContext

	// IsRowDelimiterPropertyContext differentiates from other interfaces.
	IsRowDelimiterPropertyContext()
}

type RowDelimiterPropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowDelimiterPropertyContext() *RowDelimiterPropertyContext {
	var p = new(RowDelimiterPropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rowDelimiterProperty
	return p
}

func InitEmptyRowDelimiterPropertyContext(p *RowDelimiterPropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rowDelimiterProperty
}

func (*RowDelimiterPropertyContext) IsRowDelimiterPropertyContext() {}

func NewRowDelimiterPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowDelimiterPropertyContext {
	var p = new(RowDelimiterPropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rowDelimiterProperty

	return p
}

func (s *RowDelimiterPropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *RowDelimiterPropertyContext) ROWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROWS, 0)
}

func (s *RowDelimiterPropertyContext) TERMINATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTERMINATED, 0)
}

func (s *RowDelimiterPropertyContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *RowDelimiterPropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RowDelimiterPropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowDelimiterPropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowDelimiterPropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRowDelimiterProperty(s)
	}
}

func (s *RowDelimiterPropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRowDelimiterProperty(s)
	}
}

func (p *StarRocksParser) RowDelimiterProperty() (localctx IRowDelimiterPropertyContext) {
	localctx = NewRowDelimiterPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, StarRocksParserRULE_rowDelimiterProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3508)
		p.Match(StarRocksParserROWS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3509)
		p.Match(StarRocksParserTERMINATED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3510)
		p.Match(StarRocksParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3511)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IImportColumnsContext is an interface to support dynamic dispatch.
type IImportColumnsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS() antlr.TerminalNode
	ColumnProperties() IColumnPropertiesContext

	// IsImportColumnsContext differentiates from other interfaces.
	IsImportColumnsContext()
}

type ImportColumnsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImportColumnsContext() *ImportColumnsContext {
	var p = new(ImportColumnsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_importColumns
	return p
}

func InitEmptyImportColumnsContext(p *ImportColumnsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_importColumns
}

func (*ImportColumnsContext) IsImportColumnsContext() {}

func NewImportColumnsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ImportColumnsContext {
	var p = new(ImportColumnsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_importColumns

	return p
}

func (s *ImportColumnsContext) GetParser() antlr.Parser { return s.parser }

func (s *ImportColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *ImportColumnsContext) ColumnProperties() IColumnPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnPropertiesContext)
}

func (s *ImportColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImportColumnsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ImportColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterImportColumns(s)
	}
}

func (s *ImportColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitImportColumns(s)
	}
}

func (p *StarRocksParser) ImportColumns() (localctx IImportColumnsContext) {
	localctx = NewImportColumnsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, StarRocksParserRULE_importColumns)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3513)
		p.Match(StarRocksParserCOLUMNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3514)
		p.ColumnProperties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnPropertiesContext is an interface to support dynamic dispatch.
type IColumnPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllAssignment() []IAssignmentContext
	Assignment(i int) IAssignmentContext

	// IsColumnPropertiesContext differentiates from other interfaces.
	IsColumnPropertiesContext()
}

type ColumnPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnPropertiesContext() *ColumnPropertiesContext {
	var p = new(ColumnPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnProperties
	return p
}

func InitEmptyColumnPropertiesContext(p *ColumnPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnProperties
}

func (*ColumnPropertiesContext) IsColumnPropertiesContext() {}

func NewColumnPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnPropertiesContext {
	var p = new(ColumnPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnProperties

	return p
}

func (s *ColumnPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnPropertiesContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ColumnPropertiesContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ColumnPropertiesContext) AllAssignment() []IAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentContext); ok {
			tst[i] = t.(IAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *ColumnPropertiesContext) Assignment(i int) IAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *ColumnPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnProperties(s)
	}
}

func (s *ColumnPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnProperties(s)
	}
}

func (p *StarRocksParser) ColumnProperties() (localctx IColumnPropertiesContext) {
	localctx = NewColumnPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, StarRocksParserRULE_columnProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3516)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3519)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3517)
			p.QualifiedName()
		}

	case 2:
		{
			p.SetState(3518)
			p.Assignment()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(3528)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(3521)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 322, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3522)
				p.QualifiedName()
			}

		case 2:
			{
				p.SetState(3523)
				p.Assignment()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(3530)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3531)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJobPropertiesContext is an interface to support dynamic dispatch.
type IJobPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Properties() IPropertiesContext

	// IsJobPropertiesContext differentiates from other interfaces.
	IsJobPropertiesContext()
}

type JobPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJobPropertiesContext() *JobPropertiesContext {
	var p = new(JobPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_jobProperties
	return p
}

func InitEmptyJobPropertiesContext(p *JobPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_jobProperties
}

func (*JobPropertiesContext) IsJobPropertiesContext() {}

func NewJobPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JobPropertiesContext {
	var p = new(JobPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_jobProperties

	return p
}

func (s *JobPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *JobPropertiesContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *JobPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JobPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JobPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterJobProperties(s)
	}
}

func (s *JobPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitJobProperties(s)
	}
}

func (p *StarRocksParser) JobProperties() (localctx IJobPropertiesContext) {
	localctx = NewJobPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, StarRocksParserRULE_jobProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3533)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataSourcePropertiesContext is an interface to support dynamic dispatch.
type IDataSourcePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PropertyList() IPropertyListContext

	// IsDataSourcePropertiesContext differentiates from other interfaces.
	IsDataSourcePropertiesContext()
}

type DataSourcePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSourcePropertiesContext() *DataSourcePropertiesContext {
	var p = new(DataSourcePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataSourceProperties
	return p
}

func InitEmptyDataSourcePropertiesContext(p *DataSourcePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataSourceProperties
}

func (*DataSourcePropertiesContext) IsDataSourcePropertiesContext() {}

func NewDataSourcePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSourcePropertiesContext {
	var p = new(DataSourcePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataSourceProperties

	return p
}

func (s *DataSourcePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSourcePropertiesContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *DataSourcePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSourcePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSourcePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataSourceProperties(s)
	}
}

func (s *DataSourcePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataSourceProperties(s)
	}
}

func (p *StarRocksParser) DataSourceProperties() (localctx IDataSourcePropertiesContext) {
	localctx = NewDataSourcePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, StarRocksParserRULE_dataSourceProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3535)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStopRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IStopRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	STOP() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsStopRoutineLoadStatementContext differentiates from other interfaces.
	IsStopRoutineLoadStatementContext()
}

type StopRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyStopRoutineLoadStatementContext() *StopRoutineLoadStatementContext {
	var p = new(StopRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_stopRoutineLoadStatement
	return p
}

func InitEmptyStopRoutineLoadStatementContext(p *StopRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_stopRoutineLoadStatement
}

func (*StopRoutineLoadStatementContext) IsStopRoutineLoadStatementContext() {}

func NewStopRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopRoutineLoadStatementContext {
	var p = new(StopRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_stopRoutineLoadStatement

	return p
}

func (s *StopRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StopRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *StopRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *StopRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *StopRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *StopRoutineLoadStatementContext) STOP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTOP, 0)
}

func (s *StopRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *StopRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *StopRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *StopRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StopRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *StopRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStopRoutineLoadStatement(s)
	}
}

func (s *StopRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStopRoutineLoadStatement(s)
	}
}

func (p *StarRocksParser) StopRoutineLoadStatement() (localctx IStopRoutineLoadStatementContext) {
	localctx = NewStopRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, StarRocksParserRULE_stopRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3537)
		p.Match(StarRocksParserSTOP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3538)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3539)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3540)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3544)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 324, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3541)

			var _x = p.QualifiedName()

			localctx.(*StopRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3542)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3546)

		var _x = p.Identifier()

		localctx.(*StopRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResumeRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IResumeRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	RESUME() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsResumeRoutineLoadStatementContext differentiates from other interfaces.
	IsResumeRoutineLoadStatementContext()
}

type ResumeRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyResumeRoutineLoadStatementContext() *ResumeRoutineLoadStatementContext {
	var p = new(ResumeRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resumeRoutineLoadStatement
	return p
}

func InitEmptyResumeRoutineLoadStatementContext(p *ResumeRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resumeRoutineLoadStatement
}

func (*ResumeRoutineLoadStatementContext) IsResumeRoutineLoadStatementContext() {}

func NewResumeRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumeRoutineLoadStatementContext {
	var p = new(ResumeRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_resumeRoutineLoadStatement

	return p
}

func (s *ResumeRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumeRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ResumeRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ResumeRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ResumeRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ResumeRoutineLoadStatementContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESUME, 0)
}

func (s *ResumeRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *ResumeRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ResumeRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ResumeRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ResumeRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumeRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterResumeRoutineLoadStatement(s)
	}
}

func (s *ResumeRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitResumeRoutineLoadStatement(s)
	}
}

func (p *StarRocksParser) ResumeRoutineLoadStatement() (localctx IResumeRoutineLoadStatementContext) {
	localctx = NewResumeRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, StarRocksParserRULE_resumeRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3548)
		p.Match(StarRocksParserRESUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3549)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3550)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3551)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3555)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3552)

			var _x = p.QualifiedName()

			localctx.(*ResumeRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3553)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3557)

		var _x = p.Identifier()

		localctx.(*ResumeRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPauseRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IPauseRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	PAUSE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsPauseRoutineLoadStatementContext differentiates from other interfaces.
	IsPauseRoutineLoadStatementContext()
}

type PauseRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyPauseRoutineLoadStatementContext() *PauseRoutineLoadStatementContext {
	var p = new(PauseRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pauseRoutineLoadStatement
	return p
}

func InitEmptyPauseRoutineLoadStatementContext(p *PauseRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pauseRoutineLoadStatement
}

func (*PauseRoutineLoadStatementContext) IsPauseRoutineLoadStatementContext() {}

func NewPauseRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PauseRoutineLoadStatementContext {
	var p = new(PauseRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_pauseRoutineLoadStatement

	return p
}

func (s *PauseRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PauseRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *PauseRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *PauseRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *PauseRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *PauseRoutineLoadStatementContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPAUSE, 0)
}

func (s *PauseRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *PauseRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *PauseRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *PauseRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PauseRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PauseRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PauseRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PauseRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPauseRoutineLoadStatement(s)
	}
}

func (s *PauseRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPauseRoutineLoadStatement(s)
	}
}

func (p *StarRocksParser) PauseRoutineLoadStatement() (localctx IPauseRoutineLoadStatementContext) {
	localctx = NewPauseRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, StarRocksParserRULE_pauseRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3559)
		p.Match(StarRocksParserPAUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3560)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3561)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3562)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3566)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 326, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3563)

			var _x = p.QualifiedName()

			localctx.(*PauseRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3564)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3568)

		var _x = p.Identifier()

		localctx.(*PauseRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IShowRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	Identifier() IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowRoutineLoadStatementContext differentiates from other interfaces.
	IsShowRoutineLoadStatementContext()
}

type ShowRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowRoutineLoadStatementContext() *ShowRoutineLoadStatementContext {
	var p = new(ShowRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadStatement
	return p
}

func InitEmptyShowRoutineLoadStatementContext(p *ShowRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadStatement
}

func (*ShowRoutineLoadStatementContext) IsShowRoutineLoadStatementContext() {}

func NewShowRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRoutineLoadStatementContext {
	var p = new(ShowRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadStatement

	return p
}

func (s *ShowRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowRoutineLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *ShowRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowRoutineLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowRoutineLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowRoutineLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowRoutineLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowRoutineLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRoutineLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowRoutineLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowRoutineLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowRoutineLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowRoutineLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRoutineLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowRoutineLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRoutineLoadStatement(s)
	}
}

func (s *ShowRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRoutineLoadStatement(s)
	}
}

func (p *StarRocksParser) ShowRoutineLoadStatement() (localctx IShowRoutineLoadStatementContext) {
	localctx = NewShowRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, StarRocksParserRULE_showRoutineLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3570)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3572)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserALL {
		{
			p.SetState(3571)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3574)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3575)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3583)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(3576)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3580)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 328, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3577)

				var _x = p.QualifiedName()

				localctx.(*ShowRoutineLoadStatementContext).db = _x
			}
			{
				p.SetState(3578)
				p.Match(StarRocksParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3582)

			var _x = p.Identifier()

			localctx.(*ShowRoutineLoadStatementContext).name = _x
		}

	}
	p.SetState(3587)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3585)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3586)

			var _x = p.QualifiedName()

			localctx.(*ShowRoutineLoadStatementContext).db = _x
		}

	}
	p.SetState(3591)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3589)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3590)
			p.expression(0)
		}

	}
	p.SetState(3603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3593)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3594)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3595)
			p.SortItem()
		}
		p.SetState(3600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3596)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3597)
				p.SortItem()
			}

			p.SetState(3602)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3605)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRoutineLoadTaskStatementContext is an interface to support dynamic dispatch.
type IShowRoutineLoadTaskStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	TASK() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowRoutineLoadTaskStatementContext differentiates from other interfaces.
	IsShowRoutineLoadTaskStatementContext()
}

type ShowRoutineLoadTaskStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowRoutineLoadTaskStatementContext() *ShowRoutineLoadTaskStatementContext {
	var p = new(ShowRoutineLoadTaskStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadTaskStatement
	return p
}

func InitEmptyShowRoutineLoadTaskStatementContext(p *ShowRoutineLoadTaskStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadTaskStatement
}

func (*ShowRoutineLoadTaskStatementContext) IsShowRoutineLoadTaskStatementContext() {}

func NewShowRoutineLoadTaskStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRoutineLoadTaskStatementContext {
	var p = new(ShowRoutineLoadTaskStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRoutineLoadTaskStatement

	return p
}

func (s *ShowRoutineLoadTaskStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRoutineLoadTaskStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowRoutineLoadTaskStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowRoutineLoadTaskStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) TASK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTASK, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRoutineLoadTaskStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowRoutineLoadTaskStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowRoutineLoadTaskStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRoutineLoadTaskStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRoutineLoadTaskStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRoutineLoadTaskStatement(s)
	}
}

func (s *ShowRoutineLoadTaskStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRoutineLoadTaskStatement(s)
	}
}

func (p *StarRocksParser) ShowRoutineLoadTaskStatement() (localctx IShowRoutineLoadTaskStatementContext) {
	localctx = NewShowRoutineLoadTaskStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, StarRocksParserRULE_showRoutineLoadTaskStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3608)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3609)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3610)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3611)
		p.Match(StarRocksParserTASK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3612)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3613)

			var _x = p.QualifiedName()

			localctx.(*ShowRoutineLoadTaskStatementContext).db = _x
		}

	}
	{
		p.SetState(3616)
		p.Match(StarRocksParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3617)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateRoutineLoadStatementContext is an interface to support dynamic dispatch.
type IShowCreateRoutineLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	Identifier() IIdentifierContext
	QualifiedName() IQualifiedNameContext

	// IsShowCreateRoutineLoadStatementContext differentiates from other interfaces.
	IsShowCreateRoutineLoadStatementContext()
}

type ShowCreateRoutineLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowCreateRoutineLoadStatementContext() *ShowCreateRoutineLoadStatementContext {
	var p = new(ShowCreateRoutineLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateRoutineLoadStatement
	return p
}

func InitEmptyShowCreateRoutineLoadStatementContext(p *ShowCreateRoutineLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateRoutineLoadStatement
}

func (*ShowCreateRoutineLoadStatementContext) IsShowCreateRoutineLoadStatementContext() {}

func NewShowCreateRoutineLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateRoutineLoadStatementContext {
	var p = new(ShowCreateRoutineLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateRoutineLoadStatement

	return p
}

func (s *ShowCreateRoutineLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateRoutineLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowCreateRoutineLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowCreateRoutineLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowCreateRoutineLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowCreateRoutineLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowCreateRoutineLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateRoutineLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowCreateRoutineLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateRoutineLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateRoutineLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateRoutineLoadStatement(s)
	}
}

func (s *ShowCreateRoutineLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateRoutineLoadStatement(s)
	}
}

func (p *StarRocksParser) ShowCreateRoutineLoadStatement() (localctx IShowCreateRoutineLoadStatementContext) {
	localctx = NewShowCreateRoutineLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, StarRocksParserRULE_showCreateRoutineLoadStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3619)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3620)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3621)
		p.Match(StarRocksParserROUTINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3622)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3626)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3623)

			var _x = p.QualifiedName()

			localctx.(*ShowCreateRoutineLoadStatementContext).db = _x
		}
		{
			p.SetState(3624)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(3628)

		var _x = p.Identifier()

		localctx.(*ShowCreateRoutineLoadStatementContext).name = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStreamLoadStatementContext is an interface to support dynamic dispatch.
type IShowStreamLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	Identifier() IIdentifierContext
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext

	// IsShowStreamLoadStatementContext differentiates from other interfaces.
	IsShowStreamLoadStatementContext()
}

type ShowStreamLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyShowStreamLoadStatementContext() *ShowStreamLoadStatementContext {
	var p = new(ShowStreamLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStreamLoadStatement
	return p
}

func InitEmptyShowStreamLoadStatementContext(p *ShowStreamLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStreamLoadStatement
}

func (*ShowStreamLoadStatementContext) IsShowStreamLoadStatementContext() {}

func NewShowStreamLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStreamLoadStatementContext {
	var p = new(ShowStreamLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showStreamLoadStatement

	return p
}

func (s *ShowStreamLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStreamLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowStreamLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *ShowStreamLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowStreamLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *ShowStreamLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowStreamLoadStatementContext) STREAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTREAM, 0)
}

func (s *ShowStreamLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowStreamLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowStreamLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowStreamLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowStreamLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowStreamLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStreamLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowStreamLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowStreamLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowStreamLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowStreamLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowStreamLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowStreamLoadStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *ShowStreamLoadStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowStreamLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStreamLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStreamLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowStreamLoadStatement(s)
	}
}

func (s *ShowStreamLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowStreamLoadStatement(s)
	}
}

func (p *StarRocksParser) ShowStreamLoadStatement() (localctx IShowStreamLoadStatementContext) {
	localctx = NewShowStreamLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, StarRocksParserRULE_showStreamLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3630)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserALL {
		{
			p.SetState(3631)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3634)
		p.Match(StarRocksParserSTREAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3635)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(3636)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3640)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 338, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3637)

				var _x = p.QualifiedName()

				localctx.(*ShowStreamLoadStatementContext).db = _x
			}
			{
				p.SetState(3638)
				p.Match(StarRocksParserT__0)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(3642)

			var _x = p.Identifier()

			localctx.(*ShowStreamLoadStatementContext).name = _x
		}

	}
	p.SetState(3647)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(3645)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3646)

			var _x = p.QualifiedName()

			localctx.(*ShowStreamLoadStatementContext).db = _x
		}

	}
	p.SetState(3651)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3649)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3650)
			p.expression(0)
		}

	}
	p.SetState(3663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3653)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3654)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3655)
			p.SortItem()
		}
		p.SetState(3660)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3656)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3657)
				p.SortItem()
			}

			p.SetState(3662)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3666)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3665)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeStatementContext is an interface to support dynamic dispatch.
type IAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	AnalyzeColumnClause() IAnalyzeColumnClauseContext
	PartitionNames() IPartitionNamesContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	Properties() IPropertiesContext
	FULL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAnalyzeStatementContext differentiates from other interfaces.
	IsAnalyzeStatementContext()
}

type AnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeStatementContext() *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeStatement
	return p
}

func InitEmptyAnalyzeStatementContext(p *AnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeStatement
}

func (*AnalyzeStatementContext) IsAnalyzeStatementContext() {}

func NewAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeStatementContext {
	var p = new(AnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_analyzeStatement

	return p
}

func (s *AnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *AnalyzeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *AnalyzeStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *AnalyzeStatementContext) AnalyzeColumnClause() IAnalyzeColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeColumnClauseContext)
}

func (s *AnalyzeStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *AnalyzeStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AnalyzeStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *AnalyzeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AnalyzeStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *AnalyzeStatementContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSAMPLE, 0)
}

func (s *AnalyzeStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *AnalyzeStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *AnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAnalyzeStatement(s)
	}
}

func (s *AnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAnalyzeStatement(s)
	}
}

func (p *StarRocksParser) AnalyzeStatement() (localctx IAnalyzeStatementContext) {
	localctx = NewAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, StarRocksParserRULE_analyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3668)
		p.Match(StarRocksParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL || _la == StarRocksParserSAMPLE {
		{
			p.SetState(3669)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFULL || _la == StarRocksParserSAMPLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(3672)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3673)
		p.TableName()
	}
	p.SetState(3675)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 346, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3674)
			p.AnalyzeColumnClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3678)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(3677)
			p.PartitionNames()
		}

	}
	p.SetState(3683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3680)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3681)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASYNC || _la == StarRocksParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3682)
			p.Match(StarRocksParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3685)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeColumnClauseContext is an interface to support dynamic dispatch.
type IAnalyzeColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAnalyzeColumnClauseContext differentiates from other interfaces.
	IsAnalyzeColumnClauseContext()
}

type AnalyzeColumnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeColumnClauseContext() *AnalyzeColumnClauseContext {
	var p = new(AnalyzeColumnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeColumnClause
	return p
}

func InitEmptyAnalyzeColumnClauseContext(p *AnalyzeColumnClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeColumnClause
}

func (*AnalyzeColumnClauseContext) IsAnalyzeColumnClauseContext() {}

func NewAnalyzeColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeColumnClauseContext {
	var p = new(AnalyzeColumnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_analyzeColumnClause

	return p
}

func (s *AnalyzeColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeColumnClauseContext) CopyAll(ctx *AnalyzeColumnClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AnalyzeColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PredicateColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewPredicateColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateColumnsContext {
	var p = new(PredicateColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *PredicateColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateColumnsContext) PREDICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPREDICATE, 0)
}

func (s *PredicateColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *PredicateColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPredicateColumns(s)
	}
}

func (s *PredicateColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPredicateColumns(s)
	}
}

type RegularColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewRegularColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RegularColumnsContext {
	var p = new(RegularColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *RegularColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RegularColumnsContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *RegularColumnsContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RegularColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRegularColumns(s)
	}
}

func (s *RegularColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRegularColumns(s)
	}
}

type AllColumnsContext struct {
	AnalyzeColumnClauseContext
}

func NewAllColumnsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AllColumnsContext {
	var p = new(AllColumnsContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *AllColumnsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AllColumnsContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *AllColumnsContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *AllColumnsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAllColumns(s)
	}
}

func (s *AllColumnsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAllColumns(s)
	}
}

type MultiColumnSetContext struct {
	AnalyzeColumnClauseContext
}

func NewMultiColumnSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiColumnSetContext {
	var p = new(MultiColumnSetContext)

	InitEmptyAnalyzeColumnClauseContext(&p.AnalyzeColumnClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*AnalyzeColumnClauseContext))

	return p
}

func (s *MultiColumnSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiColumnSetContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMULTIPLE, 0)
}

func (s *MultiColumnSetContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *MultiColumnSetContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *MultiColumnSetContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *MultiColumnSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultiColumnSet(s)
	}
}

func (s *MultiColumnSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultiColumnSet(s)
	}
}

func (p *StarRocksParser) AnalyzeColumnClause() (localctx IAnalyzeColumnClauseContext) {
	localctx = NewAnalyzeColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, StarRocksParserRULE_analyzeColumnClause)
	var _la int

	p.SetState(3724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 353, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRegularColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3688)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3689)
			p.QualifiedName()
		}
		p.SetState(3694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3690)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3691)
				p.QualifiedName()
			}

			p.SetState(3696)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3697)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewRegularColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3699)
			p.QualifiedName()
		}
		p.SetState(3704)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3700)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3701)
				p.QualifiedName()
			}

			p.SetState(3706)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 3:
		localctx = NewAllColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3707)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3708)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewPredicateColumnsContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3709)
			p.Match(StarRocksParserPREDICATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3710)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewMultiColumnSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3711)
			p.Match(StarRocksParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3712)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3713)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3714)
			p.QualifiedName()
		}
		p.SetState(3719)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3715)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3716)
				p.QualifiedName()
			}

			p.SetState(3721)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3722)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropStatsStatementContext is an interface to support dynamic dispatch.
type IDropStatsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	STATS() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	MULTIPLE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode

	// IsDropStatsStatementContext differentiates from other interfaces.
	IsDropStatsStatementContext()
}

type DropStatsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropStatsStatementContext() *DropStatsStatementContext {
	var p = new(DropStatsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropStatsStatement
	return p
}

func InitEmptyDropStatsStatementContext(p *DropStatsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropStatsStatement
}

func (*DropStatsStatementContext) IsDropStatsStatementContext() {}

func NewDropStatsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropStatsStatementContext {
	var p = new(DropStatsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropStatsStatement

	return p
}

func (s *DropStatsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropStatsStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropStatsStatementContext) STATS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATS, 0)
}

func (s *DropStatsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropStatsStatementContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMULTIPLE, 0)
}

func (s *DropStatsStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *DropStatsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropStatsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropStatsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropStatsStatement(s)
	}
}

func (s *DropStatsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropStatsStatement(s)
	}
}

func (p *StarRocksParser) DropStatsStatement() (localctx IDropStatsStatementContext) {
	localctx = NewDropStatsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, StarRocksParserRULE_dropStatsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3726)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3729)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserMULTIPLE {
		{
			p.SetState(3727)
			p.Match(StarRocksParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3728)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3731)
		p.Match(StarRocksParserSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3732)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHistogramStatementContext is an interface to support dynamic dispatch.
type IHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetBucket returns the bucket token.
	GetBucket() antlr.Token

	// SetBucket sets the bucket token.
	SetBucket(antlr.Token)

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableName() ITableNameContext
	UPDATE() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	ON() antlr.TerminalNode
	AnalyzeColumnClause() IAnalyzeColumnClauseContext
	WITH() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	Properties() IPropertiesContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsHistogramStatementContext differentiates from other interfaces.
	IsHistogramStatementContext()
}

type HistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	bucket antlr.Token
}

func NewEmptyHistogramStatementContext() *HistogramStatementContext {
	var p = new(HistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_histogramStatement
	return p
}

func InitEmptyHistogramStatementContext(p *HistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_histogramStatement
}

func (*HistogramStatementContext) IsHistogramStatementContext() {}

func NewHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HistogramStatementContext {
	var p = new(HistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_histogramStatement

	return p
}

func (s *HistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HistogramStatementContext) GetBucket() antlr.Token { return s.bucket }

func (s *HistogramStatementContext) SetBucket(v antlr.Token) { s.bucket = v }

func (s *HistogramStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *HistogramStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *HistogramStatementContext) TableName() ITableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableNameContext)
}

func (s *HistogramStatementContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUPDATE, 0)
}

func (s *HistogramStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHISTOGRAM, 0)
}

func (s *HistogramStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *HistogramStatementContext) AnalyzeColumnClause() IAnalyzeColumnClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAnalyzeColumnClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAnalyzeColumnClauseContext)
}

func (s *HistogramStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *HistogramStatementContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUCKETS, 0)
}

func (s *HistogramStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *HistogramStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *HistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterHistogramStatement(s)
	}
}

func (s *HistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitHistogramStatement(s)
	}
}

func (p *StarRocksParser) HistogramStatement() (localctx IHistogramStatementContext) {
	localctx = NewHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, StarRocksParserRULE_histogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3734)
		p.Match(StarRocksParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3735)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3736)
		p.TableName()
	}
	{
		p.SetState(3737)
		p.Match(StarRocksParserUPDATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3738)
		p.Match(StarRocksParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3739)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3740)
		p.AnalyzeColumnClause()
	}
	p.SetState(3744)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 355, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3741)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3742)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*HistogramStatementContext).bucket = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3743)
			p.Match(StarRocksParserBUCKETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(3747)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3746)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeHistogramStatementContext is an interface to support dynamic dispatch.
type IAnalyzeHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HistogramStatement() IHistogramStatementContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsAnalyzeHistogramStatementContext differentiates from other interfaces.
	IsAnalyzeHistogramStatementContext()
}

type AnalyzeHistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeHistogramStatementContext() *AnalyzeHistogramStatementContext {
	var p = new(AnalyzeHistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeHistogramStatement
	return p
}

func InitEmptyAnalyzeHistogramStatementContext(p *AnalyzeHistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeHistogramStatement
}

func (*AnalyzeHistogramStatementContext) IsAnalyzeHistogramStatementContext() {}

func NewAnalyzeHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeHistogramStatementContext {
	var p = new(AnalyzeHistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_analyzeHistogramStatement

	return p
}

func (s *AnalyzeHistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeHistogramStatementContext) HistogramStatement() IHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramStatementContext)
}

func (s *AnalyzeHistogramStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AnalyzeHistogramStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *AnalyzeHistogramStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *AnalyzeHistogramStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *AnalyzeHistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeHistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeHistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAnalyzeHistogramStatement(s)
	}
}

func (s *AnalyzeHistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAnalyzeHistogramStatement(s)
	}
}

func (p *StarRocksParser) AnalyzeHistogramStatement() (localctx IAnalyzeHistogramStatementContext) {
	localctx = NewAnalyzeHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, StarRocksParserRULE_analyzeHistogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3749)
		p.HistogramStatement()
	}
	p.SetState(3753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(3750)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3751)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASYNC || _la == StarRocksParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3752)
			p.Match(StarRocksParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropHistogramStatementContext is an interface to support dynamic dispatch.
type IDropHistogramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	DROP() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	ON() antlr.TerminalNode

	// IsDropHistogramStatementContext differentiates from other interfaces.
	IsDropHistogramStatementContext()
}

type DropHistogramStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropHistogramStatementContext() *DropHistogramStatementContext {
	var p = new(DropHistogramStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropHistogramStatement
	return p
}

func InitEmptyDropHistogramStatementContext(p *DropHistogramStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropHistogramStatement
}

func (*DropHistogramStatementContext) IsDropHistogramStatementContext() {}

func NewDropHistogramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropHistogramStatementContext {
	var p = new(DropHistogramStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropHistogramStatement

	return p
}

func (s *DropHistogramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropHistogramStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *DropHistogramStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *DropHistogramStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *DropHistogramStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropHistogramStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropHistogramStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHISTOGRAM, 0)
}

func (s *DropHistogramStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *DropHistogramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropHistogramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropHistogramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropHistogramStatement(s)
	}
}

func (s *DropHistogramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropHistogramStatement(s)
	}
}

func (p *StarRocksParser) DropHistogramStatement() (localctx IDropHistogramStatementContext) {
	localctx = NewDropHistogramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, StarRocksParserRULE_dropHistogramStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3755)
		p.Match(StarRocksParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3756)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3757)
		p.QualifiedName()
	}
	{
		p.SetState(3758)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3759)
		p.Match(StarRocksParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3760)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3761)
		p.QualifiedName()
	}
	p.SetState(3766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(3762)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3763)
			p.QualifiedName()
		}

		p.SetState(3768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateAnalyzeStatementContext is an interface to support dynamic dispatch.
type ICreateAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IIdentifierContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Properties() IPropertiesContext
	FULL() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLE() antlr.TerminalNode
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	HistogramStatement() IHistogramStatementContext

	// IsCreateAnalyzeStatementContext differentiates from other interfaces.
	IsCreateAnalyzeStatementContext()
}

type CreateAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IIdentifierContext
}

func NewEmptyCreateAnalyzeStatementContext() *CreateAnalyzeStatementContext {
	var p = new(CreateAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createAnalyzeStatement
	return p
}

func InitEmptyCreateAnalyzeStatementContext(p *CreateAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createAnalyzeStatement
}

func (*CreateAnalyzeStatementContext) IsCreateAnalyzeStatementContext() {}

func NewCreateAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateAnalyzeStatementContext {
	var p = new(CreateAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createAnalyzeStatement

	return p
}

func (s *CreateAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateAnalyzeStatementContext) GetDb() IIdentifierContext { return s.db }

func (s *CreateAnalyzeStatementContext) SetDb(v IIdentifierContext) { s.db = v }

func (s *CreateAnalyzeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *CreateAnalyzeStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *CreateAnalyzeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateAnalyzeStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *CreateAnalyzeStatementContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSAMPLE, 0)
}

func (s *CreateAnalyzeStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *CreateAnalyzeStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateAnalyzeStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateAnalyzeStatementContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *CreateAnalyzeStatementContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateAnalyzeStatementContext) HistogramStatement() IHistogramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramStatementContext)
}

func (s *CreateAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateAnalyzeStatement(s)
	}
}

func (s *CreateAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateAnalyzeStatement(s)
	}
}

func (p *StarRocksParser) CreateAnalyzeStatement() (localctx ICreateAnalyzeStatementContext) {
	localctx = NewCreateAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, StarRocksParserRULE_createAnalyzeStatement)
	var _la int

	p.SetState(3813)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 367, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3769)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3770)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3772)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFULL || _la == StarRocksParserSAMPLE {
			{
				p.SetState(3771)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFULL || _la == StarRocksParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3774)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3775)
				p.Properties()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3778)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3779)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3781)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFULL || _la == StarRocksParserSAMPLE {
			{
				p.SetState(3780)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFULL || _la == StarRocksParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3783)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3784)

			var _x = p.Identifier()

			localctx.(*CreateAnalyzeStatementContext).db = _x
		}
		p.SetState(3786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3785)
				p.Properties()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3788)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3789)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFULL || _la == StarRocksParserSAMPLE {
			{
				p.SetState(3790)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFULL || _la == StarRocksParserSAMPLE) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(3793)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3794)
			p.QualifiedName()
		}
		p.SetState(3806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(3795)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3796)
				p.QualifiedName()
			}
			p.SetState(3801)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(3797)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3798)
					p.QualifiedName()
				}

				p.SetState(3803)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(3804)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(3808)
				p.Properties()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3811)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3812)
			p.HistogramStatement()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropAnalyzeJobStatementContext is an interface to support dynamic dispatch.
type IDropAnalyzeJobStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	JOB() antlr.TerminalNode

	// IsDropAnalyzeJobStatementContext differentiates from other interfaces.
	IsDropAnalyzeJobStatementContext()
}

type DropAnalyzeJobStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropAnalyzeJobStatementContext() *DropAnalyzeJobStatementContext {
	var p = new(DropAnalyzeJobStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropAnalyzeJobStatement
	return p
}

func InitEmptyDropAnalyzeJobStatementContext(p *DropAnalyzeJobStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropAnalyzeJobStatement
}

func (*DropAnalyzeJobStatementContext) IsDropAnalyzeJobStatementContext() {}

func NewDropAnalyzeJobStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropAnalyzeJobStatementContext {
	var p = new(DropAnalyzeJobStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropAnalyzeJobStatement

	return p
}

func (s *DropAnalyzeJobStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropAnalyzeJobStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropAnalyzeJobStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *DropAnalyzeJobStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DropAnalyzeJobStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *DropAnalyzeJobStatementContext) JOB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOB, 0)
}

func (s *DropAnalyzeJobStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropAnalyzeJobStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropAnalyzeJobStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropAnalyzeJobStatement(s)
	}
}

func (s *DropAnalyzeJobStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropAnalyzeJobStatement(s)
	}
}

func (p *StarRocksParser) DropAnalyzeJobStatement() (localctx IDropAnalyzeJobStatementContext) {
	localctx = NewDropAnalyzeJobStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, StarRocksParserRULE_dropAnalyzeJobStatement)
	p.SetState(3822)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 368, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3815)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3816)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3817)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3818)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3819)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3820)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3821)
			p.Match(StarRocksParserJOB)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAnalyzeStatementContext is an interface to support dynamic dispatch.
type IShowAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	JOB() antlr.TerminalNode
	STATUS() antlr.TerminalNode

	// IsShowAnalyzeStatementContext differentiates from other interfaces.
	IsShowAnalyzeStatementContext()
}

type ShowAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAnalyzeStatementContext() *ShowAnalyzeStatementContext {
	var p = new(ShowAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAnalyzeStatement
	return p
}

func InitEmptyShowAnalyzeStatementContext(p *ShowAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAnalyzeStatement
}

func (*ShowAnalyzeStatementContext) IsShowAnalyzeStatementContext() {}

func NewShowAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAnalyzeStatementContext {
	var p = new(ShowAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showAnalyzeStatement

	return p
}

func (s *ShowAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAnalyzeStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *ShowAnalyzeStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowAnalyzeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowAnalyzeStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowAnalyzeStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowAnalyzeStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowAnalyzeStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowAnalyzeStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowAnalyzeStatementContext) JOB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOB, 0)
}

func (s *ShowAnalyzeStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *ShowAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAnalyzeStatement(s)
	}
}

func (s *ShowAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAnalyzeStatement(s)
	}
}

func (p *StarRocksParser) ShowAnalyzeStatement() (localctx IShowAnalyzeStatementContext) {
	localctx = NewShowAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, StarRocksParserRULE_showAnalyzeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3824)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3825)
		p.Match(StarRocksParserANALYZE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserJOB || _la == StarRocksParserSTATUS {
		{
			p.SetState(3826)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserJOB || _la == StarRocksParserSTATUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3831)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3829)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3830)
			p.expression(0)
		}

	}
	p.SetState(3843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3833)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3834)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3835)
			p.SortItem()
		}
		p.SetState(3840)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3836)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3837)
				p.SortItem()
			}

			p.SetState(3842)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3846)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3845)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatsMetaStatementContext is an interface to support dynamic dispatch.
type IShowStatsMetaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATS() antlr.TerminalNode
	META() antlr.TerminalNode
	MULTIPLE() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowStatsMetaStatementContext differentiates from other interfaces.
	IsShowStatsMetaStatementContext()
}

type ShowStatsMetaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowStatsMetaStatementContext() *ShowStatsMetaStatementContext {
	var p = new(ShowStatsMetaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStatsMetaStatement
	return p
}

func InitEmptyShowStatsMetaStatementContext(p *ShowStatsMetaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStatsMetaStatement
}

func (*ShowStatsMetaStatementContext) IsShowStatsMetaStatementContext() {}

func NewShowStatsMetaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatsMetaStatementContext {
	var p = new(ShowStatsMetaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showStatsMetaStatement

	return p
}

func (s *ShowStatsMetaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatsMetaStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowStatsMetaStatementContext) STATS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATS, 0)
}

func (s *ShowStatsMetaStatementContext) META() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMETA, 0)
}

func (s *ShowStatsMetaStatementContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMULTIPLE, 0)
}

func (s *ShowStatsMetaStatementContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *ShowStatsMetaStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowStatsMetaStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStatsMetaStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowStatsMetaStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowStatsMetaStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowStatsMetaStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowStatsMetaStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowStatsMetaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatsMetaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatsMetaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowStatsMetaStatement(s)
	}
}

func (s *ShowStatsMetaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowStatsMetaStatement(s)
	}
}

func (p *StarRocksParser) ShowStatsMetaStatement() (localctx IShowStatsMetaStatementContext) {
	localctx = NewShowStatsMetaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, StarRocksParserRULE_showStatsMetaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3848)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserMULTIPLE {
		{
			p.SetState(3849)
			p.Match(StarRocksParserMULTIPLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3850)
			p.Match(StarRocksParserCOLUMNS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3853)
		p.Match(StarRocksParserSTATS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3854)
		p.Match(StarRocksParserMETA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3857)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3855)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3856)
			p.expression(0)
		}

	}
	p.SetState(3869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3859)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3860)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3861)
			p.SortItem()
		}
		p.SetState(3866)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3862)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3863)
				p.SortItem()
			}

			p.SetState(3868)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3872)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3871)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowHistogramMetaStatementContext is an interface to support dynamic dispatch.
type IShowHistogramMetaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	META() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowHistogramMetaStatementContext differentiates from other interfaces.
	IsShowHistogramMetaStatementContext()
}

type ShowHistogramMetaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowHistogramMetaStatementContext() *ShowHistogramMetaStatementContext {
	var p = new(ShowHistogramMetaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showHistogramMetaStatement
	return p
}

func InitEmptyShowHistogramMetaStatementContext(p *ShowHistogramMetaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showHistogramMetaStatement
}

func (*ShowHistogramMetaStatementContext) IsShowHistogramMetaStatementContext() {}

func NewShowHistogramMetaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowHistogramMetaStatementContext {
	var p = new(ShowHistogramMetaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showHistogramMetaStatement

	return p
}

func (s *ShowHistogramMetaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowHistogramMetaStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowHistogramMetaStatementContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHISTOGRAM, 0)
}

func (s *ShowHistogramMetaStatementContext) META() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMETA, 0)
}

func (s *ShowHistogramMetaStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowHistogramMetaStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowHistogramMetaStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowHistogramMetaStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowHistogramMetaStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowHistogramMetaStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowHistogramMetaStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowHistogramMetaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowHistogramMetaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowHistogramMetaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowHistogramMetaStatement(s)
	}
}

func (s *ShowHistogramMetaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowHistogramMetaStatement(s)
	}
}

func (p *StarRocksParser) ShowHistogramMetaStatement() (localctx IShowHistogramMetaStatementContext) {
	localctx = NewShowHistogramMetaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, StarRocksParserRULE_showHistogramMetaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3874)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3875)
		p.Match(StarRocksParserHISTOGRAM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3876)
		p.Match(StarRocksParserMETA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3879)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(3877)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3878)
			p.expression(0)
		}

	}
	p.SetState(3891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(3881)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3882)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3883)
			p.SortItem()
		}
		p.SetState(3888)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3884)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3885)
				p.SortItem()
			}

			p.SetState(3890)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(3894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(3893)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKillAnalyzeStatementContext is an interface to support dynamic dispatch.
type IKillAnalyzeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KILL() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	PENDING() antlr.TerminalNode

	// IsKillAnalyzeStatementContext differentiates from other interfaces.
	IsKillAnalyzeStatementContext()
}

type KillAnalyzeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKillAnalyzeStatementContext() *KillAnalyzeStatementContext {
	var p = new(KillAnalyzeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_killAnalyzeStatement
	return p
}

func InitEmptyKillAnalyzeStatementContext(p *KillAnalyzeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_killAnalyzeStatement
}

func (*KillAnalyzeStatementContext) IsKillAnalyzeStatementContext() {}

func NewKillAnalyzeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KillAnalyzeStatementContext {
	var p = new(KillAnalyzeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_killAnalyzeStatement

	return p
}

func (s *KillAnalyzeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *KillAnalyzeStatementContext) KILL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserKILL, 0)
}

func (s *KillAnalyzeStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *KillAnalyzeStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *KillAnalyzeStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *KillAnalyzeStatementContext) PENDING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPENDING, 0)
}

func (s *KillAnalyzeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KillAnalyzeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KillAnalyzeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKillAnalyzeStatement(s)
	}
}

func (s *KillAnalyzeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKillAnalyzeStatement(s)
	}
}

func (p *StarRocksParser) KillAnalyzeStatement() (localctx IKillAnalyzeStatementContext) {
	localctx = NewKillAnalyzeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, StarRocksParserRULE_killAnalyzeStatement)
	p.SetState(3903)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 383, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3896)
			p.Match(StarRocksParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3897)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3898)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3899)
			p.Match(StarRocksParserKILL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3900)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3901)
			p.Match(StarRocksParserPENDING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3902)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAnalyzeProfileStatementContext is an interface to support dynamic dispatch.
type IAnalyzeProfileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ANALYZE() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	String_() IStringContext
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsAnalyzeProfileStatementContext differentiates from other interfaces.
	IsAnalyzeProfileStatementContext()
}

type AnalyzeProfileStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnalyzeProfileStatementContext() *AnalyzeProfileStatementContext {
	var p = new(AnalyzeProfileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeProfileStatement
	return p
}

func InitEmptyAnalyzeProfileStatementContext(p *AnalyzeProfileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_analyzeProfileStatement
}

func (*AnalyzeProfileStatementContext) IsAnalyzeProfileStatementContext() {}

func NewAnalyzeProfileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AnalyzeProfileStatementContext {
	var p = new(AnalyzeProfileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_analyzeProfileStatement

	return p
}

func (s *AnalyzeProfileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AnalyzeProfileStatementContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *AnalyzeProfileStatementContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROFILE, 0)
}

func (s *AnalyzeProfileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *AnalyzeProfileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AnalyzeProfileStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *AnalyzeProfileStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *AnalyzeProfileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AnalyzeProfileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AnalyzeProfileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAnalyzeProfileStatement(s)
	}
}

func (s *AnalyzeProfileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAnalyzeProfileStatement(s)
	}
}

func (p *StarRocksParser) AnalyzeProfileStatement() (localctx IAnalyzeProfileStatementContext) {
	localctx = NewAnalyzeProfileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, StarRocksParserRULE_analyzeProfileStatement)
	var _la int

	p.SetState(3922)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 385, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3905)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3906)
			p.Match(StarRocksParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3907)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3908)
			p.String_()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3909)
			p.Match(StarRocksParserANALYZE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3910)
			p.Match(StarRocksParserPROFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3911)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3912)
			p.String_()
		}
		{
			p.SetState(3913)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3914)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3919)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3915)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3916)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(3921)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateBaselinePlanStatementContext is an interface to support dynamic dispatch.
type ICreateBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	USING() antlr.TerminalNode
	AllQueryRelation() []IQueryRelationContext
	QueryRelation(i int) IQueryRelationContext
	GLOBAL() antlr.TerminalNode
	ON() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateBaselinePlanStatementContext differentiates from other interfaces.
	IsCreateBaselinePlanStatementContext()
}

type CreateBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateBaselinePlanStatementContext() *CreateBaselinePlanStatementContext {
	var p = new(CreateBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createBaselinePlanStatement
	return p
}

func InitEmptyCreateBaselinePlanStatementContext(p *CreateBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createBaselinePlanStatement
}

func (*CreateBaselinePlanStatementContext) IsCreateBaselinePlanStatementContext() {}

func NewCreateBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateBaselinePlanStatementContext {
	var p = new(CreateBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createBaselinePlanStatement

	return p
}

func (s *CreateBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateBaselinePlanStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASELINE, 0)
}

func (s *CreateBaselinePlanStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *CreateBaselinePlanStatementContext) AllQueryRelation() []IQueryRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryRelationContext); ok {
			len++
		}
	}

	tst := make([]IQueryRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryRelationContext); ok {
			tst[i] = t.(IQueryRelationContext)
			i++
		}
	}

	return tst
}

func (s *CreateBaselinePlanStatementContext) QueryRelation(i int) IQueryRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *CreateBaselinePlanStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *CreateBaselinePlanStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CreateBaselinePlanStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateBaselinePlanStatement(s)
	}
}

func (s *CreateBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateBaselinePlanStatement(s)
	}
}

func (p *StarRocksParser) CreateBaselinePlanStatement() (localctx ICreateBaselinePlanStatementContext) {
	localctx = NewCreateBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, StarRocksParserRULE_createBaselinePlanStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3924)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3926)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL {
		{
			p.SetState(3925)
			p.Match(StarRocksParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3928)
		p.Match(StarRocksParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserON {
		{
			p.SetState(3929)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3930)
			p.QueryRelation()
		}

	}
	{
		p.SetState(3933)
		p.Match(StarRocksParserUSING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3934)
		p.QueryRelation()
	}
	p.SetState(3936)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(3935)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropBaselinePlanStatementContext is an interface to support dynamic dispatch.
type IDropBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDropBaselinePlanStatementContext differentiates from other interfaces.
	IsDropBaselinePlanStatementContext()
}

type DropBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropBaselinePlanStatementContext() *DropBaselinePlanStatementContext {
	var p = new(DropBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBaselinePlanStatement
	return p
}

func InitEmptyDropBaselinePlanStatementContext(p *DropBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropBaselinePlanStatement
}

func (*DropBaselinePlanStatementContext) IsDropBaselinePlanStatementContext() {}

func NewDropBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropBaselinePlanStatementContext {
	var p = new(DropBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropBaselinePlanStatement

	return p
}

func (s *DropBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropBaselinePlanStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASELINE, 0)
}

func (s *DropBaselinePlanStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DropBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropBaselinePlanStatement(s)
	}
}

func (s *DropBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropBaselinePlanStatement(s)
	}
}

func (p *StarRocksParser) DropBaselinePlanStatement() (localctx IDropBaselinePlanStatementContext) {
	localctx = NewDropBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, StarRocksParserRULE_dropBaselinePlanStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3938)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3939)
		p.Match(StarRocksParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3940)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBaselinePlanStatementContext is an interface to support dynamic dispatch.
type IShowBaselinePlanStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BASELINE() antlr.TerminalNode

	// IsShowBaselinePlanStatementContext differentiates from other interfaces.
	IsShowBaselinePlanStatementContext()
}

type ShowBaselinePlanStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBaselinePlanStatementContext() *ShowBaselinePlanStatementContext {
	var p = new(ShowBaselinePlanStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBaselinePlanStatement
	return p
}

func InitEmptyShowBaselinePlanStatementContext(p *ShowBaselinePlanStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBaselinePlanStatement
}

func (*ShowBaselinePlanStatementContext) IsShowBaselinePlanStatementContext() {}

func NewShowBaselinePlanStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBaselinePlanStatementContext {
	var p = new(ShowBaselinePlanStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBaselinePlanStatement

	return p
}

func (s *ShowBaselinePlanStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBaselinePlanStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBaselinePlanStatementContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASELINE, 0)
}

func (s *ShowBaselinePlanStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBaselinePlanStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBaselinePlanStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBaselinePlanStatement(s)
	}
}

func (s *ShowBaselinePlanStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBaselinePlanStatement(s)
	}
}

func (p *StarRocksParser) ShowBaselinePlanStatement() (localctx IShowBaselinePlanStatementContext) {
	localctx = NewShowBaselinePlanStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, StarRocksParserRULE_showBaselinePlanStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3942)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3943)
		p.Match(StarRocksParserBASELINE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceGroupStatementContext is an interface to support dynamic dispatch.
type ICreateResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	WITH() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	OR() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	TO() antlr.TerminalNode
	AllClassifier() []IClassifierContext
	Classifier(i int) IClassifierContext

	// IsCreateResourceGroupStatementContext differentiates from other interfaces.
	IsCreateResourceGroupStatementContext()
}

type CreateResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateResourceGroupStatementContext() *CreateResourceGroupStatementContext {
	var p = new(CreateResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createResourceGroupStatement
	return p
}

func InitEmptyCreateResourceGroupStatementContext(p *CreateResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createResourceGroupStatement
}

func (*CreateResourceGroupStatementContext) IsCreateResourceGroupStatementContext() {}

func NewCreateResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceGroupStatementContext {
	var p = new(CreateResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createResourceGroupStatement

	return p
}

func (s *CreateResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceGroupStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *CreateResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *CreateResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateResourceGroupStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *CreateResourceGroupStatementContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *CreateResourceGroupStatementContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *CreateResourceGroupStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateResourceGroupStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateResourceGroupStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateResourceGroupStatementContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *CreateResourceGroupStatementContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *CreateResourceGroupStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *CreateResourceGroupStatementContext) AllClassifier() []IClassifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassifierContext); ok {
			len++
		}
	}

	tst := make([]IClassifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassifierContext); ok {
			tst[i] = t.(IClassifierContext)
			i++
		}
	}

	return tst
}

func (s *CreateResourceGroupStatementContext) Classifier(i int) IClassifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *CreateResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateResourceGroupStatement(s)
	}
}

func (s *CreateResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateResourceGroupStatement(s)
	}
}

func (p *StarRocksParser) CreateResourceGroupStatement() (localctx ICreateResourceGroupStatementContext) {
	localctx = NewCreateResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, StarRocksParserRULE_createResourceGroupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3945)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3946)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3947)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(3948)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3949)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3950)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(3955)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserOR {
		{
			p.SetState(3953)
			p.Match(StarRocksParserOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3954)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3957)
		p.Identifier()
	}
	p.SetState(3967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTO {
		{
			p.SetState(3958)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3959)
			p.Classifier()
		}
		p.SetState(3964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3960)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3961)
				p.Classifier()
			}

			p.SetState(3966)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3969)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3970)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3971)
		p.Property()
	}
	p.SetState(3976)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(3972)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3973)
			p.Property()
		}

		p.SetState(3978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3979)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceGroupStatementContext is an interface to support dynamic dispatch.
type IDropResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropResourceGroupStatementContext differentiates from other interfaces.
	IsDropResourceGroupStatementContext()
}

type DropResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropResourceGroupStatementContext() *DropResourceGroupStatementContext {
	var p = new(DropResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropResourceGroupStatement
	return p
}

func InitEmptyDropResourceGroupStatementContext(p *DropResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropResourceGroupStatement
}

func (*DropResourceGroupStatementContext) IsDropResourceGroupStatementContext() {}

func NewDropResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceGroupStatementContext {
	var p = new(DropResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropResourceGroupStatement

	return p
}

func (s *DropResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *DropResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *DropResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropResourceGroupStatement(s)
	}
}

func (s *DropResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropResourceGroupStatement(s)
	}
}

func (p *StarRocksParser) DropResourceGroupStatement() (localctx IDropResourceGroupStatementContext) {
	localctx = NewDropResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, StarRocksParserRULE_dropResourceGroupStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3981)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3982)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3983)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3984)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceGroupStatementContext is an interface to support dynamic dispatch.
type IAlterResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	ADD() antlr.TerminalNode
	AllClassifier() []IClassifierContext
	Classifier(i int) IClassifierContext
	DROP() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode
	ALL() antlr.TerminalNode
	WITH() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsAlterResourceGroupStatementContext differentiates from other interfaces.
	IsAlterResourceGroupStatementContext()
}

type AlterResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterResourceGroupStatementContext() *AlterResourceGroupStatementContext {
	var p = new(AlterResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterResourceGroupStatement
	return p
}

func InitEmptyAlterResourceGroupStatementContext(p *AlterResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterResourceGroupStatement
}

func (*AlterResourceGroupStatementContext) IsAlterResourceGroupStatementContext() {}

func NewAlterResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceGroupStatementContext {
	var p = new(AlterResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterResourceGroupStatement

	return p
}

func (s *AlterResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceGroupStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *AlterResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *AlterResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterResourceGroupStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AlterResourceGroupStatementContext) AllClassifier() []IClassifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassifierContext); ok {
			len++
		}
	}

	tst := make([]IClassifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassifierContext); ok {
			tst[i] = t.(IClassifierContext)
			i++
		}
	}

	return tst
}

func (s *AlterResourceGroupStatementContext) Classifier(i int) IClassifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *AlterResourceGroupStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *AlterResourceGroupStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *AlterResourceGroupStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *AlterResourceGroupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *AlterResourceGroupStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AlterResourceGroupStatementContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *AlterResourceGroupStatementContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *AlterResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterResourceGroupStatement(s)
	}
}

func (s *AlterResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterResourceGroupStatement(s)
	}
}

func (p *StarRocksParser) AlterResourceGroupStatement() (localctx IAlterResourceGroupStatementContext) {
	localctx = NewAlterResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, StarRocksParserRULE_alterResourceGroupStatement)
	var _la int

	p.SetState(4038)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 397, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3986)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3987)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3988)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3989)
			p.Identifier()
		}
		{
			p.SetState(3990)
			p.Match(StarRocksParserADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3991)
			p.Classifier()
		}
		p.SetState(3996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(3992)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3993)
				p.Classifier()
			}

			p.SetState(3998)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3999)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4000)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4001)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4002)
			p.Identifier()
		}
		{
			p.SetState(4003)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4004)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4005)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(4006)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4007)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

			p.SetState(4012)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4013)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4015)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4016)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4017)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4018)
			p.Identifier()
		}
		{
			p.SetState(4019)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4020)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4022)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4023)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4024)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4025)
			p.Identifier()
		}
		{
			p.SetState(4026)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4027)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4028)
			p.Property()
		}
		p.SetState(4033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(4029)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4030)
				p.Property()
			}

			p.SetState(4035)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4036)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceGroupStatementContext is an interface to support dynamic dispatch.
type IShowResourceGroupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	VERBOSE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsShowResourceGroupStatementContext differentiates from other interfaces.
	IsShowResourceGroupStatementContext()
}

type ShowResourceGroupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceGroupStatementContext() *ShowResourceGroupStatementContext {
	var p = new(ShowResourceGroupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceGroupStatement
	return p
}

func InitEmptyShowResourceGroupStatementContext(p *ShowResourceGroupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceGroupStatement
}

func (*ShowResourceGroupStatementContext) IsShowResourceGroupStatementContext() {}

func NewShowResourceGroupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceGroupStatementContext {
	var p = new(ShowResourceGroupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showResourceGroupStatement

	return p
}

func (s *ShowResourceGroupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceGroupStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowResourceGroupStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *ShowResourceGroupStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *ShowResourceGroupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowResourceGroupStatementContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERBOSE, 0)
}

func (s *ShowResourceGroupStatementContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPS, 0)
}

func (s *ShowResourceGroupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowResourceGroupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceGroupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceGroupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowResourceGroupStatement(s)
	}
}

func (s *ShowResourceGroupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowResourceGroupStatement(s)
	}
}

func (p *StarRocksParser) ShowResourceGroupStatement() (localctx IShowResourceGroupStatementContext) {
	localctx = NewShowResourceGroupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, StarRocksParserRULE_showResourceGroupStatement)
	var _la int

	p.SetState(4056)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 401, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4040)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4042)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserVERBOSE {
			{
				p.SetState(4041)
				p.Match(StarRocksParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4044)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4045)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4046)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4047)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserVERBOSE {
			{
				p.SetState(4048)
				p.Match(StarRocksParserVERBOSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4051)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4052)
			p.Match(StarRocksParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL {
			{
				p.SetState(4053)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceGroupUsageStatementContext is an interface to support dynamic dispatch.
type IShowResourceGroupUsageStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	GROUPS() antlr.TerminalNode

	// IsShowResourceGroupUsageStatementContext differentiates from other interfaces.
	IsShowResourceGroupUsageStatementContext()
}

type ShowResourceGroupUsageStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceGroupUsageStatementContext() *ShowResourceGroupUsageStatementContext {
	var p = new(ShowResourceGroupUsageStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceGroupUsageStatement
	return p
}

func InitEmptyShowResourceGroupUsageStatementContext(p *ShowResourceGroupUsageStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceGroupUsageStatement
}

func (*ShowResourceGroupUsageStatementContext) IsShowResourceGroupUsageStatementContext() {}

func NewShowResourceGroupUsageStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceGroupUsageStatementContext {
	var p = new(ShowResourceGroupUsageStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showResourceGroupUsageStatement

	return p
}

func (s *ShowResourceGroupUsageStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceGroupUsageStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowResourceGroupUsageStatementContext) USAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSAGE, 0)
}

func (s *ShowResourceGroupUsageStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *ShowResourceGroupUsageStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *ShowResourceGroupUsageStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowResourceGroupUsageStatementContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPS, 0)
}

func (s *ShowResourceGroupUsageStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceGroupUsageStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceGroupUsageStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowResourceGroupUsageStatement(s)
	}
}

func (s *ShowResourceGroupUsageStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowResourceGroupUsageStatement(s)
	}
}

func (p *StarRocksParser) ShowResourceGroupUsageStatement() (localctx IShowResourceGroupUsageStatementContext) {
	localctx = NewShowResourceGroupUsageStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, StarRocksParserRULE_showResourceGroupUsageStatement)
	p.SetState(4067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 402, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4058)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4059)
			p.Match(StarRocksParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4060)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4061)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4062)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4063)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4064)
			p.Match(StarRocksParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4065)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4066)
			p.Match(StarRocksParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceStatementContext is an interface to support dynamic dispatch.
type ICreateResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	EXTERNAL() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateResourceStatementContext differentiates from other interfaces.
	IsCreateResourceStatementContext()
}

type CreateResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyCreateResourceStatementContext() *CreateResourceStatementContext {
	var p = new(CreateResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createResourceStatement
	return p
}

func InitEmptyCreateResourceStatementContext(p *CreateResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createResourceStatement
}

func (*CreateResourceStatementContext) IsCreateResourceStatementContext() {}

func NewCreateResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceStatementContext {
	var p = new(CreateResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createResourceStatement

	return p
}

func (s *CreateResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *CreateResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *CreateResourceStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *CreateResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateResourceStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CreateResourceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateResourceStatement(s)
	}
}

func (s *CreateResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateResourceStatement(s)
	}
}

func (p *StarRocksParser) CreateResourceStatement() (localctx ICreateResourceStatementContext) {
	localctx = NewCreateResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, StarRocksParserRULE_createResourceStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4069)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4071)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEXTERNAL {
		{
			p.SetState(4070)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4073)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4074)

		var _x = p.IdentifierOrString()

		localctx.(*CreateResourceStatementContext).resourceName = _x
	}
	p.SetState(4076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(4075)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceStatementContext is an interface to support dynamic dispatch.
type IAlterResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	SET() antlr.TerminalNode
	Properties() IPropertiesContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterResourceStatementContext differentiates from other interfaces.
	IsAlterResourceStatementContext()
}

type AlterResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyAlterResourceStatementContext() *AlterResourceStatementContext {
	var p = new(AlterResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterResourceStatement
	return p
}

func InitEmptyAlterResourceStatementContext(p *AlterResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterResourceStatement
}

func (*AlterResourceStatementContext) IsAlterResourceStatementContext() {}

func NewAlterResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceStatementContext {
	var p = new(AlterResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterResourceStatement

	return p
}

func (s *AlterResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *AlterResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *AlterResourceStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *AlterResourceStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterResourceStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterResourceStatement(s)
	}
}

func (s *AlterResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterResourceStatement(s)
	}
}

func (p *StarRocksParser) AlterResourceStatement() (localctx IAlterResourceStatementContext) {
	localctx = NewAlterResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, StarRocksParserRULE_alterResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4078)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4079)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4080)

		var _x = p.IdentifierOrString()

		localctx.(*AlterResourceStatementContext).resourceName = _x
	}
	{
		p.SetState(4081)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4082)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceStatementContext is an interface to support dynamic dispatch.
type IDropResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetResourceName returns the resourceName rule contexts.
	GetResourceName() IIdentifierOrStringContext

	// SetResourceName sets the resourceName rule contexts.
	SetResourceName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsDropResourceStatementContext differentiates from other interfaces.
	IsDropResourceStatementContext()
}

type DropResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	resourceName IIdentifierOrStringContext
}

func NewEmptyDropResourceStatementContext() *DropResourceStatementContext {
	var p = new(DropResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropResourceStatement
	return p
}

func InitEmptyDropResourceStatementContext(p *DropResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropResourceStatement
}

func (*DropResourceStatementContext) IsDropResourceStatementContext() {}

func NewDropResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceStatementContext {
	var p = new(DropResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropResourceStatement

	return p
}

func (s *DropResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceStatementContext) GetResourceName() IIdentifierOrStringContext {
	return s.resourceName
}

func (s *DropResourceStatementContext) SetResourceName(v IIdentifierOrStringContext) {
	s.resourceName = v
}

func (s *DropResourceStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropResourceStatementContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *DropResourceStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropResourceStatement(s)
	}
}

func (s *DropResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropResourceStatement(s)
	}
}

func (p *StarRocksParser) DropResourceStatement() (localctx IDropResourceStatementContext) {
	localctx = NewDropResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, StarRocksParserRULE_dropResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4084)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4085)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4086)

		var _x = p.IdentifierOrString()

		localctx.(*DropResourceStatementContext).resourceName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowResourceStatementContext is an interface to support dynamic dispatch.
type IShowResourceStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode

	// IsShowResourceStatementContext differentiates from other interfaces.
	IsShowResourceStatementContext()
}

type ShowResourceStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowResourceStatementContext() *ShowResourceStatementContext {
	var p = new(ShowResourceStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceStatement
	return p
}

func InitEmptyShowResourceStatementContext(p *ShowResourceStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showResourceStatement
}

func (*ShowResourceStatementContext) IsShowResourceStatementContext() {}

func NewShowResourceStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowResourceStatementContext {
	var p = new(ShowResourceStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showResourceStatement

	return p
}

func (s *ShowResourceStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowResourceStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowResourceStatementContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCES, 0)
}

func (s *ShowResourceStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowResourceStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowResourceStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowResourceStatement(s)
	}
}

func (s *ShowResourceStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowResourceStatement(s)
	}
}

func (p *StarRocksParser) ShowResourceStatement() (localctx IShowResourceStatementContext) {
	localctx = NewShowResourceStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, StarRocksParserRULE_showResourceStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4088)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4089)
		p.Match(StarRocksParserRESOURCES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClassifierContext is an interface to support dynamic dispatch.
type IClassifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsClassifierContext differentiates from other interfaces.
	IsClassifierContext()
}

type ClassifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassifierContext() *ClassifierContext {
	var p = new(ClassifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_classifier
	return p
}

func InitEmptyClassifierContext(p *ClassifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_classifier
}

func (*ClassifierContext) IsClassifierContext() {}

func NewClassifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassifierContext {
	var p = new(ClassifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_classifier

	return p
}

func (s *ClassifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassifierContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ClassifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterClassifier(s)
	}
}

func (s *ClassifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitClassifier(s)
	}
}

func (p *StarRocksParser) Classifier() (localctx IClassifierContext) {
	localctx = NewClassifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, StarRocksParserRULE_classifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4091)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4092)
		p.ExpressionList()
	}
	{
		p.SetState(4093)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFunctionsStatementContext is an interface to support dynamic dispatch.
type IShowFunctionsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowFunctionsStatementContext differentiates from other interfaces.
	IsShowFunctionsStatementContext()
}

type ShowFunctionsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	db      IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowFunctionsStatementContext() *ShowFunctionsStatementContext {
	var p = new(ShowFunctionsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFunctionsStatement
	return p
}

func InitEmptyShowFunctionsStatementContext(p *ShowFunctionsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFunctionsStatement
}

func (*ShowFunctionsStatementContext) IsShowFunctionsStatementContext() {}

func NewShowFunctionsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFunctionsStatementContext {
	var p = new(ShowFunctionsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showFunctionsStatement

	return p
}

func (s *ShowFunctionsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFunctionsStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowFunctionsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowFunctionsStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowFunctionsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowFunctionsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowFunctionsStatementContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTIONS, 0)
}

func (s *ShowFunctionsStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowFunctionsStatementContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUILTIN, 0)
}

func (s *ShowFunctionsStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *ShowFunctionsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowFunctionsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowFunctionsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowFunctionsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowFunctionsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowFunctionsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowFunctionsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowFunctionsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFunctionsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFunctionsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowFunctionsStatement(s)
	}
}

func (s *ShowFunctionsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowFunctionsStatement(s)
	}
}

func (p *StarRocksParser) ShowFunctionsStatement() (localctx IShowFunctionsStatementContext) {
	localctx = NewShowFunctionsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, StarRocksParserRULE_showFunctionsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4095)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(4096)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserBUILTIN || _la == StarRocksParserGLOBAL {
		{
			p.SetState(4099)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserBUILTIN || _la == StarRocksParserGLOBAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4102)
		p.Match(StarRocksParserFUNCTIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4103)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4104)

			var _x = p.QualifiedName()

			localctx.(*ShowFunctionsStatementContext).db = _x
		}

	}
	p.SetState(4111)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4107)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4108)

			var _x = p.String_()

			localctx.(*ShowFunctionsStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4109)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4110)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFunctionStatementContext is an interface to support dynamic dispatch.
type IDropFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TypeList() ITypeListContext
	GLOBAL() antlr.TerminalNode
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropFunctionStatementContext differentiates from other interfaces.
	IsDropFunctionStatementContext()
}

type DropFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropFunctionStatementContext() *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFunctionStatement
	return p
}

func InitEmptyDropFunctionStatementContext(p *DropFunctionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFunctionStatement
}

func (*DropFunctionStatementContext) IsDropFunctionStatementContext() {}

func NewDropFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFunctionStatementContext {
	var p = new(DropFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropFunctionStatement

	return p
}

func (s *DropFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFunctionStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropFunctionStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *DropFunctionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFunctionStatementContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *DropFunctionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *DropFunctionStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropFunctionStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropFunctionStatement(s)
	}
}

func (s *DropFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropFunctionStatement(s)
	}
}

func (p *StarRocksParser) DropFunctionStatement() (localctx IDropFunctionStatementContext) {
	localctx = NewDropFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, StarRocksParserRULE_dropFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4113)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4115)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL {
		{
			p.SetState(4114)
			p.Match(StarRocksParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4117)
		p.Match(StarRocksParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4120)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4118)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4119)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4122)
		p.QualifiedName()
	}
	{
		p.SetState(4123)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4124)
		p.TypeList()
	}
	{
		p.SetState(4125)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFunctionStatementContext is an interface to support dynamic dispatch.
type ICreateFunctionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFunctionType returns the functionType token.
	GetFunctionType() antlr.Token

	// SetFunctionType sets the functionType token.
	SetFunctionType(antlr.Token)

	// GetReturnType returns the returnType rule contexts.
	GetReturnType() ITypeContext

	// SetReturnType sets the returnType rule contexts.
	SetReturnType(ITypeContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	FUNCTION() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	QualifiedName() IQualifiedNameContext
	TypeList() ITypeListContext
	RETURNS() antlr.TerminalNode
	Type_() ITypeContext
	GLOBAL() antlr.TerminalNode
	Properties() IPropertiesContext
	InlineProperties() IInlinePropertiesContext
	InlineFunction() IInlineFunctionContext
	TABLE() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode

	// IsCreateFunctionStatementContext differentiates from other interfaces.
	IsCreateFunctionStatementContext()
}

type CreateFunctionStatementContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	functionType antlr.Token
	returnType   ITypeContext
}

func NewEmptyCreateFunctionStatementContext() *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createFunctionStatement
	return p
}

func InitEmptyCreateFunctionStatementContext(p *CreateFunctionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createFunctionStatement
}

func (*CreateFunctionStatementContext) IsCreateFunctionStatementContext() {}

func NewCreateFunctionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFunctionStatementContext {
	var p = new(CreateFunctionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createFunctionStatement

	return p
}

func (s *CreateFunctionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFunctionStatementContext) GetFunctionType() antlr.Token { return s.functionType }

func (s *CreateFunctionStatementContext) SetFunctionType(v antlr.Token) { s.functionType = v }

func (s *CreateFunctionStatementContext) GetReturnType() ITypeContext { return s.returnType }

func (s *CreateFunctionStatementContext) SetReturnType(v ITypeContext) { s.returnType = v }

func (s *CreateFunctionStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateFunctionStatementContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreateFunctionStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *CreateFunctionStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateFunctionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFunctionStatementContext) TypeList() ITypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *CreateFunctionStatementContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETURNS, 0)
}

func (s *CreateFunctionStatementContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CreateFunctionStatementContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *CreateFunctionStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateFunctionStatementContext) InlineProperties() IInlinePropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlinePropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlinePropertiesContext)
}

func (s *CreateFunctionStatementContext) InlineFunction() IInlineFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlineFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlineFunctionContext)
}

func (s *CreateFunctionStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *CreateFunctionStatementContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAGGREGATE, 0)
}

func (s *CreateFunctionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFunctionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFunctionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateFunctionStatement(s)
	}
}

func (s *CreateFunctionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateFunctionStatement(s)
	}
}

func (p *StarRocksParser) CreateFunctionStatement() (localctx ICreateFunctionStatementContext) {
	localctx = NewCreateFunctionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, StarRocksParserRULE_createFunctionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4127)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4128)
		p.OrReplace()
	}
	p.SetState(4130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL {
		{
			p.SetState(4129)
			p.Match(StarRocksParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAGGREGATE || _la == StarRocksParserTABLE {
		{
			p.SetState(4132)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateFunctionStatementContext).functionType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserAGGREGATE || _la == StarRocksParserTABLE) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateFunctionStatementContext).functionType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(4135)
		p.Match(StarRocksParserFUNCTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4136)
		p.IfNotExists()
	}
	{
		p.SetState(4137)
		p.QualifiedName()
	}
	{
		p.SetState(4138)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4139)
		p.TypeList()
	}
	{
		p.SetState(4140)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4141)
		p.Match(StarRocksParserRETURNS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4142)

		var _x = p.Type_()

		localctx.(*CreateFunctionStatementContext).returnType = _x
	}
	p.SetState(4145)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext()) == 1+1 {
		{
			p.SetState(4143)
			p.Properties()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 413, p.GetParserRuleContext()) == 2+1 {
		{
			p.SetState(4144)
			p.InlineProperties()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(4147)
			p.InlineFunction()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlineFunctionContext is an interface to support dynamic dispatch.
type IInlineFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS() antlr.TerminalNode
	ATTACHMENT() antlr.TerminalNode

	// IsInlineFunctionContext differentiates from other interfaces.
	IsInlineFunctionContext()
}

type InlineFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlineFunctionContext() *InlineFunctionContext {
	var p = new(InlineFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineFunction
	return p
}

func InitEmptyInlineFunctionContext(p *InlineFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineFunction
}

func (*InlineFunctionContext) IsInlineFunctionContext() {}

func NewInlineFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlineFunctionContext {
	var p = new(InlineFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_inlineFunction

	return p
}

func (s *InlineFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *InlineFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *InlineFunctionContext) ATTACHMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserATTACHMENT, 0)
}

func (s *InlineFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlineFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInlineFunction(s)
	}
}

func (s *InlineFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInlineFunction(s)
	}
}

func (p *StarRocksParser) InlineFunction() (localctx IInlineFunctionContext) {
	localctx = NewInlineFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, StarRocksParserRULE_inlineFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4150)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4151)
		p.Match(StarRocksParserATTACHMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeListContext is an interface to support dynamic dispatch.
type ITypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	DOTDOTDOT() antlr.TerminalNode

	// IsTypeListContext differentiates from other interfaces.
	IsTypeListContext()
}

type TypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeListContext() *TypeListContext {
	var p = new(TypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeList
	return p
}

func InitEmptyTypeListContext(p *TypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeList
}

func (*TypeListContext) IsTypeListContext() {}

func NewTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeListContext {
	var p = new(TypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_typeList

	return p
}

func (s *TypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeListContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *TypeListContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *TypeListContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOTDOTDOT, 0)
}

func (s *TypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTypeList(s)
	}
}

func (s *TypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTypeList(s)
	}
}

func (p *StarRocksParser) TypeList() (localctx ITypeListContext) {
	localctx = NewTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, StarRocksParserRULE_typeList)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&1099547017217) != 0) || ((int64((_la-104)) & ^0x3f) == 0 && ((int64(1)<<(_la-104))&72057594071483363) != 0) || ((int64((_la-187)) & ^0x3f) == 0 && ((int64(1)<<(_la-187))&4611690485199667201) != 0) || ((int64((_la-281)) & ^0x3f) == 0 && ((int64(1)<<(_la-281))&67108867) != 0) || ((int64((_la-396)) & ^0x3f) == 0 && ((int64(1)<<(_la-396))&72058160982048777) != 0) || _la == StarRocksParserVARBINARY || _la == StarRocksParserVARCHAR {
		{
			p.SetState(4153)
			p.Type_()
		}

	}
	p.SetState(4160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4156)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4157)
				p.Type_()
			}

		}
		p.SetState(4162)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(4165)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__2 {
		{
			p.SetState(4163)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4164)
			p.Match(StarRocksParserDOTDOTDOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILoadStatementContext is an interface to support dynamic dispatch.
type ILoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLabel returns the label rule contexts.
	GetLabel() ILabelNameContext

	// GetData returns the data rule contexts.
	GetData() IDataDescListContext

	// GetBroker returns the broker rule contexts.
	GetBroker() IBrokerDescContext

	// GetSystem returns the system rule contexts.
	GetSystem() IIdentifierOrStringContext

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// GetResource returns the resource rule contexts.
	GetResource() IResourceDescContext

	// SetLabel sets the label rule contexts.
	SetLabel(ILabelNameContext)

	// SetData sets the data rule contexts.
	SetData(IDataDescListContext)

	// SetBroker sets the broker rule contexts.
	SetBroker(IBrokerDescContext)

	// SetSystem sets the system rule contexts.
	SetSystem(IIdentifierOrStringContext)

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// SetResource sets the resource rule contexts.
	SetResource(IResourceDescContext)

	// Getter signatures
	LOAD() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LabelName() ILabelNameContext
	BY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	DataDescList() IDataDescListContext
	BrokerDesc() IBrokerDescContext
	IdentifierOrString() IIdentifierOrStringContext
	PropertyList() IPropertyListContext
	ResourceDesc() IResourceDescContext

	// IsLoadStatementContext differentiates from other interfaces.
	IsLoadStatementContext()
}

type LoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	label    ILabelNameContext
	data     IDataDescListContext
	broker   IBrokerDescContext
	system   IIdentifierOrStringContext
	props    IPropertyListContext
	resource IResourceDescContext
}

func NewEmptyLoadStatementContext() *LoadStatementContext {
	var p = new(LoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_loadStatement
	return p
}

func InitEmptyLoadStatementContext(p *LoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_loadStatement
}

func (*LoadStatementContext) IsLoadStatementContext() {}

func NewLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LoadStatementContext {
	var p = new(LoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_loadStatement

	return p
}

func (s *LoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LoadStatementContext) GetLabel() ILabelNameContext { return s.label }

func (s *LoadStatementContext) GetData() IDataDescListContext { return s.data }

func (s *LoadStatementContext) GetBroker() IBrokerDescContext { return s.broker }

func (s *LoadStatementContext) GetSystem() IIdentifierOrStringContext { return s.system }

func (s *LoadStatementContext) GetProps() IPropertyListContext { return s.props }

func (s *LoadStatementContext) GetResource() IResourceDescContext { return s.resource }

func (s *LoadStatementContext) SetLabel(v ILabelNameContext) { s.label = v }

func (s *LoadStatementContext) SetData(v IDataDescListContext) { s.data = v }

func (s *LoadStatementContext) SetBroker(v IBrokerDescContext) { s.broker = v }

func (s *LoadStatementContext) SetSystem(v IIdentifierOrStringContext) { s.system = v }

func (s *LoadStatementContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *LoadStatementContext) SetResource(v IResourceDescContext) { s.resource = v }

func (s *LoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *LoadStatementContext) LABEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLABEL, 0)
}

func (s *LoadStatementContext) LabelName() ILabelNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelNameContext)
}

func (s *LoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *LoadStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *LoadStatementContext) DataDescList() IDataDescListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescListContext)
}

func (s *LoadStatementContext) BrokerDesc() IBrokerDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBrokerDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBrokerDescContext)
}

func (s *LoadStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *LoadStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *LoadStatementContext) ResourceDesc() IResourceDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceDescContext)
}

func (s *LoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLoadStatement(s)
	}
}

func (s *LoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLoadStatement(s)
	}
}

func (p *StarRocksParser) LoadStatement() (localctx ILoadStatementContext) {
	localctx = NewLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, StarRocksParserRULE_loadStatement)
	var _la int

	p.SetState(4195)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 424, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4167)
			p.Match(StarRocksParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4168)
			p.Match(StarRocksParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4169)

			var _x = p.LabelName()

			localctx.(*LoadStatementContext).label = _x
		}
		p.SetState(4171)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4170)

				var _x = p.DataDescList()

				localctx.(*LoadStatementContext).data = _x
			}

		}
		p.SetState(4174)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4173)

				var _x = p.BrokerDesc()

				localctx.(*LoadStatementContext).broker = _x
			}

		}
		p.SetState(4178)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserBY {
			{
				p.SetState(4176)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4177)

				var _x = p.IdentifierOrString()

				localctx.(*LoadStatementContext).system = _x
			}

		}
		p.SetState(4182)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(4180)
				p.Match(StarRocksParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4181)

				var _x = p.PropertyList()

				localctx.(*LoadStatementContext).props = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4184)
			p.Match(StarRocksParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4185)
			p.Match(StarRocksParserLABEL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4186)

			var _x = p.LabelName()

			localctx.(*LoadStatementContext).label = _x
		}
		p.SetState(4188)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4187)

				var _x = p.DataDescList()

				localctx.(*LoadStatementContext).data = _x
			}

		}
		{
			p.SetState(4190)

			var _x = p.ResourceDesc()

			localctx.(*LoadStatementContext).resource = _x
		}
		p.SetState(4193)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPROPERTIES {
			{
				p.SetState(4191)
				p.Match(StarRocksParserPROPERTIES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4192)

				var _x = p.PropertyList()

				localctx.(*LoadStatementContext).props = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelNameContext is an interface to support dynamic dispatch.
type ILabelNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IIdentifierContext

	// GetLabel returns the label rule contexts.
	GetLabel() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IIdentifierContext)

	// SetLabel sets the label rule contexts.
	SetLabel(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsLabelNameContext differentiates from other interfaces.
	IsLabelNameContext()
}

type LabelNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IIdentifierContext
	label  IIdentifierContext
}

func NewEmptyLabelNameContext() *LabelNameContext {
	var p = new(LabelNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_labelName
	return p
}

func InitEmptyLabelNameContext(p *LabelNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_labelName
}

func (*LabelNameContext) IsLabelNameContext() {}

func NewLabelNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelNameContext {
	var p = new(LabelNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_labelName

	return p
}

func (s *LabelNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelNameContext) GetDb() IIdentifierContext { return s.db }

func (s *LabelNameContext) GetLabel() IIdentifierContext { return s.label }

func (s *LabelNameContext) SetDb(v IIdentifierContext) { s.db = v }

func (s *LabelNameContext) SetLabel(v IIdentifierContext) { s.label = v }

func (s *LabelNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *LabelNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LabelNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLabelName(s)
	}
}

func (s *LabelNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLabelName(s)
	}
}

func (p *StarRocksParser) LabelName() (localctx ILabelNameContext) {
	localctx = NewLabelNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, StarRocksParserRULE_labelName)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4200)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 425, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4197)

			var _x = p.Identifier()

			localctx.(*LabelNameContext).db = _x
		}
		{
			p.SetState(4198)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4202)

		var _x = p.Identifier()

		localctx.(*LabelNameContext).label = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescListContext is an interface to support dynamic dispatch.
type IDataDescListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllDataDesc() []IDataDescContext
	DataDesc(i int) IDataDescContext

	// IsDataDescListContext differentiates from other interfaces.
	IsDataDescListContext()
}

type DataDescListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescListContext() *DataDescListContext {
	var p = new(DataDescListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataDescList
	return p
}

func InitEmptyDataDescListContext(p *DataDescListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataDescList
}

func (*DataDescListContext) IsDataDescListContext() {}

func NewDataDescListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescListContext {
	var p = new(DataDescListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataDescList

	return p
}

func (s *DataDescListContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescListContext) AllDataDesc() []IDataDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescContext); ok {
			len++
		}
	}

	tst := make([]IDataDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescContext); ok {
			tst[i] = t.(IDataDescContext)
			i++
		}
	}

	return tst
}

func (s *DataDescListContext) DataDesc(i int) IDataDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescContext)
}

func (s *DataDescListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataDescList(s)
	}
}

func (s *DataDescListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataDescList(s)
	}
}

func (p *StarRocksParser) DataDescList() (localctx IDataDescListContext) {
	localctx = NewDataDescListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, StarRocksParserRULE_dataDescList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4204)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4205)
		p.DataDesc()
	}
	p.SetState(4210)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(4206)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4207)
			p.DataDesc()
		}

		p.SetState(4212)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4213)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDescContext is an interface to support dynamic dispatch.
type IDataDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSrcFiles returns the srcFiles rule contexts.
	GetSrcFiles() IStringListContext

	// GetDstTableName returns the dstTableName rule contexts.
	GetDstTableName() IIdentifierContext

	// GetPartitions returns the partitions rule contexts.
	GetPartitions() IPartitionNamesContext

	// GetColSep returns the colSep rule contexts.
	GetColSep() IStringContext

	// GetRowSep returns the rowSep rule contexts.
	GetRowSep() IStringContext

	// GetFormat returns the format rule contexts.
	GetFormat() IFileFormatContext

	// GetFormatPropsField returns the formatPropsField rule contexts.
	GetFormatPropsField() IFormatPropsContext

	// GetColList returns the colList rule contexts.
	GetColList() IColumnAliasesContext

	// GetColFromPath returns the colFromPath rule contexts.
	GetColFromPath() IIdentifierListContext

	// GetColMappingList returns the colMappingList rule contexts.
	GetColMappingList() IClassifierContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// GetSrcTableName returns the srcTableName rule contexts.
	GetSrcTableName() IIdentifierContext

	// SetSrcFiles sets the srcFiles rule contexts.
	SetSrcFiles(IStringListContext)

	// SetDstTableName sets the dstTableName rule contexts.
	SetDstTableName(IIdentifierContext)

	// SetPartitions sets the partitions rule contexts.
	SetPartitions(IPartitionNamesContext)

	// SetColSep sets the colSep rule contexts.
	SetColSep(IStringContext)

	// SetRowSep sets the rowSep rule contexts.
	SetRowSep(IStringContext)

	// SetFormat sets the format rule contexts.
	SetFormat(IFileFormatContext)

	// SetFormatPropsField sets the formatPropsField rule contexts.
	SetFormatPropsField(IFormatPropsContext)

	// SetColList sets the colList rule contexts.
	SetColList(IColumnAliasesContext)

	// SetColFromPath sets the colFromPath rule contexts.
	SetColFromPath(IIdentifierListContext)

	// SetColMappingList sets the colMappingList rule contexts.
	SetColMappingList(IClassifierContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// SetSrcTableName sets the srcTableName rule contexts.
	SetSrcTableName(IIdentifierContext)

	// Getter signatures
	DATA() antlr.TerminalNode
	INFILE() antlr.TerminalNode
	INTO() antlr.TerminalNode
	AllTABLE() []antlr.TerminalNode
	TABLE(i int) antlr.TerminalNode
	StringList() IStringListContext
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	NEGATIVE() antlr.TerminalNode
	AllCOLUMNS() []antlr.TerminalNode
	COLUMNS(i int) antlr.TerminalNode
	AllTERMINATED() []antlr.TerminalNode
	TERMINATED(i int) antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ROWS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	PATH() antlr.TerminalNode
	AS() antlr.TerminalNode
	SET() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext
	AllString_() []IStringContext
	String_(i int) IStringContext
	FileFormat() IFileFormatContext
	FormatProps() IFormatPropsContext
	ColumnAliases() IColumnAliasesContext
	IdentifierList() IIdentifierListContext
	Classifier() IClassifierContext
	Expression() IExpressionContext

	// IsDataDescContext differentiates from other interfaces.
	IsDataDescContext()
}

type DataDescContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	srcFiles         IStringListContext
	dstTableName     IIdentifierContext
	partitions       IPartitionNamesContext
	colSep           IStringContext
	rowSep           IStringContext
	format           IFileFormatContext
	formatPropsField IFormatPropsContext
	colList          IColumnAliasesContext
	colFromPath      IIdentifierListContext
	colMappingList   IClassifierContext
	where            IExpressionContext
	srcTableName     IIdentifierContext
}

func NewEmptyDataDescContext() *DataDescContext {
	var p = new(DataDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataDesc
	return p
}

func InitEmptyDataDescContext(p *DataDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataDesc
}

func (*DataDescContext) IsDataDescContext() {}

func NewDataDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescContext {
	var p = new(DataDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataDesc

	return p
}

func (s *DataDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescContext) GetSrcFiles() IStringListContext { return s.srcFiles }

func (s *DataDescContext) GetDstTableName() IIdentifierContext { return s.dstTableName }

func (s *DataDescContext) GetPartitions() IPartitionNamesContext { return s.partitions }

func (s *DataDescContext) GetColSep() IStringContext { return s.colSep }

func (s *DataDescContext) GetRowSep() IStringContext { return s.rowSep }

func (s *DataDescContext) GetFormat() IFileFormatContext { return s.format }

func (s *DataDescContext) GetFormatPropsField() IFormatPropsContext { return s.formatPropsField }

func (s *DataDescContext) GetColList() IColumnAliasesContext { return s.colList }

func (s *DataDescContext) GetColFromPath() IIdentifierListContext { return s.colFromPath }

func (s *DataDescContext) GetColMappingList() IClassifierContext { return s.colMappingList }

func (s *DataDescContext) GetWhere() IExpressionContext { return s.where }

func (s *DataDescContext) GetSrcTableName() IIdentifierContext { return s.srcTableName }

func (s *DataDescContext) SetSrcFiles(v IStringListContext) { s.srcFiles = v }

func (s *DataDescContext) SetDstTableName(v IIdentifierContext) { s.dstTableName = v }

func (s *DataDescContext) SetPartitions(v IPartitionNamesContext) { s.partitions = v }

func (s *DataDescContext) SetColSep(v IStringContext) { s.colSep = v }

func (s *DataDescContext) SetRowSep(v IStringContext) { s.rowSep = v }

func (s *DataDescContext) SetFormat(v IFileFormatContext) { s.format = v }

func (s *DataDescContext) SetFormatPropsField(v IFormatPropsContext) { s.formatPropsField = v }

func (s *DataDescContext) SetColList(v IColumnAliasesContext) { s.colList = v }

func (s *DataDescContext) SetColFromPath(v IIdentifierListContext) { s.colFromPath = v }

func (s *DataDescContext) SetColMappingList(v IClassifierContext) { s.colMappingList = v }

func (s *DataDescContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DataDescContext) SetSrcTableName(v IIdentifierContext) { s.srcTableName = v }

func (s *DataDescContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *DataDescContext) INFILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINFILE, 0)
}

func (s *DataDescContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *DataDescContext) AllTABLE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserTABLE)
}

func (s *DataDescContext) TABLE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, i)
}

func (s *DataDescContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *DataDescContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DataDescContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNEGATIVE, 0)
}

func (s *DataDescContext) AllCOLUMNS() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserCOLUMNS)
}

func (s *DataDescContext) COLUMNS(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, i)
}

func (s *DataDescContext) AllTERMINATED() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserTERMINATED)
}

func (s *DataDescContext) TERMINATED(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserTERMINATED, i)
}

func (s *DataDescContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserBY)
}

func (s *DataDescContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, i)
}

func (s *DataDescContext) ROWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROWS, 0)
}

func (s *DataDescContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DataDescContext) PATH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPATH, 0)
}

func (s *DataDescContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *DataDescContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *DataDescContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *DataDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *DataDescContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *DataDescContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DataDescContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *DataDescContext) FormatProps() IFormatPropsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFormatPropsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFormatPropsContext)
}

func (s *DataDescContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *DataDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DataDescContext) Classifier() IClassifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassifierContext)
}

func (s *DataDescContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataDesc(s)
	}
}

func (s *DataDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataDesc(s)
	}
}

func (p *StarRocksParser) DataDesc() (localctx IDataDescContext) {
	localctx = NewDataDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, StarRocksParserRULE_dataDesc)
	var _la int

	p.SetState(4284)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 441, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4215)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4216)
			p.Match(StarRocksParserINFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4217)

			var _x = p.StringList()

			localctx.(*DataDescContext).srcFiles = _x
		}
		p.SetState(4219)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNEGATIVE {
			{
				p.SetState(4218)
				p.Match(StarRocksParserNEGATIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4221)
			p.Match(StarRocksParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4222)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4223)

			var _x = p.Identifier()

			localctx.(*DataDescContext).dstTableName = _x
		}
		p.SetState(4225)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
			{
				p.SetState(4224)

				var _x = p.PartitionNames()

				localctx.(*DataDescContext).partitions = _x
			}

		}
		p.SetState(4231)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 429, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4227)
				p.Match(StarRocksParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4228)
				p.Match(StarRocksParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4229)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4230)

				var _x = p.String_()

				localctx.(*DataDescContext).colSep = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4237)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserROWS {
			{
				p.SetState(4233)
				p.Match(StarRocksParserROWS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4234)
				p.Match(StarRocksParserTERMINATED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4235)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4236)

				var _x = p.String_()

				localctx.(*DataDescContext).rowSep = _x
			}

		}
		p.SetState(4240)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFORMAT {
			{
				p.SetState(4239)

				var _x = p.FileFormat()

				localctx.(*DataDescContext).format = _x
			}

		}
		p.SetState(4243)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4242)

				var _x = p.FormatProps()

				localctx.(*DataDescContext).formatPropsField = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4246)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4245)

				var _x = p.ColumnAliases()

				localctx.(*DataDescContext).colList = _x
			}

		}
		p.SetState(4253)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCOLUMNS {
			{
				p.SetState(4248)
				p.Match(StarRocksParserCOLUMNS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4249)
				p.Match(StarRocksParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4250)
				p.Match(StarRocksParserPATH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4251)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4252)

				var _x = p.IdentifierList()

				localctx.(*DataDescContext).colFromPath = _x
			}

		}
		p.SetState(4257)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSET {
			{
				p.SetState(4255)
				p.Match(StarRocksParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4256)

				var _x = p.Classifier()

				localctx.(*DataDescContext).colMappingList = _x
			}

		}
		p.SetState(4261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(4259)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4260)

				var _x = p.expression(0)

				localctx.(*DataDescContext).where = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4263)
			p.Match(StarRocksParserDATA)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4264)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4265)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4266)

			var _x = p.Identifier()

			localctx.(*DataDescContext).srcTableName = _x
		}
		p.SetState(4268)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNEGATIVE {
			{
				p.SetState(4267)
				p.Match(StarRocksParserNEGATIVE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4270)
			p.Match(StarRocksParserINTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4271)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4272)

			var _x = p.Identifier()

			localctx.(*DataDescContext).dstTableName = _x
		}
		p.SetState(4274)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
			{
				p.SetState(4273)

				var _x = p.PartitionNames()

				localctx.(*DataDescContext).partitions = _x
			}

		}
		p.SetState(4278)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSET {
			{
				p.SetState(4276)
				p.Match(StarRocksParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4277)

				var _x = p.Classifier()

				localctx.(*DataDescContext).colMappingList = _x
			}

		}
		p.SetState(4282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(4280)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4281)

				var _x = p.expression(0)

				localctx.(*DataDescContext).where = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFormatPropsContext is an interface to support dynamic dispatch.
type IFormatPropsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEncloseCharacter returns the encloseCharacter rule contexts.
	GetEncloseCharacter() IStringContext

	// GetEscapeCharacter returns the escapeCharacter rule contexts.
	GetEscapeCharacter() IStringContext

	// SetEncloseCharacter sets the encloseCharacter rule contexts.
	SetEncloseCharacter(IStringContext)

	// SetEscapeCharacter sets the escapeCharacter rule contexts.
	SetEscapeCharacter(IStringContext)

	// Getter signatures
	SKIP_HEADER() antlr.TerminalNode
	AllEQ() []antlr.TerminalNode
	EQ(i int) antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	TRIM_SPACE() antlr.TerminalNode
	BooleanValue() IBooleanValueContext
	ENCLOSE() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsFormatPropsContext differentiates from other interfaces.
	IsFormatPropsContext()
}

type FormatPropsContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	encloseCharacter IStringContext
	escapeCharacter  IStringContext
}

func NewEmptyFormatPropsContext() *FormatPropsContext {
	var p = new(FormatPropsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_formatProps
	return p
}

func InitEmptyFormatPropsContext(p *FormatPropsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_formatProps
}

func (*FormatPropsContext) IsFormatPropsContext() {}

func NewFormatPropsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FormatPropsContext {
	var p = new(FormatPropsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_formatProps

	return p
}

func (s *FormatPropsContext) GetParser() antlr.Parser { return s.parser }

func (s *FormatPropsContext) GetEncloseCharacter() IStringContext { return s.encloseCharacter }

func (s *FormatPropsContext) GetEscapeCharacter() IStringContext { return s.escapeCharacter }

func (s *FormatPropsContext) SetEncloseCharacter(v IStringContext) { s.encloseCharacter = v }

func (s *FormatPropsContext) SetEscapeCharacter(v IStringContext) { s.escapeCharacter = v }

func (s *FormatPropsContext) SKIP_HEADER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSKIP_HEADER, 0)
}

func (s *FormatPropsContext) AllEQ() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserEQ)
}

func (s *FormatPropsContext) EQ(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, i)
}

func (s *FormatPropsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *FormatPropsContext) TRIM_SPACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRIM_SPACE, 0)
}

func (s *FormatPropsContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *FormatPropsContext) ENCLOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENCLOSE, 0)
}

func (s *FormatPropsContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserESCAPE, 0)
}

func (s *FormatPropsContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *FormatPropsContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *FormatPropsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FormatPropsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FormatPropsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFormatProps(s)
	}
}

func (s *FormatPropsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFormatProps(s)
	}
}

func (p *StarRocksParser) FormatProps() (localctx IFormatPropsContext) {
	localctx = NewFormatPropsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, StarRocksParserRULE_formatProps)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4286)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4290)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSKIP_HEADER {
		{
			p.SetState(4287)
			p.Match(StarRocksParserSKIP_HEADER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4288)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4289)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserTRIM_SPACE {
		{
			p.SetState(4292)
			p.Match(StarRocksParserTRIM_SPACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4293)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4294)
			p.BooleanValue()
		}

	}
	p.SetState(4300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserENCLOSE {
		{
			p.SetState(4297)
			p.Match(StarRocksParserENCLOSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4298)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4299)

			var _x = p.String_()

			localctx.(*FormatPropsContext).encloseCharacter = _x
		}

	}
	p.SetState(4305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserESCAPE {
		{
			p.SetState(4302)
			p.Match(StarRocksParserESCAPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4303)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4304)

			var _x = p.String_()

			localctx.(*FormatPropsContext).escapeCharacter = _x
		}

	}
	{
		p.SetState(4307)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBrokerDescContext is an interface to support dynamic dispatch.
type IBrokerDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierOrStringContext

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierOrStringContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	PropertyList() IPropertyListContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsBrokerDescContext differentiates from other interfaces.
	IsBrokerDescContext()
}

type BrokerDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	props  IPropertyListContext
	name   IIdentifierOrStringContext
}

func NewEmptyBrokerDescContext() *BrokerDescContext {
	var p = new(BrokerDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_brokerDesc
	return p
}

func InitEmptyBrokerDescContext(p *BrokerDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_brokerDesc
}

func (*BrokerDescContext) IsBrokerDescContext() {}

func NewBrokerDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BrokerDescContext {
	var p = new(BrokerDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_brokerDesc

	return p
}

func (s *BrokerDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BrokerDescContext) GetProps() IPropertyListContext { return s.props }

func (s *BrokerDescContext) GetName() IIdentifierOrStringContext { return s.name }

func (s *BrokerDescContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *BrokerDescContext) SetName(v IIdentifierOrStringContext) { s.name = v }

func (s *BrokerDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *BrokerDescContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *BrokerDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *BrokerDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *BrokerDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BrokerDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BrokerDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBrokerDesc(s)
	}
}

func (s *BrokerDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBrokerDesc(s)
	}
}

func (p *StarRocksParser) BrokerDesc() (localctx IBrokerDescContext) {
	localctx = NewBrokerDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, StarRocksParserRULE_brokerDesc)
	var _la int

	p.SetState(4320)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 448, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4309)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4310)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4311)

				var _x = p.PropertyList()

				localctx.(*BrokerDescContext).props = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4314)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4315)
			p.Match(StarRocksParserBROKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4316)

			var _x = p.IdentifierOrString()

			localctx.(*BrokerDescContext).name = _x
		}
		p.SetState(4318)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(4317)

				var _x = p.PropertyList()

				localctx.(*BrokerDescContext).props = _x
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceDescContext is an interface to support dynamic dispatch.
type IResourceDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierOrStringContext

	// GetProps returns the props rule contexts.
	GetProps() IPropertyListContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierOrStringContext)

	// SetProps sets the props rule contexts.
	SetProps(IPropertyListContext)

	// Getter signatures
	WITH() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	PropertyList() IPropertyListContext

	// IsResourceDescContext differentiates from other interfaces.
	IsResourceDescContext()
}

type ResourceDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierOrStringContext
	props  IPropertyListContext
}

func NewEmptyResourceDescContext() *ResourceDescContext {
	var p = new(ResourceDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resourceDesc
	return p
}

func InitEmptyResourceDescContext(p *ResourceDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resourceDesc
}

func (*ResourceDescContext) IsResourceDescContext() {}

func NewResourceDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceDescContext {
	var p = new(ResourceDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_resourceDesc

	return p
}

func (s *ResourceDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceDescContext) GetName() IIdentifierOrStringContext { return s.name }

func (s *ResourceDescContext) GetProps() IPropertyListContext { return s.props }

func (s *ResourceDescContext) SetName(v IIdentifierOrStringContext) { s.name = v }

func (s *ResourceDescContext) SetProps(v IPropertyListContext) { s.props = v }

func (s *ResourceDescContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *ResourceDescContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *ResourceDescContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ResourceDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *ResourceDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterResourceDesc(s)
	}
}

func (s *ResourceDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitResourceDesc(s)
	}
}

func (p *StarRocksParser) ResourceDesc() (localctx IResourceDescContext) {
	localctx = NewResourceDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, StarRocksParserRULE_resourceDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4322)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4323)
		p.Match(StarRocksParserRESOURCE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4324)

		var _x = p.IdentifierOrString()

		localctx.(*ResourceDescContext).name = _x
	}
	p.SetState(4326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(4325)

			var _x = p.PropertyList()

			localctx.(*ResourceDescContext).props = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowLoadStatementContext is an interface to support dynamic dispatch.
type IShowLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowLoadStatementContext differentiates from other interfaces.
	IsShowLoadStatementContext()
}

type ShowLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowLoadStatementContext() *ShowLoadStatementContext {
	var p = new(ShowLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showLoadStatement
	return p
}

func InitEmptyShowLoadStatementContext(p *ShowLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showLoadStatement
}

func (*ShowLoadStatementContext) IsShowLoadStatementContext() {}

func NewShowLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowLoadStatementContext {
	var p = new(ShowLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showLoadStatement

	return p
}

func (s *ShowLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowLoadStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowLoadStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowLoadStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowLoadStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowLoadStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowLoadStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowLoadStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowLoadStatement(s)
	}
}

func (s *ShowLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowLoadStatement(s)
	}
}

func (p *StarRocksParser) ShowLoadStatement() (localctx IShowLoadStatementContext) {
	localctx = NewShowLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, StarRocksParserRULE_showLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4328)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4329)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4331)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserALL {
		{
			p.SetState(4330)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4335)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(4333)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4334)
			p.Identifier()
		}

	}
	p.SetState(4339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(4337)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4338)
			p.expression(0)
		}

	}
	p.SetState(4351)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(4341)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4342)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4343)
			p.SortItem()
		}
		p.SetState(4348)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(4344)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4345)
				p.SortItem()
			}

			p.SetState(4350)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(4354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(4353)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowLoadWarningsStatementContext is an interface to support dynamic dispatch.
type IShowLoadWarningsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	LimitElement() ILimitElementContext
	ON() antlr.TerminalNode
	String_() IStringContext

	// IsShowLoadWarningsStatementContext differentiates from other interfaces.
	IsShowLoadWarningsStatementContext()
}

type ShowLoadWarningsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowLoadWarningsStatementContext() *ShowLoadWarningsStatementContext {
	var p = new(ShowLoadWarningsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showLoadWarningsStatement
	return p
}

func InitEmptyShowLoadWarningsStatementContext(p *ShowLoadWarningsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showLoadWarningsStatement
}

func (*ShowLoadWarningsStatementContext) IsShowLoadWarningsStatementContext() {}

func NewShowLoadWarningsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowLoadWarningsStatementContext {
	var p = new(ShowLoadWarningsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showLoadWarningsStatement

	return p
}

func (s *ShowLoadWarningsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowLoadWarningsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowLoadWarningsStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *ShowLoadWarningsStatementContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWARNINGS, 0)
}

func (s *ShowLoadWarningsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowLoadWarningsStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowLoadWarningsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowLoadWarningsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowLoadWarningsStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowLoadWarningsStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *ShowLoadWarningsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowLoadWarningsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowLoadWarningsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowLoadWarningsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowLoadWarningsStatement(s)
	}
}

func (s *ShowLoadWarningsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowLoadWarningsStatement(s)
	}
}

func (p *StarRocksParser) ShowLoadWarningsStatement() (localctx IShowLoadWarningsStatementContext) {
	localctx = NewShowLoadWarningsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, StarRocksParserRULE_showLoadWarningsStatement)
	var _la int

	p.SetState(4375)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 459, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4356)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4357)
			p.Match(StarRocksParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4358)
			p.Match(StarRocksParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4361)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFROM {
			{
				p.SetState(4359)
				p.Match(StarRocksParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4360)
				p.Identifier()
			}

		}
		p.SetState(4365)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(4363)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4364)
				p.expression(0)
			}

		}
		p.SetState(4368)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIMIT {
			{
				p.SetState(4367)
				p.LimitElement()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4370)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4371)
			p.Match(StarRocksParserLOAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4372)
			p.Match(StarRocksParserWARNINGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4373)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4374)
			p.String_()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelLoadStatementContext is an interface to support dynamic dispatch.
type ICancelLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FROM() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsCancelLoadStatementContext differentiates from other interfaces.
	IsCancelLoadStatementContext()
}

type CancelLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelLoadStatementContext() *CancelLoadStatementContext {
	var p = new(CancelLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelLoadStatement
	return p
}

func InitEmptyCancelLoadStatementContext(p *CancelLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelLoadStatement
}

func (*CancelLoadStatementContext) IsCancelLoadStatementContext() {}

func NewCancelLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelLoadStatementContext {
	var p = new(CancelLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelLoadStatement

	return p
}

func (s *CancelLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelLoadStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *CancelLoadStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelLoadStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *CancelLoadStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelLoadStatement(s)
	}
}

func (s *CancelLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelLoadStatement(s)
	}
}

func (p *StarRocksParser) CancelLoadStatement() (localctx ICancelLoadStatementContext) {
	localctx = NewCancelLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, StarRocksParserRULE_cancelLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4377)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4378)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM {
		{
			p.SetState(4379)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4380)
			p.Identifier()
		}

	}
	p.SetState(4385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(4383)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4384)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterLoadStatementContext is an interface to support dynamic dispatch.
type IAlterLoadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	LOAD() antlr.TerminalNode
	FOR() antlr.TerminalNode
	Identifier() IIdentifierContext
	JobProperties() IJobPropertiesContext
	QualifiedName() IQualifiedNameContext

	// IsAlterLoadStatementContext differentiates from other interfaces.
	IsAlterLoadStatementContext()
}

type AlterLoadStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
	name   IIdentifierContext
}

func NewEmptyAlterLoadStatementContext() *AlterLoadStatementContext {
	var p = new(AlterLoadStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterLoadStatement
	return p
}

func InitEmptyAlterLoadStatementContext(p *AlterLoadStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterLoadStatement
}

func (*AlterLoadStatementContext) IsAlterLoadStatementContext() {}

func NewAlterLoadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterLoadStatementContext {
	var p = new(AlterLoadStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterLoadStatement

	return p
}

func (s *AlterLoadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterLoadStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *AlterLoadStatementContext) GetName() IIdentifierContext { return s.name }

func (s *AlterLoadStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *AlterLoadStatementContext) SetName(v IIdentifierContext) { s.name = v }

func (s *AlterLoadStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterLoadStatementContext) LOAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOAD, 0)
}

func (s *AlterLoadStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *AlterLoadStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterLoadStatementContext) JobProperties() IJobPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJobPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJobPropertiesContext)
}

func (s *AlterLoadStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterLoadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterLoadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterLoadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterLoadStatement(s)
	}
}

func (s *AlterLoadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterLoadStatement(s)
	}
}

func (p *StarRocksParser) AlterLoadStatement() (localctx IAlterLoadStatementContext) {
	localctx = NewAlterLoadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, StarRocksParserRULE_alterLoadStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4387)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4388)
		p.Match(StarRocksParserLOAD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4389)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4393)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 462, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4390)

			var _x = p.QualifiedName()

			localctx.(*AlterLoadStatementContext).db = _x
		}
		{
			p.SetState(4391)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4395)

		var _x = p.Identifier()

		localctx.(*AlterLoadStatementContext).name = _x
	}
	p.SetState(4397)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(4396)
			p.JobProperties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelCompactionStatementContext is an interface to support dynamic dispatch.
type ICancelCompactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	COMPACTION() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsCancelCompactionStatementContext differentiates from other interfaces.
	IsCancelCompactionStatementContext()
}

type CancelCompactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelCompactionStatementContext() *CancelCompactionStatementContext {
	var p = new(CancelCompactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelCompactionStatement
	return p
}

func InitEmptyCancelCompactionStatementContext(p *CancelCompactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelCompactionStatement
}

func (*CancelCompactionStatementContext) IsCancelCompactionStatementContext() {}

func NewCancelCompactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelCompactionStatementContext {
	var p = new(CancelCompactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelCompactionStatement

	return p
}

func (s *CancelCompactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelCompactionStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelCompactionStatementContext) COMPACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPACTION, 0)
}

func (s *CancelCompactionStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *CancelCompactionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelCompactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelCompactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelCompactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelCompactionStatement(s)
	}
}

func (s *CancelCompactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelCompactionStatement(s)
	}
}

func (p *StarRocksParser) CancelCompactionStatement() (localctx ICancelCompactionStatementContext) {
	localctx = NewCancelCompactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, StarRocksParserRULE_cancelCompactionStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4399)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4400)
		p.Match(StarRocksParserCOMPACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4401)
		p.Match(StarRocksParserWHERE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4402)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAuthorStatementContext is an interface to support dynamic dispatch.
type IShowAuthorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode

	// IsShowAuthorStatementContext differentiates from other interfaces.
	IsShowAuthorStatementContext()
}

type ShowAuthorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAuthorStatementContext() *ShowAuthorStatementContext {
	var p = new(ShowAuthorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAuthorStatement
	return p
}

func InitEmptyShowAuthorStatementContext(p *ShowAuthorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAuthorStatement
}

func (*ShowAuthorStatementContext) IsShowAuthorStatementContext() {}

func NewShowAuthorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAuthorStatementContext {
	var p = new(ShowAuthorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showAuthorStatement

	return p
}

func (s *ShowAuthorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAuthorStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAuthorStatementContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHORS, 0)
}

func (s *ShowAuthorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowAuthorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAuthorStatement(s)
	}
}

func (s *ShowAuthorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAuthorStatement(s)
	}
}

func (p *StarRocksParser) ShowAuthorStatement() (localctx IShowAuthorStatementContext) {
	localctx = NewShowAuthorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, StarRocksParserRULE_showAuthorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4404)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4405)
		p.Match(StarRocksParserAUTHORS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackendsStatementContext is an interface to support dynamic dispatch.
type IShowBackendsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode

	// IsShowBackendsStatementContext differentiates from other interfaces.
	IsShowBackendsStatementContext()
}

type ShowBackendsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackendsStatementContext() *ShowBackendsStatementContext {
	var p = new(ShowBackendsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackendsStatement
	return p
}

func InitEmptyShowBackendsStatementContext(p *ShowBackendsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackendsStatement
}

func (*ShowBackendsStatementContext) IsShowBackendsStatementContext() {}

func NewShowBackendsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackendsStatementContext {
	var p = new(ShowBackendsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBackendsStatement

	return p
}

func (s *ShowBackendsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackendsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBackendsStatementContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKENDS, 0)
}

func (s *ShowBackendsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackendsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBackendsStatement(s)
	}
}

func (s *ShowBackendsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBackendsStatement(s)
	}
}

func (p *StarRocksParser) ShowBackendsStatement() (localctx IShowBackendsStatementContext) {
	localctx = NewShowBackendsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, StarRocksParserRULE_showBackendsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4407)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4408)
		p.Match(StarRocksParserBACKENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBrokerStatementContext is an interface to support dynamic dispatch.
type IShowBrokerStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BROKER() antlr.TerminalNode

	// IsShowBrokerStatementContext differentiates from other interfaces.
	IsShowBrokerStatementContext()
}

type ShowBrokerStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBrokerStatementContext() *ShowBrokerStatementContext {
	var p = new(ShowBrokerStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBrokerStatement
	return p
}

func InitEmptyShowBrokerStatementContext(p *ShowBrokerStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBrokerStatement
}

func (*ShowBrokerStatementContext) IsShowBrokerStatementContext() {}

func NewShowBrokerStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBrokerStatementContext {
	var p = new(ShowBrokerStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBrokerStatement

	return p
}

func (s *ShowBrokerStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBrokerStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBrokerStatementContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *ShowBrokerStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBrokerStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBrokerStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBrokerStatement(s)
	}
}

func (s *ShowBrokerStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBrokerStatement(s)
	}
}

func (p *StarRocksParser) ShowBrokerStatement() (localctx IShowBrokerStatementContext) {
	localctx = NewShowBrokerStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, StarRocksParserRULE_showBrokerStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4410)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4411)
		p.Match(StarRocksParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCharsetStatementContext is an interface to support dynamic dispatch.
type IShowCharsetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	SET() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CHARACTER() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowCharsetStatementContext differentiates from other interfaces.
	IsShowCharsetStatementContext()
}

type ShowCharsetStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCharsetStatementContext() *ShowCharsetStatementContext {
	var p = new(ShowCharsetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCharsetStatement
	return p
}

func InitEmptyShowCharsetStatementContext(p *ShowCharsetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCharsetStatement
}

func (*ShowCharsetStatementContext) IsShowCharsetStatementContext() {}

func NewShowCharsetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCharsetStatementContext {
	var p = new(ShowCharsetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCharsetStatement

	return p
}

func (s *ShowCharsetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCharsetStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCharsetStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCharsetStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCharsetStatementContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *ShowCharsetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *ShowCharsetStatementContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *ShowCharsetStatementContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARACTER, 0)
}

func (s *ShowCharsetStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowCharsetStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowCharsetStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCharsetStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCharsetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCharsetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCharsetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCharsetStatement(s)
	}
}

func (s *ShowCharsetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCharsetStatement(s)
	}
}

func (p *StarRocksParser) ShowCharsetStatement() (localctx IShowCharsetStatementContext) {
	localctx = NewShowCharsetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, StarRocksParserRULE_showCharsetStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4413)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4419)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCHAR:
		{
			p.SetState(4414)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4415)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCHARSET:
		{
			p.SetState(4416)
			p.Match(StarRocksParserCHARSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCHARACTER:
		{
			p.SetState(4417)
			p.Match(StarRocksParserCHARACTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4418)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(4425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4421)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4422)

			var _x = p.String_()

			localctx.(*ShowCharsetStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4423)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4424)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCollationStatementContext is an interface to support dynamic dispatch.
type IShowCollationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowCollationStatementContext differentiates from other interfaces.
	IsShowCollationStatementContext()
}

type ShowCollationStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowCollationStatementContext() *ShowCollationStatementContext {
	var p = new(ShowCollationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCollationStatement
	return p
}

func InitEmptyShowCollationStatementContext(p *ShowCollationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCollationStatement
}

func (*ShowCollationStatementContext) IsShowCollationStatementContext() {}

func NewShowCollationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCollationStatementContext {
	var p = new(ShowCollationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCollationStatement

	return p
}

func (s *ShowCollationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCollationStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowCollationStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowCollationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCollationStatementContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATION, 0)
}

func (s *ShowCollationStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowCollationStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowCollationStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowCollationStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowCollationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCollationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCollationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCollationStatement(s)
	}
}

func (s *ShowCollationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCollationStatement(s)
	}
}

func (p *StarRocksParser) ShowCollationStatement() (localctx IShowCollationStatementContext) {
	localctx = NewShowCollationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, StarRocksParserRULE_showCollationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4427)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4428)
		p.Match(StarRocksParserCOLLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4433)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4429)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4430)

			var _x = p.String_()

			localctx.(*ShowCollationStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4431)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4432)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDeleteStatementContext is an interface to support dynamic dispatch.
type IShowDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDeleteStatementContext differentiates from other interfaces.
	IsShowDeleteStatementContext()
}

type ShowDeleteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowDeleteStatementContext() *ShowDeleteStatementContext {
	var p = new(ShowDeleteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDeleteStatement
	return p
}

func InitEmptyShowDeleteStatementContext(p *ShowDeleteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDeleteStatement
}

func (*ShowDeleteStatementContext) IsShowDeleteStatementContext() {}

func NewShowDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDeleteStatementContext {
	var p = new(ShowDeleteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDeleteStatement

	return p
}

func (s *ShowDeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDeleteStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowDeleteStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowDeleteStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *ShowDeleteStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDeleteStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowDeleteStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDeleteStatement(s)
	}
}

func (s *ShowDeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDeleteStatement(s)
	}
}

func (p *StarRocksParser) ShowDeleteStatement() (localctx IShowDeleteStatementContext) {
	localctx = NewShowDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, StarRocksParserRULE_showDeleteStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4435)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4436)
		p.Match(StarRocksParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4439)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4437)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4438)

			var _x = p.QualifiedName()

			localctx.(*ShowDeleteStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDynamicPartitionStatementContext is an interface to support dynamic dispatch.
type IShowDynamicPartitionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowDynamicPartitionStatementContext differentiates from other interfaces.
	IsShowDynamicPartitionStatementContext()
}

type ShowDynamicPartitionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowDynamicPartitionStatementContext() *ShowDynamicPartitionStatementContext {
	var p = new(ShowDynamicPartitionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDynamicPartitionStatement
	return p
}

func InitEmptyShowDynamicPartitionStatementContext(p *ShowDynamicPartitionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDynamicPartitionStatement
}

func (*ShowDynamicPartitionStatementContext) IsShowDynamicPartitionStatementContext() {}

func NewShowDynamicPartitionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDynamicPartitionStatementContext {
	var p = new(ShowDynamicPartitionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDynamicPartitionStatement

	return p
}

func (s *ShowDynamicPartitionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDynamicPartitionStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowDynamicPartitionStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowDynamicPartitionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDynamicPartitionStatementContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDYNAMIC, 0)
}

func (s *ShowDynamicPartitionStatementContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *ShowDynamicPartitionStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *ShowDynamicPartitionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowDynamicPartitionStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowDynamicPartitionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowDynamicPartitionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDynamicPartitionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDynamicPartitionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDynamicPartitionStatement(s)
	}
}

func (s *ShowDynamicPartitionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDynamicPartitionStatement(s)
	}
}

func (p *StarRocksParser) ShowDynamicPartitionStatement() (localctx IShowDynamicPartitionStatementContext) {
	localctx = NewShowDynamicPartitionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, StarRocksParserRULE_showDynamicPartitionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4441)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4442)
		p.Match(StarRocksParserDYNAMIC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4443)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4444)
		p.Match(StarRocksParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4445)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4446)

			var _x = p.QualifiedName()

			localctx.(*ShowDynamicPartitionStatementContext).db = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowEventsStatementContext is an interface to support dynamic dispatch.
type IShowEventsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowEventsStatementContext differentiates from other interfaces.
	IsShowEventsStatementContext()
}

type ShowEventsStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowEventsStatementContext() *ShowEventsStatementContext {
	var p = new(ShowEventsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showEventsStatement
	return p
}

func InitEmptyShowEventsStatementContext(p *ShowEventsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showEventsStatement
}

func (*ShowEventsStatementContext) IsShowEventsStatementContext() {}

func NewShowEventsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowEventsStatementContext {
	var p = new(ShowEventsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showEventsStatement

	return p
}

func (s *ShowEventsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowEventsStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowEventsStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowEventsStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowEventsStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowEventsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowEventsStatementContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVENTS, 0)
}

func (s *ShowEventsStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowEventsStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowEventsStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowEventsStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowEventsStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowEventsStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowEventsStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowEventsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEventsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowEventsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowEventsStatement(s)
	}
}

func (s *ShowEventsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowEventsStatement(s)
	}
}

func (p *StarRocksParser) ShowEventsStatement() (localctx IShowEventsStatementContext) {
	localctx = NewShowEventsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, StarRocksParserRULE_showEventsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4449)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4450)
		p.Match(StarRocksParserEVENTS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4451)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4452)

			var _x = p.QualifiedName()

			localctx.(*ShowEventsStatementContext).catalog = _x
		}

	}
	p.SetState(4459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4455)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4456)

			var _x = p.String_()

			localctx.(*ShowEventsStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4457)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4458)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowEnginesStatementContext is an interface to support dynamic dispatch.
type IShowEnginesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ENGINES() antlr.TerminalNode

	// IsShowEnginesStatementContext differentiates from other interfaces.
	IsShowEnginesStatementContext()
}

type ShowEnginesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowEnginesStatementContext() *ShowEnginesStatementContext {
	var p = new(ShowEnginesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showEnginesStatement
	return p
}

func InitEmptyShowEnginesStatementContext(p *ShowEnginesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showEnginesStatement
}

func (*ShowEnginesStatementContext) IsShowEnginesStatementContext() {}

func NewShowEnginesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowEnginesStatementContext {
	var p = new(ShowEnginesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showEnginesStatement

	return p
}

func (s *ShowEnginesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowEnginesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowEnginesStatementContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENGINES, 0)
}

func (s *ShowEnginesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowEnginesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowEnginesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowEnginesStatement(s)
	}
}

func (s *ShowEnginesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowEnginesStatement(s)
	}
}

func (p *StarRocksParser) ShowEnginesStatement() (localctx IShowEnginesStatementContext) {
	localctx = NewShowEnginesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, StarRocksParserRULE_showEnginesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4461)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4462)
		p.Match(StarRocksParserENGINES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowFrontendsStatementContext is an interface to support dynamic dispatch.
type IShowFrontendsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode

	// IsShowFrontendsStatementContext differentiates from other interfaces.
	IsShowFrontendsStatementContext()
}

type ShowFrontendsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowFrontendsStatementContext() *ShowFrontendsStatementContext {
	var p = new(ShowFrontendsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFrontendsStatement
	return p
}

func InitEmptyShowFrontendsStatementContext(p *ShowFrontendsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showFrontendsStatement
}

func (*ShowFrontendsStatementContext) IsShowFrontendsStatementContext() {}

func NewShowFrontendsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowFrontendsStatementContext {
	var p = new(ShowFrontendsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showFrontendsStatement

	return p
}

func (s *ShowFrontendsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowFrontendsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowFrontendsStatementContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTENDS, 0)
}

func (s *ShowFrontendsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowFrontendsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowFrontendsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowFrontendsStatement(s)
	}
}

func (s *ShowFrontendsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowFrontendsStatement(s)
	}
}

func (p *StarRocksParser) ShowFrontendsStatement() (localctx IShowFrontendsStatementContext) {
	localctx = NewShowFrontendsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, StarRocksParserRULE_showFrontendsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4464)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4465)
		p.Match(StarRocksParserFRONTENDS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPluginsStatementContext is an interface to support dynamic dispatch.
type IShowPluginsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode

	// IsShowPluginsStatementContext differentiates from other interfaces.
	IsShowPluginsStatementContext()
}

type ShowPluginsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPluginsStatementContext() *ShowPluginsStatementContext {
	var p = new(ShowPluginsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPluginsStatement
	return p
}

func InitEmptyShowPluginsStatementContext(p *ShowPluginsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPluginsStatement
}

func (*ShowPluginsStatementContext) IsShowPluginsStatementContext() {}

func NewShowPluginsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPluginsStatementContext {
	var p = new(ShowPluginsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPluginsStatement

	return p
}

func (s *ShowPluginsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPluginsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPluginsStatementContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGINS, 0)
}

func (s *ShowPluginsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPluginsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPluginsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPluginsStatement(s)
	}
}

func (s *ShowPluginsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPluginsStatement(s)
	}
}

func (p *StarRocksParser) ShowPluginsStatement() (localctx IShowPluginsStatementContext) {
	localctx = NewShowPluginsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, StarRocksParserRULE_showPluginsStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4467)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4468)
		p.Match(StarRocksParserPLUGINS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRepositoriesStatementContext is an interface to support dynamic dispatch.
type IShowRepositoriesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode

	// IsShowRepositoriesStatementContext differentiates from other interfaces.
	IsShowRepositoriesStatementContext()
}

type ShowRepositoriesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRepositoriesStatementContext() *ShowRepositoriesStatementContext {
	var p = new(ShowRepositoriesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRepositoriesStatement
	return p
}

func InitEmptyShowRepositoriesStatementContext(p *ShowRepositoriesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRepositoriesStatement
}

func (*ShowRepositoriesStatementContext) IsShowRepositoriesStatementContext() {}

func NewShowRepositoriesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRepositoriesStatementContext {
	var p = new(ShowRepositoriesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRepositoriesStatement

	return p
}

func (s *ShowRepositoriesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRepositoriesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRepositoriesStatementContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORIES, 0)
}

func (s *ShowRepositoriesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRepositoriesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRepositoriesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRepositoriesStatement(s)
	}
}

func (s *ShowRepositoriesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRepositoriesStatement(s)
	}
}

func (p *StarRocksParser) ShowRepositoriesStatement() (localctx IShowRepositoriesStatementContext) {
	localctx = NewShowRepositoriesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, StarRocksParserRULE_showRepositoriesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4470)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4471)
		p.Match(StarRocksParserREPOSITORIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowOpenTableStatementContext is an interface to support dynamic dispatch.
type IShowOpenTableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	TABLES() antlr.TerminalNode

	// IsShowOpenTableStatementContext differentiates from other interfaces.
	IsShowOpenTableStatementContext()
}

type ShowOpenTableStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowOpenTableStatementContext() *ShowOpenTableStatementContext {
	var p = new(ShowOpenTableStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showOpenTableStatement
	return p
}

func InitEmptyShowOpenTableStatementContext(p *ShowOpenTableStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showOpenTableStatement
}

func (*ShowOpenTableStatementContext) IsShowOpenTableStatementContext() {}

func NewShowOpenTableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowOpenTableStatementContext {
	var p = new(ShowOpenTableStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showOpenTableStatement

	return p
}

func (s *ShowOpenTableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowOpenTableStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowOpenTableStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPEN, 0)
}

func (s *ShowOpenTableStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *ShowOpenTableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowOpenTableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowOpenTableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowOpenTableStatement(s)
	}
}

func (s *ShowOpenTableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowOpenTableStatement(s)
	}
}

func (p *StarRocksParser) ShowOpenTableStatement() (localctx IShowOpenTableStatementContext) {
	localctx = NewShowOpenTableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, StarRocksParserRULE_showOpenTableStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4473)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4474)
		p.Match(StarRocksParserOPEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4475)
		p.Match(StarRocksParserTABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPrivilegesStatementContext is an interface to support dynamic dispatch.
type IShowPrivilegesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode

	// IsShowPrivilegesStatementContext differentiates from other interfaces.
	IsShowPrivilegesStatementContext()
}

type ShowPrivilegesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPrivilegesStatementContext() *ShowPrivilegesStatementContext {
	var p = new(ShowPrivilegesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPrivilegesStatement
	return p
}

func InitEmptyShowPrivilegesStatementContext(p *ShowPrivilegesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPrivilegesStatement
}

func (*ShowPrivilegesStatementContext) IsShowPrivilegesStatementContext() {}

func NewShowPrivilegesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPrivilegesStatementContext {
	var p = new(ShowPrivilegesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPrivilegesStatement

	return p
}

func (s *ShowPrivilegesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPrivilegesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPrivilegesStatementContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIVILEGES, 0)
}

func (s *ShowPrivilegesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPrivilegesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPrivilegesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPrivilegesStatement(s)
	}
}

func (s *ShowPrivilegesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPrivilegesStatement(s)
	}
}

func (p *StarRocksParser) ShowPrivilegesStatement() (localctx IShowPrivilegesStatementContext) {
	localctx = NewShowPrivilegesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, StarRocksParserRULE_showPrivilegesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4477)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4478)
		p.Match(StarRocksParserPRIVILEGES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcedureStatementContext is an interface to support dynamic dispatch.
type IShowProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	PROCEDURE() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	String_() IStringContext
	Expression() IExpressionContext

	// IsShowProcedureStatementContext differentiates from other interfaces.
	IsShowProcedureStatementContext()
}

type ShowProcedureStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
	where   IExpressionContext
}

func NewEmptyShowProcedureStatementContext() *ShowProcedureStatementContext {
	var p = new(ShowProcedureStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcedureStatement
	return p
}

func InitEmptyShowProcedureStatementContext(p *ShowProcedureStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcedureStatement
}

func (*ShowProcedureStatementContext) IsShowProcedureStatementContext() {}

func NewShowProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcedureStatementContext {
	var p = new(ShowProcedureStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showProcedureStatement

	return p
}

func (s *ShowProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcedureStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowProcedureStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *ShowProcedureStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowProcedureStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *ShowProcedureStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowProcedureStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *ShowProcedureStatementContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROCEDURE, 0)
}

func (s *ShowProcedureStatementContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *ShowProcedureStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowProcedureStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowProcedureStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcedureStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowProcedureStatement(s)
	}
}

func (s *ShowProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowProcedureStatement(s)
	}
}

func (p *StarRocksParser) ShowProcedureStatement() (localctx IShowProcedureStatementContext) {
	localctx = NewShowProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, StarRocksParserRULE_showProcedureStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4480)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4481)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFUNCTION || _la == StarRocksParserPROCEDURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4482)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4487)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4483)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4484)

			var _x = p.String_()

			localctx.(*ShowProcedureStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4485)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4486)

			var _x = p.expression(0)

			localctx.(*ShowProcedureStatementContext).where = _x
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcStatementContext is an interface to support dynamic dispatch.
type IShowProcStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPath returns the path rule contexts.
	GetPath() IStringContext

	// SetPath sets the path rule contexts.
	SetPath(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROC() antlr.TerminalNode
	String_() IStringContext

	// IsShowProcStatementContext differentiates from other interfaces.
	IsShowProcStatementContext()
}

type ShowProcStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	path   IStringContext
}

func NewEmptyShowProcStatementContext() *ShowProcStatementContext {
	var p = new(ShowProcStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcStatement
	return p
}

func InitEmptyShowProcStatementContext(p *ShowProcStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcStatement
}

func (*ShowProcStatementContext) IsShowProcStatementContext() {}

func NewShowProcStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcStatementContext {
	var p = new(ShowProcStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showProcStatement

	return p
}

func (s *ShowProcStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcStatementContext) GetPath() IStringContext { return s.path }

func (s *ShowProcStatementContext) SetPath(v IStringContext) { s.path = v }

func (s *ShowProcStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowProcStatementContext) PROC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROC, 0)
}

func (s *ShowProcStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowProcStatement(s)
	}
}

func (s *ShowProcStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowProcStatement(s)
	}
}

func (p *StarRocksParser) ShowProcStatement() (localctx IShowProcStatementContext) {
	localctx = NewShowProcStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, StarRocksParserRULE_showProcStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4489)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4490)
		p.Match(StarRocksParserPROC)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4491)

		var _x = p.String_()

		localctx.(*ShowProcStatementContext).path = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProcesslistStatementContext is an interface to support dynamic dispatch.
type IShowProcesslistStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FOR() antlr.TerminalNode
	String_() IStringContext

	// IsShowProcesslistStatementContext differentiates from other interfaces.
	IsShowProcesslistStatementContext()
}

type ShowProcesslistStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowProcesslistStatementContext() *ShowProcesslistStatementContext {
	var p = new(ShowProcesslistStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcesslistStatement
	return p
}

func InitEmptyShowProcesslistStatementContext(p *ShowProcesslistStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProcesslistStatement
}

func (*ShowProcesslistStatementContext) IsShowProcesslistStatementContext() {}

func NewShowProcesslistStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProcesslistStatementContext {
	var p = new(ShowProcesslistStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showProcesslistStatement

	return p
}

func (s *ShowProcesslistStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProcesslistStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowProcesslistStatementContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROCESSLIST, 0)
}

func (s *ShowProcesslistStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowProcesslistStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowProcesslistStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowProcesslistStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProcesslistStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProcesslistStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowProcesslistStatement(s)
	}
}

func (s *ShowProcesslistStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowProcesslistStatement(s)
	}
}

func (p *StarRocksParser) ShowProcesslistStatement() (localctx IShowProcesslistStatementContext) {
	localctx = NewShowProcesslistStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, StarRocksParserRULE_showProcesslistStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4493)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(4494)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4497)
		p.Match(StarRocksParserPROCESSLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4500)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(4498)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4499)
			p.String_()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowProfilelistStatementContext is an interface to support dynamic dispatch.
type IShowProfilelistStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROFILELIST() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsShowProfilelistStatementContext differentiates from other interfaces.
	IsShowProfilelistStatementContext()
}

type ShowProfilelistStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyShowProfilelistStatementContext() *ShowProfilelistStatementContext {
	var p = new(ShowProfilelistStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProfilelistStatement
	return p
}

func InitEmptyShowProfilelistStatementContext(p *ShowProfilelistStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showProfilelistStatement
}

func (*ShowProfilelistStatementContext) IsShowProfilelistStatementContext() {}

func NewShowProfilelistStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowProfilelistStatementContext {
	var p = new(ShowProfilelistStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showProfilelistStatement

	return p
}

func (s *ShowProfilelistStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowProfilelistStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *ShowProfilelistStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *ShowProfilelistStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowProfilelistStatementContext) PROFILELIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROFILELIST, 0)
}

func (s *ShowProfilelistStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIMIT, 0)
}

func (s *ShowProfilelistStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *ShowProfilelistStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowProfilelistStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowProfilelistStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowProfilelistStatement(s)
	}
}

func (s *ShowProfilelistStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowProfilelistStatement(s)
	}
}

func (p *StarRocksParser) ShowProfilelistStatement() (localctx IShowProfilelistStatementContext) {
	localctx = NewShowProfilelistStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, StarRocksParserRULE_showProfilelistStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4502)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4503)
		p.Match(StarRocksParserPROFILELIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4506)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(4504)
			p.Match(StarRocksParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4505)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*ShowProfilelistStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRunningQueriesStatementContext is an interface to support dynamic dispatch.
type IShowRunningQueriesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// Getter signatures
	SHOW() antlr.TerminalNode
	RUNNING() antlr.TerminalNode
	QUERIES() antlr.TerminalNode
	LIMIT() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsShowRunningQueriesStatementContext differentiates from other interfaces.
	IsShowRunningQueriesStatementContext()
}

type ShowRunningQueriesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  antlr.Token
}

func NewEmptyShowRunningQueriesStatementContext() *ShowRunningQueriesStatementContext {
	var p = new(ShowRunningQueriesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRunningQueriesStatement
	return p
}

func InitEmptyShowRunningQueriesStatementContext(p *ShowRunningQueriesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRunningQueriesStatement
}

func (*ShowRunningQueriesStatementContext) IsShowRunningQueriesStatementContext() {}

func NewShowRunningQueriesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRunningQueriesStatementContext {
	var p = new(ShowRunningQueriesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRunningQueriesStatement

	return p
}

func (s *ShowRunningQueriesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRunningQueriesStatementContext) GetLimit() antlr.Token { return s.limit }

func (s *ShowRunningQueriesStatementContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *ShowRunningQueriesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRunningQueriesStatementContext) RUNNING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRUNNING, 0)
}

func (s *ShowRunningQueriesStatementContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUERIES, 0)
}

func (s *ShowRunningQueriesStatementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIMIT, 0)
}

func (s *ShowRunningQueriesStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *ShowRunningQueriesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRunningQueriesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRunningQueriesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRunningQueriesStatement(s)
	}
}

func (s *ShowRunningQueriesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRunningQueriesStatement(s)
	}
}

func (p *StarRocksParser) ShowRunningQueriesStatement() (localctx IShowRunningQueriesStatementContext) {
	localctx = NewShowRunningQueriesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, StarRocksParserRULE_showRunningQueriesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4508)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4509)
		p.Match(StarRocksParserRUNNING)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4510)
		p.Match(StarRocksParserQUERIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4513)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(4511)
			p.Match(StarRocksParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4512)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*ShowRunningQueriesStatementContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatusStatementContext is an interface to support dynamic dispatch.
type IShowStatusStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	VarType() IVarTypeContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowStatusStatementContext differentiates from other interfaces.
	IsShowStatusStatementContext()
}

type ShowStatusStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowStatusStatementContext() *ShowStatusStatementContext {
	var p = new(ShowStatusStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStatusStatement
	return p
}

func InitEmptyShowStatusStatementContext(p *ShowStatusStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showStatusStatement
}

func (*ShowStatusStatementContext) IsShowStatusStatementContext() {}

func NewShowStatusStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatusStatementContext {
	var p = new(ShowStatusStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showStatusStatement

	return p
}

func (s *ShowStatusStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatusStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowStatusStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowStatusStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowStatusStatementContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *ShowStatusStatementContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ShowStatusStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowStatusStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowStatusStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowStatusStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowStatusStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatusStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatusStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowStatusStatement(s)
	}
}

func (s *ShowStatusStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowStatusStatement(s)
	}
}

func (p *StarRocksParser) ShowStatusStatement() (localctx IShowStatusStatementContext) {
	localctx = NewShowStatusStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, StarRocksParserRULE_showStatusStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4515)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4517)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL || _la == StarRocksParserLOCAL || _la == StarRocksParserSESSION || _la == StarRocksParserVERBOSE {
		{
			p.SetState(4516)
			p.VarType()
		}

	}
	{
		p.SetState(4519)
		p.Match(StarRocksParserSTATUS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4520)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4521)

			var _x = p.String_()

			localctx.(*ShowStatusStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4522)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4523)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTabletStatementContext is an interface to support dynamic dispatch.
type IShowTabletStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TABLETS() antlr.TerminalNode
	PartitionNames() IPartitionNamesContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsShowTabletStatementContext differentiates from other interfaces.
	IsShowTabletStatementContext()
}

type ShowTabletStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowTabletStatementContext() *ShowTabletStatementContext {
	var p = new(ShowTabletStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTabletStatement
	return p
}

func InitEmptyShowTabletStatementContext(p *ShowTabletStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTabletStatement
}

func (*ShowTabletStatementContext) IsShowTabletStatementContext() {}

func NewShowTabletStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTabletStatementContext {
	var p = new(ShowTabletStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTabletStatement

	return p
}

func (s *ShowTabletStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTabletStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTabletStatementContext) TABLET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLET, 0)
}

func (s *ShowTabletStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *ShowTabletStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTabletStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTabletStatementContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLETS, 0)
}

func (s *ShowTabletStatementContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *ShowTabletStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTabletStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTabletStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowTabletStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowTabletStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowTabletStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowTabletStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowTabletStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTabletStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTabletStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTabletStatement(s)
	}
}

func (s *ShowTabletStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTabletStatement(s)
	}
}

func (p *StarRocksParser) ShowTabletStatement() (localctx IShowTabletStatementContext) {
	localctx = NewShowTabletStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, StarRocksParserRULE_showTabletStatement)
	var _la int

	p.SetState(4555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 483, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4526)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4527)
			p.Match(StarRocksParserTABLET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4528)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4529)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4530)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserTABLET || _la == StarRocksParserTABLETS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4531)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4532)
			p.QualifiedName()
		}
		p.SetState(4534)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
			{
				p.SetState(4533)
				p.PartitionNames()
			}

		}
		p.SetState(4538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWHERE {
			{
				p.SetState(4536)
				p.Match(StarRocksParserWHERE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4537)
				p.expression(0)
			}

		}
		p.SetState(4550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(4540)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4541)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4542)
				p.SortItem()
			}
			p.SetState(4547)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(4543)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(4544)
					p.SortItem()
				}

				p.SetState(4549)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(4553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIMIT {
			{
				p.SetState(4552)
				p.LimitElement()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTransactionStatementContext is an interface to support dynamic dispatch.
type IShowTransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDb returns the db rule contexts.
	GetDb() IQualifiedNameContext

	// SetDb sets the db rule contexts.
	SetDb(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowTransactionStatementContext differentiates from other interfaces.
	IsShowTransactionStatementContext()
}

type ShowTransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	db     IQualifiedNameContext
}

func NewEmptyShowTransactionStatementContext() *ShowTransactionStatementContext {
	var p = new(ShowTransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTransactionStatement
	return p
}

func InitEmptyShowTransactionStatementContext(p *ShowTransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTransactionStatement
}

func (*ShowTransactionStatementContext) IsShowTransactionStatementContext() {}

func NewShowTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTransactionStatementContext {
	var p = new(ShowTransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTransactionStatement

	return p
}

func (s *ShowTransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTransactionStatementContext) GetDb() IQualifiedNameContext { return s.db }

func (s *ShowTransactionStatementContext) SetDb(v IQualifiedNameContext) { s.db = v }

func (s *ShowTransactionStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTransactionStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSACTION, 0)
}

func (s *ShowTransactionStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTransactionStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTransactionStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTransactionStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTransactionStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTransactionStatement(s)
	}
}

func (s *ShowTransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTransactionStatement(s)
	}
}

func (p *StarRocksParser) ShowTransactionStatement() (localctx IShowTransactionStatementContext) {
	localctx = NewShowTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, StarRocksParserRULE_showTransactionStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4557)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4558)
		p.Match(StarRocksParserTRANSACTION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4559)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4560)

			var _x = p.QualifiedName()

			localctx.(*ShowTransactionStatementContext).db = _x
		}

	}
	p.SetState(4565)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(4563)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4564)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowTriggersStatementContext is an interface to support dynamic dispatch.
type IShowTriggersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	FULL() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowTriggersStatementContext differentiates from other interfaces.
	IsShowTriggersStatementContext()
}

type ShowTriggersStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowTriggersStatementContext() *ShowTriggersStatementContext {
	var p = new(ShowTriggersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTriggersStatement
	return p
}

func InitEmptyShowTriggersStatementContext(p *ShowTriggersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showTriggersStatement
}

func (*ShowTriggersStatementContext) IsShowTriggersStatementContext() {}

func NewShowTriggersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowTriggersStatementContext {
	var p = new(ShowTriggersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showTriggersStatement

	return p
}

func (s *ShowTriggersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowTriggersStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowTriggersStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowTriggersStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowTriggersStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowTriggersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowTriggersStatementContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRIGGERS, 0)
}

func (s *ShowTriggersStatementContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *ShowTriggersStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowTriggersStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowTriggersStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowTriggersStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowTriggersStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowTriggersStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowTriggersStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowTriggersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowTriggersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowTriggersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowTriggersStatement(s)
	}
}

func (s *ShowTriggersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowTriggersStatement(s)
	}
}

func (p *StarRocksParser) ShowTriggersStatement() (localctx IShowTriggersStatementContext) {
	localctx = NewShowTriggersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, StarRocksParserRULE_showTriggersStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4567)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4569)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFULL {
		{
			p.SetState(4568)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4571)
		p.Match(StarRocksParserTRIGGERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4574)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(4572)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4573)

			var _x = p.QualifiedName()

			localctx.(*ShowTriggersStatementContext).catalog = _x
		}

	}
	p.SetState(4580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4576)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4577)

			var _x = p.String_()

			localctx.(*ShowTriggersStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4578)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4579)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowUserPropertyStatementContext is an interface to support dynamic dispatch.
type IShowUserPropertyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	FOR() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	LIKE() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode

	// IsShowUserPropertyStatementContext differentiates from other interfaces.
	IsShowUserPropertyStatementContext()
}

type ShowUserPropertyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowUserPropertyStatementContext() *ShowUserPropertyStatementContext {
	var p = new(ShowUserPropertyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showUserPropertyStatement
	return p
}

func InitEmptyShowUserPropertyStatementContext(p *ShowUserPropertyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showUserPropertyStatement
}

func (*ShowUserPropertyStatementContext) IsShowUserPropertyStatementContext() {}

func NewShowUserPropertyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowUserPropertyStatementContext {
	var p = new(ShowUserPropertyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showUserPropertyStatement

	return p
}

func (s *ShowUserPropertyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowUserPropertyStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowUserPropertyStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTY, 0)
}

func (s *ShowUserPropertyStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowUserPropertyStatementContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *ShowUserPropertyStatementContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowUserPropertyStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowUserPropertyStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *ShowUserPropertyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserPropertyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowUserPropertyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowUserPropertyStatement(s)
	}
}

func (s *ShowUserPropertyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowUserPropertyStatement(s)
	}
}

func (p *StarRocksParser) ShowUserPropertyStatement() (localctx IShowUserPropertyStatementContext) {
	localctx = NewShowUserPropertyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, StarRocksParserRULE_showUserPropertyStatement)
	var _la int

	p.SetState(4602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 493, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4582)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4583)
			p.Match(StarRocksParserPROPERTY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(4584)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4585)
				p.String_()
			}

		}
		p.SetState(4590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIKE {
			{
				p.SetState(4588)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4589)
				p.String_()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4592)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4593)
			p.Match(StarRocksParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4596)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(4594)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4595)
				p.String_()
			}

		}
		p.SetState(4600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIKE {
			{
				p.SetState(4598)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4599)
				p.String_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowVariablesStatementContext is an interface to support dynamic dispatch.
type IShowVariablesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VarType() IVarTypeContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowVariablesStatementContext differentiates from other interfaces.
	IsShowVariablesStatementContext()
}

type ShowVariablesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowVariablesStatementContext() *ShowVariablesStatementContext {
	var p = new(ShowVariablesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showVariablesStatement
	return p
}

func InitEmptyShowVariablesStatementContext(p *ShowVariablesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showVariablesStatement
}

func (*ShowVariablesStatementContext) IsShowVariablesStatementContext() {}

func NewShowVariablesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowVariablesStatementContext {
	var p = new(ShowVariablesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showVariablesStatement

	return p
}

func (s *ShowVariablesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowVariablesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowVariablesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowVariablesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowVariablesStatementContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARIABLES, 0)
}

func (s *ShowVariablesStatementContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *ShowVariablesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowVariablesStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowVariablesStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowVariablesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowVariablesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowVariablesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowVariablesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowVariablesStatement(s)
	}
}

func (s *ShowVariablesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowVariablesStatement(s)
	}
}

func (p *StarRocksParser) ShowVariablesStatement() (localctx IShowVariablesStatementContext) {
	localctx = NewShowVariablesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, StarRocksParserRULE_showVariablesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4604)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4606)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserGLOBAL || _la == StarRocksParserLOCAL || _la == StarRocksParserSESSION || _la == StarRocksParserVERBOSE {
		{
			p.SetState(4605)
			p.VarType()
		}

	}
	{
		p.SetState(4608)
		p.Match(StarRocksParserVARIABLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(4609)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4610)

			var _x = p.String_()

			localctx.(*ShowVariablesStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(4611)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4612)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWarningStatementContext is an interface to support dynamic dispatch.
type IShowWarningStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	LimitElement() ILimitElementContext

	// IsShowWarningStatementContext differentiates from other interfaces.
	IsShowWarningStatementContext()
}

type ShowWarningStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowWarningStatementContext() *ShowWarningStatementContext {
	var p = new(ShowWarningStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWarningStatement
	return p
}

func InitEmptyShowWarningStatementContext(p *ShowWarningStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWarningStatement
}

func (*ShowWarningStatementContext) IsShowWarningStatementContext() {}

func NewShowWarningStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWarningStatementContext {
	var p = new(ShowWarningStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showWarningStatement

	return p
}

func (s *ShowWarningStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWarningStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowWarningStatementContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWARNINGS, 0)
}

func (s *ShowWarningStatementContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserERRORS, 0)
}

func (s *ShowWarningStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowWarningStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarningStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWarningStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowWarningStatement(s)
	}
}

func (s *ShowWarningStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowWarningStatement(s)
	}
}

func (p *StarRocksParser) ShowWarningStatement() (localctx IShowWarningStatementContext) {
	localctx = NewShowWarningStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, StarRocksParserRULE_showWarningStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4615)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4616)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserERRORS || _la == StarRocksParserWARNINGS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4618)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(4617)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHelpStatementContext is an interface to support dynamic dispatch.
type IHelpStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HELP() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsHelpStatementContext differentiates from other interfaces.
	IsHelpStatementContext()
}

type HelpStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHelpStatementContext() *HelpStatementContext {
	var p = new(HelpStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_helpStatement
	return p
}

func InitEmptyHelpStatementContext(p *HelpStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_helpStatement
}

func (*HelpStatementContext) IsHelpStatementContext() {}

func NewHelpStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HelpStatementContext {
	var p = new(HelpStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_helpStatement

	return p
}

func (s *HelpStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *HelpStatementContext) HELP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHELP, 0)
}

func (s *HelpStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *HelpStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HelpStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HelpStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterHelpStatement(s)
	}
}

func (s *HelpStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitHelpStatement(s)
	}
}

func (p *StarRocksParser) HelpStatement() (localctx IHelpStatementContext) {
	localctx = NewHelpStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, StarRocksParserRULE_helpStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4620)
		p.Match(StarRocksParserHELP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4621)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserStatementContext is an interface to support dynamic dispatch.
type ICreateUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	AuthOption() IAuthOptionContext
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	Properties() IPropertiesContext

	// IsCreateUserStatementContext differentiates from other interfaces.
	IsCreateUserStatementContext()
}

type CreateUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserStatementContext() *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createUserStatement
	return p
}

func InitEmptyCreateUserStatementContext(p *CreateUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createUserStatement
}

func (*CreateUserStatementContext) IsCreateUserStatementContext() {}

func NewCreateUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserStatementContext {
	var p = new(CreateUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createUserStatement

	return p
}

func (s *CreateUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *CreateUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CreateUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateUserStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateUserStatementContext) AuthOption() IAuthOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionContext)
}

func (s *CreateUserStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *CreateUserStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *CreateUserStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *CreateUserStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateUserStatement(s)
	}
}

func (s *CreateUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateUserStatement(s)
	}
}

func (p *StarRocksParser) CreateUserStatement() (localctx ICreateUserStatementContext) {
	localctx = NewCreateUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, StarRocksParserRULE_createUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4623)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4624)
		p.Match(StarRocksParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4628)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4625)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4626)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4627)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4630)
		p.User()
	}
	p.SetState(4632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIDENTIFIED {
		{
			p.SetState(4631)
			p.AuthOption()
		}

	}
	p.SetState(4637)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDEFAULT {
		{
			p.SetState(4634)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4635)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4636)
			p.RoleList()
		}

	}
	p.SetState(4640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(4639)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserStatementContext is an interface to support dynamic dispatch.
type IDropUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropUserStatementContext differentiates from other interfaces.
	IsDropUserStatementContext()
}

type DropUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserStatementContext() *DropUserStatementContext {
	var p = new(DropUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropUserStatement
	return p
}

func InitEmptyDropUserStatementContext(p *DropUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropUserStatement
}

func (*DropUserStatementContext) IsDropUserStatementContext() {}

func NewDropUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserStatementContext {
	var p = new(DropUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropUserStatement

	return p
}

func (s *DropUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *DropUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DropUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropUserStatement(s)
	}
}

func (s *DropUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropUserStatement(s)
	}
}

func (p *StarRocksParser) DropUserStatement() (localctx IDropUserStatementContext) {
	localctx = NewDropUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, StarRocksParserRULE_dropUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4642)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4643)
		p.Match(StarRocksParserUSER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4646)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4644)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4645)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4648)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserStatementContext is an interface to support dynamic dispatch.
type IAlterUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	USER() antlr.TerminalNode
	User() IUserContext
	AuthOption() IAuthOptionContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RoleList() IRoleListContext
	SET() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsAlterUserStatementContext differentiates from other interfaces.
	IsAlterUserStatementContext()
}

type AlterUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserStatementContext() *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterUserStatement
	return p
}

func InitEmptyAlterUserStatementContext(p *AlterUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterUserStatement
}

func (*AlterUserStatementContext) IsAlterUserStatementContext() {}

func NewAlterUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserStatementContext {
	var p = new(AlterUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterUserStatement

	return p
}

func (s *AlterUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *AlterUserStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserStatementContext) AuthOption() IAuthOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthOptionContext)
}

func (s *AlterUserStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *AlterUserStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *AlterUserStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *AlterUserStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *AlterUserStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *AlterUserStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *AlterUserStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterUserStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterUserStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *AlterUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterUserStatement(s)
	}
}

func (s *AlterUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterUserStatement(s)
	}
}

func (p *StarRocksParser) AlterUserStatement() (localctx IAlterUserStatementContext) {
	localctx = NewAlterUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, StarRocksParserRULE_alterUserStatement)
	var _la int

	p.SetState(4683)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 506, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4650)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4651)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(4652)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4653)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4656)
			p.User()
		}
		{
			p.SetState(4657)
			p.AuthOption()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4659)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4660)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4663)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(4661)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4662)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4665)
			p.User()
		}
		{
			p.SetState(4666)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4667)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4671)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 504, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4668)
				p.Match(StarRocksParserNONE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(4669)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(4670)
				p.RoleList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4673)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4674)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4677)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIF {
			{
				p.SetState(4675)
				p.Match(StarRocksParserIF)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4676)
				p.Match(StarRocksParserEXISTS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4679)
			p.User()
		}
		{
			p.SetState(4680)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4681)
			p.Properties()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowUserStatementContext is an interface to support dynamic dispatch.
type IShowUserStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	USER() antlr.TerminalNode
	USERS() antlr.TerminalNode

	// IsShowUserStatementContext differentiates from other interfaces.
	IsShowUserStatementContext()
}

type ShowUserStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowUserStatementContext() *ShowUserStatementContext {
	var p = new(ShowUserStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showUserStatement
	return p
}

func InitEmptyShowUserStatementContext(p *ShowUserStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showUserStatement
}

func (*ShowUserStatementContext) IsShowUserStatementContext() {}

func NewShowUserStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowUserStatementContext {
	var p = new(ShowUserStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showUserStatement

	return p
}

func (s *ShowUserStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowUserStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowUserStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *ShowUserStatementContext) USERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSERS, 0)
}

func (s *ShowUserStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowUserStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowUserStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowUserStatement(s)
	}
}

func (s *ShowUserStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowUserStatement(s)
	}
}

func (p *StarRocksParser) ShowUserStatement() (localctx IShowUserStatementContext) {
	localctx = NewShowUserStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, StarRocksParserRULE_showUserStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4685)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4686)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserUSER || _la == StarRocksParserUSERS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowAuthenticationStatementContext is an interface to support dynamic dispatch.
type IShowAuthenticationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsShowAuthenticationStatementContext differentiates from other interfaces.
	IsShowAuthenticationStatementContext()
}

type ShowAuthenticationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowAuthenticationStatementContext() *ShowAuthenticationStatementContext {
	var p = new(ShowAuthenticationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAuthenticationStatement
	return p
}

func InitEmptyShowAuthenticationStatementContext(p *ShowAuthenticationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showAuthenticationStatement
}

func (*ShowAuthenticationStatementContext) IsShowAuthenticationStatementContext() {}

func NewShowAuthenticationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowAuthenticationStatementContext {
	var p = new(ShowAuthenticationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showAuthenticationStatement

	return p
}

func (s *ShowAuthenticationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowAuthenticationStatementContext) CopyAll(ctx *ShowAuthenticationStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ShowAuthenticationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthenticationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ShowAllAuthenticationContext struct {
	ShowAuthenticationStatementContext
}

func NewShowAllAuthenticationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAllAuthenticationContext {
	var p = new(ShowAllAuthenticationContext)

	InitEmptyShowAuthenticationStatementContext(&p.ShowAuthenticationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowAuthenticationStatementContext))

	return p
}

func (s *ShowAllAuthenticationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAllAuthenticationContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAllAuthenticationContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *ShowAllAuthenticationContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHENTICATION, 0)
}

func (s *ShowAllAuthenticationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAllAuthentication(s)
	}
}

func (s *ShowAllAuthenticationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAllAuthentication(s)
	}
}

type ShowAuthenticationForUserContext struct {
	ShowAuthenticationStatementContext
}

func NewShowAuthenticationForUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ShowAuthenticationForUserContext {
	var p = new(ShowAuthenticationForUserContext)

	InitEmptyShowAuthenticationStatementContext(&p.ShowAuthenticationStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*ShowAuthenticationStatementContext))

	return p
}

func (s *ShowAuthenticationForUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowAuthenticationForUserContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowAuthenticationForUserContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHENTICATION, 0)
}

func (s *ShowAuthenticationForUserContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowAuthenticationForUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowAuthenticationForUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowAuthenticationForUser(s)
	}
}

func (s *ShowAuthenticationForUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowAuthenticationForUser(s)
	}
}

func (p *StarRocksParser) ShowAuthenticationStatement() (localctx IShowAuthenticationStatementContext) {
	localctx = NewShowAuthenticationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, StarRocksParserRULE_showAuthenticationStatement)
	var _la int

	p.SetState(4697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 508, p.GetParserRuleContext()) {
	case 1:
		localctx = NewShowAllAuthenticationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4688)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4689)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4690)
			p.Match(StarRocksParserAUTHENTICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewShowAuthenticationForUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4691)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4692)
			p.Match(StarRocksParserAUTHENTICATION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4695)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(4693)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4694)
				p.User()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteAsStatementContext is an interface to support dynamic dispatch.
type IExecuteAsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	AS() antlr.TerminalNode
	User() IUserContext
	WITH() antlr.TerminalNode
	NO() antlr.TerminalNode
	REVERT() antlr.TerminalNode

	// IsExecuteAsStatementContext differentiates from other interfaces.
	IsExecuteAsStatementContext()
}

type ExecuteAsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteAsStatementContext() *ExecuteAsStatementContext {
	var p = new(ExecuteAsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeAsStatement
	return p
}

func InitEmptyExecuteAsStatementContext(p *ExecuteAsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeAsStatement
}

func (*ExecuteAsStatementContext) IsExecuteAsStatementContext() {}

func NewExecuteAsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteAsStatementContext {
	var p = new(ExecuteAsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_executeAsStatement

	return p
}

func (s *ExecuteAsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteAsStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *ExecuteAsStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *ExecuteAsStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ExecuteAsStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *ExecuteAsStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNO, 0)
}

func (s *ExecuteAsStatementContext) REVERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVERT, 0)
}

func (s *ExecuteAsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteAsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteAsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExecuteAsStatement(s)
	}
}

func (s *ExecuteAsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExecuteAsStatement(s)
	}
}

func (p *StarRocksParser) ExecuteAsStatement() (localctx IExecuteAsStatementContext) {
	localctx = NewExecuteAsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, StarRocksParserRULE_executeAsStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4699)
		p.Match(StarRocksParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4700)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4701)
		p.User()
	}
	p.SetState(4705)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(4702)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4703)
			p.Match(StarRocksParserNO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4704)
			p.Match(StarRocksParserREVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRoleStatementContext is an interface to support dynamic dispatch.
type ICreateRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext

	// IsCreateRoleStatementContext differentiates from other interfaces.
	IsCreateRoleStatementContext()
}

type CreateRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateRoleStatementContext() *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRoleStatement
	return p
}

func InitEmptyCreateRoleStatementContext(p *CreateRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRoleStatement
}

func (*CreateRoleStatementContext) IsCreateRoleStatementContext() {}

func NewCreateRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRoleStatementContext {
	var p = new(CreateRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createRoleStatement

	return p
}

func (s *CreateRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRoleStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *CreateRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *CreateRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateRoleStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateRoleStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateRoleStatement(s)
	}
}

func (s *CreateRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateRoleStatement(s)
	}
}

func (p *StarRocksParser) CreateRoleStatement() (localctx ICreateRoleStatementContext) {
	localctx = NewCreateRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, StarRocksParserRULE_createRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4707)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4708)
		p.Match(StarRocksParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4709)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4710)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4711)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4714)
		p.RoleList()
	}
	p.SetState(4716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(4715)
			p.Comment()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterRoleStatementContext is an interface to support dynamic dispatch.
type IAlterRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	SET() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	EQ() antlr.TerminalNode
	String_() IStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsAlterRoleStatementContext differentiates from other interfaces.
	IsAlterRoleStatementContext()
}

type AlterRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterRoleStatementContext() *AlterRoleStatementContext {
	var p = new(AlterRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterRoleStatement
	return p
}

func InitEmptyAlterRoleStatementContext(p *AlterRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterRoleStatement
}

func (*AlterRoleStatementContext) IsAlterRoleStatementContext() {}

func NewAlterRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterRoleStatementContext {
	var p = new(AlterRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterRoleStatement

	return p
}

func (s *AlterRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterRoleStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *AlterRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterRoleStatementContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *AlterRoleStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *AlterRoleStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *AlterRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *AlterRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterRoleStatement(s)
	}
}

func (s *AlterRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterRoleStatement(s)
	}
}

func (p *StarRocksParser) AlterRoleStatement() (localctx IAlterRoleStatementContext) {
	localctx = NewAlterRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, StarRocksParserRULE_alterRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4718)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4719)
		p.Match(StarRocksParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4720)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4721)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4724)
		p.RoleList()
	}
	{
		p.SetState(4725)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4726)
		p.Match(StarRocksParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4727)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4728)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRoleStatementContext is an interface to support dynamic dispatch.
type IDropRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	RoleList() IRoleListContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropRoleStatementContext differentiates from other interfaces.
	IsDropRoleStatementContext()
}

type DropRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRoleStatementContext() *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropRoleStatement
	return p
}

func InitEmptyDropRoleStatementContext(p *DropRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropRoleStatement
}

func (*DropRoleStatementContext) IsDropRoleStatementContext() {}

func NewDropRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRoleStatementContext {
	var p = new(DropRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropRoleStatement

	return p
}

func (s *DropRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRoleStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *DropRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *DropRoleStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropRoleStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropRoleStatement(s)
	}
}

func (s *DropRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropRoleStatement(s)
	}
}

func (p *StarRocksParser) DropRoleStatement() (localctx IDropRoleStatementContext) {
	localctx = NewDropRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, StarRocksParserRULE_dropRoleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4730)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4731)
		p.Match(StarRocksParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(4732)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4733)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4736)
		p.RoleList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRolesStatementContext is an interface to support dynamic dispatch.
type IShowRolesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	ROLES() antlr.TerminalNode

	// IsShowRolesStatementContext differentiates from other interfaces.
	IsShowRolesStatementContext()
}

type ShowRolesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowRolesStatementContext() *ShowRolesStatementContext {
	var p = new(ShowRolesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRolesStatement
	return p
}

func InitEmptyShowRolesStatementContext(p *ShowRolesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRolesStatement
}

func (*ShowRolesStatementContext) IsShowRolesStatementContext() {}

func NewShowRolesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRolesStatementContext {
	var p = new(ShowRolesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRolesStatement

	return p
}

func (s *ShowRolesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRolesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRolesStatementContext) ROLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLES, 0)
}

func (s *ShowRolesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRolesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRolesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRolesStatement(s)
	}
}

func (s *ShowRolesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRolesStatement(s)
	}
}

func (p *StarRocksParser) ShowRolesStatement() (localctx IShowRolesStatementContext) {
	localctx = NewShowRolesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, StarRocksParserRULE_showRolesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4738)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4739)
		p.Match(StarRocksParserROLES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantRoleStatementContext is an interface to support dynamic dispatch.
type IGrantRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantRoleStatementContext differentiates from other interfaces.
	IsGrantRoleStatementContext()
}

type GrantRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantRoleStatementContext() *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantRoleStatement
	return p
}

func InitEmptyGrantRoleStatementContext(p *GrantRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantRoleStatement
}

func (*GrantRoleStatementContext) IsGrantRoleStatementContext() {}

func NewGrantRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRoleStatementContext {
	var p = new(GrantRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_grantRoleStatement

	return p
}

func (s *GrantRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRoleStatementContext) CopyAll(ctx *GrantRoleStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantRoleToUserContext struct {
	GrantRoleStatementContext
}

func NewGrantRoleToUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleToUserContext {
	var p = new(GrantRoleToUserContext)

	InitEmptyGrantRoleStatementContext(&p.GrantRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantRoleStatementContext))

	return p
}

func (s *GrantRoleToUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleToUserContext) GRANT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, 0)
}

func (s *GrantRoleToUserContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *GrantRoleToUserContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantRoleToUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantRoleToUserContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *GrantRoleToUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantRoleToUser(s)
	}
}

func (s *GrantRoleToUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantRoleToUser(s)
	}
}

type GrantRoleToRoleContext struct {
	GrantRoleStatementContext
}

func NewGrantRoleToRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantRoleToRoleContext {
	var p = new(GrantRoleToRoleContext)

	InitEmptyGrantRoleStatementContext(&p.GrantRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantRoleStatementContext))

	return p
}

func (s *GrantRoleToRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRoleToRoleContext) GRANT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, 0)
}

func (s *GrantRoleToRoleContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *GrantRoleToRoleContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantRoleToRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *GrantRoleToRoleContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantRoleToRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantRoleToRole(s)
	}
}

func (s *GrantRoleToRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantRoleToRole(s)
	}
}

func (p *StarRocksParser) GrantRoleStatement() (localctx IGrantRoleStatementContext) {
	localctx = NewGrantRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, StarRocksParserRULE_grantRoleStatement)
	p.SetState(4755)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 515, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantRoleToUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4741)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4742)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4743)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4745)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 514, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4744)
				p.Match(StarRocksParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4747)
			p.User()
		}

	case 2:
		localctx = NewGrantRoleToRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4749)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4750)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4751)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4752)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4753)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeRoleStatementContext is an interface to support dynamic dispatch.
type IRevokeRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokeRoleStatementContext differentiates from other interfaces.
	IsRevokeRoleStatementContext()
}

type RevokeRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeRoleStatementContext() *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_revokeRoleStatement
	return p
}

func InitEmptyRevokeRoleStatementContext(p *RevokeRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_revokeRoleStatement
}

func (*RevokeRoleStatementContext) IsRevokeRoleStatementContext() {}

func NewRevokeRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeRoleStatementContext {
	var p = new(RevokeRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_revokeRoleStatement

	return p
}

func (s *RevokeRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeRoleStatementContext) CopyAll(ctx *RevokeRoleStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokeRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RevokeRoleFromUserContext struct {
	RevokeRoleStatementContext
}

func NewRevokeRoleFromUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleFromUserContext {
	var p = new(RevokeRoleFromUserContext)

	InitEmptyRevokeRoleStatementContext(&p.RevokeRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeRoleStatementContext))

	return p
}

func (s *RevokeRoleFromUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleFromUserContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeRoleFromUserContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *RevokeRoleFromUserContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeRoleFromUserContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeRoleFromUserContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *RevokeRoleFromUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeRoleFromUser(s)
	}
}

func (s *RevokeRoleFromUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeRoleFromUser(s)
	}
}

type RevokeRoleFromRoleContext struct {
	RevokeRoleStatementContext
}

func NewRevokeRoleFromRoleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeRoleFromRoleContext {
	var p = new(RevokeRoleFromRoleContext)

	InitEmptyRevokeRoleStatementContext(&p.RevokeRoleStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokeRoleStatementContext))

	return p
}

func (s *RevokeRoleFromRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeRoleFromRoleContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeRoleFromRoleContext) IdentifierOrStringList() IIdentifierOrStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringListContext)
}

func (s *RevokeRoleFromRoleContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeRoleFromRoleContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *RevokeRoleFromRoleContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RevokeRoleFromRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeRoleFromRole(s)
	}
}

func (s *RevokeRoleFromRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeRoleFromRole(s)
	}
}

func (p *StarRocksParser) RevokeRoleStatement() (localctx IRevokeRoleStatementContext) {
	localctx = NewRevokeRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, StarRocksParserRULE_revokeRoleStatement)
	p.SetState(4771)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 517, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRevokeRoleFromUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4757)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4758)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4759)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4761)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 516, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4760)
				p.Match(StarRocksParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4763)
			p.User()
		}

	case 2:
		localctx = NewRevokeRoleFromRoleContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4765)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4766)
			p.IdentifierOrStringList()
		}
		{
			p.SetState(4767)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4768)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4769)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetRoleStatementContext is an interface to support dynamic dispatch.
type ISetRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	EXCEPT() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsSetRoleStatementContext differentiates from other interfaces.
	IsSetRoleStatementContext()
}

type SetRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleStatementContext() *SetRoleStatementContext {
	var p = new(SetRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setRoleStatement
	return p
}

func InitEmptySetRoleStatementContext(p *SetRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setRoleStatement
}

func (*SetRoleStatementContext) IsSetRoleStatementContext() {}

func NewSetRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleStatementContext {
	var p = new(SetRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setRoleStatement

	return p
}

func (s *SetRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *SetRoleStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *SetRoleStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *SetRoleStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *SetRoleStatementContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXCEPT, 0)
}

func (s *SetRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetRoleStatement(s)
	}
}

func (s *SetRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetRoleStatement(s)
	}
}

func (p *StarRocksParser) SetRoleStatement() (localctx ISetRoleStatementContext) {
	localctx = NewSetRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, StarRocksParserRULE_setRoleStatement)
	var _la int

	p.SetState(4789)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4773)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4774)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4775)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4776)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4777)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4778)
			p.Match(StarRocksParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4779)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4780)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4781)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4784)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserEXCEPT {
			{
				p.SetState(4782)
				p.Match(StarRocksParserEXCEPT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4783)
				p.RoleList()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4786)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4787)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4788)
			p.RoleList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetDefaultRoleStatementContext is an interface to support dynamic dispatch.
type ISetDefaultRoleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	DEFAULT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	TO() antlr.TerminalNode
	User() IUserContext
	NONE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsSetDefaultRoleStatementContext differentiates from other interfaces.
	IsSetDefaultRoleStatementContext()
}

type SetDefaultRoleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetDefaultRoleStatementContext() *SetDefaultRoleStatementContext {
	var p = new(SetDefaultRoleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setDefaultRoleStatement
	return p
}

func InitEmptySetDefaultRoleStatementContext(p *SetDefaultRoleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setDefaultRoleStatement
}

func (*SetDefaultRoleStatementContext) IsSetDefaultRoleStatementContext() {}

func NewSetDefaultRoleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetDefaultRoleStatementContext {
	var p = new(SetDefaultRoleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setDefaultRoleStatement

	return p
}

func (s *SetDefaultRoleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetDefaultRoleStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetDefaultRoleStatementContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *SetDefaultRoleStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *SetDefaultRoleStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *SetDefaultRoleStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *SetDefaultRoleStatementContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *SetDefaultRoleStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *SetDefaultRoleStatementContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetDefaultRoleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetDefaultRoleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetDefaultRoleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetDefaultRoleStatement(s)
	}
}

func (s *SetDefaultRoleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetDefaultRoleStatement(s)
	}
}

func (p *StarRocksParser) SetDefaultRoleStatement() (localctx ISetDefaultRoleStatementContext) {
	localctx = NewSetDefaultRoleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, StarRocksParserRULE_setDefaultRoleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4791)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4792)
		p.Match(StarRocksParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4793)
		p.Match(StarRocksParserROLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 520, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4794)
			p.Match(StarRocksParserNONE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(4795)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(4796)
			p.RoleList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(4799)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4800)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantRevokeClauseContext is an interface to support dynamic dispatch.
type IGrantRevokeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	ROLE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	USER() antlr.TerminalNode

	// IsGrantRevokeClauseContext differentiates from other interfaces.
	IsGrantRevokeClauseContext()
}

type GrantRevokeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantRevokeClauseContext() *GrantRevokeClauseContext {
	var p = new(GrantRevokeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantRevokeClause
	return p
}

func InitEmptyGrantRevokeClauseContext(p *GrantRevokeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantRevokeClause
}

func (*GrantRevokeClauseContext) IsGrantRevokeClauseContext() {}

func NewGrantRevokeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantRevokeClauseContext {
	var p = new(GrantRevokeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_grantRevokeClause

	return p
}

func (s *GrantRevokeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantRevokeClauseContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantRevokeClauseContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *GrantRevokeClauseContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantRevokeClauseContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *GrantRevokeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantRevokeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantRevokeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantRevokeClause(s)
	}
}

func (s *GrantRevokeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantRevokeClause(s)
	}
}

func (p *StarRocksParser) GrantRevokeClause() (localctx IGrantRevokeClauseContext) {
	localctx = NewGrantRevokeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, StarRocksParserRULE_grantRevokeClause)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4808)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 522, p.GetParserRuleContext()) {
	case 1:
		p.SetState(4803)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 521, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4802)
				p.Match(StarRocksParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4805)
			p.User()
		}

	case 2:
		{
			p.SetState(4806)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4807)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantPrivilegeStatementContext is an interface to support dynamic dispatch.
type IGrantPrivilegeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGrantPrivilegeStatementContext differentiates from other interfaces.
	IsGrantPrivilegeStatementContext()
}

type GrantPrivilegeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantPrivilegeStatementContext() *GrantPrivilegeStatementContext {
	var p = new(GrantPrivilegeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantPrivilegeStatement
	return p
}

func InitEmptyGrantPrivilegeStatementContext(p *GrantPrivilegeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_grantPrivilegeStatement
}

func (*GrantPrivilegeStatementContext) IsGrantPrivilegeStatementContext() {}

func NewGrantPrivilegeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantPrivilegeStatementContext {
	var p = new(GrantPrivilegeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_grantPrivilegeStatement

	return p
}

func (s *GrantPrivilegeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantPrivilegeStatementContext) CopyAll(ctx *GrantPrivilegeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GrantPrivilegeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantPrivilegeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type GrantOnAllContext struct {
	GrantPrivilegeStatementContext
	isAll antlr.Token
}

func NewGrantOnAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnAllContext {
	var p = new(GrantOnAllContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnAllContext) GetIsAll() antlr.Token { return s.isAll }

func (s *GrantOnAllContext) SetIsAll(v antlr.Token) { s.isAll = v }

func (s *GrantOnAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnAllContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnAllContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnAllContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnAllContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnAllContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserALL)
}

func (s *GrantOnAllContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, i)
}

func (s *GrantOnAllContext) PrivObjectTypePlural() IPrivObjectTypePluralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypePluralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypePluralContext)
}

func (s *GrantOnAllContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnAllContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnAllContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *GrantOnAllContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASES, 0)
}

func (s *GrantOnAllContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *GrantOnAllContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *GrantOnAllContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnAllContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnAll(s)
	}
}

func (s *GrantOnAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnAll(s)
	}
}

type GrantOnFuncContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnFuncContext {
	var p = new(GrantOnFuncContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnFuncContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnFuncContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnFuncContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnFuncContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnFuncContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *GrantOnFuncContext) PrivFunctionObjectNameList() IPrivFunctionObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivFunctionObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivFunctionObjectNameListContext)
}

func (s *GrantOnFuncContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnFuncContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnFuncContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *GrantOnFuncContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnFuncContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnFuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnFunc(s)
	}
}

func (s *GrantOnFuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnFunc(s)
	}
}

type GrantOnPrimaryObjContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnPrimaryObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnPrimaryObjContext {
	var p = new(GrantOnPrimaryObjContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnPrimaryObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnPrimaryObjContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnPrimaryObjContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnPrimaryObjContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnPrimaryObjContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnPrimaryObjContext) PrivObjectType() IPrivObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypeContext)
}

func (s *GrantOnPrimaryObjContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *GrantOnPrimaryObjContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnPrimaryObjContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnPrimaryObjContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnPrimaryObjContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnPrimaryObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnPrimaryObj(s)
	}
}

func (s *GrantOnPrimaryObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnPrimaryObj(s)
	}
}

type GrantOnTableBriefContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnTableBriefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnTableBriefContext {
	var p = new(GrantOnTableBriefContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnTableBriefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnTableBriefContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnTableBriefContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnTableBriefContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnTableBriefContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnTableBriefContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *GrantOnTableBriefContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnTableBriefContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnTableBriefContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnTableBriefContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnTableBriefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnTableBrief(s)
	}
}

func (s *GrantOnTableBriefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnTableBrief(s)
	}
}

type GrantOnUserContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnUserContext {
	var p = new(GrantOnUserContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnUserContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnUserContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnUserContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMPERSONATE, 0)
}

func (s *GrantOnUserContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnUserContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *GrantOnUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *GrantOnUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantOnUserContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnUserContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnUserContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnUserContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnUser(s)
	}
}

func (s *GrantOnUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnUser(s)
	}
}

type GrantOnSystemContext struct {
	GrantPrivilegeStatementContext
}

func NewGrantOnSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GrantOnSystemContext {
	var p = new(GrantOnSystemContext)

	InitEmptyGrantPrivilegeStatementContext(&p.GrantPrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GrantPrivilegeStatementContext))

	return p
}

func (s *GrantOnSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOnSystemContext) AllGRANT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserGRANT)
}

func (s *GrantOnSystemContext) GRANT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, i)
}

func (s *GrantOnSystemContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *GrantOnSystemContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *GrantOnSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM, 0)
}

func (s *GrantOnSystemContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *GrantOnSystemContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *GrantOnSystemContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *GrantOnSystemContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *GrantOnSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGrantOnSystem(s)
	}
}

func (s *GrantOnSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGrantOnSystem(s)
	}
}

func (p *StarRocksParser) GrantPrivilegeStatement() (localctx IGrantPrivilegeStatementContext) {
	localctx = NewGrantPrivilegeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, StarRocksParserRULE_grantPrivilegeStatement)
	var _la int

	p.SetState(4898)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 532, p.GetParserRuleContext()) {
	case 1:
		localctx = NewGrantOnUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4810)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4811)
			p.Match(StarRocksParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4812)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4813)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4814)
			p.User()
		}
		p.SetState(4819)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(4815)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4816)
				p.User()
			}

			p.SetState(4821)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4822)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4823)
			p.GrantRevokeClause()
		}
		p.SetState(4827)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4824)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4825)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4826)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		localctx = NewGrantOnTableBriefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4829)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4830)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4831)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4832)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4833)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4834)
			p.GrantRevokeClause()
		}
		p.SetState(4838)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4835)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4836)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4837)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		localctx = NewGrantOnFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4840)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4841)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4842)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4844)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserGLOBAL {
			{
				p.SetState(4843)
				p.Match(StarRocksParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4846)
			p.Match(StarRocksParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4847)
			p.PrivFunctionObjectNameList()
		}
		{
			p.SetState(4848)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4849)
			p.GrantRevokeClause()
		}
		p.SetState(4853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4850)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4851)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4852)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 4:
		localctx = NewGrantOnSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4855)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4856)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4857)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4858)
			p.Match(StarRocksParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4859)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4860)
			p.GrantRevokeClause()
		}
		p.SetState(4864)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4861)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4862)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4863)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		localctx = NewGrantOnPrimaryObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4866)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4867)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4868)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4869)
			p.PrivObjectType()
		}
		{
			p.SetState(4870)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4871)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4872)
			p.GrantRevokeClause()
		}
		p.SetState(4876)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4873)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4874)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4875)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		localctx = NewGrantOnAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4878)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4879)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4880)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4881)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4882)
			p.PrivObjectTypePlural()
		}
		p.SetState(4889)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 530, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4883)
				p.Match(StarRocksParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4884)

				var _m = p.Match(StarRocksParserALL)

				localctx.(*GrantOnAllContext).isAll = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4885)
				p.Match(StarRocksParserDATABASES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 530, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4886)
				p.Match(StarRocksParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4887)
				p.Match(StarRocksParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4888)
				p.IdentifierOrString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4891)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4892)
			p.GrantRevokeClause()
		}
		p.SetState(4896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(4893)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4894)
				p.Match(StarRocksParserGRANT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4895)
				p.Match(StarRocksParserOPTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokePrivilegeStatementContext is an interface to support dynamic dispatch.
type IRevokePrivilegeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRevokePrivilegeStatementContext differentiates from other interfaces.
	IsRevokePrivilegeStatementContext()
}

type RevokePrivilegeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokePrivilegeStatementContext() *RevokePrivilegeStatementContext {
	var p = new(RevokePrivilegeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_revokePrivilegeStatement
	return p
}

func InitEmptyRevokePrivilegeStatementContext(p *RevokePrivilegeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_revokePrivilegeStatement
}

func (*RevokePrivilegeStatementContext) IsRevokePrivilegeStatementContext() {}

func NewRevokePrivilegeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokePrivilegeStatementContext {
	var p = new(RevokePrivilegeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_revokePrivilegeStatement

	return p
}

func (s *RevokePrivilegeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokePrivilegeStatementContext) CopyAll(ctx *RevokePrivilegeStatementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RevokePrivilegeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokePrivilegeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type RevokeOnPrimaryObjContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnPrimaryObjContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnPrimaryObjContext {
	var p = new(RevokeOnPrimaryObjContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnPrimaryObjContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnPrimaryObjContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnPrimaryObjContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnPrimaryObjContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnPrimaryObjContext) PrivObjectType() IPrivObjectTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypeContext)
}

func (s *RevokeOnPrimaryObjContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *RevokeOnPrimaryObjContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnPrimaryObjContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnPrimaryObjContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnPrimaryObj(s)
	}
}

func (s *RevokeOnPrimaryObjContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnPrimaryObj(s)
	}
}

type RevokeOnTableBriefContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnTableBriefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnTableBriefContext {
	var p = new(RevokeOnTableBriefContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnTableBriefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnTableBriefContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnTableBriefContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnTableBriefContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnTableBriefContext) PrivObjectNameList() IPrivObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameListContext)
}

func (s *RevokeOnTableBriefContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnTableBriefContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnTableBriefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnTableBrief(s)
	}
}

func (s *RevokeOnTableBriefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnTableBrief(s)
	}
}

type RevokeOnAllContext struct {
	RevokePrivilegeStatementContext
	isAll antlr.Token
}

func NewRevokeOnAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnAllContext {
	var p = new(RevokeOnAllContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnAllContext) GetIsAll() antlr.Token { return s.isAll }

func (s *RevokeOnAllContext) SetIsAll(v antlr.Token) { s.isAll = v }

func (s *RevokeOnAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnAllContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnAllContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnAllContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnAllContext) AllALL() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserALL)
}

func (s *RevokeOnAllContext) ALL(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, i)
}

func (s *RevokeOnAllContext) PrivObjectTypePlural() IPrivObjectTypePluralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectTypePluralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectTypePluralContext)
}

func (s *RevokeOnAllContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnAllContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnAllContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *RevokeOnAllContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASES, 0)
}

func (s *RevokeOnAllContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *RevokeOnAllContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RevokeOnAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnAll(s)
	}
}

func (s *RevokeOnAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnAll(s)
	}
}

type RevokeOnUserContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnUserContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnUserContext {
	var p = new(RevokeOnUserContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnUserContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnUserContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMPERSONATE, 0)
}

func (s *RevokeOnUserContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnUserContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *RevokeOnUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *RevokeOnUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeOnUserContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnUserContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnUser(s)
	}
}

func (s *RevokeOnUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnUser(s)
	}
}

type RevokeOnFuncContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnFuncContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnFuncContext {
	var p = new(RevokeOnFuncContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnFuncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnFuncContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnFuncContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnFuncContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnFuncContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *RevokeOnFuncContext) PrivFunctionObjectNameList() IPrivFunctionObjectNameListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivFunctionObjectNameListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivFunctionObjectNameListContext)
}

func (s *RevokeOnFuncContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnFuncContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnFuncContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *RevokeOnFuncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnFunc(s)
	}
}

func (s *RevokeOnFuncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnFunc(s)
	}
}

type RevokeOnSystemContext struct {
	RevokePrivilegeStatementContext
}

func NewRevokeOnSystemContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RevokeOnSystemContext {
	var p = new(RevokeOnSystemContext)

	InitEmptyRevokePrivilegeStatementContext(&p.RevokePrivilegeStatementContext)
	p.parser = parser
	p.CopyAll(ctx.(*RevokePrivilegeStatementContext))

	return p
}

func (s *RevokeOnSystemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeOnSystemContext) REVOKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVOKE, 0)
}

func (s *RevokeOnSystemContext) PrivilegeTypeList() IPrivilegeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeListContext)
}

func (s *RevokeOnSystemContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RevokeOnSystemContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM, 0)
}

func (s *RevokeOnSystemContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RevokeOnSystemContext) GrantRevokeClause() IGrantRevokeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantRevokeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantRevokeClauseContext)
}

func (s *RevokeOnSystemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRevokeOnSystem(s)
	}
}

func (s *RevokeOnSystemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRevokeOnSystem(s)
	}
}

func (p *StarRocksParser) RevokePrivilegeStatement() (localctx IRevokePrivilegeStatementContext) {
	localctx = NewRevokePrivilegeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, StarRocksParserRULE_revokePrivilegeStatement)
	var _la int

	p.SetState(4964)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 536, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRevokeOnUserContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4900)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4901)
			p.Match(StarRocksParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4902)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4903)
			p.Match(StarRocksParserUSER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4904)
			p.User()
		}
		p.SetState(4909)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(4905)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4906)
				p.User()
			}

			p.SetState(4911)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4912)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4913)
			p.GrantRevokeClause()
		}

	case 2:
		localctx = NewRevokeOnTableBriefContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4915)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4916)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4917)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4918)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4919)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4920)
			p.GrantRevokeClause()
		}

	case 3:
		localctx = NewRevokeOnFuncContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4922)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4923)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4924)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4926)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserGLOBAL {
			{
				p.SetState(4925)
				p.Match(StarRocksParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4928)
			p.Match(StarRocksParserFUNCTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4929)
			p.PrivFunctionObjectNameList()
		}
		{
			p.SetState(4930)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4931)
			p.GrantRevokeClause()
		}

	case 4:
		localctx = NewRevokeOnSystemContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4933)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4934)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4935)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4936)
			p.Match(StarRocksParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4937)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4938)
			p.GrantRevokeClause()
		}

	case 5:
		localctx = NewRevokeOnPrimaryObjContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4940)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4941)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4942)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4943)
			p.PrivObjectType()
		}
		{
			p.SetState(4944)
			p.PrivObjectNameList()
		}
		{
			p.SetState(4945)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4946)
			p.GrantRevokeClause()
		}

	case 6:
		localctx = NewRevokeOnAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4948)
			p.Match(StarRocksParserREVOKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4949)
			p.PrivilegeTypeList()
		}
		{
			p.SetState(4950)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4951)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4952)
			p.PrivObjectTypePlural()
		}
		p.SetState(4959)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4953)
				p.Match(StarRocksParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4954)

				var _m = p.Match(StarRocksParserALL)

				localctx.(*RevokeOnAllContext).isAll = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4955)
				p.Match(StarRocksParserDATABASES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 535, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4956)
				p.Match(StarRocksParserIN)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4957)
				p.Match(StarRocksParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4958)
				p.IdentifierOrString()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4961)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4962)
			p.GrantRevokeClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGrantsStatementContext is an interface to support dynamic dispatch.
type IShowGrantsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	FOR() antlr.TerminalNode
	User() IUserContext
	USER() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsShowGrantsStatementContext differentiates from other interfaces.
	IsShowGrantsStatementContext()
}

type ShowGrantsStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGrantsStatementContext() *ShowGrantsStatementContext {
	var p = new(ShowGrantsStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showGrantsStatement
	return p
}

func InitEmptyShowGrantsStatementContext(p *ShowGrantsStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showGrantsStatement
}

func (*ShowGrantsStatementContext) IsShowGrantsStatementContext() {}

func NewShowGrantsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGrantsStatementContext {
	var p = new(ShowGrantsStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showGrantsStatement

	return p
}

func (s *ShowGrantsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGrantsStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowGrantsStatementContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANTS, 0)
}

func (s *ShowGrantsStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *ShowGrantsStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowGrantsStatementContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *ShowGrantsStatementContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *ShowGrantsStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ShowGrantsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGrantsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGrantsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowGrantsStatement(s)
	}
}

func (s *ShowGrantsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowGrantsStatement(s)
	}
}

func (p *StarRocksParser) ShowGrantsStatement() (localctx IShowGrantsStatementContext) {
	localctx = NewShowGrantsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, StarRocksParserRULE_showGrantsStatement)
	p.SetState(4980)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 538, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4966)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4967)
			p.Match(StarRocksParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4968)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4969)
			p.Match(StarRocksParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4970)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4972)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 537, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4971)
				p.Match(StarRocksParserUSER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(4974)
			p.User()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4975)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4976)
			p.Match(StarRocksParserGRANTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4977)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4978)
			p.Match(StarRocksParserROLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4979)
			p.IdentifierOrString()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAuthOptionContext is an interface to support dynamic dispatch.
type IAuthOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAuthOptionContext differentiates from other interfaces.
	IsAuthOptionContext()
}

type AuthOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthOptionContext() *AuthOptionContext {
	var p = new(AuthOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_authOption
	return p
}

func InitEmptyAuthOptionContext(p *AuthOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_authOption
}

func (*AuthOptionContext) IsAuthOptionContext() {}

func NewAuthOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthOptionContext {
	var p = new(AuthOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_authOption

	return p
}

func (s *AuthOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthOptionContext) CopyAll(ctx *AuthOptionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *AuthOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AuthWithPluginContext struct {
	AuthOptionContext
}

func NewAuthWithPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AuthWithPluginContext {
	var p = new(AuthWithPluginContext)

	InitEmptyAuthOptionContext(&p.AuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthOptionContext))

	return p
}

func (s *AuthWithPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthWithPluginContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIDENTIFIED, 0)
}

func (s *AuthWithPluginContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *AuthWithPluginContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AuthWithPluginContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AuthWithPluginContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *AuthWithPluginContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *AuthWithPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAuthWithPlugin(s)
	}
}

func (s *AuthWithPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAuthWithPlugin(s)
	}
}

type AuthWithoutPluginContext struct {
	AuthOptionContext
}

func NewAuthWithoutPluginContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AuthWithoutPluginContext {
	var p = new(AuthWithoutPluginContext)

	InitEmptyAuthOptionContext(&p.AuthOptionContext)
	p.parser = parser
	p.CopyAll(ctx.(*AuthOptionContext))

	return p
}

func (s *AuthWithoutPluginContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthWithoutPluginContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIDENTIFIED, 0)
}

func (s *AuthWithoutPluginContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *AuthWithoutPluginContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AuthWithoutPluginContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPASSWORD, 0)
}

func (s *AuthWithoutPluginContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAuthWithoutPlugin(s)
	}
}

func (s *AuthWithoutPluginContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAuthWithoutPlugin(s)
	}
}

func (p *StarRocksParser) AuthOption() (localctx IAuthOptionContext) {
	localctx = NewAuthOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, StarRocksParserRULE_authOption)
	var _la int

	p.SetState(4995)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 541, p.GetParserRuleContext()) {
	case 1:
		localctx = NewAuthWithoutPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4982)
			p.Match(StarRocksParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4983)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4985)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPASSWORD {
			{
				p.SetState(4984)
				p.Match(StarRocksParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4987)
			p.String_()
		}

	case 2:
		localctx = NewAuthWithPluginContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4988)
			p.Match(StarRocksParserIDENTIFIED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4989)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4990)
			p.IdentifierOrString()
		}
		p.SetState(4993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS || _la == StarRocksParserBY {
			{
				p.SetState(4991)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserAS || _la == StarRocksParserBY) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(4992)
				p.String_()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectNameContext is an interface to support dynamic dispatch.
type IPrivObjectNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext
	IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext

	// IsPrivObjectNameContext differentiates from other interfaces.
	IsPrivObjectNameContext()
}

type PrivObjectNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectNameContext() *PrivObjectNameContext {
	var p = new(PrivObjectNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectName
	return p
}

func InitEmptyPrivObjectNameContext(p *PrivObjectNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectName
}

func (*PrivObjectNameContext) IsPrivObjectNameContext() {}

func NewPrivObjectNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectNameContext {
	var p = new(PrivObjectNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privObjectName

	return p
}

func (s *PrivObjectNameContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectNameContext) AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringOrStarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			tst[i] = t.(IIdentifierOrStringOrStarContext)
			i++
		}
	}

	return tst
}

func (s *PrivObjectNameContext) IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringOrStarContext)
}

func (s *PrivObjectNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivObjectName(s)
	}
}

func (s *PrivObjectNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivObjectName(s)
	}
}

func (p *StarRocksParser) PrivObjectName() (localctx IPrivObjectNameContext) {
	localctx = NewPrivObjectNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, StarRocksParserRULE_privObjectName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4997)
		p.IdentifierOrStringOrStar()
	}
	p.SetState(5000)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__0 {
		{
			p.SetState(4998)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4999)
			p.IdentifierOrStringOrStar()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectNameListContext is an interface to support dynamic dispatch.
type IPrivObjectNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivObjectName() []IPrivObjectNameContext
	PrivObjectName(i int) IPrivObjectNameContext

	// IsPrivObjectNameListContext differentiates from other interfaces.
	IsPrivObjectNameListContext()
}

type PrivObjectNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectNameListContext() *PrivObjectNameListContext {
	var p = new(PrivObjectNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectNameList
	return p
}

func InitEmptyPrivObjectNameListContext(p *PrivObjectNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectNameList
}

func (*PrivObjectNameListContext) IsPrivObjectNameListContext() {}

func NewPrivObjectNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectNameListContext {
	var p = new(PrivObjectNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privObjectNameList

	return p
}

func (s *PrivObjectNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectNameListContext) AllPrivObjectName() []IPrivObjectNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivObjectNameContext); ok {
			len++
		}
	}

	tst := make([]IPrivObjectNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivObjectNameContext); ok {
			tst[i] = t.(IPrivObjectNameContext)
			i++
		}
	}

	return tst
}

func (s *PrivObjectNameListContext) PrivObjectName(i int) IPrivObjectNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivObjectNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivObjectNameContext)
}

func (s *PrivObjectNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivObjectNameList(s)
	}
}

func (s *PrivObjectNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivObjectNameList(s)
	}
}

func (p *StarRocksParser) PrivObjectNameList() (localctx IPrivObjectNameListContext) {
	localctx = NewPrivObjectNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, StarRocksParserRULE_privObjectNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5002)
		p.PrivObjectName()
	}
	p.SetState(5007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5003)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5004)
			p.PrivObjectName()
		}

		p.SetState(5009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivFunctionObjectNameListContext is an interface to support dynamic dispatch.
type IPrivFunctionObjectNameListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQualifiedName() []IQualifiedNameContext
	QualifiedName(i int) IQualifiedNameContext
	AllTypeList() []ITypeListContext
	TypeList(i int) ITypeListContext

	// IsPrivFunctionObjectNameListContext differentiates from other interfaces.
	IsPrivFunctionObjectNameListContext()
}

type PrivFunctionObjectNameListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivFunctionObjectNameListContext() *PrivFunctionObjectNameListContext {
	var p = new(PrivFunctionObjectNameListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privFunctionObjectNameList
	return p
}

func InitEmptyPrivFunctionObjectNameListContext(p *PrivFunctionObjectNameListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privFunctionObjectNameList
}

func (*PrivFunctionObjectNameListContext) IsPrivFunctionObjectNameListContext() {}

func NewPrivFunctionObjectNameListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivFunctionObjectNameListContext {
	var p = new(PrivFunctionObjectNameListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privFunctionObjectNameList

	return p
}

func (s *PrivFunctionObjectNameListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivFunctionObjectNameListContext) AllQualifiedName() []IQualifiedNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedNameContext); ok {
			tst[i] = t.(IQualifiedNameContext)
			i++
		}
	}

	return tst
}

func (s *PrivFunctionObjectNameListContext) QualifiedName(i int) IQualifiedNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *PrivFunctionObjectNameListContext) AllTypeList() []ITypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeListContext); ok {
			len++
		}
	}

	tst := make([]ITypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeListContext); ok {
			tst[i] = t.(ITypeListContext)
			i++
		}
	}

	return tst
}

func (s *PrivFunctionObjectNameListContext) TypeList(i int) ITypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeListContext)
}

func (s *PrivFunctionObjectNameListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivFunctionObjectNameListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivFunctionObjectNameListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivFunctionObjectNameList(s)
	}
}

func (s *PrivFunctionObjectNameListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivFunctionObjectNameList(s)
	}
}

func (p *StarRocksParser) PrivFunctionObjectNameList() (localctx IPrivFunctionObjectNameListContext) {
	localctx = NewPrivFunctionObjectNameListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, StarRocksParserRULE_privFunctionObjectNameList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5010)
		p.QualifiedName()
	}
	{
		p.SetState(5011)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5012)
		p.TypeList()
	}
	{
		p.SetState(5013)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5022)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5014)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5015)
			p.QualifiedName()
		}
		{
			p.SetState(5016)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5017)
			p.TypeList()
		}
		{
			p.SetState(5018)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5024)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeTypeListContext is an interface to support dynamic dispatch.
type IPrivilegeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPrivilegeType() []IPrivilegeTypeContext
	PrivilegeType(i int) IPrivilegeTypeContext

	// IsPrivilegeTypeListContext differentiates from other interfaces.
	IsPrivilegeTypeListContext()
}

type PrivilegeTypeListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeListContext() *PrivilegeTypeListContext {
	var p = new(PrivilegeTypeListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privilegeTypeList
	return p
}

func InitEmptyPrivilegeTypeListContext(p *PrivilegeTypeListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privilegeTypeList
}

func (*PrivilegeTypeListContext) IsPrivilegeTypeListContext() {}

func NewPrivilegeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeListContext {
	var p = new(PrivilegeTypeListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privilegeTypeList

	return p
}

func (s *PrivilegeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeListContext) AllPrivilegeType() []IPrivilegeTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrivilegeTypeContext); ok {
			len++
		}
	}

	tst := make([]IPrivilegeTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrivilegeTypeContext); ok {
			tst[i] = t.(IPrivilegeTypeContext)
			i++
		}
	}

	return tst
}

func (s *PrivilegeTypeListContext) PrivilegeType(i int) IPrivilegeTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeTypeContext)
}

func (s *PrivilegeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivilegeTypeList(s)
	}
}

func (s *PrivilegeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivilegeTypeList(s)
	}
}

func (p *StarRocksParser) PrivilegeTypeList() (localctx IPrivilegeTypeListContext) {
	localctx = NewPrivilegeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, StarRocksParserRULE_privilegeTypeList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5025)
		p.PrivilegeType()
	}
	p.SetState(5030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5026)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5027)
			p.PrivilegeType()
		}

		p.SetState(5032)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeTypeContext is an interface to support dynamic dispatch.
type IPrivilegeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	ALTER() antlr.TerminalNode
	APPLY() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	FUNCTION() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	DELETE() antlr.TerminalNode
	DROP() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FILE() antlr.TerminalNode
	IMPERSONATE() antlr.TerminalNode
	INSERT() antlr.TerminalNode
	GRANT() antlr.TerminalNode
	NODE() antlr.TerminalNode
	OPERATE() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	UPDATE() antlr.TerminalNode
	USAGE() antlr.TerminalNode

	// IsPrivilegeTypeContext differentiates from other interfaces.
	IsPrivilegeTypeContext()
}

type PrivilegeTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeTypeContext() *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privilegeType
	return p
}

func InitEmptyPrivilegeTypeContext(p *PrivilegeTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privilegeType
}

func (*PrivilegeTypeContext) IsPrivilegeTypeContext() {}

func NewPrivilegeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeTypeContext {
	var p = new(PrivilegeTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privilegeType

	return p
}

func (s *PrivilegeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeTypeContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *PrivilegeTypeContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIVILEGES, 0)
}

func (s *PrivilegeTypeContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *PrivilegeTypeContext) APPLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAPPLY, 0)
}

func (s *PrivilegeTypeContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *PrivilegeTypeContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *PrivilegeTypeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *PrivilegeTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *PrivilegeTypeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *PrivilegeTypeContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *PrivilegeTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *PrivilegeTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *PrivilegeTypeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *PrivilegeTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *PrivilegeTypeContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *PrivilegeTypeContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *PrivilegeTypeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *PrivilegeTypeContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *PrivilegeTypeContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *PrivilegeTypeContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *PrivilegeTypeContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *PrivilegeTypeContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *PrivilegeTypeContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *PrivilegeTypeContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *PrivilegeTypeContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMPERSONATE, 0)
}

func (s *PrivilegeTypeContext) INSERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINSERT, 0)
}

func (s *PrivilegeTypeContext) GRANT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANT, 0)
}

func (s *PrivilegeTypeContext) NODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODE, 0)
}

func (s *PrivilegeTypeContext) OPERATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPERATE, 0)
}

func (s *PrivilegeTypeContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *PrivilegeTypeContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGIN, 0)
}

func (s *PrivilegeTypeContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORY, 0)
}

func (s *PrivilegeTypeContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *PrivilegeTypeContext) SELECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSELECT, 0)
}

func (s *PrivilegeTypeContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUPDATE, 0)
}

func (s *PrivilegeTypeContext) USAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSAGE, 0)
}

func (s *PrivilegeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivilegeType(s)
	}
}

func (s *PrivilegeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivilegeType(s)
	}
}

func (p *StarRocksParser) PrivilegeType() (localctx IPrivilegeTypeContext) {
	localctx = NewPrivilegeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, StarRocksParserRULE_privilegeType)
	var _la int

	p.SetState(5076)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5033)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5035)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPRIVILEGES {
			{
				p.SetState(5034)
				p.Match(StarRocksParserPRIVILEGES)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserALTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5037)
			p.Match(StarRocksParserALTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAPPLY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5038)
			p.Match(StarRocksParserAPPLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserBLACKLIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5039)
			p.Match(StarRocksParserBLACKLIST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCREATE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5040)
			p.Match(StarRocksParserCREATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 547, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5041)
				p.Match(StarRocksParserDATABASE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(5042)
				p.Match(StarRocksParserTABLE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(5043)
				p.Match(StarRocksParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(5044)
				p.Match(StarRocksParserFUNCTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(5045)
				p.Match(StarRocksParserGLOBAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5046)
				p.Match(StarRocksParserFUNCTION)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(5047)
				p.Match(StarRocksParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5048)
				p.Match(StarRocksParserVIEW)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(5049)
				p.Match(StarRocksParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(5050)
				p.Match(StarRocksParserRESOURCE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5051)
				p.Match(StarRocksParserGROUP)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(5052)
				p.Match(StarRocksParserEXTERNAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5053)
				p.Match(StarRocksParserCATALOG)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 10:
			{
				p.SetState(5054)
				p.Match(StarRocksParserSTORAGE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5055)
				p.Match(StarRocksParserVOLUME)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 11:
			{
				p.SetState(5056)
				p.Match(StarRocksParserWAREHOUSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 12:
			{
				p.SetState(5057)
				p.Match(StarRocksParserPIPE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case StarRocksParserDELETE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5060)
			p.Match(StarRocksParserDELETE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDROP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5061)
			p.Match(StarRocksParserDROP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEXPORT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5062)
			p.Match(StarRocksParserEXPORT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserFILE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5063)
			p.Match(StarRocksParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserIMPERSONATE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5064)
			p.Match(StarRocksParserIMPERSONATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserINSERT:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5065)
			p.Match(StarRocksParserINSERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserGRANT:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5066)
			p.Match(StarRocksParserGRANT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserNODE:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5067)
			p.Match(StarRocksParserNODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserOPERATE:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5068)
			p.Match(StarRocksParserOPERATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSECURITY:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(5069)
			p.Match(StarRocksParserSECURITY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPLUGIN:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(5070)
			p.Match(StarRocksParserPLUGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserREPOSITORY:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(5071)
			p.Match(StarRocksParserREPOSITORY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserREFRESH:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(5072)
			p.Match(StarRocksParserREFRESH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSELECT:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(5073)
			p.Match(StarRocksParserSELECT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserUPDATE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(5074)
			p.Match(StarRocksParserUPDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserUSAGE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(5075)
			p.Match(StarRocksParserUSAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectTypeContext is an interface to support dynamic dispatch.
type IPrivObjectTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATALOG() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	SYSTEM() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	PIPE() antlr.TerminalNode

	// IsPrivObjectTypeContext differentiates from other interfaces.
	IsPrivObjectTypeContext()
}

type PrivObjectTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectTypeContext() *PrivObjectTypeContext {
	var p = new(PrivObjectTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectType
	return p
}

func InitEmptyPrivObjectTypeContext(p *PrivObjectTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectType
}

func (*PrivObjectTypeContext) IsPrivObjectTypeContext() {}

func NewPrivObjectTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectTypeContext {
	var p = new(PrivObjectTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privObjectType

	return p
}

func (s *PrivObjectTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectTypeContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *PrivObjectTypeContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *PrivObjectTypeContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *PrivObjectTypeContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *PrivObjectTypeContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *PrivObjectTypeContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *PrivObjectTypeContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *PrivObjectTypeContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *PrivObjectTypeContext) SYSTEM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM, 0)
}

func (s *PrivObjectTypeContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *PrivObjectTypeContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *PrivObjectTypeContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *PrivObjectTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivObjectType(s)
	}
}

func (s *PrivObjectTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivObjectType(s)
	}
}

func (p *StarRocksParser) PrivObjectType() (localctx IPrivObjectTypeContext) {
	localctx = NewPrivObjectTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, StarRocksParserRULE_privObjectType)
	p.SetState(5092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 549, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5078)
			p.Match(StarRocksParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5079)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5080)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5081)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5082)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5083)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5084)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5085)
			p.Match(StarRocksParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5086)
			p.Match(StarRocksParserVOLUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5087)
			p.Match(StarRocksParserSYSTEM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5088)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5089)
			p.Match(StarRocksParserVIEW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5090)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5091)
			p.Match(StarRocksParserPIPE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivObjectTypePluralContext is an interface to support dynamic dispatch.
type IPrivObjectTypePluralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CATALOGS() antlr.TerminalNode
	DATABASES() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	POLICIES() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	GROUPS() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	USERS() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	PIPES() antlr.TerminalNode

	// IsPrivObjectTypePluralContext differentiates from other interfaces.
	IsPrivObjectTypePluralContext()
}

type PrivObjectTypePluralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivObjectTypePluralContext() *PrivObjectTypePluralContext {
	var p = new(PrivObjectTypePluralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectTypePlural
	return p
}

func InitEmptyPrivObjectTypePluralContext(p *PrivObjectTypePluralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_privObjectTypePlural
}

func (*PrivObjectTypePluralContext) IsPrivObjectTypePluralContext() {}

func NewPrivObjectTypePluralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivObjectTypePluralContext {
	var p = new(PrivObjectTypePluralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_privObjectTypePlural

	return p
}

func (s *PrivObjectTypePluralContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivObjectTypePluralContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *PrivObjectTypePluralContext) DATABASES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASES, 0)
}

func (s *PrivObjectTypePluralContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTIONS, 0)
}

func (s *PrivObjectTypePluralContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *PrivObjectTypePluralContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *PrivObjectTypePluralContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEWS, 0)
}

func (s *PrivObjectTypePluralContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPOLICIES, 0)
}

func (s *PrivObjectTypePluralContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCES, 0)
}

func (s *PrivObjectTypePluralContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *PrivObjectTypePluralContext) GROUPS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPS, 0)
}

func (s *PrivObjectTypePluralContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *PrivObjectTypePluralContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUMES, 0)
}

func (s *PrivObjectTypePluralContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *PrivObjectTypePluralContext) USERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSERS, 0)
}

func (s *PrivObjectTypePluralContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSES, 0)
}

func (s *PrivObjectTypePluralContext) PIPES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPES, 0)
}

func (s *PrivObjectTypePluralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivObjectTypePluralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivObjectTypePluralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrivObjectTypePlural(s)
	}
}

func (s *PrivObjectTypePluralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrivObjectTypePlural(s)
	}
}

func (p *StarRocksParser) PrivObjectTypePlural() (localctx IPrivObjectTypePluralContext) {
	localctx = NewPrivObjectTypePluralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, StarRocksParserRULE_privObjectTypePlural)
	p.SetState(5112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCATALOGS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5094)
			p.Match(StarRocksParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDATABASES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5095)
			p.Match(StarRocksParserDATABASES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserFUNCTIONS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5096)
			p.Match(StarRocksParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserGLOBAL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5097)
			p.Match(StarRocksParserGLOBAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5098)
			p.Match(StarRocksParserFUNCTIONS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMATERIALIZED:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5099)
			p.Match(StarRocksParserMATERIALIZED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5100)
			p.Match(StarRocksParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPOLICIES:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5101)
			p.Match(StarRocksParserPOLICIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRESOURCES:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5102)
			p.Match(StarRocksParserRESOURCES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRESOURCE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(5103)
			p.Match(StarRocksParserRESOURCE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5104)
			p.Match(StarRocksParserGROUPS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSTORAGE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(5105)
			p.Match(StarRocksParserSTORAGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5106)
			p.Match(StarRocksParserVOLUMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserTABLES:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(5107)
			p.Match(StarRocksParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserUSERS:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(5108)
			p.Match(StarRocksParserUSERS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserVIEWS:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(5109)
			p.Match(StarRocksParserVIEWS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserWAREHOUSES:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(5110)
			p.Match(StarRocksParserWAREHOUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPIPES:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(5111)
			p.Match(StarRocksParserPIPES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type ICreateSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	Properties() IPropertiesContext

	// IsCreateSecurityIntegrationStatementContext differentiates from other interfaces.
	IsCreateSecurityIntegrationStatementContext()
}

type CreateSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateSecurityIntegrationStatementContext() *CreateSecurityIntegrationStatementContext {
	var p = new(CreateSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createSecurityIntegrationStatement
	return p
}

func InitEmptyCreateSecurityIntegrationStatementContext(p *CreateSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createSecurityIntegrationStatement
}

func (*CreateSecurityIntegrationStatementContext) IsCreateSecurityIntegrationStatementContext() {}

func NewCreateSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateSecurityIntegrationStatementContext {
	var p = new(CreateSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createSecurityIntegrationStatement

	return p
}

func (s *CreateSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateSecurityIntegrationStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *CreateSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *CreateSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateSecurityIntegrationStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateSecurityIntegrationStatement(s)
	}
}

func (s *CreateSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateSecurityIntegrationStatement(s)
	}
}

func (p *StarRocksParser) CreateSecurityIntegrationStatement() (localctx ICreateSecurityIntegrationStatementContext) {
	localctx = NewCreateSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, StarRocksParserRULE_createSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5114)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5115)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5116)
		p.Match(StarRocksParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5117)
		p.Identifier()
	}
	{
		p.SetState(5118)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IAlterSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsAlterSecurityIntegrationStatementContext differentiates from other interfaces.
	IsAlterSecurityIntegrationStatementContext()
}

type AlterSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterSecurityIntegrationStatementContext() *AlterSecurityIntegrationStatementContext {
	var p = new(AlterSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterSecurityIntegrationStatement
	return p
}

func InitEmptyAlterSecurityIntegrationStatementContext(p *AlterSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterSecurityIntegrationStatement
}

func (*AlterSecurityIntegrationStatementContext) IsAlterSecurityIntegrationStatementContext() {}

func NewAlterSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterSecurityIntegrationStatementContext {
	var p = new(AlterSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterSecurityIntegrationStatement

	return p
}

func (s *AlterSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterSecurityIntegrationStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *AlterSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *AlterSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AlterSecurityIntegrationStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterSecurityIntegrationStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterSecurityIntegrationStatement(s)
	}
}

func (s *AlterSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterSecurityIntegrationStatement(s)
	}
}

func (p *StarRocksParser) AlterSecurityIntegrationStatement() (localctx IAlterSecurityIntegrationStatementContext) {
	localctx = NewAlterSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, StarRocksParserRULE_alterSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5120)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5121)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5122)
		p.Match(StarRocksParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5123)
		p.Identifier()
	}
	{
		p.SetState(5124)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5125)
		p.PropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IDropSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropSecurityIntegrationStatementContext differentiates from other interfaces.
	IsDropSecurityIntegrationStatementContext()
}

type DropSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropSecurityIntegrationStatementContext() *DropSecurityIntegrationStatementContext {
	var p = new(DropSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropSecurityIntegrationStatement
	return p
}

func InitEmptyDropSecurityIntegrationStatementContext(p *DropSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropSecurityIntegrationStatement
}

func (*DropSecurityIntegrationStatementContext) IsDropSecurityIntegrationStatementContext() {}

func NewDropSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropSecurityIntegrationStatementContext {
	var p = new(DropSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropSecurityIntegrationStatement

	return p
}

func (s *DropSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropSecurityIntegrationStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *DropSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *DropSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropSecurityIntegrationStatement(s)
	}
}

func (s *DropSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropSecurityIntegrationStatement(s)
	}
}

func (p *StarRocksParser) DropSecurityIntegrationStatement() (localctx IDropSecurityIntegrationStatementContext) {
	localctx = NewDropSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, StarRocksParserRULE_dropSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5127)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5128)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5129)
		p.Match(StarRocksParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5130)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IShowSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATIONS() antlr.TerminalNode

	// IsShowSecurityIntegrationStatementContext differentiates from other interfaces.
	IsShowSecurityIntegrationStatementContext()
}

type ShowSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSecurityIntegrationStatementContext() *ShowSecurityIntegrationStatementContext {
	var p = new(ShowSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSecurityIntegrationStatement
	return p
}

func InitEmptyShowSecurityIntegrationStatementContext(p *ShowSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSecurityIntegrationStatement
}

func (*ShowSecurityIntegrationStatementContext) IsShowSecurityIntegrationStatementContext() {}

func NewShowSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSecurityIntegrationStatementContext {
	var p = new(ShowSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showSecurityIntegrationStatement

	return p
}

func (s *ShowSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSecurityIntegrationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *ShowSecurityIntegrationStatementContext) INTEGRATIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATIONS, 0)
}

func (s *ShowSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowSecurityIntegrationStatement(s)
	}
}

func (s *ShowSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowSecurityIntegrationStatement(s)
	}
}

func (p *StarRocksParser) ShowSecurityIntegrationStatement() (localctx IShowSecurityIntegrationStatementContext) {
	localctx = NewShowSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, StarRocksParserRULE_showSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5132)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5133)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5134)
		p.Match(StarRocksParserINTEGRATIONS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateSecurityIntegrationStatementContext is an interface to support dynamic dispatch.
type IShowCreateSecurityIntegrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowCreateSecurityIntegrationStatementContext differentiates from other interfaces.
	IsShowCreateSecurityIntegrationStatementContext()
}

type ShowCreateSecurityIntegrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateSecurityIntegrationStatementContext() *ShowCreateSecurityIntegrationStatementContext {
	var p = new(ShowCreateSecurityIntegrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateSecurityIntegrationStatement
	return p
}

func InitEmptyShowCreateSecurityIntegrationStatementContext(p *ShowCreateSecurityIntegrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateSecurityIntegrationStatement
}

func (*ShowCreateSecurityIntegrationStatementContext) IsShowCreateSecurityIntegrationStatementContext() {
}

func NewShowCreateSecurityIntegrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateSecurityIntegrationStatementContext {
	var p = new(ShowCreateSecurityIntegrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateSecurityIntegrationStatement

	return p
}

func (s *ShowCreateSecurityIntegrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateSecurityIntegrationStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *ShowCreateSecurityIntegrationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateSecurityIntegrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateSecurityIntegrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateSecurityIntegrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateSecurityIntegrationStatement(s)
	}
}

func (s *ShowCreateSecurityIntegrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateSecurityIntegrationStatement(s)
	}
}

func (p *StarRocksParser) ShowCreateSecurityIntegrationStatement() (localctx IShowCreateSecurityIntegrationStatementContext) {
	localctx = NewShowCreateSecurityIntegrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, StarRocksParserRULE_showCreateSecurityIntegrationStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5136)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5137)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5138)
		p.Match(StarRocksParserSECURITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5139)
		p.Match(StarRocksParserINTEGRATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5140)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateGroupProviderStatementContext is an interface to support dynamic dispatch.
type ICreateGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext
	Properties() IPropertiesContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsCreateGroupProviderStatementContext differentiates from other interfaces.
	IsCreateGroupProviderStatementContext()
}

type CreateGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateGroupProviderStatementContext() *CreateGroupProviderStatementContext {
	var p = new(CreateGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createGroupProviderStatement
	return p
}

func InitEmptyCreateGroupProviderStatementContext(p *CreateGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createGroupProviderStatement
}

func (*CreateGroupProviderStatementContext) IsCreateGroupProviderStatementContext() {}

func NewCreateGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateGroupProviderStatementContext {
	var p = new(CreateGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createGroupProviderStatement

	return p
}

func (s *CreateGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateGroupProviderStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *CreateGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDER, 0)
}

func (s *CreateGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateGroupProviderStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateGroupProviderStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateGroupProviderStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateGroupProviderStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateGroupProviderStatement(s)
	}
}

func (s *CreateGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateGroupProviderStatement(s)
	}
}

func (p *StarRocksParser) CreateGroupProviderStatement() (localctx ICreateGroupProviderStatementContext) {
	localctx = NewCreateGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, StarRocksParserRULE_createGroupProviderStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5142)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5143)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5144)
		p.Match(StarRocksParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5148)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5145)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5146)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5147)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5150)
		p.Identifier()
	}
	{
		p.SetState(5151)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropGroupProviderStatementContext is an interface to support dynamic dispatch.
type IDropGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropGroupProviderStatementContext differentiates from other interfaces.
	IsDropGroupProviderStatementContext()
}

type DropGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropGroupProviderStatementContext() *DropGroupProviderStatementContext {
	var p = new(DropGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropGroupProviderStatement
	return p
}

func InitEmptyDropGroupProviderStatementContext(p *DropGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropGroupProviderStatement
}

func (*DropGroupProviderStatementContext) IsDropGroupProviderStatementContext() {}

func NewDropGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropGroupProviderStatementContext {
	var p = new(DropGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropGroupProviderStatement

	return p
}

func (s *DropGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropGroupProviderStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *DropGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDER, 0)
}

func (s *DropGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropGroupProviderStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropGroupProviderStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropGroupProviderStatement(s)
	}
}

func (s *DropGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropGroupProviderStatement(s)
	}
}

func (p *StarRocksParser) DropGroupProviderStatement() (localctx IDropGroupProviderStatementContext) {
	localctx = NewDropGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, StarRocksParserRULE_dropGroupProviderStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5153)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5154)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5155)
		p.Match(StarRocksParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5156)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5157)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5160)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowGroupProvidersStatementContext is an interface to support dynamic dispatch.
type IShowGroupProvidersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDERS() antlr.TerminalNode

	// IsShowGroupProvidersStatementContext differentiates from other interfaces.
	IsShowGroupProvidersStatementContext()
}

type ShowGroupProvidersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowGroupProvidersStatementContext() *ShowGroupProvidersStatementContext {
	var p = new(ShowGroupProvidersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showGroupProvidersStatement
	return p
}

func InitEmptyShowGroupProvidersStatementContext(p *ShowGroupProvidersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showGroupProvidersStatement
}

func (*ShowGroupProvidersStatementContext) IsShowGroupProvidersStatementContext() {}

func NewShowGroupProvidersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowGroupProvidersStatementContext {
	var p = new(ShowGroupProvidersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showGroupProvidersStatement

	return p
}

func (s *ShowGroupProvidersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowGroupProvidersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowGroupProvidersStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *ShowGroupProvidersStatementContext) PROVIDERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDERS, 0)
}

func (s *ShowGroupProvidersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowGroupProvidersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowGroupProvidersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowGroupProvidersStatement(s)
	}
}

func (s *ShowGroupProvidersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowGroupProvidersStatement(s)
	}
}

func (p *StarRocksParser) ShowGroupProvidersStatement() (localctx IShowGroupProvidersStatementContext) {
	localctx = NewShowGroupProvidersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, StarRocksParserRULE_showGroupProvidersStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5162)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5163)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5164)
		p.Match(StarRocksParserPROVIDERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCreateGroupProviderStatementContext is an interface to support dynamic dispatch.
type IShowCreateGroupProviderStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CREATE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowCreateGroupProviderStatementContext differentiates from other interfaces.
	IsShowCreateGroupProviderStatementContext()
}

type ShowCreateGroupProviderStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCreateGroupProviderStatementContext() *ShowCreateGroupProviderStatementContext {
	var p = new(ShowCreateGroupProviderStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateGroupProviderStatement
	return p
}

func InitEmptyShowCreateGroupProviderStatementContext(p *ShowCreateGroupProviderStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showCreateGroupProviderStatement
}

func (*ShowCreateGroupProviderStatementContext) IsShowCreateGroupProviderStatementContext() {}

func NewShowCreateGroupProviderStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCreateGroupProviderStatementContext {
	var p = new(ShowCreateGroupProviderStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showCreateGroupProviderStatement

	return p
}

func (s *ShowCreateGroupProviderStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCreateGroupProviderStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowCreateGroupProviderStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *ShowCreateGroupProviderStatementContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *ShowCreateGroupProviderStatementContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDER, 0)
}

func (s *ShowCreateGroupProviderStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowCreateGroupProviderStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCreateGroupProviderStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCreateGroupProviderStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowCreateGroupProviderStatement(s)
	}
}

func (s *ShowCreateGroupProviderStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowCreateGroupProviderStatement(s)
	}
}

func (p *StarRocksParser) ShowCreateGroupProviderStatement() (localctx IShowCreateGroupProviderStatementContext) {
	localctx = NewShowCreateGroupProviderStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, StarRocksParserRULE_showCreateGroupProviderStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5166)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5167)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5168)
		p.Match(StarRocksParserGROUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5169)
		p.Match(StarRocksParserPROVIDER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5170)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupStatementContext is an interface to support dynamic dispatch.
type IBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// Getter signatures
	BACKUP() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	TO() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ALL() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DATABASE() antlr.TerminalNode
	ON() antlr.TerminalNode
	AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext
	BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	CATALOG() antlr.TerminalNode

	// IsBackupStatementContext differentiates from other interfaces.
	IsBackupStatementContext()
}

type BackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	dbName   IIdentifierContext
	repoName IIdentifierContext
}

func NewEmptyBackupStatementContext() *BackupStatementContext {
	var p = new(BackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupStatement
	return p
}

func InitEmptyBackupStatementContext(p *BackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupStatement
}

func (*BackupStatementContext) IsBackupStatementContext() {}

func NewBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupStatementContext {
	var p = new(BackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_backupStatement

	return p
}

func (s *BackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupStatementContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *BackupStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *BackupStatementContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *BackupStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *BackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKUP, 0)
}

func (s *BackupStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *BackupStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *BackupStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BackupStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *BackupStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *BackupStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *BackupStatementContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *BackupStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *BackupStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *BackupStatementContext) AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			len++
		}
	}

	tst := make([]IBackupRestoreObjectDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			tst[i] = t.(IBackupRestoreObjectDescContext)
			i++
		}
	}

	return tst
}

func (s *BackupStatementContext) BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreObjectDescContext)
}

func (s *BackupStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *BackupStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *BackupStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *BackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBackupStatement(s)
	}
}

func (s *BackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBackupStatement(s)
	}
}

func (p *StarRocksParser) BackupStatement() (localctx IBackupStatementContext) {
	localctx = NewBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, StarRocksParserRULE_backupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5172)
		p.Match(StarRocksParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserALL:
		{
			p.SetState(5173)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5174)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5175)
			p.Match(StarRocksParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEXTERNAL:
		{
			p.SetState(5176)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5177)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserCATALOG || _la == StarRocksParserCATALOGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5178)
			p.IdentifierList()
		}

	case StarRocksParserDATABASE, StarRocksParserSNAPSHOT:

	default:
	}
	p.SetState(5183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDATABASE {
		{
			p.SetState(5181)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5182)

			var _x = p.Identifier()

			localctx.(*BackupStatementContext).dbName = _x
		}

	}
	{
		p.SetState(5185)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5186)
		p.QualifiedName()
	}
	{
		p.SetState(5187)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5188)

		var _x = p.Identifier()

		localctx.(*BackupStatementContext).repoName = _x
	}
	p.SetState(5201)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserON {
		{
			p.SetState(5189)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5190)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5191)
			p.BackupRestoreObjectDesc()
		}
		p.SetState(5196)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5192)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5193)
				p.BackupRestoreObjectDesc()
			}

			p.SetState(5198)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5199)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5205)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5203)
			p.Match(StarRocksParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5204)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelBackupStatementContext is an interface to support dynamic dispatch.
type ICancelBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsCancelBackupStatementContext differentiates from other interfaces.
	IsCancelBackupStatementContext()
}

type CancelBackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelBackupStatementContext() *CancelBackupStatementContext {
	var p = new(CancelBackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelBackupStatement
	return p
}

func InitEmptyCancelBackupStatementContext(p *CancelBackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelBackupStatement
}

func (*CancelBackupStatementContext) IsCancelBackupStatementContext() {}

func NewCancelBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelBackupStatementContext {
	var p = new(CancelBackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelBackupStatement

	return p
}

func (s *CancelBackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelBackupStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelBackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKUP, 0)
}

func (s *CancelBackupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelBackupStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *CancelBackupStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CancelBackupStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *CancelBackupStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelBackupStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *CancelBackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelBackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelBackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelBackupStatement(s)
	}
}

func (s *CancelBackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelBackupStatement(s)
	}
}

func (p *StarRocksParser) CancelBackupStatement() (localctx ICancelBackupStatementContext) {
	localctx = NewCancelBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, StarRocksParserRULE_cancelBackupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5207)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5208)
		p.Match(StarRocksParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFROM, StarRocksParserIN:
		{
			p.SetState(5209)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5210)
			p.Identifier()
		}

	case StarRocksParserFOR:
		{
			p.SetState(5211)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5212)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5213)
			p.Match(StarRocksParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackupStatementContext is an interface to support dynamic dispatch.
type IShowBackupStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsShowBackupStatementContext differentiates from other interfaces.
	IsShowBackupStatementContext()
}

type ShowBackupStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackupStatementContext() *ShowBackupStatementContext {
	var p = new(ShowBackupStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackupStatement
	return p
}

func InitEmptyShowBackupStatementContext(p *ShowBackupStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackupStatement
}

func (*ShowBackupStatementContext) IsShowBackupStatementContext() {}

func NewShowBackupStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackupStatementContext {
	var p = new(ShowBackupStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBackupStatement

	return p
}

func (s *ShowBackupStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackupStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBackupStatementContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKUP, 0)
}

func (s *ShowBackupStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowBackupStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowBackupStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowBackupStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackupStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackupStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBackupStatement(s)
	}
}

func (s *ShowBackupStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBackupStatement(s)
	}
}

func (p *StarRocksParser) ShowBackupStatement() (localctx IShowBackupStatementContext) {
	localctx = NewShowBackupStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, StarRocksParserRULE_showBackupStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5216)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5217)
		p.Match(StarRocksParserBACKUP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5220)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5218)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5219)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRestoreStatementContext is an interface to support dynamic dispatch.
type IRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// GetDbName returns the dbName rule contexts.
	GetDbName() IIdentifierContext

	// GetDbAlias returns the dbAlias rule contexts.
	GetDbAlias() IIdentifierContext

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// SetDbName sets the dbName rule contexts.
	SetDbName(IIdentifierContext)

	// SetDbAlias sets the dbAlias rule contexts.
	SetDbAlias(IIdentifierContext)

	// Getter signatures
	RESTORE() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FROM() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	ALL() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	IdentifierWithAliasList() IIdentifierWithAliasListContext
	DATABASE() antlr.TerminalNode
	ON() antlr.TerminalNode
	AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext
	BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	CATALOG() antlr.TerminalNode
	AS() antlr.TerminalNode

	// IsRestoreStatementContext differentiates from other interfaces.
	IsRestoreStatementContext()
}

type RestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	repoName IIdentifierContext
	dbName   IIdentifierContext
	dbAlias  IIdentifierContext
}

func NewEmptyRestoreStatementContext() *RestoreStatementContext {
	var p = new(RestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_restoreStatement
	return p
}

func InitEmptyRestoreStatementContext(p *RestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_restoreStatement
}

func (*RestoreStatementContext) IsRestoreStatementContext() {}

func NewRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestoreStatementContext {
	var p = new(RestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_restoreStatement

	return p
}

func (s *RestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RestoreStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *RestoreStatementContext) GetDbName() IIdentifierContext { return s.dbName }

func (s *RestoreStatementContext) GetDbAlias() IIdentifierContext { return s.dbAlias }

func (s *RestoreStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *RestoreStatementContext) SetDbName(v IIdentifierContext) { s.dbName = v }

func (s *RestoreStatementContext) SetDbAlias(v IIdentifierContext) { s.dbAlias = v }

func (s *RestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESTORE, 0)
}

func (s *RestoreStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *RestoreStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *RestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *RestoreStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *RestoreStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RestoreStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *RestoreStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *RestoreStatementContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *RestoreStatementContext) IdentifierWithAliasList() IIdentifierWithAliasListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierWithAliasListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierWithAliasListContext)
}

func (s *RestoreStatementContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *RestoreStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *RestoreStatementContext) AllBackupRestoreObjectDesc() []IBackupRestoreObjectDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			len++
		}
	}

	tst := make([]IBackupRestoreObjectDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			tst[i] = t.(IBackupRestoreObjectDescContext)
			i++
		}
	}

	return tst
}

func (s *RestoreStatementContext) BackupRestoreObjectDesc(i int) IBackupRestoreObjectDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreObjectDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreObjectDescContext)
}

func (s *RestoreStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *RestoreStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *RestoreStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *RestoreStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *RestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRestoreStatement(s)
	}
}

func (s *RestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRestoreStatement(s)
	}
}

func (p *StarRocksParser) RestoreStatement() (localctx IRestoreStatementContext) {
	localctx = NewRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, StarRocksParserRULE_restoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5222)
		p.Match(StarRocksParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5223)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5224)
		p.QualifiedName()
	}
	{
		p.SetState(5225)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5226)

		var _x = p.Identifier()

		localctx.(*RestoreStatementContext).repoName = _x
	}
	p.SetState(5233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserALL:
		{
			p.SetState(5227)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5228)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5229)
			p.Match(StarRocksParserCATALOGS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEXTERNAL:
		{
			p.SetState(5230)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5231)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserCATALOG || _la == StarRocksParserCATALOGS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5232)
			p.IdentifierWithAliasList()
		}

	case StarRocksParserEOF, StarRocksParserDATABASE, StarRocksParserON, StarRocksParserPROPERTIES, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(5241)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDATABASE {
		{
			p.SetState(5235)
			p.Match(StarRocksParserDATABASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5236)

			var _x = p.Identifier()

			localctx.(*RestoreStatementContext).dbName = _x
		}
		p.SetState(5239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS {
			{
				p.SetState(5237)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5238)

				var _x = p.Identifier()

				localctx.(*RestoreStatementContext).dbAlias = _x
			}

		}

	}
	p.SetState(5255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserON {
		{
			p.SetState(5243)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5244)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5245)
			p.BackupRestoreObjectDesc()
		}
		p.SetState(5250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5246)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5247)
				p.BackupRestoreObjectDesc()
			}

			p.SetState(5252)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(5253)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5259)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5257)
			p.Match(StarRocksParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5258)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelRestoreStatementContext is an interface to support dynamic dispatch.
type ICancelRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CANCEL() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode

	// IsCancelRestoreStatementContext differentiates from other interfaces.
	IsCancelRestoreStatementContext()
}

type CancelRestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelRestoreStatementContext() *CancelRestoreStatementContext {
	var p = new(CancelRestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRestoreStatement
	return p
}

func InitEmptyCancelRestoreStatementContext(p *CancelRestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelRestoreStatement
}

func (*CancelRestoreStatementContext) IsCancelRestoreStatementContext() {}

func NewCancelRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelRestoreStatementContext {
	var p = new(CancelRestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelRestoreStatement

	return p
}

func (s *CancelRestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelRestoreStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelRestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESTORE, 0)
}

func (s *CancelRestoreStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelRestoreStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *CancelRestoreStatementContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *CancelRestoreStatementContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *CancelRestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelRestoreStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *CancelRestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelRestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelRestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelRestoreStatement(s)
	}
}

func (s *CancelRestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelRestoreStatement(s)
	}
}

func (p *StarRocksParser) CancelRestoreStatement() (localctx ICancelRestoreStatementContext) {
	localctx = NewCancelRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, StarRocksParserRULE_cancelRestoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5261)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5262)
		p.Match(StarRocksParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserFROM, StarRocksParserIN:
		{
			p.SetState(5263)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5264)
			p.Identifier()
		}

	case StarRocksParserFOR:
		{
			p.SetState(5265)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5266)
			p.Match(StarRocksParserEXTERNAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5267)
			p.Match(StarRocksParserCATALOG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowRestoreStatementContext is an interface to support dynamic dispatch.
type IShowRestoreStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowRestoreStatementContext differentiates from other interfaces.
	IsShowRestoreStatementContext()
}

type ShowRestoreStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyShowRestoreStatementContext() *ShowRestoreStatementContext {
	var p = new(ShowRestoreStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRestoreStatement
	return p
}

func InitEmptyShowRestoreStatementContext(p *ShowRestoreStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showRestoreStatement
}

func (*ShowRestoreStatementContext) IsShowRestoreStatementContext() {}

func NewShowRestoreStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowRestoreStatementContext {
	var p = new(ShowRestoreStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showRestoreStatement

	return p
}

func (s *ShowRestoreStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowRestoreStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *ShowRestoreStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *ShowRestoreStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowRestoreStatementContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESTORE, 0)
}

func (s *ShowRestoreStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowRestoreStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowRestoreStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowRestoreStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowRestoreStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowRestoreStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowRestoreStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowRestoreStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowRestoreStatement(s)
	}
}

func (s *ShowRestoreStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowRestoreStatement(s)
	}
}

func (p *StarRocksParser) ShowRestoreStatement() (localctx IShowRestoreStatementContext) {
	localctx = NewShowRestoreStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, StarRocksParserRULE_showRestoreStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5270)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5271)
		p.Match(StarRocksParserRESTORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5274)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5272)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5273)
			p.Identifier()
		}

	}
	p.SetState(5278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(5276)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5277)

			var _x = p.expression(0)

			localctx.(*ShowRestoreStatementContext).where = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSnapshotStatementContext is an interface to support dynamic dispatch.
type IShowSnapshotStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	ON() antlr.TerminalNode
	Identifier() IIdentifierContext
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext

	// IsShowSnapshotStatementContext differentiates from other interfaces.
	IsShowSnapshotStatementContext()
}

type ShowSnapshotStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSnapshotStatementContext() *ShowSnapshotStatementContext {
	var p = new(ShowSnapshotStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSnapshotStatement
	return p
}

func InitEmptyShowSnapshotStatementContext(p *ShowSnapshotStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSnapshotStatement
}

func (*ShowSnapshotStatementContext) IsShowSnapshotStatementContext() {}

func NewShowSnapshotStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSnapshotStatementContext {
	var p = new(ShowSnapshotStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showSnapshotStatement

	return p
}

func (s *ShowSnapshotStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSnapshotStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowSnapshotStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *ShowSnapshotStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *ShowSnapshotStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowSnapshotStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowSnapshotStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowSnapshotStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSnapshotStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSnapshotStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowSnapshotStatement(s)
	}
}

func (s *ShowSnapshotStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowSnapshotStatement(s)
	}
}

func (p *StarRocksParser) ShowSnapshotStatement() (localctx IShowSnapshotStatementContext) {
	localctx = NewShowSnapshotStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, StarRocksParserRULE_showSnapshotStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5280)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5281)
		p.Match(StarRocksParserSNAPSHOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5282)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5283)
		p.Identifier()
	}
	p.SetState(5286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(5284)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5285)
			p.expression(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateRepositoryStatementContext is an interface to support dynamic dispatch.
type ICreateRepositoryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRepoName returns the repoName rule contexts.
	GetRepoName() IIdentifierContext

	// GetBrokerName returns the brokerName rule contexts.
	GetBrokerName() IIdentifierOrStringContext

	// GetLocation returns the location rule contexts.
	GetLocation() IStringContext

	// SetRepoName sets the repoName rule contexts.
	SetRepoName(IIdentifierContext)

	// SetBrokerName sets the brokerName rule contexts.
	SetBrokerName(IIdentifierOrStringContext)

	// SetLocation sets the location rule contexts.
	SetLocation(IStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	WITH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	ON() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PropertyList() IPropertyListContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsCreateRepositoryStatementContext differentiates from other interfaces.
	IsCreateRepositoryStatementContext()
}

type CreateRepositoryStatementContext struct {
	antlr.BaseParserRuleContext
	parser     antlr.Parser
	repoName   IIdentifierContext
	brokerName IIdentifierOrStringContext
	location   IStringContext
}

func NewEmptyCreateRepositoryStatementContext() *CreateRepositoryStatementContext {
	var p = new(CreateRepositoryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRepositoryStatement
	return p
}

func InitEmptyCreateRepositoryStatementContext(p *CreateRepositoryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createRepositoryStatement
}

func (*CreateRepositoryStatementContext) IsCreateRepositoryStatementContext() {}

func NewCreateRepositoryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateRepositoryStatementContext {
	var p = new(CreateRepositoryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createRepositoryStatement

	return p
}

func (s *CreateRepositoryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateRepositoryStatementContext) GetRepoName() IIdentifierContext { return s.repoName }

func (s *CreateRepositoryStatementContext) GetBrokerName() IIdentifierOrStringContext {
	return s.brokerName
}

func (s *CreateRepositoryStatementContext) GetLocation() IStringContext { return s.location }

func (s *CreateRepositoryStatementContext) SetRepoName(v IIdentifierContext) { s.repoName = v }

func (s *CreateRepositoryStatementContext) SetBrokerName(v IIdentifierOrStringContext) {
	s.brokerName = v
}

func (s *CreateRepositoryStatementContext) SetLocation(v IStringContext) { s.location = v }

func (s *CreateRepositoryStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateRepositoryStatementContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORY, 0)
}

func (s *CreateRepositoryStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *CreateRepositoryStatementContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *CreateRepositoryStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *CreateRepositoryStatementContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCATION, 0)
}

func (s *CreateRepositoryStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateRepositoryStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateRepositoryStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREAD, 0)
}

func (s *CreateRepositoryStatementContext) ONLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserONLY, 0)
}

func (s *CreateRepositoryStatementContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *CreateRepositoryStatementContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *CreateRepositoryStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateRepositoryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateRepositoryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateRepositoryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateRepositoryStatement(s)
	}
}

func (s *CreateRepositoryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateRepositoryStatement(s)
	}
}

func (p *StarRocksParser) CreateRepositoryStatement() (localctx ICreateRepositoryStatementContext) {
	localctx = NewCreateRepositoryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, StarRocksParserRULE_createRepositoryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5288)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserREAD {
		{
			p.SetState(5289)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5290)
			p.Match(StarRocksParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5293)
		p.Match(StarRocksParserREPOSITORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5294)

		var _x = p.Identifier()

		localctx.(*CreateRepositoryStatementContext).repoName = _x
	}
	{
		p.SetState(5295)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5296)
		p.Match(StarRocksParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&7557330222697660093) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-4653295000587626501) != 0) || ((int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&-3747053846437727955) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&8790990742223650807) != 0) || ((int64((_la-326)) & ^0x3f) == 0 && ((int64(1)<<(_la-326))&-5479769140411580417) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&3742173942658366679) != 0) || ((int64((_la-454)) & ^0x3f) == 0 && ((int64(1)<<(_la-454))&8856199495341) != 0) || ((int64((_la-519)) & ^0x3f) == 0 && ((int64(1)<<(_la-519))&4211) != 0) {
		{
			p.SetState(5297)

			var _x = p.IdentifierOrString()

			localctx.(*CreateRepositoryStatementContext).brokerName = _x
		}

	}
	{
		p.SetState(5300)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5301)
		p.Match(StarRocksParserLOCATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5302)

		var _x = p.String_()

		localctx.(*CreateRepositoryStatementContext).location = _x
	}
	p.SetState(5305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5303)
			p.Match(StarRocksParserPROPERTIES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5304)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropRepositoryStatementContext is an interface to support dynamic dispatch.
type IDropRepositoryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDropRepositoryStatementContext differentiates from other interfaces.
	IsDropRepositoryStatementContext()
}

type DropRepositoryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropRepositoryStatementContext() *DropRepositoryStatementContext {
	var p = new(DropRepositoryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropRepositoryStatement
	return p
}

func InitEmptyDropRepositoryStatementContext(p *DropRepositoryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropRepositoryStatement
}

func (*DropRepositoryStatementContext) IsDropRepositoryStatementContext() {}

func NewDropRepositoryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropRepositoryStatementContext {
	var p = new(DropRepositoryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropRepositoryStatement

	return p
}

func (s *DropRepositoryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropRepositoryStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropRepositoryStatementContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORY, 0)
}

func (s *DropRepositoryStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DropRepositoryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropRepositoryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropRepositoryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropRepositoryStatement(s)
	}
}

func (s *DropRepositoryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropRepositoryStatement(s)
	}
}

func (p *StarRocksParser) DropRepositoryStatement() (localctx IDropRepositoryStatementContext) {
	localctx = NewDropRepositoryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, StarRocksParserRULE_dropRepositoryStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5307)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5308)
		p.Match(StarRocksParserREPOSITORY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5309)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IAddSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	String_() IStringContext

	// IsAddSqlBlackListStatementContext differentiates from other interfaces.
	IsAddSqlBlackListStatementContext()
}

type AddSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddSqlBlackListStatementContext() *AddSqlBlackListStatementContext {
	var p = new(AddSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addSqlBlackListStatement
	return p
}

func InitEmptyAddSqlBlackListStatementContext(p *AddSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addSqlBlackListStatement
}

func (*AddSqlBlackListStatementContext) IsAddSqlBlackListStatementContext() {}

func NewAddSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddSqlBlackListStatementContext {
	var p = new(AddSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addSqlBlackListStatement

	return p
}

func (s *AddSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddSqlBlackListStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSQLBLACKLIST, 0)
}

func (s *AddSqlBlackListStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AddSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddSqlBlackListStatement(s)
	}
}

func (s *AddSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddSqlBlackListStatement(s)
	}
}

func (p *StarRocksParser) AddSqlBlackListStatement() (localctx IAddSqlBlackListStatementContext) {
	localctx = NewAddSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, StarRocksParserRULE_addSqlBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5311)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5312)
		p.Match(StarRocksParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5313)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IDelSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDelSqlBlackListStatementContext differentiates from other interfaces.
	IsDelSqlBlackListStatementContext()
}

type DelSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelSqlBlackListStatementContext() *DelSqlBlackListStatementContext {
	var p = new(DelSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_delSqlBlackListStatement
	return p
}

func InitEmptyDelSqlBlackListStatementContext(p *DelSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_delSqlBlackListStatement
}

func (*DelSqlBlackListStatementContext) IsDelSqlBlackListStatementContext() {}

func NewDelSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelSqlBlackListStatementContext {
	var p = new(DelSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_delSqlBlackListStatement

	return p
}

func (s *DelSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelSqlBlackListStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *DelSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSQLBLACKLIST, 0)
}

func (s *DelSqlBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *DelSqlBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *DelSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDelSqlBlackListStatement(s)
	}
}

func (s *DelSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDelSqlBlackListStatement(s)
	}
}

func (p *StarRocksParser) DelSqlBlackListStatement() (localctx IDelSqlBlackListStatementContext) {
	localctx = NewDelSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, StarRocksParserRULE_delSqlBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5315)
		p.Match(StarRocksParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5316)
		p.Match(StarRocksParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5317)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5318)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5319)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5324)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSqlBlackListStatementContext is an interface to support dynamic dispatch.
type IShowSqlBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode

	// IsShowSqlBlackListStatementContext differentiates from other interfaces.
	IsShowSqlBlackListStatementContext()
}

type ShowSqlBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowSqlBlackListStatementContext() *ShowSqlBlackListStatementContext {
	var p = new(ShowSqlBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSqlBlackListStatement
	return p
}

func InitEmptyShowSqlBlackListStatementContext(p *ShowSqlBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSqlBlackListStatement
}

func (*ShowSqlBlackListStatementContext) IsShowSqlBlackListStatementContext() {}

func NewShowSqlBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSqlBlackListStatementContext {
	var p = new(ShowSqlBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showSqlBlackListStatement

	return p
}

func (s *ShowSqlBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSqlBlackListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowSqlBlackListStatementContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSQLBLACKLIST, 0)
}

func (s *ShowSqlBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSqlBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSqlBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowSqlBlackListStatement(s)
	}
}

func (s *ShowSqlBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowSqlBlackListStatement(s)
	}
}

func (p *StarRocksParser) ShowSqlBlackListStatement() (localctx IShowSqlBlackListStatementContext) {
	localctx = NewShowSqlBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, StarRocksParserRULE_showSqlBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5325)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5326)
		p.Match(StarRocksParserSQLBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWhiteListStatementContext is an interface to support dynamic dispatch.
type IShowWhiteListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	WHITELIST() antlr.TerminalNode

	// IsShowWhiteListStatementContext differentiates from other interfaces.
	IsShowWhiteListStatementContext()
}

type ShowWhiteListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowWhiteListStatementContext() *ShowWhiteListStatementContext {
	var p = new(ShowWhiteListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWhiteListStatement
	return p
}

func InitEmptyShowWhiteListStatementContext(p *ShowWhiteListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWhiteListStatement
}

func (*ShowWhiteListStatementContext) IsShowWhiteListStatementContext() {}

func NewShowWhiteListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWhiteListStatementContext {
	var p = new(ShowWhiteListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showWhiteListStatement

	return p
}

func (s *ShowWhiteListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWhiteListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowWhiteListStatementContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHITELIST, 0)
}

func (s *ShowWhiteListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWhiteListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWhiteListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowWhiteListStatement(s)
	}
}

func (s *ShowWhiteListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowWhiteListStatement(s)
	}
}

func (p *StarRocksParser) ShowWhiteListStatement() (localctx IShowWhiteListStatementContext) {
	localctx = NewShowWhiteListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, StarRocksParserRULE_showWhiteListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5328)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5329)
		p.Match(StarRocksParserWHITELIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAddBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IAddBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADD() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsAddBackendBlackListStatementContext differentiates from other interfaces.
	IsAddBackendBlackListStatementContext()
}

type AddBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddBackendBlackListStatementContext() *AddBackendBlackListStatementContext {
	var p = new(AddBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addBackendBlackListStatement
	return p
}

func InitEmptyAddBackendBlackListStatementContext(p *AddBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_addBackendBlackListStatement
}

func (*AddBackendBlackListStatementContext) IsAddBackendBlackListStatementContext() {}

func NewAddBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddBackendBlackListStatementContext {
	var p = new(AddBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_addBackendBlackListStatement

	return p
}

func (s *AddBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddBackendBlackListStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AddBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *AddBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *AddBackendBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *AddBackendBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *AddBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAddBackendBlackListStatement(s)
	}
}

func (s *AddBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAddBackendBlackListStatement(s)
	}
}

func (p *StarRocksParser) AddBackendBlackListStatement() (localctx IAddBackendBlackListStatementContext) {
	localctx = NewAddBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, StarRocksParserRULE_addBackendBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5331)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5332)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5333)
		p.Match(StarRocksParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5334)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5335)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5336)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5341)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDelBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IDelBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DELETE() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDelBackendBlackListStatementContext differentiates from other interfaces.
	IsDelBackendBlackListStatementContext()
}

type DelBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDelBackendBlackListStatementContext() *DelBackendBlackListStatementContext {
	var p = new(DelBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_delBackendBlackListStatement
	return p
}

func InitEmptyDelBackendBlackListStatementContext(p *DelBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_delBackendBlackListStatement
}

func (*DelBackendBlackListStatementContext) IsDelBackendBlackListStatementContext() {}

func NewDelBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DelBackendBlackListStatementContext {
	var p = new(DelBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_delBackendBlackListStatement

	return p
}

func (s *DelBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DelBackendBlackListStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDELETE, 0)
}

func (s *DelBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *DelBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *DelBackendBlackListStatementContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *DelBackendBlackListStatementContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *DelBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DelBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DelBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDelBackendBlackListStatement(s)
	}
}

func (s *DelBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDelBackendBlackListStatement(s)
	}
}

func (p *StarRocksParser) DelBackendBlackListStatement() (localctx IDelBackendBlackListStatementContext) {
	localctx = NewDelBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, StarRocksParserRULE_delBackendBlackListStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5342)
		p.Match(StarRocksParserDELETE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5343)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5344)
		p.Match(StarRocksParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5345)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5346)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5347)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(5352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowBackendBlackListStatementContext is an interface to support dynamic dispatch.
type IShowBackendBlackListStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode

	// IsShowBackendBlackListStatementContext differentiates from other interfaces.
	IsShowBackendBlackListStatementContext()
}

type ShowBackendBlackListStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowBackendBlackListStatementContext() *ShowBackendBlackListStatementContext {
	var p = new(ShowBackendBlackListStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackendBlackListStatement
	return p
}

func InitEmptyShowBackendBlackListStatementContext(p *ShowBackendBlackListStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showBackendBlackListStatement
}

func (*ShowBackendBlackListStatementContext) IsShowBackendBlackListStatementContext() {}

func NewShowBackendBlackListStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowBackendBlackListStatementContext {
	var p = new(ShowBackendBlackListStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showBackendBlackListStatement

	return p
}

func (s *ShowBackendBlackListStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowBackendBlackListStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowBackendBlackListStatementContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *ShowBackendBlackListStatementContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *ShowBackendBlackListStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowBackendBlackListStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowBackendBlackListStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowBackendBlackListStatement(s)
	}
}

func (s *ShowBackendBlackListStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowBackendBlackListStatement(s)
	}
}

func (p *StarRocksParser) ShowBackendBlackListStatement() (localctx IShowBackendBlackListStatementContext) {
	localctx = NewShowBackendBlackListStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, StarRocksParserRULE_showBackendBlackListStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5353)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5354)
		p.Match(StarRocksParserBACKEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5355)
		p.Match(StarRocksParserBLACKLIST)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCacheTargetContext is an interface to support dynamic dispatch.
type IDataCacheTargetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext
	IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext

	// IsDataCacheTargetContext differentiates from other interfaces.
	IsDataCacheTargetContext()
}

type DataCacheTargetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCacheTargetContext() *DataCacheTargetContext {
	var p = new(DataCacheTargetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataCacheTarget
	return p
}

func InitEmptyDataCacheTargetContext(p *DataCacheTargetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataCacheTarget
}

func (*DataCacheTargetContext) IsDataCacheTargetContext() {}

func NewDataCacheTargetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCacheTargetContext {
	var p = new(DataCacheTargetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataCacheTarget

	return p
}

func (s *DataCacheTargetContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCacheTargetContext) AllIdentifierOrStringOrStar() []IIdentifierOrStringOrStarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringOrStarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			tst[i] = t.(IIdentifierOrStringOrStarContext)
			i++
		}
	}

	return tst
}

func (s *DataCacheTargetContext) IdentifierOrStringOrStar(i int) IIdentifierOrStringOrStarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringOrStarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringOrStarContext)
}

func (s *DataCacheTargetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCacheTargetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCacheTargetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataCacheTarget(s)
	}
}

func (s *DataCacheTargetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataCacheTarget(s)
	}
}

func (p *StarRocksParser) DataCacheTarget() (localctx IDataCacheTargetContext) {
	localctx = NewDataCacheTargetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, StarRocksParserRULE_dataCacheTarget)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5357)
		p.IdentifierOrStringOrStar()
	}
	{
		p.SetState(5358)
		p.Match(StarRocksParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5359)
		p.IdentifierOrStringOrStar()
	}
	{
		p.SetState(5360)
		p.Match(StarRocksParserT__0)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5361)
		p.IdentifierOrStringOrStar()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateDataCacheRuleStatementContext is an interface to support dynamic dispatch.
type ICreateDataCacheRuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULE() antlr.TerminalNode
	DataCacheTarget() IDataCacheTargetContext
	PRIORITY() antlr.TerminalNode
	EQ() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	MINUS_SYMBOL() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsCreateDataCacheRuleStatementContext differentiates from other interfaces.
	IsCreateDataCacheRuleStatementContext()
}

type CreateDataCacheRuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateDataCacheRuleStatementContext() *CreateDataCacheRuleStatementContext {
	var p = new(CreateDataCacheRuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDataCacheRuleStatement
	return p
}

func InitEmptyCreateDataCacheRuleStatementContext(p *CreateDataCacheRuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createDataCacheRuleStatement
}

func (*CreateDataCacheRuleStatementContext) IsCreateDataCacheRuleStatementContext() {}

func NewCreateDataCacheRuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateDataCacheRuleStatementContext {
	var p = new(CreateDataCacheRuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createDataCacheRuleStatement

	return p
}

func (s *CreateDataCacheRuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateDataCacheRuleStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateDataCacheRuleStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *CreateDataCacheRuleStatementContext) RULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULE, 0)
}

func (s *CreateDataCacheRuleStatementContext) DataCacheTarget() IDataCacheTargetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCacheTargetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCacheTargetContext)
}

func (s *CreateDataCacheRuleStatementContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIORITY, 0)
}

func (s *CreateDataCacheRuleStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *CreateDataCacheRuleStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *CreateDataCacheRuleStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *CreateDataCacheRuleStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CreateDataCacheRuleStatementContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS_SYMBOL, 0)
}

func (s *CreateDataCacheRuleStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateDataCacheRuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateDataCacheRuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateDataCacheRuleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateDataCacheRuleStatement(s)
	}
}

func (s *CreateDataCacheRuleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateDataCacheRuleStatement(s)
	}
}

func (p *StarRocksParser) CreateDataCacheRuleStatement() (localctx ICreateDataCacheRuleStatementContext) {
	localctx = NewCreateDataCacheRuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, StarRocksParserRULE_createDataCacheRuleStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5363)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5364)
		p.Match(StarRocksParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5365)
		p.Match(StarRocksParserRULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5366)
		p.DataCacheTarget()
	}
	p.SetState(5369)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(5367)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5368)
			p.expression(0)
		}

	}
	{
		p.SetState(5371)
		p.Match(StarRocksParserPRIORITY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5372)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5374)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserMINUS_SYMBOL {
		{
			p.SetState(5373)
			p.Match(StarRocksParserMINUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5376)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5378)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5377)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowDataCacheRulesStatementContext is an interface to support dynamic dispatch.
type IShowDataCacheRulesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULES() antlr.TerminalNode

	// IsShowDataCacheRulesStatementContext differentiates from other interfaces.
	IsShowDataCacheRulesStatementContext()
}

type ShowDataCacheRulesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowDataCacheRulesStatementContext() *ShowDataCacheRulesStatementContext {
	var p = new(ShowDataCacheRulesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataCacheRulesStatement
	return p
}

func InitEmptyShowDataCacheRulesStatementContext(p *ShowDataCacheRulesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showDataCacheRulesStatement
}

func (*ShowDataCacheRulesStatementContext) IsShowDataCacheRulesStatementContext() {}

func NewShowDataCacheRulesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowDataCacheRulesStatementContext {
	var p = new(ShowDataCacheRulesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showDataCacheRulesStatement

	return p
}

func (s *ShowDataCacheRulesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowDataCacheRulesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowDataCacheRulesStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *ShowDataCacheRulesStatementContext) RULES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULES, 0)
}

func (s *ShowDataCacheRulesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowDataCacheRulesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowDataCacheRulesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowDataCacheRulesStatement(s)
	}
}

func (s *ShowDataCacheRulesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowDataCacheRulesStatement(s)
	}
}

func (p *StarRocksParser) ShowDataCacheRulesStatement() (localctx IShowDataCacheRulesStatementContext) {
	localctx = NewShowDataCacheRulesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, StarRocksParserRULE_showDataCacheRulesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5380)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5381)
		p.Match(StarRocksParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5382)
		p.Match(StarRocksParserRULES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropDataCacheRuleStatementContext is an interface to support dynamic dispatch.
type IDropDataCacheRuleStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULE() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDropDataCacheRuleStatementContext differentiates from other interfaces.
	IsDropDataCacheRuleStatementContext()
}

type DropDataCacheRuleStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropDataCacheRuleStatementContext() *DropDataCacheRuleStatementContext {
	var p = new(DropDataCacheRuleStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDataCacheRuleStatement
	return p
}

func InitEmptyDropDataCacheRuleStatementContext(p *DropDataCacheRuleStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropDataCacheRuleStatement
}

func (*DropDataCacheRuleStatementContext) IsDropDataCacheRuleStatementContext() {}

func NewDropDataCacheRuleStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropDataCacheRuleStatementContext {
	var p = new(DropDataCacheRuleStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropDataCacheRuleStatement

	return p
}

func (s *DropDataCacheRuleStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropDataCacheRuleStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropDataCacheRuleStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *DropDataCacheRuleStatementContext) RULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULE, 0)
}

func (s *DropDataCacheRuleStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DropDataCacheRuleStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropDataCacheRuleStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropDataCacheRuleStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropDataCacheRuleStatement(s)
	}
}

func (s *DropDataCacheRuleStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropDataCacheRuleStatement(s)
	}
}

func (p *StarRocksParser) DropDataCacheRuleStatement() (localctx IDropDataCacheRuleStatementContext) {
	localctx = NewDropDataCacheRuleStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, StarRocksParserRULE_dropDataCacheRuleStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5384)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5385)
		p.Match(StarRocksParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5386)
		p.Match(StarRocksParserRULE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5387)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IClearDataCacheRulesStatementContext is an interface to support dynamic dispatch.
type IClearDataCacheRulesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLEAR() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	RULES() antlr.TerminalNode

	// IsClearDataCacheRulesStatementContext differentiates from other interfaces.
	IsClearDataCacheRulesStatementContext()
}

type ClearDataCacheRulesStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClearDataCacheRulesStatementContext() *ClearDataCacheRulesStatementContext {
	var p = new(ClearDataCacheRulesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_clearDataCacheRulesStatement
	return p
}

func InitEmptyClearDataCacheRulesStatementContext(p *ClearDataCacheRulesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_clearDataCacheRulesStatement
}

func (*ClearDataCacheRulesStatementContext) IsClearDataCacheRulesStatementContext() {}

func NewClearDataCacheRulesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClearDataCacheRulesStatementContext {
	var p = new(ClearDataCacheRulesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_clearDataCacheRulesStatement

	return p
}

func (s *ClearDataCacheRulesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClearDataCacheRulesStatementContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAR, 0)
}

func (s *ClearDataCacheRulesStatementContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *ClearDataCacheRulesStatementContext) RULES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULES, 0)
}

func (s *ClearDataCacheRulesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClearDataCacheRulesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClearDataCacheRulesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterClearDataCacheRulesStatement(s)
	}
}

func (s *ClearDataCacheRulesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitClearDataCacheRulesStatement(s)
	}
}

func (p *StarRocksParser) ClearDataCacheRulesStatement() (localctx IClearDataCacheRulesStatementContext) {
	localctx = NewClearDataCacheRulesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, StarRocksParserRULE_clearDataCacheRulesStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5389)
		p.Match(StarRocksParserCLEAR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5390)
		p.Match(StarRocksParserDATACACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5391)
		p.Match(StarRocksParserRULES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataCacheSelectStatementContext is an interface to support dynamic dispatch.
type IDataCacheSelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// Getter signatures
	CACHE() antlr.TerminalNode
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	WHERE() antlr.TerminalNode
	Properties() IPropertiesContext
	Expression() IExpressionContext

	// IsDataCacheSelectStatementContext differentiates from other interfaces.
	IsDataCacheSelectStatementContext()
}

type DataCacheSelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	where  IExpressionContext
}

func NewEmptyDataCacheSelectStatementContext() *DataCacheSelectStatementContext {
	var p = new(DataCacheSelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataCacheSelectStatement
	return p
}

func InitEmptyDataCacheSelectStatementContext(p *DataCacheSelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dataCacheSelectStatement
}

func (*DataCacheSelectStatementContext) IsDataCacheSelectStatementContext() {}

func NewDataCacheSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCacheSelectStatementContext {
	var p = new(DataCacheSelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dataCacheSelectStatement

	return p
}

func (s *DataCacheSelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCacheSelectStatementContext) GetWhere() IExpressionContext { return s.where }

func (s *DataCacheSelectStatementContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *DataCacheSelectStatementContext) CACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCACHE, 0)
}

func (s *DataCacheSelectStatementContext) SELECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSELECT, 0)
}

func (s *DataCacheSelectStatementContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *DataCacheSelectStatementContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *DataCacheSelectStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DataCacheSelectStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DataCacheSelectStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *DataCacheSelectStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DataCacheSelectStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *DataCacheSelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCacheSelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCacheSelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDataCacheSelectStatement(s)
	}
}

func (s *DataCacheSelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDataCacheSelectStatement(s)
	}
}

func (p *StarRocksParser) DataCacheSelectStatement() (localctx IDataCacheSelectStatementContext) {
	localctx = NewDataCacheSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, StarRocksParserRULE_dataCacheSelectStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5393)
		p.Match(StarRocksParserCACHE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5394)
		p.Match(StarRocksParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5395)
		p.SelectItem()
	}
	p.SetState(5400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5396)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5397)
			p.SelectItem()
		}

		p.SetState(5402)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5403)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5404)
		p.QualifiedName()
	}
	p.SetState(5407)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWHERE {
		{
			p.SetState(5405)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5406)

			var _x = p.expression(0)

			localctx.(*DataCacheSelectStatementContext).where = _x
		}

	}
	p.SetState(5410)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5409)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExportStatementContext is an interface to support dynamic dispatch.
type IExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXPORT() antlr.TerminalNode
	TABLE() antlr.TerminalNode
	TableDesc() ITableDescContext
	TO() antlr.TerminalNode
	String_() IStringContext
	ColumnAliases() IColumnAliasesContext
	WITH() antlr.TerminalNode
	MODE() antlr.TerminalNode
	Properties() IPropertiesContext
	BrokerDesc() IBrokerDescContext
	SYNC() antlr.TerminalNode
	ASYNC() antlr.TerminalNode

	// IsExportStatementContext differentiates from other interfaces.
	IsExportStatementContext()
}

type ExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportStatementContext() *ExportStatementContext {
	var p = new(ExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_exportStatement
	return p
}

func InitEmptyExportStatementContext(p *ExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_exportStatement
}

func (*ExportStatementContext) IsExportStatementContext() {}

func NewExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportStatementContext {
	var p = new(ExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_exportStatement

	return p
}

func (s *ExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *ExportStatementContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *ExportStatementContext) TableDesc() ITableDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableDescContext)
}

func (s *ExportStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *ExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExportStatementContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *ExportStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *ExportStatementContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *ExportStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ExportStatementContext) BrokerDesc() IBrokerDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBrokerDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBrokerDescContext)
}

func (s *ExportStatementContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *ExportStatementContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *ExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExportStatement(s)
	}
}

func (s *ExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExportStatement(s)
	}
}

func (p *StarRocksParser) ExportStatement() (localctx IExportStatementContext) {
	localctx = NewExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, StarRocksParserRULE_exportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5412)
		p.Match(StarRocksParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5413)
		p.Match(StarRocksParserTABLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5414)
		p.TableDesc()
	}
	p.SetState(5416)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(5415)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(5418)
		p.Match(StarRocksParserTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5419)
		p.String_()
	}
	p.SetState(5423)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 583, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5420)
			p.Match(StarRocksParserWITH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5421)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASYNC || _la == StarRocksParserSYNC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5422)
			p.Match(StarRocksParserMODE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(5426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5425)
			p.Properties()
		}

	}
	p.SetState(5429)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(5428)
			p.BrokerDesc()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICancelExportStatementContext is an interface to support dynamic dispatch.
type ICancelExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	CANCEL() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsCancelExportStatementContext differentiates from other interfaces.
	IsCancelExportStatementContext()
}

type CancelExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyCancelExportStatementContext() *CancelExportStatementContext {
	var p = new(CancelExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelExportStatement
	return p
}

func InitEmptyCancelExportStatementContext(p *CancelExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_cancelExportStatement
}

func (*CancelExportStatementContext) IsCancelExportStatementContext() {}

func NewCancelExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelExportStatementContext {
	var p = new(CancelExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_cancelExportStatement

	return p
}

func (s *CancelExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelExportStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *CancelExportStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *CancelExportStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *CancelExportStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *CancelExportStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *CancelExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *CancelExportStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CancelExportStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *CancelExportStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CancelExportStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *CancelExportStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *CancelExportStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CancelExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CancelExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCancelExportStatement(s)
	}
}

func (s *CancelExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCancelExportStatement(s)
	}
}

func (p *StarRocksParser) CancelExportStatement() (localctx ICancelExportStatementContext) {
	localctx = NewCancelExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, StarRocksParserRULE_cancelExportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5431)
		p.Match(StarRocksParserCANCEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5432)
		p.Match(StarRocksParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5433)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5434)

			var _x = p.QualifiedName()

			localctx.(*CancelExportStatementContext).catalog = _x
		}

	}
	p.SetState(5441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(5437)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5438)

			var _x = p.String_()

			localctx.(*CancelExportStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(5439)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5440)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserSEMICOLON:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowExportStatementContext is an interface to support dynamic dispatch.
type IShowExportStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	String_() IStringContext

	// IsShowExportStatementContext differentiates from other interfaces.
	IsShowExportStatementContext()
}

type ShowExportStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
	pattern IStringContext
}

func NewEmptyShowExportStatementContext() *ShowExportStatementContext {
	var p = new(ShowExportStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showExportStatement
	return p
}

func InitEmptyShowExportStatementContext(p *ShowExportStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showExportStatement
}

func (*ShowExportStatementContext) IsShowExportStatementContext() {}

func NewShowExportStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowExportStatementContext {
	var p = new(ShowExportStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showExportStatement

	return p
}

func (s *ShowExportStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowExportStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowExportStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowExportStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowExportStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowExportStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowExportStatementContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *ShowExportStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowExportStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowExportStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowExportStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowExportStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowExportStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowExportStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowExportStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowExportStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowExportStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowExportStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowExportStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowExportStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowExportStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowExportStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowExportStatement(s)
	}
}

func (s *ShowExportStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowExportStatement(s)
	}
}

func (p *StarRocksParser) ShowExportStatement() (localctx IShowExportStatementContext) {
	localctx = NewShowExportStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, StarRocksParserRULE_showExportStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5443)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5444)
		p.Match(StarRocksParserEXPORT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5447)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5445)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5446)

			var _x = p.QualifiedName()

			localctx.(*ShowExportStatementContext).catalog = _x
		}

	}
	p.SetState(5453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(5449)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5450)

			var _x = p.String_()

			localctx.(*ShowExportStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(5451)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5452)
			p.expression(0)
		}

	case StarRocksParserEOF, StarRocksParserLIMIT, StarRocksParserORDER, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(5465)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(5455)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5456)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5457)
			p.SortItem()
		}
		p.SetState(5462)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5458)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5459)
				p.SortItem()
			}

			p.SetState(5464)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5468)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(5467)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstallPluginStatementContext is an interface to support dynamic dispatch.
type IInstallPluginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	Properties() IPropertiesContext

	// IsInstallPluginStatementContext differentiates from other interfaces.
	IsInstallPluginStatementContext()
}

type InstallPluginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallPluginStatementContext() *InstallPluginStatementContext {
	var p = new(InstallPluginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_installPluginStatement
	return p
}

func InitEmptyInstallPluginStatementContext(p *InstallPluginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_installPluginStatement
}

func (*InstallPluginStatementContext) IsInstallPluginStatementContext() {}

func NewInstallPluginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallPluginStatementContext {
	var p = new(InstallPluginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_installPluginStatement

	return p
}

func (s *InstallPluginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallPluginStatementContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINSTALL, 0)
}

func (s *InstallPluginStatementContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGIN, 0)
}

func (s *InstallPluginStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *InstallPluginStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *InstallPluginStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *InstallPluginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallPluginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallPluginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInstallPluginStatement(s)
	}
}

func (s *InstallPluginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInstallPluginStatement(s)
	}
}

func (p *StarRocksParser) InstallPluginStatement() (localctx IInstallPluginStatementContext) {
	localctx = NewInstallPluginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, StarRocksParserRULE_installPluginStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5470)
		p.Match(StarRocksParserINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5471)
		p.Match(StarRocksParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5472)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5473)
		p.IdentifierOrString()
	}
	p.SetState(5475)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5474)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUninstallPluginStatementContext is an interface to support dynamic dispatch.
type IUninstallPluginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNINSTALL() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsUninstallPluginStatementContext differentiates from other interfaces.
	IsUninstallPluginStatementContext()
}

type UninstallPluginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUninstallPluginStatementContext() *UninstallPluginStatementContext {
	var p = new(UninstallPluginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_uninstallPluginStatement
	return p
}

func InitEmptyUninstallPluginStatementContext(p *UninstallPluginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_uninstallPluginStatement
}

func (*UninstallPluginStatementContext) IsUninstallPluginStatementContext() {}

func NewUninstallPluginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UninstallPluginStatementContext {
	var p = new(UninstallPluginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_uninstallPluginStatement

	return p
}

func (s *UninstallPluginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UninstallPluginStatementContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNINSTALL, 0)
}

func (s *UninstallPluginStatementContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGIN, 0)
}

func (s *UninstallPluginStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UninstallPluginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UninstallPluginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UninstallPluginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUninstallPluginStatement(s)
	}
}

func (s *UninstallPluginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUninstallPluginStatement(s)
	}
}

func (p *StarRocksParser) UninstallPluginStatement() (localctx IUninstallPluginStatementContext) {
	localctx = NewUninstallPluginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, StarRocksParserRULE_uninstallPluginStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5477)
		p.Match(StarRocksParserUNINSTALL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5478)
		p.Match(StarRocksParserPLUGIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5479)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateFileStatementContext is an interface to support dynamic dispatch.
type ICreateFileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	Properties() IPropertiesContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsCreateFileStatementContext differentiates from other interfaces.
	IsCreateFileStatementContext()
}

type CreateFileStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyCreateFileStatementContext() *CreateFileStatementContext {
	var p = new(CreateFileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createFileStatement
	return p
}

func InitEmptyCreateFileStatementContext(p *CreateFileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createFileStatement
}

func (*CreateFileStatementContext) IsCreateFileStatementContext() {}

func NewCreateFileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateFileStatementContext {
	var p = new(CreateFileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createFileStatement

	return p
}

func (s *CreateFileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateFileStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *CreateFileStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *CreateFileStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateFileStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *CreateFileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CreateFileStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateFileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *CreateFileStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *CreateFileStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreateFileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateFileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateFileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateFileStatement(s)
	}
}

func (s *CreateFileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateFileStatement(s)
	}
}

func (p *StarRocksParser) CreateFileStatement() (localctx ICreateFileStatementContext) {
	localctx = NewCreateFileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, StarRocksParserRULE_createFileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5481)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5482)
		p.Match(StarRocksParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5483)
		p.String_()
	}
	p.SetState(5486)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5484)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5485)

			var _x = p.QualifiedName()

			localctx.(*CreateFileStatementContext).catalog = _x
		}

	}
	{
		p.SetState(5488)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropFileStatementContext is an interface to support dynamic dispatch.
type IDropFileStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	Properties() IPropertiesContext
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsDropFileStatementContext differentiates from other interfaces.
	IsDropFileStatementContext()
}

type DropFileStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyDropFileStatementContext() *DropFileStatementContext {
	var p = new(DropFileStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFileStatement
	return p
}

func InitEmptyDropFileStatementContext(p *DropFileStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropFileStatement
}

func (*DropFileStatementContext) IsDropFileStatementContext() {}

func NewDropFileStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropFileStatementContext {
	var p = new(DropFileStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropFileStatement

	return p
}

func (s *DropFileStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropFileStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *DropFileStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *DropFileStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropFileStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *DropFileStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DropFileStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *DropFileStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DropFileStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *DropFileStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropFileStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropFileStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropFileStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropFileStatement(s)
	}
}

func (s *DropFileStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropFileStatement(s)
	}
}

func (p *StarRocksParser) DropFileStatement() (localctx IDropFileStatementContext) {
	localctx = NewDropFileStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, StarRocksParserRULE_dropFileStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5490)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5491)
		p.Match(StarRocksParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5492)
		p.String_()
	}
	p.SetState(5495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5493)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5494)

			var _x = p.QualifiedName()

			localctx.(*DropFileStatementContext).catalog = _x
		}

	}
	{
		p.SetState(5497)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowSmallFilesStatementContext is an interface to support dynamic dispatch.
type IShowSmallFilesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCatalog returns the catalog rule contexts.
	GetCatalog() IQualifiedNameContext

	// SetCatalog sets the catalog rule contexts.
	SetCatalog(IQualifiedNameContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FROM() antlr.TerminalNode
	IN() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext

	// IsShowSmallFilesStatementContext differentiates from other interfaces.
	IsShowSmallFilesStatementContext()
}

type ShowSmallFilesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	catalog IQualifiedNameContext
}

func NewEmptyShowSmallFilesStatementContext() *ShowSmallFilesStatementContext {
	var p = new(ShowSmallFilesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSmallFilesStatement
	return p
}

func InitEmptyShowSmallFilesStatementContext(p *ShowSmallFilesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showSmallFilesStatement
}

func (*ShowSmallFilesStatementContext) IsShowSmallFilesStatementContext() {}

func NewShowSmallFilesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowSmallFilesStatementContext {
	var p = new(ShowSmallFilesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showSmallFilesStatement

	return p
}

func (s *ShowSmallFilesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowSmallFilesStatementContext) GetCatalog() IQualifiedNameContext { return s.catalog }

func (s *ShowSmallFilesStatementContext) SetCatalog(v IQualifiedNameContext) { s.catalog = v }

func (s *ShowSmallFilesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowSmallFilesStatementContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *ShowSmallFilesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowSmallFilesStatementContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *ShowSmallFilesStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowSmallFilesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowSmallFilesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowSmallFilesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowSmallFilesStatement(s)
	}
}

func (s *ShowSmallFilesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowSmallFilesStatement(s)
	}
}

func (p *StarRocksParser) ShowSmallFilesStatement() (localctx IShowSmallFilesStatementContext) {
	localctx = NewShowSmallFilesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, StarRocksParserRULE_showSmallFilesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5499)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5500)
		p.Match(StarRocksParserFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5503)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFROM || _la == StarRocksParserIN {
		{
			p.SetState(5501)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFROM || _la == StarRocksParserIN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5502)

			var _x = p.QualifiedName()

			localctx.(*ShowSmallFilesStatementContext).catalog = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreatePipeStatementContext is an interface to support dynamic dispatch.
type ICreatePipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE() antlr.TerminalNode
	OrReplace() IOrReplaceContext
	PIPE() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	QualifiedName() IQualifiedNameContext
	AS() antlr.TerminalNode
	InsertStatement() IInsertStatementContext
	Properties() IPropertiesContext

	// IsCreatePipeStatementContext differentiates from other interfaces.
	IsCreatePipeStatementContext()
}

type CreatePipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreatePipeStatementContext() *CreatePipeStatementContext {
	var p = new(CreatePipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createPipeStatement
	return p
}

func InitEmptyCreatePipeStatementContext(p *CreatePipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createPipeStatement
}

func (*CreatePipeStatementContext) IsCreatePipeStatementContext() {}

func NewCreatePipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreatePipeStatementContext {
	var p = new(CreatePipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createPipeStatement

	return p
}

func (s *CreatePipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreatePipeStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreatePipeStatementContext) OrReplace() IOrReplaceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrReplaceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrReplaceContext)
}

func (s *CreatePipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *CreatePipeStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreatePipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *CreatePipeStatementContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CreatePipeStatementContext) InsertStatement() IInsertStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInsertStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInsertStatementContext)
}

func (s *CreatePipeStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreatePipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreatePipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreatePipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreatePipeStatement(s)
	}
}

func (s *CreatePipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreatePipeStatement(s)
	}
}

func (p *StarRocksParser) CreatePipeStatement() (localctx ICreatePipeStatementContext) {
	localctx = NewCreatePipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, StarRocksParserRULE_createPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5505)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5506)
		p.OrReplace()
	}
	{
		p.SetState(5507)
		p.Match(StarRocksParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5508)
		p.IfNotExists()
	}
	{
		p.SetState(5509)
		p.QualifiedName()
	}
	p.SetState(5511)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5510)
			p.Properties()
		}

	}
	{
		p.SetState(5513)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5514)
		p.InsertStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropPipeStatementContext is an interface to support dynamic dispatch.
type IDropPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropPipeStatementContext differentiates from other interfaces.
	IsDropPipeStatementContext()
}

type DropPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropPipeStatementContext() *DropPipeStatementContext {
	var p = new(DropPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPipeStatement
	return p
}

func InitEmptyDropPipeStatementContext(p *DropPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropPipeStatement
}

func (*DropPipeStatementContext) IsDropPipeStatementContext() {}

func NewDropPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropPipeStatementContext {
	var p = new(DropPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropPipeStatement

	return p
}

func (s *DropPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropPipeStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *DropPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DropPipeStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropPipeStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropPipeStatement(s)
	}
}

func (s *DropPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropPipeStatement(s)
	}
}

func (p *StarRocksParser) DropPipeStatement() (localctx IDropPipeStatementContext) {
	localctx = NewDropPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, StarRocksParserRULE_dropPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5516)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5517)
		p.Match(StarRocksParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5518)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5519)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5522)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPipeClauseContext is an interface to support dynamic dispatch.
type IAlterPipeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFileName returns the fileName rule contexts.
	GetFileName() IStringContext

	// SetFileName sets the fileName rule contexts.
	SetFileName(IStringContext)

	// Getter signatures
	SUSPEND() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETRY() antlr.TerminalNode
	ALL() antlr.TerminalNode
	FILE() antlr.TerminalNode
	String_() IStringContext
	SET() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsAlterPipeClauseContext differentiates from other interfaces.
	IsAlterPipeClauseContext()
}

type AlterPipeClauseContext struct {
	antlr.BaseParserRuleContext
	parser   antlr.Parser
	fileName IStringContext
}

func NewEmptyAlterPipeClauseContext() *AlterPipeClauseContext {
	var p = new(AlterPipeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPipeClause
	return p
}

func InitEmptyAlterPipeClauseContext(p *AlterPipeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPipeClause
}

func (*AlterPipeClauseContext) IsAlterPipeClauseContext() {}

func NewAlterPipeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPipeClauseContext {
	var p = new(AlterPipeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterPipeClause

	return p
}

func (s *AlterPipeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPipeClauseContext) GetFileName() IStringContext { return s.fileName }

func (s *AlterPipeClauseContext) SetFileName(v IStringContext) { s.fileName = v }

func (s *AlterPipeClauseContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUSPEND, 0)
}

func (s *AlterPipeClauseContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESUME, 0)
}

func (s *AlterPipeClauseContext) RETRY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETRY, 0)
}

func (s *AlterPipeClauseContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *AlterPipeClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *AlterPipeClauseContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterPipeClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *AlterPipeClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *AlterPipeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPipeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPipeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterPipeClause(s)
	}
}

func (s *AlterPipeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterPipeClause(s)
	}
}

func (p *StarRocksParser) AlterPipeClause() (localctx IAlterPipeClauseContext) {
	localctx = NewAlterPipeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, StarRocksParserRULE_alterPipeClause)
	p.SetState(5533)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 599, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5524)
			p.Match(StarRocksParserSUSPEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5525)
			p.Match(StarRocksParserRESUME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5526)
			p.Match(StarRocksParserRETRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5527)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5528)
			p.Match(StarRocksParserRETRY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5529)
			p.Match(StarRocksParserFILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5530)

			var _x = p.String_()

			localctx.(*AlterPipeClauseContext).fileName = _x
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5531)
			p.Match(StarRocksParserSET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5532)
			p.PropertyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPipeStatementContext is an interface to support dynamic dispatch.
type IAlterPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	AlterPipeClause() IAlterPipeClauseContext

	// IsAlterPipeStatementContext differentiates from other interfaces.
	IsAlterPipeStatementContext()
}

type AlterPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPipeStatementContext() *AlterPipeStatementContext {
	var p = new(AlterPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPipeStatement
	return p
}

func InitEmptyAlterPipeStatementContext(p *AlterPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPipeStatement
}

func (*AlterPipeStatementContext) IsAlterPipeStatementContext() {}

func NewAlterPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPipeStatementContext {
	var p = new(AlterPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterPipeStatement

	return p
}

func (s *AlterPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPipeStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *AlterPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *AlterPipeStatementContext) AlterPipeClause() IAlterPipeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterPipeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterPipeClauseContext)
}

func (s *AlterPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterPipeStatement(s)
	}
}

func (s *AlterPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterPipeStatement(s)
	}
}

func (p *StarRocksParser) AlterPipeStatement() (localctx IAlterPipeStatementContext) {
	localctx = NewAlterPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, StarRocksParserRULE_alterPipeStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5535)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5536)
		p.Match(StarRocksParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5537)
		p.QualifiedName()
	}
	{
		p.SetState(5538)
		p.AlterPipeClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDescPipeStatementContext is an interface to support dynamic dispatch.
type IDescPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PIPE() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode

	// IsDescPipeStatementContext differentiates from other interfaces.
	IsDescPipeStatementContext()
}

type DescPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDescPipeStatementContext() *DescPipeStatementContext {
	var p = new(DescPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descPipeStatement
	return p
}

func InitEmptyDescPipeStatementContext(p *DescPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_descPipeStatement
}

func (*DescPipeStatementContext) IsDescPipeStatementContext() {}

func NewDescPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DescPipeStatementContext {
	var p = new(DescPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_descPipeStatement

	return p
}

func (s *DescPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DescPipeStatementContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *DescPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *DescPipeStatementContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *DescPipeStatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESCRIBE, 0)
}

func (s *DescPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DescPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DescPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDescPipeStatement(s)
	}
}

func (s *DescPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDescPipeStatement(s)
	}
}

func (p *StarRocksParser) DescPipeStatement() (localctx IDescPipeStatementContext) {
	localctx = NewDescPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, StarRocksParserRULE_descPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5540)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDESC || _la == StarRocksParserDESCRIBE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5541)
		p.Match(StarRocksParserPIPE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5542)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPipeStatementContext is an interface to support dynamic dispatch.
type IShowPipeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	PIPES() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext
	LIKE() antlr.TerminalNode
	WHERE() antlr.TerminalNode
	Expression() IExpressionContext
	FROM() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	String_() IStringContext

	// IsShowPipeStatementContext differentiates from other interfaces.
	IsShowPipeStatementContext()
}

type ShowPipeStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowPipeStatementContext() *ShowPipeStatementContext {
	var p = new(ShowPipeStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPipeStatement
	return p
}

func InitEmptyShowPipeStatementContext(p *ShowPipeStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPipeStatement
}

func (*ShowPipeStatementContext) IsShowPipeStatementContext() {}

func NewShowPipeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPipeStatementContext {
	var p = new(ShowPipeStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPipeStatement

	return p
}

func (s *ShowPipeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPipeStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowPipeStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowPipeStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPipeStatementContext) PIPES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPES, 0)
}

func (s *ShowPipeStatementContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *ShowPipeStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *ShowPipeStatementContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *ShowPipeStatementContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *ShowPipeStatementContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *ShowPipeStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowPipeStatementContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *ShowPipeStatementContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ShowPipeStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowPipeStatementContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *ShowPipeStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowPipeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPipeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPipeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPipeStatement(s)
	}
}

func (s *ShowPipeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPipeStatement(s)
	}
}

func (p *StarRocksParser) ShowPipeStatement() (localctx IShowPipeStatementContext) {
	localctx = NewShowPipeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, StarRocksParserRULE_showPipeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5544)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5545)
		p.Match(StarRocksParserPIPES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5552)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLIKE:
		{
			p.SetState(5546)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5547)

			var _x = p.String_()

			localctx.(*ShowPipeStatementContext).pattern = _x
		}

	case StarRocksParserWHERE:
		{
			p.SetState(5548)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5549)
			p.expression(0)
		}

	case StarRocksParserFROM:
		{
			p.SetState(5550)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5551)
			p.QualifiedName()
		}

	case StarRocksParserEOF, StarRocksParserLIMIT, StarRocksParserORDER, StarRocksParserSEMICOLON:

	default:
	}
	p.SetState(5564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(5554)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5555)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5556)
			p.SortItem()
		}
		p.SetState(5561)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5557)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5558)
				p.SortItem()
			}

			p.SetState(5563)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5567)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(5566)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	AllSetVar() []ISetVarContext
	SetVar(i int) ISetVarContext

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetStatementContext) AllSetVar() []ISetVarContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetVarContext); ok {
			len++
		}
	}

	tst := make([]ISetVarContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetVarContext); ok {
			tst[i] = t.(ISetVarContext)
			i++
		}
	}

	return tst
}

func (s *SetStatementContext) SetVar(i int) ISetVarContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetVarContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetVarContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (p *StarRocksParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, StarRocksParserRULE_setStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5569)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5570)
		p.SetVar()
	}
	p.SetState(5575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5571)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5572)
			p.SetVar()
		}

		p.SetState(5577)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetVarContext is an interface to support dynamic dispatch.
type ISetVarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSetVarContext differentiates from other interfaces.
	IsSetVarContext()
}

type SetVarContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetVarContext() *SetVarContext {
	var p = new(SetVarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setVar
	return p
}

func InitEmptySetVarContext(p *SetVarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setVar
}

func (*SetVarContext) IsSetVarContext() {}

func NewSetVarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetVarContext {
	var p = new(SetVarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setVar

	return p
}

func (s *SetVarContext) GetParser() antlr.Parser { return s.parser }

func (s *SetVarContext) CopyAll(ctx *SetVarContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SetVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SetTransactionContext struct {
	SetVarContext
}

func NewSetTransactionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetTransactionContext {
	var p = new(SetTransactionContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetTransactionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetTransactionContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSACTION, 0)
}

func (s *SetTransactionContext) Transaction_characteristics() ITransaction_characteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_characteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_characteristicsContext)
}

func (s *SetTransactionContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SetTransactionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetTransaction(s)
	}
}

func (s *SetTransactionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetTransaction(s)
	}
}

type SetNamesContext struct {
	SetVarContext
	charset IIdentifierOrStringContext
	collate IIdentifierOrStringContext
}

func NewSetNamesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetNamesContext {
	var p = new(SetNamesContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetNamesContext) GetCharset() IIdentifierOrStringContext { return s.charset }

func (s *SetNamesContext) GetCollate() IIdentifierOrStringContext { return s.collate }

func (s *SetNamesContext) SetCharset(v IIdentifierOrStringContext) { s.charset = v }

func (s *SetNamesContext) SetCollate(v IIdentifierOrStringContext) { s.collate = v }

func (s *SetNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetNamesContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *SetNamesContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetNamesContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *SetNamesContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARACTER, 0)
}

func (s *SetNamesContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *SetNamesContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetNamesContext) AllDEFAULT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserDEFAULT)
}

func (s *SetNamesContext) DEFAULT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, i)
}

func (s *SetNamesContext) NAMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNAMES, 0)
}

func (s *SetNamesContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATE, 0)
}

func (s *SetNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetNames(s)
	}
}

func (s *SetNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetNames(s)
	}
}

type SetPasswordContext struct {
	SetVarContext
}

func NewSetPasswordContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetPasswordContext {
	var p = new(SetPasswordContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetPasswordContext) AllPASSWORD() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserPASSWORD)
}

func (s *SetPasswordContext) PASSWORD(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserPASSWORD, i)
}

func (s *SetPasswordContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *SetPasswordContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SetPasswordContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *SetPasswordContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *SetPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetPassword(s)
	}
}

func (s *SetPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetPassword(s)
	}
}

type SetUserVarContext struct {
	SetVarContext
}

func NewSetUserVarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetUserVarContext {
	var p = new(SetUserVarContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetUserVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserVarContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *SetUserVarContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *SetUserVarContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetUserVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetUserVar(s)
	}
}

func (s *SetUserVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetUserVar(s)
	}
}

type SetSystemVarContext struct {
	SetVarContext
}

func NewSetSystemVarContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetSystemVarContext {
	var p = new(SetSystemVarContext)

	InitEmptySetVarContext(&p.SetVarContext)
	p.parser = parser
	p.CopyAll(ctx.(*SetVarContext))

	return p
}

func (s *SetSystemVarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVarContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetSystemVarContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *SetSystemVarContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *SetSystemVarContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SetSystemVarContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *SetSystemVarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetSystemVar(s)
	}
}

func (s *SetSystemVarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetSystemVar(s)
	}
}

func (p *StarRocksParser) SetVar() (localctx ISetVarContext) {
	localctx = NewSetVarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, StarRocksParserRULE_setVar)
	var _la int

	p.SetState(5643)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 614, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5583)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserCHAR:
			{
				p.SetState(5578)
				p.Match(StarRocksParserCHAR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5579)
				p.Match(StarRocksParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StarRocksParserCHARSET:
			{
				p.SetState(5580)
				p.Match(StarRocksParserCHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StarRocksParserCHARACTER:
			{
				p.SetState(5581)
				p.Match(StarRocksParserCHARACTER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5582)
				p.Match(StarRocksParserSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(5587)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(5585)
				p.IdentifierOrString()
			}

		case StarRocksParserDEFAULT:
			{
				p.SetState(5586)
				p.Match(StarRocksParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		localctx = NewSetNamesContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5589)
			p.Match(StarRocksParserNAMES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5592)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(5590)

				var _x = p.IdentifierOrString()

				localctx.(*SetNamesContext).charset = _x
			}

		case StarRocksParserDEFAULT:
			{
				p.SetState(5591)
				p.Match(StarRocksParserDEFAULT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(5599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserCOLLATE {
			{
				p.SetState(5594)
				p.Match(StarRocksParserCOLLATE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5597)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
				{
					p.SetState(5595)

					var _x = p.IdentifierOrString()

					localctx.(*SetNamesContext).collate = _x
				}

			case StarRocksParserDEFAULT:
				{
					p.SetState(5596)
					p.Match(StarRocksParserDEFAULT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}

	case 3:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5601)
			p.Match(StarRocksParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5602)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5609)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(5603)
				p.String_()
			}

		case StarRocksParserPASSWORD:
			{
				p.SetState(5604)
				p.Match(StarRocksParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5605)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5606)
				p.String_()
			}
			{
				p.SetState(5607)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		localctx = NewSetPasswordContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5611)
			p.Match(StarRocksParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5612)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5613)
			p.User()
		}
		{
			p.SetState(5614)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5621)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(5615)
				p.String_()
			}

		case StarRocksParserPASSWORD:
			{
				p.SetState(5616)
				p.Match(StarRocksParserPASSWORD)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5617)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5618)
				p.String_()
			}
			{
				p.SetState(5619)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		localctx = NewSetUserVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5623)
			p.UserVariable()
		}
		{
			p.SetState(5624)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5625)
			p.expression(0)
		}

	case 6:
		localctx = NewSetSystemVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(5628)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 612, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5627)
				p.VarType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(5630)
			p.Identifier()
		}
		{
			p.SetState(5631)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5632)
			p.SetExprOrDefault()
		}

	case 7:
		localctx = NewSetSystemVarContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(5634)
			p.SystemVariable()
		}
		{
			p.SetState(5635)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5636)
			p.SetExprOrDefault()
		}

	case 8:
		localctx = NewSetTransactionContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		p.SetState(5639)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserGLOBAL || _la == StarRocksParserLOCAL || _la == StarRocksParserSESSION || _la == StarRocksParserVERBOSE {
			{
				p.SetState(5638)
				p.VarType()
			}

		}
		{
			p.SetState(5641)
			p.Match(StarRocksParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5642)
			p.Transaction_characteristics()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_characteristicsContext is an interface to support dynamic dispatch.
type ITransaction_characteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Transaction_access_mode() ITransaction_access_modeContext
	Isolation_level() IIsolation_levelContext

	// IsTransaction_characteristicsContext differentiates from other interfaces.
	IsTransaction_characteristicsContext()
}

type Transaction_characteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_characteristicsContext() *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_transaction_characteristics
	return p
}

func InitEmptyTransaction_characteristicsContext(p *Transaction_characteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_transaction_characteristics
}

func (*Transaction_characteristicsContext) IsTransaction_characteristicsContext() {}

func NewTransaction_characteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_characteristicsContext {
	var p = new(Transaction_characteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_transaction_characteristics

	return p
}

func (s *Transaction_characteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_characteristicsContext) Transaction_access_mode() ITransaction_access_modeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransaction_access_modeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransaction_access_modeContext)
}

func (s *Transaction_characteristicsContext) Isolation_level() IIsolation_levelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolation_levelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolation_levelContext)
}

func (s *Transaction_characteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_characteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_characteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTransaction_characteristics(s)
	}
}

func (s *Transaction_characteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTransaction_characteristics(s)
	}
}

func (p *StarRocksParser) Transaction_characteristics() (localctx ITransaction_characteristicsContext) {
	localctx = NewTransaction_characteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, StarRocksParserRULE_transaction_characteristics)
	p.SetState(5655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 615, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5645)
			p.Transaction_access_mode()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5646)
			p.Isolation_level()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5647)
			p.Transaction_access_mode()
		}
		{
			p.SetState(5648)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5649)
			p.Isolation_level()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5651)
			p.Isolation_level()
		}
		{
			p.SetState(5652)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5653)
			p.Transaction_access_mode()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransaction_access_modeContext is an interface to support dynamic dispatch.
type ITransaction_access_modeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	WRITE() antlr.TerminalNode

	// IsTransaction_access_modeContext differentiates from other interfaces.
	IsTransaction_access_modeContext()
}

type Transaction_access_modeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransaction_access_modeContext() *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_transaction_access_mode
	return p
}

func InitEmptyTransaction_access_modeContext(p *Transaction_access_modeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_transaction_access_mode
}

func (*Transaction_access_modeContext) IsTransaction_access_modeContext() {}

func NewTransaction_access_modeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Transaction_access_modeContext {
	var p = new(Transaction_access_modeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_transaction_access_mode

	return p
}

func (s *Transaction_access_modeContext) GetParser() antlr.Parser { return s.parser }

func (s *Transaction_access_modeContext) READ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREAD, 0)
}

func (s *Transaction_access_modeContext) ONLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserONLY, 0)
}

func (s *Transaction_access_modeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWRITE, 0)
}

func (s *Transaction_access_modeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Transaction_access_modeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Transaction_access_modeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTransaction_access_mode(s)
	}
}

func (s *Transaction_access_modeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTransaction_access_mode(s)
	}
}

func (p *StarRocksParser) Transaction_access_mode() (localctx ITransaction_access_modeContext) {
	localctx = NewTransaction_access_modeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, StarRocksParserRULE_transaction_access_mode)
	p.SetState(5661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 616, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5657)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5658)
			p.Match(StarRocksParserONLY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5659)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5660)
			p.Match(StarRocksParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolation_levelContext is an interface to support dynamic dispatch.
type IIsolation_levelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	Isolation_types() IIsolation_typesContext

	// IsIsolation_levelContext differentiates from other interfaces.
	IsIsolation_levelContext()
}

type Isolation_levelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolation_levelContext() *Isolation_levelContext {
	var p = new(Isolation_levelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_isolation_level
	return p
}

func InitEmptyIsolation_levelContext(p *Isolation_levelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_isolation_level
}

func (*Isolation_levelContext) IsIsolation_levelContext() {}

func NewIsolation_levelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Isolation_levelContext {
	var p = new(Isolation_levelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_isolation_level

	return p
}

func (s *Isolation_levelContext) GetParser() antlr.Parser { return s.parser }

func (s *Isolation_levelContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserISOLATION, 0)
}

func (s *Isolation_levelContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEVEL, 0)
}

func (s *Isolation_levelContext) Isolation_types() IIsolation_typesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolation_typesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolation_typesContext)
}

func (s *Isolation_levelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Isolation_levelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Isolation_levelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIsolation_level(s)
	}
}

func (s *Isolation_levelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIsolation_level(s)
	}
}

func (p *StarRocksParser) Isolation_level() (localctx IIsolation_levelContext) {
	localctx = NewIsolation_levelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, StarRocksParserRULE_isolation_level)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5663)
		p.Match(StarRocksParserISOLATION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5664)
		p.Match(StarRocksParserLEVEL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5665)
		p.Isolation_types()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolation_typesContext is an interface to support dynamic dispatch.
type IIsolation_typesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode

	// IsIsolation_typesContext differentiates from other interfaces.
	IsIsolation_typesContext()
}

type Isolation_typesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolation_typesContext() *Isolation_typesContext {
	var p = new(Isolation_typesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_isolation_types
	return p
}

func InitEmptyIsolation_typesContext(p *Isolation_typesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_isolation_types
}

func (*Isolation_typesContext) IsIsolation_typesContext() {}

func NewIsolation_typesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Isolation_typesContext {
	var p = new(Isolation_typesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_isolation_types

	return p
}

func (s *Isolation_typesContext) GetParser() antlr.Parser { return s.parser }

func (s *Isolation_typesContext) READ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREAD, 0)
}

func (s *Isolation_typesContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNCOMMITTED, 0)
}

func (s *Isolation_typesContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMITTED, 0)
}

func (s *Isolation_typesContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPEATABLE, 0)
}

func (s *Isolation_typesContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSERIALIZABLE, 0)
}

func (s *Isolation_typesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Isolation_typesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Isolation_typesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIsolation_types(s)
	}
}

func (s *Isolation_typesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIsolation_types(s)
	}
}

func (p *StarRocksParser) Isolation_types() (localctx IIsolation_typesContext) {
	localctx = NewIsolation_typesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, StarRocksParserRULE_isolation_types)
	p.SetState(5674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 617, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5667)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5668)
			p.Match(StarRocksParserUNCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5669)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5670)
			p.Match(StarRocksParserCOMMITTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5671)
			p.Match(StarRocksParserREPEATABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5672)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5673)
			p.Match(StarRocksParserSERIALIZABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetExprOrDefaultContext is an interface to support dynamic dispatch.
type ISetExprOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT() antlr.TerminalNode
	ON() antlr.TerminalNode
	ALL() antlr.TerminalNode
	Expression() IExpressionContext

	// IsSetExprOrDefaultContext differentiates from other interfaces.
	IsSetExprOrDefaultContext()
}

type SetExprOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExprOrDefaultContext() *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setExprOrDefault
	return p
}

func InitEmptySetExprOrDefaultContext(p *SetExprOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setExprOrDefault
}

func (*SetExprOrDefaultContext) IsSetExprOrDefaultContext() {}

func NewSetExprOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setExprOrDefault

	return p
}

func (s *SetExprOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExprOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *SetExprOrDefaultContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *SetExprOrDefaultContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *SetExprOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetExprOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExprOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExprOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetExprOrDefault(s)
	}
}

func (p *StarRocksParser) SetExprOrDefault() (localctx ISetExprOrDefaultContext) {
	localctx = NewSetExprOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, StarRocksParserRULE_setExprOrDefault)
	p.SetState(5680)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserDEFAULT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5676)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5677)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserALL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5678)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserT__1, StarRocksParserT__5, StarRocksParserT__8, StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCASE, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHAR, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCONVERT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserCURRENT_DATE, StarRocksParserCURRENT_GROUP, StarRocksParserCURRENT_ROLE, StarRocksParserCURRENT_TIME, StarRocksParserCURRENT_TIMESTAMP, StarRocksParserCURRENT_USER, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATABASE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDENSE_RANK, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserNTILE, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXISTS, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFALSE, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFIRST_VALUE, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUPING, StarRocksParserGROUPING_ID, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIF, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAG, StarRocksParserLAST, StarRocksParserLAST_VALUE, StarRocksParserLEAD, StarRocksParserLEFT, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIKE, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCALTIME, StarRocksParserLOCALTIMESTAMP, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMOD, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNOT, StarRocksParserNULL, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARAMETER, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREGEXP, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserRIGHT, StarRocksParserRLIKE, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserROW_NUMBER, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSCHEMA, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserPLUS_SYMBOL, StarRocksParserMINUS_SYMBOL, StarRocksParserLOGICAL_NOT, StarRocksParserBITNOT, StarRocksParserAT, StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5679)
			p.expression(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetUserPropertyStatementContext is an interface to support dynamic dispatch.
type ISetUserPropertyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	UserPropertyList() IUserPropertyListContext
	FOR() antlr.TerminalNode
	String_() IStringContext

	// IsSetUserPropertyStatementContext differentiates from other interfaces.
	IsSetUserPropertyStatementContext()
}

type SetUserPropertyStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetUserPropertyStatementContext() *SetUserPropertyStatementContext {
	var p = new(SetUserPropertyStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setUserPropertyStatement
	return p
}

func InitEmptySetUserPropertyStatementContext(p *SetUserPropertyStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setUserPropertyStatement
}

func (*SetUserPropertyStatementContext) IsSetUserPropertyStatementContext() {}

func NewSetUserPropertyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetUserPropertyStatementContext {
	var p = new(SetUserPropertyStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setUserPropertyStatement

	return p
}

func (s *SetUserPropertyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetUserPropertyStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetUserPropertyStatementContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTY, 0)
}

func (s *SetUserPropertyStatementContext) UserPropertyList() IUserPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserPropertyListContext)
}

func (s *SetUserPropertyStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *SetUserPropertyStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SetUserPropertyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUserPropertyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetUserPropertyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetUserPropertyStatement(s)
	}
}

func (s *SetUserPropertyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetUserPropertyStatement(s)
	}
}

func (p *StarRocksParser) SetUserPropertyStatement() (localctx ISetUserPropertyStatementContext) {
	localctx = NewSetUserPropertyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, StarRocksParserRULE_setUserPropertyStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5682)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5683)
		p.Match(StarRocksParserPROPERTY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5686)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(5684)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5685)
			p.String_()
		}

	}
	{
		p.SetState(5688)
		p.UserPropertyList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleListContext is an interface to support dynamic dispatch.
type IRoleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsRoleListContext differentiates from other interfaces.
	IsRoleListContext()
}

type RoleListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleListContext() *RoleListContext {
	var p = new(RoleListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_roleList
	return p
}

func InitEmptyRoleListContext(p *RoleListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_roleList
}

func (*RoleListContext) IsRoleListContext() {}

func NewRoleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleListContext {
	var p = new(RoleListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_roleList

	return p
}

func (s *RoleListContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleListContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *RoleListContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *RoleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRoleList(s)
	}
}

func (s *RoleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRoleList(s)
	}
}

func (p *StarRocksParser) RoleList() (localctx IRoleListContext) {
	localctx = NewRoleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, StarRocksParserRULE_roleList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5690)
		p.IdentifierOrString()
	}
	p.SetState(5695)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5691)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5692)
			p.IdentifierOrString()
		}

		p.SetState(5697)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteScriptStatementContext is an interface to support dynamic dispatch.
type IExecuteScriptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ADMIN() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	ON() antlr.TerminalNode
	String_() IStringContext
	FRONTEND() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsExecuteScriptStatementContext differentiates from other interfaces.
	IsExecuteScriptStatementContext()
}

type ExecuteScriptStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteScriptStatementContext() *ExecuteScriptStatementContext {
	var p = new(ExecuteScriptStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeScriptStatement
	return p
}

func InitEmptyExecuteScriptStatementContext(p *ExecuteScriptStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeScriptStatement
}

func (*ExecuteScriptStatementContext) IsExecuteScriptStatementContext() {}

func NewExecuteScriptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteScriptStatementContext {
	var p = new(ExecuteScriptStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_executeScriptStatement

	return p
}

func (s *ExecuteScriptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteScriptStatementContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *ExecuteScriptStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *ExecuteScriptStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *ExecuteScriptStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ExecuteScriptStatementContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *ExecuteScriptStatementContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *ExecuteScriptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteScriptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteScriptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExecuteScriptStatement(s)
	}
}

func (s *ExecuteScriptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExecuteScriptStatement(s)
	}
}

func (p *StarRocksParser) ExecuteScriptStatement() (localctx IExecuteScriptStatementContext) {
	localctx = NewExecuteScriptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, StarRocksParserRULE_executeScriptStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5698)
		p.Match(StarRocksParserADMIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5699)
		p.Match(StarRocksParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5700)
		p.Match(StarRocksParserON)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5701)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFRONTEND || _la == StarRocksParserINTEGER_VALUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5702)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnsupportedStatementContext is an interface to support dynamic dispatch.
type IUnsupportedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	AllLock_item() []ILock_itemContext
	Lock_item(i int) ILock_itemContext
	UNLOCK() antlr.TerminalNode

	// IsUnsupportedStatementContext differentiates from other interfaces.
	IsUnsupportedStatementContext()
}

type UnsupportedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsupportedStatementContext() *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unsupportedStatement
	return p
}

func InitEmptyUnsupportedStatementContext(p *UnsupportedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unsupportedStatement
}

func (*UnsupportedStatementContext) IsUnsupportedStatementContext() {}

func NewUnsupportedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnsupportedStatementContext {
	var p = new(UnsupportedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_unsupportedStatement

	return p
}

func (s *UnsupportedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnsupportedStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCK, 0)
}

func (s *UnsupportedStatementContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *UnsupportedStatementContext) AllLock_item() []ILock_itemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILock_itemContext); ok {
			len++
		}
	}

	tst := make([]ILock_itemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILock_itemContext); ok {
			tst[i] = t.(ILock_itemContext)
			i++
		}
	}

	return tst
}

func (s *UnsupportedStatementContext) Lock_item(i int) ILock_itemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_itemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_itemContext)
}

func (s *UnsupportedStatementContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNLOCK, 0)
}

func (s *UnsupportedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnsupportedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnsupportedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnsupportedStatement(s)
	}
}

func (s *UnsupportedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnsupportedStatement(s)
	}
}

func (p *StarRocksParser) UnsupportedStatement() (localctx IUnsupportedStatementContext) {
	localctx = NewUnsupportedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, StarRocksParserRULE_unsupportedStatement)
	var _la int

	p.SetState(5716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5704)
			p.Match(StarRocksParserLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5705)
			p.Match(StarRocksParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5706)
			p.Lock_item()
		}
		p.SetState(5711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5707)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5708)
				p.Lock_item()
			}

			p.SetState(5713)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case StarRocksParserUNLOCK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5714)
			p.Match(StarRocksParserUNLOCK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5715)
			p.Match(StarRocksParserTABLES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_itemContext is an interface to support dynamic dispatch.
type ILock_itemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	Lock_type() ILock_typeContext
	AS() antlr.TerminalNode

	// IsLock_itemContext differentiates from other interfaces.
	IsLock_itemContext()
}

type Lock_itemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	alias  IIdentifierContext
}

func NewEmptyLock_itemContext() *Lock_itemContext {
	var p = new(Lock_itemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_lock_item
	return p
}

func InitEmptyLock_itemContext(p *Lock_itemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_lock_item
}

func (*Lock_itemContext) IsLock_itemContext() {}

func NewLock_itemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_itemContext {
	var p = new(Lock_itemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_lock_item

	return p
}

func (s *Lock_itemContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_itemContext) GetAlias() IIdentifierContext { return s.alias }

func (s *Lock_itemContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *Lock_itemContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *Lock_itemContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Lock_itemContext) Lock_type() ILock_typeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILock_typeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILock_typeContext)
}

func (s *Lock_itemContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *Lock_itemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_itemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_itemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLock_item(s)
	}
}

func (s *Lock_itemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLock_item(s)
	}
}

func (p *StarRocksParser) Lock_item() (localctx ILock_itemContext) {
	localctx = NewLock_itemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, StarRocksParserRULE_lock_item)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5718)
		p.Identifier()
	}
	p.SetState(5723)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 624, p.GetParserRuleContext()) == 1 {
		p.SetState(5720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS {
			{
				p.SetState(5719)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5722)

			var _x = p.Identifier()

			localctx.(*Lock_itemContext).alias = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(5725)
		p.Lock_type()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILock_typeContext is an interface to support dynamic dispatch.
type ILock_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode

	// IsLock_typeContext differentiates from other interfaces.
	IsLock_typeContext()
}

type Lock_typeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLock_typeContext() *Lock_typeContext {
	var p = new(Lock_typeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_lock_type
	return p
}

func InitEmptyLock_typeContext(p *Lock_typeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_lock_type
}

func (*Lock_typeContext) IsLock_typeContext() {}

func NewLock_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lock_typeContext {
	var p = new(Lock_typeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_lock_type

	return p
}

func (s *Lock_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Lock_typeContext) READ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREAD, 0)
}

func (s *Lock_typeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCAL, 0)
}

func (s *Lock_typeContext) WRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWRITE, 0)
}

func (s *Lock_typeContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOW_PRIORITY, 0)
}

func (s *Lock_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lock_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lock_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLock_type(s)
	}
}

func (s *Lock_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLock_type(s)
	}
}

func (p *StarRocksParser) Lock_type() (localctx ILock_typeContext) {
	localctx = NewLock_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, StarRocksParserRULE_lock_type)
	var _la int

	p.SetState(5735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5727)
			p.Match(StarRocksParserREAD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLOCAL {
			{
				p.SetState(5728)
				p.Match(StarRocksParserLOCAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserWRITE, StarRocksParserLOW_PRIORITY:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5732)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLOW_PRIORITY {
			{
				p.SetState(5731)
				p.Match(StarRocksParserLOW_PRIORITY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5734)
			p.Match(StarRocksParserWRITE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPlanAdvisorAddStatementContext is an interface to support dynamic dispatch.
type IAlterPlanAdvisorAddStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	ADD() antlr.TerminalNode
	QueryStatement() IQueryStatementContext

	// IsAlterPlanAdvisorAddStatementContext differentiates from other interfaces.
	IsAlterPlanAdvisorAddStatementContext()
}

type AlterPlanAdvisorAddStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPlanAdvisorAddStatementContext() *AlterPlanAdvisorAddStatementContext {
	var p = new(AlterPlanAdvisorAddStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorAddStatement
	return p
}

func InitEmptyAlterPlanAdvisorAddStatementContext(p *AlterPlanAdvisorAddStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorAddStatement
}

func (*AlterPlanAdvisorAddStatementContext) IsAlterPlanAdvisorAddStatementContext() {}

func NewAlterPlanAdvisorAddStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPlanAdvisorAddStatementContext {
	var p = new(AlterPlanAdvisorAddStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorAddStatement

	return p
}

func (s *AlterPlanAdvisorAddStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPlanAdvisorAddStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADD, 0)
}

func (s *AlterPlanAdvisorAddStatementContext) QueryStatement() IQueryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryStatementContext)
}

func (s *AlterPlanAdvisorAddStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPlanAdvisorAddStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPlanAdvisorAddStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterPlanAdvisorAddStatement(s)
	}
}

func (s *AlterPlanAdvisorAddStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterPlanAdvisorAddStatement(s)
	}
}

func (p *StarRocksParser) AlterPlanAdvisorAddStatement() (localctx IAlterPlanAdvisorAddStatementContext) {
	localctx = NewAlterPlanAdvisorAddStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, StarRocksParserRULE_alterPlanAdvisorAddStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5737)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5738)
		p.Match(StarRocksParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5739)
		p.Match(StarRocksParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5740)
		p.Match(StarRocksParserADD)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5741)
		p.QueryStatement()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITruncatePlanAdvisorStatementContext is an interface to support dynamic dispatch.
type ITruncatePlanAdvisorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUNCATE() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode

	// IsTruncatePlanAdvisorStatementContext differentiates from other interfaces.
	IsTruncatePlanAdvisorStatementContext()
}

type TruncatePlanAdvisorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTruncatePlanAdvisorStatementContext() *TruncatePlanAdvisorStatementContext {
	var p = new(TruncatePlanAdvisorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncatePlanAdvisorStatement
	return p
}

func InitEmptyTruncatePlanAdvisorStatementContext(p *TruncatePlanAdvisorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_truncatePlanAdvisorStatement
}

func (*TruncatePlanAdvisorStatementContext) IsTruncatePlanAdvisorStatementContext() {}

func NewTruncatePlanAdvisorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TruncatePlanAdvisorStatementContext {
	var p = new(TruncatePlanAdvisorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_truncatePlanAdvisorStatement

	return p
}

func (s *TruncatePlanAdvisorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TruncatePlanAdvisorStatementContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUNCATE, 0)
}

func (s *TruncatePlanAdvisorStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *TruncatePlanAdvisorStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *TruncatePlanAdvisorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TruncatePlanAdvisorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TruncatePlanAdvisorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTruncatePlanAdvisorStatement(s)
	}
}

func (s *TruncatePlanAdvisorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTruncatePlanAdvisorStatement(s)
	}
}

func (p *StarRocksParser) TruncatePlanAdvisorStatement() (localctx ITruncatePlanAdvisorStatementContext) {
	localctx = NewTruncatePlanAdvisorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, StarRocksParserRULE_truncatePlanAdvisorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5743)
		p.Match(StarRocksParserTRUNCATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5744)
		p.Match(StarRocksParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5745)
		p.Match(StarRocksParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterPlanAdvisorDropStatementContext is an interface to support dynamic dispatch.
type IAlterPlanAdvisorDropStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	DROP() antlr.TerminalNode
	String_() IStringContext

	// IsAlterPlanAdvisorDropStatementContext differentiates from other interfaces.
	IsAlterPlanAdvisorDropStatementContext()
}

type AlterPlanAdvisorDropStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterPlanAdvisorDropStatementContext() *AlterPlanAdvisorDropStatementContext {
	var p = new(AlterPlanAdvisorDropStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorDropStatement
	return p
}

func InitEmptyAlterPlanAdvisorDropStatementContext(p *AlterPlanAdvisorDropStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorDropStatement
}

func (*AlterPlanAdvisorDropStatementContext) IsAlterPlanAdvisorDropStatementContext() {}

func NewAlterPlanAdvisorDropStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterPlanAdvisorDropStatementContext {
	var p = new(AlterPlanAdvisorDropStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterPlanAdvisorDropStatement

	return p
}

func (s *AlterPlanAdvisorDropStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterPlanAdvisorDropStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *AlterPlanAdvisorDropStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *AlterPlanAdvisorDropStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterPlanAdvisorDropStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterPlanAdvisorDropStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterPlanAdvisorDropStatement(s)
	}
}

func (s *AlterPlanAdvisorDropStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterPlanAdvisorDropStatement(s)
	}
}

func (p *StarRocksParser) AlterPlanAdvisorDropStatement() (localctx IAlterPlanAdvisorDropStatementContext) {
	localctx = NewAlterPlanAdvisorDropStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, StarRocksParserRULE_alterPlanAdvisorDropStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5747)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5748)
		p.Match(StarRocksParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5749)
		p.Match(StarRocksParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5750)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5751)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowPlanAdvisorStatementContext is an interface to support dynamic dispatch.
type IShowPlanAdvisorStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode

	// IsShowPlanAdvisorStatementContext differentiates from other interfaces.
	IsShowPlanAdvisorStatementContext()
}

type ShowPlanAdvisorStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowPlanAdvisorStatementContext() *ShowPlanAdvisorStatementContext {
	var p = new(ShowPlanAdvisorStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPlanAdvisorStatement
	return p
}

func InitEmptyShowPlanAdvisorStatementContext(p *ShowPlanAdvisorStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showPlanAdvisorStatement
}

func (*ShowPlanAdvisorStatementContext) IsShowPlanAdvisorStatementContext() {}

func NewShowPlanAdvisorStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowPlanAdvisorStatementContext {
	var p = new(ShowPlanAdvisorStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showPlanAdvisorStatement

	return p
}

func (s *ShowPlanAdvisorStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowPlanAdvisorStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowPlanAdvisorStatementContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *ShowPlanAdvisorStatementContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *ShowPlanAdvisorStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowPlanAdvisorStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowPlanAdvisorStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowPlanAdvisorStatement(s)
	}
}

func (s *ShowPlanAdvisorStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowPlanAdvisorStatement(s)
	}
}

func (p *StarRocksParser) ShowPlanAdvisorStatement() (localctx IShowPlanAdvisorStatementContext) {
	localctx = NewShowPlanAdvisorStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, StarRocksParserRULE_showPlanAdvisorStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5753)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5754)
		p.Match(StarRocksParserPLAN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5755)
		p.Match(StarRocksParserADVISOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateWarehouseStatementContext is an interface to support dynamic dispatch.
type ICreateWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	CREATE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	WAREHOUSE() antlr.TerminalNode
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	Comment() ICommentContext
	Properties() IPropertiesContext

	// IsCreateWarehouseStatementContext differentiates from other interfaces.
	IsCreateWarehouseStatementContext()
}

type CreateWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyCreateWarehouseStatementContext() *CreateWarehouseStatementContext {
	var p = new(CreateWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createWarehouseStatement
	return p
}

func InitEmptyCreateWarehouseStatementContext(p *CreateWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_createWarehouseStatement
}

func (*CreateWarehouseStatementContext) IsCreateWarehouseStatementContext() {}

func NewCreateWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateWarehouseStatementContext {
	var p = new(CreateWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_createWarehouseStatement

	return p
}

func (s *CreateWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *CreateWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *CreateWarehouseStatementContext) CREATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCREATE, 0)
}

func (s *CreateWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *CreateWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *CreateWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *CreateWarehouseStatementContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *CreateWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *CreateWarehouseStatementContext) Comment() ICommentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CreateWarehouseStatementContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *CreateWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCreateWarehouseStatement(s)
	}
}

func (s *CreateWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCreateWarehouseStatement(s)
	}
}

func (p *StarRocksParser) CreateWarehouseStatement() (localctx ICreateWarehouseStatementContext) {
	localctx = NewCreateWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, StarRocksParserRULE_createWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5757)
		p.Match(StarRocksParserCREATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(5758)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	p.SetState(5762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5759)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5760)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5761)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5764)

		var _x = p.IdentifierOrString()

		localctx.(*CreateWarehouseStatementContext).warehouseName = _x
	}
	p.SetState(5766)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserCOMMENT {
		{
			p.SetState(5765)
			p.Comment()
		}

	}
	p.SetState(5769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(5768)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropWarehouseStatementContext is an interface to support dynamic dispatch.
type IDropWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	DROP() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsDropWarehouseStatementContext differentiates from other interfaces.
	IsDropWarehouseStatementContext()
}

type DropWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyDropWarehouseStatementContext() *DropWarehouseStatementContext {
	var p = new(DropWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropWarehouseStatement
	return p
}

func InitEmptyDropWarehouseStatementContext(p *DropWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dropWarehouseStatement
}

func (*DropWarehouseStatementContext) IsDropWarehouseStatementContext() {}

func NewDropWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropWarehouseStatementContext {
	var p = new(DropWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dropWarehouseStatement

	return p
}

func (s *DropWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DropWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *DropWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *DropWarehouseStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DropWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *DropWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *DropWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *DropWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *DropWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDropWarehouseStatement(s)
	}
}

func (s *DropWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDropWarehouseStatement(s)
	}
}

func (p *StarRocksParser) DropWarehouseStatement() (localctx IDropWarehouseStatementContext) {
	localctx = NewDropWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, StarRocksParserRULE_dropWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5771)
		p.Match(StarRocksParserDROP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5772)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5775)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5773)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5774)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5777)

		var _x = p.IdentifierOrString()

		localctx.(*DropWarehouseStatementContext).warehouseName = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISuspendWarehouseStatementContext is an interface to support dynamic dispatch.
type ISuspendWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUSPEND() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsSuspendWarehouseStatementContext differentiates from other interfaces.
	IsSuspendWarehouseStatementContext()
}

type SuspendWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuspendWarehouseStatementContext() *SuspendWarehouseStatementContext {
	var p = new(SuspendWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_suspendWarehouseStatement
	return p
}

func InitEmptySuspendWarehouseStatementContext(p *SuspendWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_suspendWarehouseStatement
}

func (*SuspendWarehouseStatementContext) IsSuspendWarehouseStatementContext() {}

func NewSuspendWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SuspendWarehouseStatementContext {
	var p = new(SuspendWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_suspendWarehouseStatement

	return p
}

func (s *SuspendWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SuspendWarehouseStatementContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUSPEND, 0)
}

func (s *SuspendWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *SuspendWarehouseStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SuspendWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *SuspendWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *SuspendWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuspendWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SuspendWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSuspendWarehouseStatement(s)
	}
}

func (s *SuspendWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSuspendWarehouseStatement(s)
	}
}

func (p *StarRocksParser) SuspendWarehouseStatement() (localctx ISuspendWarehouseStatementContext) {
	localctx = NewSuspendWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, StarRocksParserRULE_suspendWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5779)
		p.Match(StarRocksParserSUSPEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5780)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5783)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5781)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5782)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5785)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResumeWarehouseStatementContext is an interface to support dynamic dispatch.
type IResumeWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESUME() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext
	IF() antlr.TerminalNode
	EXISTS() antlr.TerminalNode

	// IsResumeWarehouseStatementContext differentiates from other interfaces.
	IsResumeWarehouseStatementContext()
}

type ResumeWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResumeWarehouseStatementContext() *ResumeWarehouseStatementContext {
	var p = new(ResumeWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resumeWarehouseStatement
	return p
}

func InitEmptyResumeWarehouseStatementContext(p *ResumeWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_resumeWarehouseStatement
}

func (*ResumeWarehouseStatementContext) IsResumeWarehouseStatementContext() {}

func NewResumeWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResumeWarehouseStatementContext {
	var p = new(ResumeWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_resumeWarehouseStatement

	return p
}

func (s *ResumeWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResumeWarehouseStatementContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESUME, 0)
}

func (s *ResumeWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *ResumeWarehouseStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResumeWarehouseStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *ResumeWarehouseStatementContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *ResumeWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResumeWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResumeWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterResumeWarehouseStatement(s)
	}
}

func (s *ResumeWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitResumeWarehouseStatement(s)
	}
}

func (p *StarRocksParser) ResumeWarehouseStatement() (localctx IResumeWarehouseStatementContext) {
	localctx = NewResumeWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, StarRocksParserRULE_resumeWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5787)
		p.Match(StarRocksParserRESUME)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5788)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5791)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(5789)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5790)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5793)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetWarehouseStatementContext is an interface to support dynamic dispatch.
type ISetWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	SESSION() antlr.TerminalNode
	EQ() antlr.TerminalNode

	// IsSetWarehouseStatementContext differentiates from other interfaces.
	IsSetWarehouseStatementContext()
}

type SetWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetWarehouseStatementContext() *SetWarehouseStatementContext {
	var p = new(SetWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setWarehouseStatement
	return p
}

func InitEmptySetWarehouseStatementContext(p *SetWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setWarehouseStatement
}

func (*SetWarehouseStatementContext) IsSetWarehouseStatementContext() {}

func NewSetWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetWarehouseStatementContext {
	var p = new(SetWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setWarehouseStatement

	return p
}

func (s *SetWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetWarehouseStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSET, 0)
}

func (s *SetWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *SetWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *SetWarehouseStatementContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSESSION, 0)
}

func (s *SetWarehouseStatementContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *SetWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetWarehouseStatement(s)
	}
}

func (s *SetWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetWarehouseStatement(s)
	}
}

func (p *StarRocksParser) SetWarehouseStatement() (localctx ISetWarehouseStatementContext) {
	localctx = NewSetWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, StarRocksParserRULE_setWarehouseStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5795)
		p.Match(StarRocksParserSET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5797)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserSESSION {
		{
			p.SetState(5796)
			p.Match(StarRocksParserSESSION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5799)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserEQ {
		{
			p.SetState(5800)
			p.Match(StarRocksParserEQ)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5803)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowWarehousesStatementContext is an interface to support dynamic dispatch.
type IShowWarehousesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext

	// IsShowWarehousesStatementContext differentiates from other interfaces.
	IsShowWarehousesStatementContext()
}

type ShowWarehousesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowWarehousesStatementContext() *ShowWarehousesStatementContext {
	var p = new(ShowWarehousesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWarehousesStatement
	return p
}

func InitEmptyShowWarehousesStatementContext(p *ShowWarehousesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showWarehousesStatement
}

func (*ShowWarehousesStatementContext) IsShowWarehousesStatementContext() {}

func NewShowWarehousesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowWarehousesStatementContext {
	var p = new(ShowWarehousesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showWarehousesStatement

	return p
}

func (s *ShowWarehousesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowWarehousesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowWarehousesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowWarehousesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowWarehousesStatementContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSES, 0)
}

func (s *ShowWarehousesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowWarehousesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowWarehousesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowWarehousesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowWarehousesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowWarehousesStatement(s)
	}
}

func (s *ShowWarehousesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowWarehousesStatement(s)
	}
}

func (p *StarRocksParser) ShowWarehousesStatement() (localctx IShowWarehousesStatementContext) {
	localctx = NewShowWarehousesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, StarRocksParserRULE_showWarehousesStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5805)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5806)
		p.Match(StarRocksParserWAREHOUSES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5809)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIKE {
		{
			p.SetState(5807)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5808)

			var _x = p.String_()

			localctx.(*ShowWarehousesStatementContext).pattern = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowClustersStatementContext is an interface to support dynamic dispatch.
type IShowClustersStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SHOW() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowClustersStatementContext differentiates from other interfaces.
	IsShowClustersStatementContext()
}

type ShowClustersStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowClustersStatementContext() *ShowClustersStatementContext {
	var p = new(ShowClustersStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showClustersStatement
	return p
}

func InitEmptyShowClustersStatementContext(p *ShowClustersStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showClustersStatement
}

func (*ShowClustersStatementContext) IsShowClustersStatementContext() {}

func NewShowClustersStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowClustersStatementContext {
	var p = new(ShowClustersStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showClustersStatement

	return p
}

func (s *ShowClustersStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowClustersStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowClustersStatementContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTERS, 0)
}

func (s *ShowClustersStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowClustersStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *ShowClustersStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowClustersStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowClustersStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowClustersStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowClustersStatement(s)
	}
}

func (s *ShowClustersStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowClustersStatement(s)
	}
}

func (p *StarRocksParser) ShowClustersStatement() (localctx IShowClustersStatementContext) {
	localctx = NewShowClustersStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, StarRocksParserRULE_showClustersStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5811)
		p.Match(StarRocksParserSHOW)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5812)
		p.Match(StarRocksParserCLUSTERS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5813)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5814)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5815)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowNodesStatementContext is an interface to support dynamic dispatch.
type IShowNodesStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPattern returns the pattern rule contexts.
	GetPattern() IStringContext

	// SetPattern sets the pattern rule contexts.
	SetPattern(IStringContext)

	// Getter signatures
	SHOW() antlr.TerminalNode
	NODES() antlr.TerminalNode
	FROM() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	String_() IStringContext
	WAREHOUSE() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsShowNodesStatementContext differentiates from other interfaces.
	IsShowNodesStatementContext()
}

type ShowNodesStatementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	pattern IStringContext
}

func NewEmptyShowNodesStatementContext() *ShowNodesStatementContext {
	var p = new(ShowNodesStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showNodesStatement
	return p
}

func InitEmptyShowNodesStatementContext(p *ShowNodesStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_showNodesStatement
}

func (*ShowNodesStatementContext) IsShowNodesStatementContext() {}

func NewShowNodesStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowNodesStatementContext {
	var p = new(ShowNodesStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_showNodesStatement

	return p
}

func (s *ShowNodesStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowNodesStatementContext) GetPattern() IStringContext { return s.pattern }

func (s *ShowNodesStatementContext) SetPattern(v IStringContext) { s.pattern = v }

func (s *ShowNodesStatementContext) SHOW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSHOW, 0)
}

func (s *ShowNodesStatementContext) NODES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODES, 0)
}

func (s *ShowNodesStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ShowNodesStatementContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSES, 0)
}

func (s *ShowNodesStatementContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *ShowNodesStatementContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ShowNodesStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *ShowNodesStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ShowNodesStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowNodesStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowNodesStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterShowNodesStatement(s)
	}
}

func (s *ShowNodesStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitShowNodesStatement(s)
	}
}

func (p *StarRocksParser) ShowNodesStatement() (localctx IShowNodesStatementContext) {
	localctx = NewShowNodesStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, StarRocksParserRULE_showNodesStatement)
	var _la int

	p.SetState(5830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 638, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5817)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5818)
			p.Match(StarRocksParserNODES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5819)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5820)
			p.Match(StarRocksParserWAREHOUSES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIKE {
			{
				p.SetState(5821)
				p.Match(StarRocksParserLIKE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5822)

				var _x = p.String_()

				localctx.(*ShowNodesStatementContext).pattern = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5825)
			p.Match(StarRocksParserSHOW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5826)
			p.Match(StarRocksParserNODES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5827)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5828)
			p.Match(StarRocksParserWAREHOUSE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5829)
			p.Identifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterWarehouseStatementContext is an interface to support dynamic dispatch.
type IAlterWarehouseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetWarehouseName returns the warehouseName rule contexts.
	GetWarehouseName() IIdentifierOrStringContext

	// SetWarehouseName sets the warehouseName rule contexts.
	SetWarehouseName(IIdentifierOrStringContext)

	// Getter signatures
	ALTER() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	ModifyPropertiesClause() IModifyPropertiesClauseContext
	IdentifierOrString() IIdentifierOrStringContext

	// IsAlterWarehouseStatementContext differentiates from other interfaces.
	IsAlterWarehouseStatementContext()
}

type AlterWarehouseStatementContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	warehouseName IIdentifierOrStringContext
}

func NewEmptyAlterWarehouseStatementContext() *AlterWarehouseStatementContext {
	var p = new(AlterWarehouseStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterWarehouseStatement
	return p
}

func InitEmptyAlterWarehouseStatementContext(p *AlterWarehouseStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterWarehouseStatement
}

func (*AlterWarehouseStatementContext) IsAlterWarehouseStatementContext() {}

func NewAlterWarehouseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterWarehouseStatementContext {
	var p = new(AlterWarehouseStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterWarehouseStatement

	return p
}

func (s *AlterWarehouseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterWarehouseStatementContext) GetWarehouseName() IIdentifierOrStringContext {
	return s.warehouseName
}

func (s *AlterWarehouseStatementContext) SetWarehouseName(v IIdentifierOrStringContext) {
	s.warehouseName = v
}

func (s *AlterWarehouseStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALTER, 0)
}

func (s *AlterWarehouseStatementContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *AlterWarehouseStatementContext) ModifyPropertiesClause() IModifyPropertiesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModifyPropertiesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModifyPropertiesClauseContext)
}

func (s *AlterWarehouseStatementContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *AlterWarehouseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterWarehouseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterWarehouseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterWarehouseStatement(s)
	}
}

func (s *AlterWarehouseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterWarehouseStatement(s)
	}
}

func (p *StarRocksParser) AlterWarehouseStatement() (localctx IAlterWarehouseStatementContext) {
	localctx = NewAlterWarehouseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, StarRocksParserRULE_alterWarehouseStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5832)
		p.Match(StarRocksParserALTER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5833)
		p.Match(StarRocksParserWAREHOUSE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5834)

		var _x = p.IdentifierOrString()

		localctx.(*AlterWarehouseStatementContext).warehouseName = _x
	}
	{
		p.SetState(5835)
		p.ModifyPropertiesClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginStatementContext is an interface to support dynamic dispatch.
type IBeginStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	WITH() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	WORK() antlr.TerminalNode

	// IsBeginStatementContext differentiates from other interfaces.
	IsBeginStatementContext()
}

type BeginStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginStatementContext() *BeginStatementContext {
	var p = new(BeginStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_beginStatement
	return p
}

func InitEmptyBeginStatementContext(p *BeginStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_beginStatement
}

func (*BeginStatementContext) IsBeginStatementContext() {}

func NewBeginStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginStatementContext {
	var p = new(BeginStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_beginStatement

	return p
}

func (s *BeginStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginStatementContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *BeginStatementContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSACTION, 0)
}

func (s *BeginStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *BeginStatementContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONSISTENT, 0)
}

func (s *BeginStatementContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *BeginStatementContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBEGIN, 0)
}

func (s *BeginStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWORK, 0)
}

func (s *BeginStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBeginStatement(s)
	}
}

func (s *BeginStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBeginStatement(s)
	}
}

func (p *StarRocksParser) BeginStatement() (localctx IBeginStatementContext) {
	localctx = NewBeginStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, StarRocksParserRULE_beginStatement)
	var _la int

	p.SetState(5848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserSTART:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5837)
			p.Match(StarRocksParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5838)
			p.Match(StarRocksParserTRANSACTION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5842)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWITH {
			{
				p.SetState(5839)
				p.Match(StarRocksParserWITH)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5840)
				p.Match(StarRocksParserCONSISTENT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5841)
				p.Match(StarRocksParserSNAPSHOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case StarRocksParserBEGIN:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5844)
			p.Match(StarRocksParserBEGIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserWORK {
			{
				p.SetState(5845)
				p.Match(StarRocksParserWORK)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommitStatementContext is an interface to support dynamic dispatch.
type ICommitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMIT() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsCommitStatementContext differentiates from other interfaces.
	IsCommitStatementContext()
}

type CommitStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitStatementContext() *CommitStatementContext {
	var p = new(CommitStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_commitStatement
	return p
}

func InitEmptyCommitStatementContext(p *CommitStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_commitStatement
}

func (*CommitStatementContext) IsCommitStatementContext() {}

func NewCommitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitStatementContext {
	var p = new(CommitStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_commitStatement

	return p
}

func (s *CommitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitStatementContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMIT, 0)
}

func (s *CommitStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWORK, 0)
}

func (s *CommitStatementContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *CommitStatementContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAIN, 0)
}

func (s *CommitStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRELEASE, 0)
}

func (s *CommitStatementContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserNO)
}

func (s *CommitStatementContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserNO, i)
}

func (s *CommitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCommitStatement(s)
	}
}

func (s *CommitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCommitStatement(s)
	}
}

func (p *StarRocksParser) CommitStatement() (localctx ICommitStatementContext) {
	localctx = NewCommitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, StarRocksParserRULE_commitStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5850)
		p.Match(StarRocksParserCOMMIT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWORK {
		{
			p.SetState(5851)
			p.Match(StarRocksParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5859)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAND {
		{
			p.SetState(5854)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5856)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNO {
			{
				p.SetState(5855)
				p.Match(StarRocksParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5858)
			p.Match(StarRocksParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5865)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNO || _la == StarRocksParserRELEASE {
		p.SetState(5862)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNO {
			{
				p.SetState(5861)
				p.Match(StarRocksParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5864)
			p.Match(StarRocksParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRollbackStatementContext is an interface to support dynamic dispatch.
type IRollbackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROLLBACK() antlr.TerminalNode
	WORK() antlr.TerminalNode
	AND() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	RELEASE() antlr.TerminalNode
	AllNO() []antlr.TerminalNode
	NO(i int) antlr.TerminalNode

	// IsRollbackStatementContext differentiates from other interfaces.
	IsRollbackStatementContext()
}

type RollbackStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRollbackStatementContext() *RollbackStatementContext {
	var p = new(RollbackStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollbackStatement
	return p
}

func InitEmptyRollbackStatementContext(p *RollbackStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rollbackStatement
}

func (*RollbackStatementContext) IsRollbackStatementContext() {}

func NewRollbackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RollbackStatementContext {
	var p = new(RollbackStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rollbackStatement

	return p
}

func (s *RollbackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RollbackStatementContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLBACK, 0)
}

func (s *RollbackStatementContext) WORK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWORK, 0)
}

func (s *RollbackStatementContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *RollbackStatementContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAIN, 0)
}

func (s *RollbackStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRELEASE, 0)
}

func (s *RollbackStatementContext) AllNO() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserNO)
}

func (s *RollbackStatementContext) NO(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserNO, i)
}

func (s *RollbackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollbackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RollbackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollbackStatement(s)
	}
}

func (s *RollbackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollbackStatement(s)
	}
}

func (p *StarRocksParser) RollbackStatement() (localctx IRollbackStatementContext) {
	localctx = NewRollbackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, StarRocksParserRULE_rollbackStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5867)
		p.Match(StarRocksParserROLLBACK)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWORK {
		{
			p.SetState(5868)
			p.Match(StarRocksParserWORK)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5876)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAND {
		{
			p.SetState(5871)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNO {
			{
				p.SetState(5872)
				p.Match(StarRocksParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5875)
			p.Match(StarRocksParserCHAIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(5882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNO || _la == StarRocksParserRELEASE {
		p.SetState(5879)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNO {
			{
				p.SetState(5878)
				p.Match(StarRocksParserNO)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5881)
			p.Match(StarRocksParserRELEASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITranslateStatementContext is an interface to support dynamic dispatch.
type ITranslateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRANSLATE() antlr.TerminalNode
	Dialect() IDialectContext
	TranslateSQL() ITranslateSQLContext

	// IsTranslateStatementContext differentiates from other interfaces.
	IsTranslateStatementContext()
}

type TranslateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslateStatementContext() *TranslateStatementContext {
	var p = new(TranslateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_translateStatement
	return p
}

func InitEmptyTranslateStatementContext(p *TranslateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_translateStatement
}

func (*TranslateStatementContext) IsTranslateStatementContext() {}

func NewTranslateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslateStatementContext {
	var p = new(TranslateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_translateStatement

	return p
}

func (s *TranslateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TranslateStatementContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSLATE, 0)
}

func (s *TranslateStatementContext) Dialect() IDialectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDialectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDialectContext)
}

func (s *TranslateStatementContext) TranslateSQL() ITranslateSQLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITranslateSQLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITranslateSQLContext)
}

func (s *TranslateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTranslateStatement(s)
	}
}

func (s *TranslateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTranslateStatement(s)
	}
}

func (p *StarRocksParser) TranslateStatement() (localctx ITranslateStatementContext) {
	localctx = NewTranslateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, StarRocksParserRULE_translateStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5884)
		p.Match(StarRocksParserTRANSLATE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5885)
		p.Dialect()
	}
	{
		p.SetState(5886)
		p.TranslateSQL()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDialectContext is an interface to support dynamic dispatch.
type IDialectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsDialectContext differentiates from other interfaces.
	IsDialectContext()
}

type DialectContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDialectContext() *DialectContext {
	var p = new(DialectContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dialect
	return p
}

func InitEmptyDialectContext(p *DialectContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_dialect
}

func (*DialectContext) IsDialectContext() {}

func NewDialectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DialectContext {
	var p = new(DialectContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_dialect

	return p
}

func (s *DialectContext) GetParser() antlr.Parser { return s.parser }

func (s *DialectContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DialectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DialectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DialectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDialect(s)
	}
}

func (s *DialectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDialect(s)
	}
}

func (p *StarRocksParser) Dialect() (localctx IDialectContext) {
	localctx = NewDialectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, StarRocksParserRULE_dialect)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5888)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITranslateSQLContext is an interface to support dynamic dispatch.
type ITranslateSQLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTranslateSQLContext differentiates from other interfaces.
	IsTranslateSQLContext()
}

type TranslateSQLContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTranslateSQLContext() *TranslateSQLContext {
	var p = new(TranslateSQLContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_translateSQL
	return p
}

func InitEmptyTranslateSQLContext(p *TranslateSQLContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_translateSQL
}

func (*TranslateSQLContext) IsTranslateSQLContext() {}

func NewTranslateSQLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TranslateSQLContext {
	var p = new(TranslateSQLContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_translateSQL

	return p
}

func (s *TranslateSQLContext) GetParser() antlr.Parser { return s.parser }
func (s *TranslateSQLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateSQLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TranslateSQLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTranslateSQL(s)
	}
}

func (s *TranslateSQLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTranslateSQL(s)
	}
}

func (p *StarRocksParser) TranslateSQL() (localctx ITranslateSQLContext) {
	localctx = NewTranslateSQLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, StarRocksParserRULE_translateSQL)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5891)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(5890)
			p.MatchWildcard()

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(5893)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 652, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryStatementContext is an interface to support dynamic dispatch.
type IQueryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryRelation() IQueryRelationContext
	ExplainDesc() IExplainDescContext
	OptimizerTrace() IOptimizerTraceContext
	Outfile() IOutfileContext

	// IsQueryStatementContext differentiates from other interfaces.
	IsQueryStatementContext()
}

type QueryStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryStatementContext() *QueryStatementContext {
	var p = new(QueryStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryStatement
	return p
}

func InitEmptyQueryStatementContext(p *QueryStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryStatement
}

func (*QueryStatementContext) IsQueryStatementContext() {}

func NewQueryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryStatementContext {
	var p = new(QueryStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryStatement

	return p
}

func (s *QueryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryStatementContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *QueryStatementContext) ExplainDesc() IExplainDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplainDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplainDescContext)
}

func (s *QueryStatementContext) OptimizerTrace() IOptimizerTraceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptimizerTraceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptimizerTraceContext)
}

func (s *QueryStatementContext) Outfile() IOutfileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOutfileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOutfileContext)
}

func (s *QueryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryStatement(s)
	}
}

func (s *QueryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryStatement(s)
	}
}

func (p *StarRocksParser) QueryStatement() (localctx IQueryStatementContext) {
	localctx = NewQueryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, StarRocksParserRULE_queryStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5897)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserEXPLAIN:
		{
			p.SetState(5895)
			p.ExplainDesc()
		}

	case StarRocksParserTRACE:
		{
			p.SetState(5896)
			p.OptimizerTrace()
		}

	case StarRocksParserT__1, StarRocksParserSELECT, StarRocksParserWITH:

	default:
	}
	{
		p.SetState(5899)
		p.QueryRelation()
	}
	p.SetState(5901)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserINTO {
		{
			p.SetState(5900)
			p.Outfile()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryRelationContext is an interface to support dynamic dispatch.
type IQueryRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryNoWith() IQueryNoWithContext
	WithClause() IWithClauseContext

	// IsQueryRelationContext differentiates from other interfaces.
	IsQueryRelationContext()
}

type QueryRelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryRelationContext() *QueryRelationContext {
	var p = new(QueryRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryRelation
	return p
}

func InitEmptyQueryRelationContext(p *QueryRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryRelation
}

func (*QueryRelationContext) IsQueryRelationContext() {}

func NewQueryRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryRelationContext {
	var p = new(QueryRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryRelation

	return p
}

func (s *QueryRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryRelationContext) QueryNoWith() IQueryNoWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryNoWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryNoWithContext)
}

func (s *QueryRelationContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryRelation(s)
	}
}

func (s *QueryRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryRelation(s)
	}
}

func (p *StarRocksParser) QueryRelation() (localctx IQueryRelationContext) {
	localctx = NewQueryRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, StarRocksParserRULE_queryRelation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserWITH {
		{
			p.SetState(5903)
			p.WithClause()
		}

	}
	{
		p.SetState(5906)
		p.QueryNoWith()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH() antlr.TerminalNode
	AllCommonTableExpression() []ICommonTableExpressionContext
	CommonTableExpression(i int) ICommonTableExpressionContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWITH, 0)
}

func (s *WithClauseContext) AllCommonTableExpression() []ICommonTableExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			len++
		}
	}

	tst := make([]ICommonTableExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommonTableExpressionContext); ok {
			tst[i] = t.(ICommonTableExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WithClauseContext) CommonTableExpression(i int) ICommonTableExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (p *StarRocksParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, StarRocksParserRULE_withClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5908)
		p.Match(StarRocksParserWITH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5909)
		p.CommonTableExpression()
	}
	p.SetState(5914)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(5910)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5911)
			p.CommonTableExpression()
		}

		p.SetState(5916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryNoWithContext is an interface to support dynamic dispatch.
type IQueryNoWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryPrimary() IQueryPrimaryContext
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	LimitElement() ILimitElementContext

	// IsQueryNoWithContext differentiates from other interfaces.
	IsQueryNoWithContext()
}

type QueryNoWithContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryNoWithContext() *QueryNoWithContext {
	var p = new(QueryNoWithContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryNoWith
	return p
}

func InitEmptyQueryNoWithContext(p *QueryNoWithContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryNoWith
}

func (*QueryNoWithContext) IsQueryNoWithContext() {}

func NewQueryNoWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryNoWithContext {
	var p = new(QueryNoWithContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryNoWith

	return p
}

func (s *QueryNoWithContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryNoWithContext) QueryPrimary() IQueryPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryNoWithContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *QueryNoWithContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *QueryNoWithContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *QueryNoWithContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *QueryNoWithContext) LimitElement() ILimitElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitElementContext)
}

func (s *QueryNoWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryNoWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryNoWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryNoWith(s)
	}
}

func (s *QueryNoWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryNoWith(s)
	}
}

func (p *StarRocksParser) QueryNoWith() (localctx IQueryNoWithContext) {
	localctx = NewQueryNoWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, StarRocksParserRULE_queryNoWith)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5917)
		p.queryPrimary(0)
	}
	p.SetState(5928)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(5918)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5919)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5920)
			p.SortItem()
		}
		p.SetState(5925)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(5921)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5922)
				p.SortItem()
			}

			p.SetState(5927)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(5931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserLIMIT {
		{
			p.SetState(5930)
			p.LimitElement()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPeriodContext is an interface to support dynamic dispatch.
type IQueryPeriodContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEnd returns the end rule contexts.
	GetEnd() IExpressionContext

	// SetEnd sets the end rule contexts.
	SetEnd(IExpressionContext)

	// Getter signatures
	PeriodType() IPeriodTypeContext
	BETWEEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	AND() antlr.TerminalNode
	FOR() antlr.TerminalNode
	FROM() antlr.TerminalNode
	TO() antlr.TerminalNode
	ALL() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode

	// IsQueryPeriodContext differentiates from other interfaces.
	IsQueryPeriodContext()
}

type QueryPeriodContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	end    IExpressionContext
}

func NewEmptyQueryPeriodContext() *QueryPeriodContext {
	var p = new(QueryPeriodContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryPeriod
	return p
}

func InitEmptyQueryPeriodContext(p *QueryPeriodContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryPeriod
}

func (*QueryPeriodContext) IsQueryPeriodContext() {}

func NewQueryPeriodContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPeriodContext {
	var p = new(QueryPeriodContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryPeriod

	return p
}

func (s *QueryPeriodContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPeriodContext) GetEnd() IExpressionContext { return s.end }

func (s *QueryPeriodContext) SetEnd(v IExpressionContext) { s.end = v }

func (s *QueryPeriodContext) PeriodType() IPeriodTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPeriodTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPeriodTypeContext)
}

func (s *QueryPeriodContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBETWEEN, 0)
}

func (s *QueryPeriodContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QueryPeriodContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QueryPeriodContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *QueryPeriodContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *QueryPeriodContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *QueryPeriodContext) TO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTO, 0)
}

func (s *QueryPeriodContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *QueryPeriodContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *QueryPeriodContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *QueryPeriodContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPeriodContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryPeriodContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryPeriod(s)
	}
}

func (s *QueryPeriodContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryPeriod(s)
	}
}

func (p *StarRocksParser) QueryPeriod() (localctx IQueryPeriodContext) {
	localctx = NewQueryPeriodContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, StarRocksParserRULE_queryPeriod)
	var _la int

	p.SetState(5965)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 664, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5934)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(5933)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5936)
			p.PeriodType()
		}
		{
			p.SetState(5937)
			p.Match(StarRocksParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5938)
			p.expression(0)
		}
		{
			p.SetState(5939)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5940)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(5942)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5945)
			p.PeriodType()
		}
		{
			p.SetState(5946)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5947)
			p.expression(0)
		}
		{
			p.SetState(5948)
			p.Match(StarRocksParserTO)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5949)
			p.expression(0)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(5952)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(5951)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5954)
			p.PeriodType()
		}
		{
			p.SetState(5955)
			p.Match(StarRocksParserALL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(5958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserFOR {
			{
				p.SetState(5957)
				p.Match(StarRocksParserFOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5960)
			p.PeriodType()
		}
		{
			p.SetState(5961)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5962)
			p.Match(StarRocksParserOF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5963)

			var _x = p.expression(0)

			localctx.(*QueryPeriodContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPeriodTypeContext is an interface to support dynamic dispatch.
type IPeriodTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SYSTEM_TIME() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	VERSION() antlr.TerminalNode

	// IsPeriodTypeContext differentiates from other interfaces.
	IsPeriodTypeContext()
}

type PeriodTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPeriodTypeContext() *PeriodTypeContext {
	var p = new(PeriodTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_periodType
	return p
}

func InitEmptyPeriodTypeContext(p *PeriodTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_periodType
}

func (*PeriodTypeContext) IsPeriodTypeContext() {}

func NewPeriodTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PeriodTypeContext {
	var p = new(PeriodTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_periodType

	return p
}

func (s *PeriodTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PeriodTypeContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM_TIME, 0)
}

func (s *PeriodTypeContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMP, 0)
}

func (s *PeriodTypeContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *PeriodTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PeriodTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PeriodTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPeriodType(s)
	}
}

func (s *PeriodTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPeriodType(s)
	}
}

func (p *StarRocksParser) PeriodType() (localctx IPeriodTypeContext) {
	localctx = NewPeriodTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, StarRocksParserRULE_periodType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5967)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-417)) & ^0x3f) == 0 && ((int64(1)<<(_la-417))&562949953454081) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) CopyAll(ctx *QueryPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type QueryWithParenthesesContext struct {
	QueryPrimaryContext
}

func NewQueryWithParenthesesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryWithParenthesesContext {
	var p = new(QueryWithParenthesesContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryWithParenthesesContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *QueryWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryWithParentheses(s)
	}
}

func (s *QueryWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryWithParentheses(s)
	}
}

type SetOperationContext struct {
	QueryPrimaryContext
	left     IQueryPrimaryContext
	operator antlr.Token
	right    IQueryPrimaryContext
}

func NewSetOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetOperationContext {
	var p = new(SetOperationContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *SetOperationContext) GetOperator() antlr.Token { return s.operator }

func (s *SetOperationContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *SetOperationContext) GetLeft() IQueryPrimaryContext { return s.left }

func (s *SetOperationContext) GetRight() IQueryPrimaryContext { return s.right }

func (s *SetOperationContext) SetLeft(v IQueryPrimaryContext) { s.left = v }

func (s *SetOperationContext) SetRight(v IQueryPrimaryContext) { s.right = v }

func (s *SetOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOperationContext) AllQueryPrimary() []IQueryPrimaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			len++
		}
	}

	tst := make([]IQueryPrimaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryPrimaryContext); ok {
			tst[i] = t.(IQueryPrimaryContext)
			i++
		}
	}

	return tst
}

func (s *SetOperationContext) QueryPrimary(i int) IQueryPrimaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *SetOperationContext) INTERSECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERSECT, 0)
}

func (s *SetOperationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *SetOperationContext) UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNION, 0)
}

func (s *SetOperationContext) EXCEPT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXCEPT, 0)
}

func (s *SetOperationContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS, 0)
}

func (s *SetOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetOperation(s)
	}
}

func (s *SetOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetOperation(s)
	}
}

type QueryPrimaryDefaultContext struct {
	QueryPrimaryContext
}

func NewQueryPrimaryDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryPrimaryDefaultContext {
	var p = new(QueryPrimaryDefaultContext)

	InitEmptyQueryPrimaryContext(&p.QueryPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*QueryPrimaryContext))

	return p
}

func (s *QueryPrimaryDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryDefaultContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQueryPrimaryDefault(s)
	}
}

func (s *QueryPrimaryDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQueryPrimaryDefault(s)
	}
}

func (p *StarRocksParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	return p.queryPrimary(0)
}

func (p *StarRocksParser) queryPrimary(_p int) (localctx IQueryPrimaryContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IQueryPrimaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 756
	p.EnterRecursionRule(localctx, 756, StarRocksParserRULE_queryPrimary, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5972)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserSELECT:
		localctx = NewQueryPrimaryDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(5970)
			p.QuerySpecification()
		}

	case StarRocksParserT__1:
		localctx = NewQueryWithParenthesesContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(5971)
			p.Subquery()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(5988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 669, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(5986)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 668, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSetOperationContext(p, NewQueryPrimaryContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_queryPrimary)
				p.SetState(5974)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(5975)

					var _m = p.Match(StarRocksParserINTERSECT)

					localctx.(*SetOperationContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(5977)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
					{
						p.SetState(5976)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(5979)

					var _x = p.queryPrimary(3)

					localctx.(*SetOperationContext).right = _x
				}

			case 2:
				localctx = NewSetOperationContext(p, NewQueryPrimaryContext(p, _parentctx, _parentState))
				localctx.(*SetOperationContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_queryPrimary)
				p.SetState(5980)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(5981)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*SetOperationContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserEXCEPT || _la == StarRocksParserMINUS || _la == StarRocksParserUNION) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*SetOperationContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(5983)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
					{
						p.SetState(5982)
						p.SetQuantifier()
					}

				}
				{
					p.SetState(5985)

					var _x = p.queryPrimary(2)

					localctx.(*SetOperationContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(5990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 669, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryRelation() IQueryRelationContext

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subquery
	return p
}

func InitEmptySubqueryContext(p *SubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subquery
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (p *StarRocksParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, StarRocksParserRULE_subquery)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5991)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5992)
		p.QueryRelation()
	}
	{
		p.SetState(5993)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowConstructorContext is an interface to support dynamic dispatch.
type IRowConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext

	// IsRowConstructorContext differentiates from other interfaces.
	IsRowConstructorContext()
}

type RowConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowConstructorContext() *RowConstructorContext {
	var p = new(RowConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rowConstructor
	return p
}

func InitEmptyRowConstructorContext(p *RowConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rowConstructor
}

func (*RowConstructorContext) IsRowConstructorContext() {}

func NewRowConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowConstructorContext {
	var p = new(RowConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rowConstructor

	return p
}

func (s *RowConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *RowConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RowConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRowConstructor(s)
	}
}

func (s *RowConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRowConstructor(s)
	}
}

func (p *StarRocksParser) RowConstructor() (localctx IRowConstructorContext) {
	localctx = NewRowConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, StarRocksParserRULE_rowConstructor)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5995)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5996)
		p.ExpressionList()
	}
	{
		p.SetState(5997)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISortItemContext is an interface to support dynamic dispatch.
type ISortItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOrdering returns the ordering token.
	GetOrdering() antlr.Token

	// GetNullOrdering returns the nullOrdering token.
	GetNullOrdering() antlr.Token

	// SetOrdering sets the ordering token.
	SetOrdering(antlr.Token)

	// SetNullOrdering sets the nullOrdering token.
	SetNullOrdering(antlr.Token)

	// Getter signatures
	Expression() IExpressionContext
	NULLS() antlr.TerminalNode
	ASC() antlr.TerminalNode
	DESC() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	LAST() antlr.TerminalNode

	// IsSortItemContext differentiates from other interfaces.
	IsSortItemContext()
}

type SortItemContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	ordering     antlr.Token
	nullOrdering antlr.Token
}

func NewEmptySortItemContext() *SortItemContext {
	var p = new(SortItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sortItem
	return p
}

func InitEmptySortItemContext(p *SortItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sortItem
}

func (*SortItemContext) IsSortItemContext() {}

func NewSortItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortItemContext {
	var p = new(SortItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_sortItem

	return p
}

func (s *SortItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortItemContext) GetOrdering() antlr.Token { return s.ordering }

func (s *SortItemContext) GetNullOrdering() antlr.Token { return s.nullOrdering }

func (s *SortItemContext) SetOrdering(v antlr.Token) { s.ordering = v }

func (s *SortItemContext) SetNullOrdering(v antlr.Token) { s.nullOrdering = v }

func (s *SortItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SortItemContext) NULLS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULLS, 0)
}

func (s *SortItemContext) ASC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASC, 0)
}

func (s *SortItemContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *SortItemContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *SortItemContext) LAST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLAST, 0)
}

func (s *SortItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSortItem(s)
	}
}

func (s *SortItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSortItem(s)
	}
}

func (p *StarRocksParser) SortItem() (localctx ISortItemContext) {
	localctx = NewSortItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, StarRocksParserRULE_sortItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5999)
		p.expression(0)
	}
	p.SetState(6001)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserASC || _la == StarRocksParserDESC {
		{
			p.SetState(6000)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).ordering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserASC || _la == StarRocksParserDESC) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).ordering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(6005)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNULLS {
		{
			p.SetState(6003)
			p.Match(StarRocksParserNULLS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6004)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SortItemContext).nullOrdering = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFIRST || _la == StarRocksParserLAST) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SortItemContext).nullOrdering = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitConstExprContext is an interface to support dynamic dispatch.
type ILimitConstExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode
	PARAMETER() antlr.TerminalNode
	UserVariable() IUserVariableContext

	// IsLimitConstExprContext differentiates from other interfaces.
	IsLimitConstExprContext()
}

type LimitConstExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitConstExprContext() *LimitConstExprContext {
	var p = new(LimitConstExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_limitConstExpr
	return p
}

func InitEmptyLimitConstExprContext(p *LimitConstExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_limitConstExpr
}

func (*LimitConstExprContext) IsLimitConstExprContext() {}

func NewLimitConstExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitConstExprContext {
	var p = new(LimitConstExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_limitConstExpr

	return p
}

func (s *LimitConstExprContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitConstExprContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *LimitConstExprContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARAMETER, 0)
}

func (s *LimitConstExprContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *LimitConstExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitConstExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitConstExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLimitConstExpr(s)
	}
}

func (s *LimitConstExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLimitConstExpr(s)
	}
}

func (p *StarRocksParser) LimitConstExpr() (localctx ILimitConstExprContext) {
	localctx = NewLimitConstExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, StarRocksParserRULE_limitConstExpr)
	p.SetState(6010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserINTEGER_VALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6007)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPARAMETER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6008)
			p.Match(StarRocksParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserAT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6009)
			p.UserVariable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitElementContext is an interface to support dynamic dispatch.
type ILimitElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit rule contexts.
	GetLimit() ILimitConstExprContext

	// GetOffset returns the offset rule contexts.
	GetOffset() ILimitConstExprContext

	// SetLimit sets the limit rule contexts.
	SetLimit(ILimitConstExprContext)

	// SetOffset sets the offset rule contexts.
	SetOffset(ILimitConstExprContext)

	// Getter signatures
	LIMIT() antlr.TerminalNode
	AllLimitConstExpr() []ILimitConstExprContext
	LimitConstExpr(i int) ILimitConstExprContext
	OFFSET() antlr.TerminalNode

	// IsLimitElementContext differentiates from other interfaces.
	IsLimitElementContext()
}

type LimitElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	limit  ILimitConstExprContext
	offset ILimitConstExprContext
}

func NewEmptyLimitElementContext() *LimitElementContext {
	var p = new(LimitElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_limitElement
	return p
}

func InitEmptyLimitElementContext(p *LimitElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_limitElement
}

func (*LimitElementContext) IsLimitElementContext() {}

func NewLimitElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitElementContext {
	var p = new(LimitElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_limitElement

	return p
}

func (s *LimitElementContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitElementContext) GetLimit() ILimitConstExprContext { return s.limit }

func (s *LimitElementContext) GetOffset() ILimitConstExprContext { return s.offset }

func (s *LimitElementContext) SetLimit(v ILimitConstExprContext) { s.limit = v }

func (s *LimitElementContext) SetOffset(v ILimitConstExprContext) { s.offset = v }

func (s *LimitElementContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIMIT, 0)
}

func (s *LimitElementContext) AllLimitConstExpr() []ILimitConstExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitConstExprContext); ok {
			len++
		}
	}

	tst := make([]ILimitConstExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitConstExprContext); ok {
			tst[i] = t.(ILimitConstExprContext)
			i++
		}
	}

	return tst
}

func (s *LimitElementContext) LimitConstExpr(i int) ILimitConstExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitConstExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitConstExprContext)
}

func (s *LimitElementContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOFFSET, 0)
}

func (s *LimitElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLimitElement(s)
	}
}

func (s *LimitElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLimitElement(s)
	}
}

func (p *StarRocksParser) LimitElement() (localctx ILimitElementContext) {
	localctx = NewLimitElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, StarRocksParserRULE_limitElement)
	var _la int

	p.SetState(6023)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 674, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6012)
			p.Match(StarRocksParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6013)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).limit = _x
		}
		p.SetState(6016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserOFFSET {
			{
				p.SetState(6014)
				p.Match(StarRocksParserOFFSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6015)

				var _x = p.LimitConstExpr()

				localctx.(*LimitElementContext).offset = _x
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6018)
			p.Match(StarRocksParserLIMIT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6019)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).offset = _x
		}
		{
			p.SetState(6020)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6021)

			var _x = p.LimitConstExpr()

			localctx.(*LimitElementContext).limit = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetLimit returns the limit token.
	GetLimit() antlr.Token

	// SetLimit sets the limit token.
	SetLimit(antlr.Token)

	// GetWhere returns the where rule contexts.
	GetWhere() IExpressionContext

	// GetHaving returns the having rule contexts.
	GetHaving() IExpressionContext

	// GetQualifyFunction returns the qualifyFunction rule contexts.
	GetQualifyFunction() ISelectItemContext

	// SetWhere sets the where rule contexts.
	SetWhere(IExpressionContext)

	// SetHaving sets the having rule contexts.
	SetHaving(IExpressionContext)

	// SetQualifyFunction sets the qualifyFunction rule contexts.
	SetQualifyFunction(ISelectItemContext)

	// Getter signatures
	SELECT() antlr.TerminalNode
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	FromClause() IFromClauseContext
	SetQuantifier() ISetQuantifierContext
	WHERE() antlr.TerminalNode
	GROUP() antlr.TerminalNode
	BY() antlr.TerminalNode
	GroupingElement() IGroupingElementContext
	HAVING() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	ComparisonOperator() IComparisonOperatorContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser          antlr.Parser
	where           IExpressionContext
	having          IExpressionContext
	qualifyFunction ISelectItemContext
	limit           antlr.Token
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) GetLimit() antlr.Token { return s.limit }

func (s *QuerySpecificationContext) SetLimit(v antlr.Token) { s.limit = v }

func (s *QuerySpecificationContext) GetWhere() IExpressionContext { return s.where }

func (s *QuerySpecificationContext) GetHaving() IExpressionContext { return s.having }

func (s *QuerySpecificationContext) GetQualifyFunction() ISelectItemContext { return s.qualifyFunction }

func (s *QuerySpecificationContext) SetWhere(v IExpressionContext) { s.where = v }

func (s *QuerySpecificationContext) SetHaving(v IExpressionContext) { s.having = v }

func (s *QuerySpecificationContext) SetQualifyFunction(v ISelectItemContext) { s.qualifyFunction = v }

func (s *QuerySpecificationContext) SELECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSELECT, 0)
}

func (s *QuerySpecificationContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *QuerySpecificationContext) WHERE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHERE, 0)
}

func (s *QuerySpecificationContext) GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP, 0)
}

func (s *QuerySpecificationContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *QuerySpecificationContext) GroupingElement() IGroupingElementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingElementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingElementContext)
}

func (s *QuerySpecificationContext) HAVING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHAVING, 0)
}

func (s *QuerySpecificationContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUALIFY, 0)
}

func (s *QuerySpecificationContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *QuerySpecificationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QuerySpecificationContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (p *StarRocksParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, StarRocksParserRULE_querySpecification)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6025)
		p.Match(StarRocksParserSELECT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
		{
			p.SetState(6026)
			p.SetQuantifier()
		}

	}
	{
		p.SetState(6029)
		p.SelectItem()
	}
	p.SetState(6034)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 676, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6030)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6031)
				p.SelectItem()
			}

		}
		p.SetState(6036)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 676, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(6037)
		p.FromClause()
	}

	p.SetState(6040)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 677, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6038)
			p.Match(StarRocksParserWHERE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6039)

			var _x = p.expression(0)

			localctx.(*QuerySpecificationContext).where = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6045)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 678, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6042)
			p.Match(StarRocksParserGROUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6043)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6044)
			p.GroupingElement()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6049)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 679, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6047)
			p.Match(StarRocksParserHAVING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6048)

			var _x = p.expression(0)

			localctx.(*QuerySpecificationContext).having = _x
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(6056)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 680, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6051)
			p.Match(StarRocksParserQUALIFY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6052)

			var _x = p.SelectItem()

			localctx.(*QuerySpecificationContext).qualifyFunction = _x
		}
		{
			p.SetState(6053)
			p.ComparisonOperator()
		}
		{
			p.SetState(6054)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*QuerySpecificationContext).limit = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) CopyAll(ctx *FromClauseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DualContext struct {
	FromClauseContext
}

func NewDualContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DualContext {
	var p = new(DualContext)

	InitEmptyFromClauseContext(&p.FromClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*FromClauseContext))

	return p
}

func (s *DualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DualContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *DualContext) DUAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDUAL, 0)
}

func (s *DualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDual(s)
	}
}

func (s *DualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDual(s)
	}
}

type FromContext struct {
	FromClauseContext
}

func NewFromContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FromContext {
	var p = new(FromContext)

	InitEmptyFromClauseContext(&p.FromClauseContext)
	p.parser = parser
	p.CopyAll(ctx.(*FromClauseContext))

	return p
}

func (s *FromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *FromContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *FromContext) PivotClause() IPivotClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotClauseContext)
}

func (s *FromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFrom(s)
	}
}

func (s *FromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFrom(s)
	}
}

func (p *StarRocksParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, StarRocksParserRULE_fromClause)
	p.SetState(6067)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 683, p.GetParserRuleContext()) {
	case 1:
		localctx = NewFromContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6063)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 682, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6058)
				p.Match(StarRocksParserFROM)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6059)
				p.Relations()
			}
			p.SetState(6061)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 681, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6060)
					p.PivotClause()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewDualContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6065)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6066)
			p.Match(StarRocksParserDUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingElementContext is an interface to support dynamic dispatch.
type IGroupingElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsGroupingElementContext differentiates from other interfaces.
	IsGroupingElementContext()
}

type GroupingElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingElementContext() *GroupingElementContext {
	var p = new(GroupingElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_groupingElement
	return p
}

func InitEmptyGroupingElementContext(p *GroupingElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_groupingElement
}

func (*GroupingElementContext) IsGroupingElementContext() {}

func NewGroupingElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingElementContext {
	var p = new(GroupingElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_groupingElement

	return p
}

func (s *GroupingElementContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingElementContext) CopyAll(ctx *GroupingElementContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *GroupingElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type MultipleGroupingSetsContext struct {
	GroupingElementContext
}

func NewMultipleGroupingSetsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultipleGroupingSetsContext {
	var p = new(MultipleGroupingSetsContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *MultipleGroupingSetsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleGroupingSetsContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPING, 0)
}

func (s *MultipleGroupingSetsContext) SETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSETS, 0)
}

func (s *MultipleGroupingSetsContext) AllGroupingSet() []IGroupingSetContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingSetContext); ok {
			len++
		}
	}

	tst := make([]IGroupingSetContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingSetContext); ok {
			tst[i] = t.(IGroupingSetContext)
			i++
		}
	}

	return tst
}

func (s *MultipleGroupingSetsContext) GroupingSet(i int) IGroupingSetContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingSetContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingSetContext)
}

func (s *MultipleGroupingSetsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultipleGroupingSets(s)
	}
}

func (s *MultipleGroupingSetsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultipleGroupingSets(s)
	}
}

type SingleGroupingSetContext struct {
	GroupingElementContext
}

func NewSingleGroupingSetContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SingleGroupingSetContext {
	var p = new(SingleGroupingSetContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *SingleGroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleGroupingSetContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *SingleGroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleGroupingSet(s)
	}
}

func (s *SingleGroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleGroupingSet(s)
	}
}

type CubeContext struct {
	GroupingElementContext
}

func NewCubeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CubeContext {
	var p = new(CubeContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *CubeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CubeContext) CUBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUBE, 0)
}

func (s *CubeContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *CubeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCube(s)
	}
}

func (s *CubeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCube(s)
	}
}

type RollupContext struct {
	GroupingElementContext
}

func NewRollupContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RollupContext {
	var p = new(RollupContext)

	InitEmptyGroupingElementContext(&p.GroupingElementContext)
	p.parser = parser
	p.CopyAll(ctx.(*GroupingElementContext))

	return p
}

func (s *RollupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RollupContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *RollupContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *RollupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRollup(s)
	}
}

func (s *RollupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRollup(s)
	}
}

func (p *StarRocksParser) GroupingElement() (localctx IGroupingElementContext) {
	localctx = NewGroupingElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, StarRocksParserRULE_groupingElement)
	var _la int

	p.SetState(6095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 687, p.GetParserRuleContext()) {
	case 1:
		localctx = NewRollupContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6069)
			p.Match(StarRocksParserROLLUP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6070)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6071)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6074)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewCubeContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6075)
			p.Match(StarRocksParserCUBE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6076)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6077)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6080)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewMultipleGroupingSetsContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6081)
			p.Match(StarRocksParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6082)
			p.Match(StarRocksParserSETS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6083)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6084)
			p.GroupingSet()
		}
		p.SetState(6089)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6085)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6086)
				p.GroupingSet()
			}

			p.SetState(6091)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6092)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewSingleGroupingSetContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6094)
			p.ExpressionList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingSetContext is an interface to support dynamic dispatch.
type IGroupingSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsGroupingSetContext differentiates from other interfaces.
	IsGroupingSetContext()
}

type GroupingSetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingSetContext() *GroupingSetContext {
	var p = new(GroupingSetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_groupingSet
	return p
}

func InitEmptyGroupingSetContext(p *GroupingSetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_groupingSet
}

func (*GroupingSetContext) IsGroupingSetContext() {}

func NewGroupingSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingSetContext {
	var p = new(GroupingSetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_groupingSet

	return p
}

func (s *GroupingSetContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingSetContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingSetContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGroupingSet(s)
	}
}

func (s *GroupingSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGroupingSet(s)
	}
}

func (p *StarRocksParser) GroupingSet() (localctx IGroupingSetContext) {
	localctx = NewGroupingSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, StarRocksParserRULE_groupingSet)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6097)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6099)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
		{
			p.SetState(6098)
			p.expression(0)
		}

	}
	p.SetState(6105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6101)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6102)
			p.expression(0)
		}

		p.SetState(6107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6108)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonTableExpressionContext is an interface to support dynamic dispatch.
type ICommonTableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name rule contexts.
	GetName() IIdentifierContext

	// SetName sets the name rule contexts.
	SetName(IIdentifierContext)

	// Getter signatures
	AS() antlr.TerminalNode
	QueryRelation() IQueryRelationContext
	Identifier() IIdentifierContext
	ColumnAliases() IColumnAliasesContext

	// IsCommonTableExpressionContext differentiates from other interfaces.
	IsCommonTableExpressionContext()
}

type CommonTableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   IIdentifierContext
}

func NewEmptyCommonTableExpressionContext() *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_commonTableExpression
	return p
}

func InitEmptyCommonTableExpressionContext(p *CommonTableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_commonTableExpression
}

func (*CommonTableExpressionContext) IsCommonTableExpressionContext() {}

func NewCommonTableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_commonTableExpression

	return p
}

func (s *CommonTableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionContext) GetName() IIdentifierContext { return s.name }

func (s *CommonTableExpressionContext) SetName(v IIdentifierContext) { s.name = v }

func (s *CommonTableExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CommonTableExpressionContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *CommonTableExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommonTableExpressionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *CommonTableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCommonTableExpression(s)
	}
}

func (p *StarRocksParser) CommonTableExpression() (localctx ICommonTableExpressionContext) {
	localctx = NewCommonTableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, StarRocksParserRULE_commonTableExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6110)

		var _x = p.Identifier()

		localctx.(*CommonTableExpressionContext).name = _x
	}
	p.SetState(6112)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(6111)
			p.ColumnAliases()
		}

	}
	{
		p.SetState(6114)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6115)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6116)
		p.QueryRelation()
	}
	{
		p.SetState(6117)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetQuantifierContext is an interface to support dynamic dispatch.
type ISetQuantifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT() antlr.TerminalNode
	ALL() antlr.TerminalNode

	// IsSetQuantifierContext differentiates from other interfaces.
	IsSetQuantifierContext()
}

type SetQuantifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetQuantifierContext() *SetQuantifierContext {
	var p = new(SetQuantifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setQuantifier
	return p
}

func InitEmptySetQuantifierContext(p *SetQuantifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_setQuantifier
}

func (*SetQuantifierContext) IsSetQuantifierContext() {}

func NewSetQuantifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetQuantifierContext {
	var p = new(SetQuantifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_setQuantifier

	return p
}

func (s *SetQuantifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SetQuantifierContext) DISTINCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTINCT, 0)
}

func (s *SetQuantifierContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *SetQuantifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetQuantifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetQuantifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSetQuantifier(s)
	}
}

func (s *SetQuantifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSetQuantifier(s)
	}
}

func (p *StarRocksParser) SetQuantifier() (localctx ISetQuantifierContext) {
	localctx = NewSetQuantifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, StarRocksParserRULE_setQuantifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6119)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserALL || _la == StarRocksParserDISTINCT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) CopyAll(ctx *SelectItemContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SelectAllContext struct {
	SelectItemContext
}

func NewSelectAllContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectAllContext {
	var p = new(SelectAllContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectAllContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAllContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SelectAllContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *SelectAllContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSelectAll(s)
	}
}

func (s *SelectAllContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSelectAll(s)
	}
}

type SelectSingleContext struct {
	SelectItemContext
}

func NewSelectSingleContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SelectSingleContext {
	var p = new(SelectSingleContext)

	InitEmptySelectItemContext(&p.SelectItemContext)
	p.parser = parser
	p.CopyAll(ctx.(*SelectItemContext))

	return p
}

func (s *SelectSingleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectSingleContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SelectSingleContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectSingleContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SelectSingleContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *SelectSingleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSelectSingle(s)
	}
}

func (s *SelectSingleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSelectSingle(s)
	}
}

func (p *StarRocksParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, StarRocksParserRULE_selectItem)
	var _la int

	p.SetState(6136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 694, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSelectSingleContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6121)
			p.expression(0)
		}
		p.SetState(6129)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 693, p.GetParserRuleContext()) == 1 {
			p.SetState(6123)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6122)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(6127)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
				{
					p.SetState(6125)
					p.Identifier()
				}

			case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
				{
					p.SetState(6126)
					p.String_()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6131)
			p.QualifiedName()
		}
		{
			p.SetState(6132)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6133)
			p.Match(StarRocksParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewSelectAllContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6135)
			p.Match(StarRocksParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationsContext is an interface to support dynamic dispatch.
type IRelationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRelation() []IRelationContext
	Relation(i int) IRelationContext
	AllLATERAL() []antlr.TerminalNode
	LATERAL(i int) antlr.TerminalNode

	// IsRelationsContext differentiates from other interfaces.
	IsRelationsContext()
}

type RelationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationsContext() *RelationsContext {
	var p = new(RelationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relations
	return p
}

func InitEmptyRelationsContext(p *RelationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relations
}

func (*RelationsContext) IsRelationsContext() {}

func NewRelationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationsContext {
	var p = new(RelationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_relations

	return p
}

func (s *RelationsContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationsContext) AllRelation() []IRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRelationContext); ok {
			len++
		}
	}

	tst := make([]IRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRelationContext); ok {
			tst[i] = t.(IRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationsContext) Relation(i int) IRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationContext)
}

func (s *RelationsContext) AllLATERAL() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserLATERAL)
}

func (s *RelationsContext) LATERAL(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserLATERAL, i)
}

func (s *RelationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRelations(s)
	}
}

func (s *RelationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRelations(s)
	}
}

func (p *StarRocksParser) Relations() (localctx IRelationsContext) {
	localctx = NewRelationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, StarRocksParserRULE_relations)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6138)
		p.Relation()
	}
	p.SetState(6146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6139)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(6141)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserLATERAL {
				{
					p.SetState(6140)
					p.Match(StarRocksParserLATERAL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6143)
				p.Relation()
			}

		}
		p.SetState(6148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 696, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationContext is an interface to support dynamic dispatch.
type IRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RelationPrimary() IRelationPrimaryContext
	AllJoinRelation() []IJoinRelationContext
	JoinRelation(i int) IJoinRelationContext

	// IsRelationContext differentiates from other interfaces.
	IsRelationContext()
}

type RelationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationContext() *RelationContext {
	var p = new(RelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relation
	return p
}

func InitEmptyRelationContext(p *RelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relation
}

func (*RelationContext) IsRelationContext() {}

func NewRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationContext {
	var p = new(RelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_relation

	return p
}

func (s *RelationContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *RelationContext) AllJoinRelation() []IJoinRelationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinRelationContext); ok {
			len++
		}
	}

	tst := make([]IJoinRelationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinRelationContext); ok {
			tst[i] = t.(IJoinRelationContext)
			i++
		}
	}

	return tst
}

func (s *RelationContext) JoinRelation(i int) IJoinRelationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinRelationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinRelationContext)
}

func (s *RelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRelation(s)
	}
}

func (s *RelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRelation(s)
	}
}

func (p *StarRocksParser) Relation() (localctx IRelationContext) {
	localctx = NewRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, StarRocksParserRULE_relation)
	var _la int

	var _alt int

	p.SetState(6166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 699, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6149)
			p.RelationPrimary()
		}
		p.SetState(6153)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(6150)
					p.JoinRelation()
				}

			}
			p.SetState(6155)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 697, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6156)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6157)
			p.RelationPrimary()
		}
		p.SetState(6161)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserCROSS || ((int64((_la-172)) & ^0x3f) == 0 && ((int64(1)<<(_la-172))&4612811926924165121) != 0) || _la == StarRocksParserRIGHT {
			{
				p.SetState(6158)
				p.JoinRelation()
			}

			p.SetState(6163)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6164)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRelationPrimaryContext is an interface to support dynamic dispatch.
type IRelationPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelationPrimaryContext differentiates from other interfaces.
	IsRelationPrimaryContext()
}

type RelationPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationPrimaryContext() *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relationPrimary
	return p
}

func InitEmptyRelationPrimaryContext(p *RelationPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_relationPrimary
}

func (*RelationPrimaryContext) IsRelationPrimaryContext() {}

func NewRelationPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationPrimaryContext {
	var p = new(RelationPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_relationPrimary

	return p
}

func (s *RelationPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationPrimaryContext) CopyAll(ctx *RelationPrimaryContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *RelationPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SubqueryWithAliasContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewSubqueryWithAliasContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryWithAliasContext {
	var p = new(SubqueryWithAliasContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *SubqueryWithAliasContext) GetAlias() IIdentifierContext { return s.alias }

func (s *SubqueryWithAliasContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *SubqueryWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryWithAliasContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SubqueryWithAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubqueryWithAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *SubqueryWithAliasContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *SubqueryWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubqueryWithAlias(s)
	}
}

func (s *SubqueryWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubqueryWithAlias(s)
	}
}

type NormalizedTableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewNormalizedTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NormalizedTableFunctionContext {
	var p = new(NormalizedTableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *NormalizedTableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *NormalizedTableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *NormalizedTableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NormalizedTableFunctionContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *NormalizedTableFunctionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *NormalizedTableFunctionContext) ArgumentList() IArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentListContext)
}

func (s *NormalizedTableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NormalizedTableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *NormalizedTableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *NormalizedTableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNormalizedTableFunction(s)
	}
}

func (s *NormalizedTableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNormalizedTableFunction(s)
	}
}

type TableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableFunctionContext {
	var p = new(TableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *TableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *TableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableFunctionContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *TableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *TableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *TableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableFunction(s)
	}
}

func (s *TableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableFunction(s)
	}
}

type ParenthesizedRelationContext struct {
	RelationPrimaryContext
}

func NewParenthesizedRelationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedRelationContext {
	var p = new(ParenthesizedRelationContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *ParenthesizedRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedRelationContext) Relations() IRelationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationsContext)
}

func (s *ParenthesizedRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterParenthesizedRelation(s)
	}
}

func (s *ParenthesizedRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitParenthesizedRelation(s)
	}
}

type FileTableFunctionContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewFileTableFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FileTableFunctionContext {
	var p = new(FileTableFunctionContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *FileTableFunctionContext) GetAlias() IIdentifierContext { return s.alias }

func (s *FileTableFunctionContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *FileTableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileTableFunctionContext) FILES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILES, 0)
}

func (s *FileTableFunctionContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *FileTableFunctionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileTableFunctionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *FileTableFunctionContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *FileTableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFileTableFunction(s)
	}
}

func (s *FileTableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFileTableFunction(s)
	}
}

type TableAtomContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
	ts    IStringContext
}

func NewTableAtomContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TableAtomContext {
	var p = new(TableAtomContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *TableAtomContext) GetAlias() IIdentifierContext { return s.alias }

func (s *TableAtomContext) GetTs() IStringContext { return s.ts }

func (s *TableAtomContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *TableAtomContext) SetTs(v IStringContext) { s.ts = v }

func (s *TableAtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAtomContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableAtomContext) QueryPeriod() IQueryPeriodContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPeriodContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPeriodContext)
}

func (s *TableAtomContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TableAtomContext) TabletList() ITabletListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITabletListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITabletListContext)
}

func (s *TableAtomContext) ReplicaList() IReplicaListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicaListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicaListContext)
}

func (s *TableAtomContext) SampleClause() ISampleClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISampleClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISampleClauseContext)
}

func (s *TableAtomContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *TableAtomContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBEFORE, 0)
}

func (s *TableAtomContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableAtomContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *TableAtomContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *TableAtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableAtom(s)
	}
}

func (s *TableAtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableAtom(s)
	}
}

type InlineTableContext struct {
	RelationPrimaryContext
	alias IIdentifierContext
}

func NewInlineTableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InlineTableContext {
	var p = new(InlineTableContext)

	InitEmptyRelationPrimaryContext(&p.RelationPrimaryContext)
	p.parser = parser
	p.CopyAll(ctx.(*RelationPrimaryContext))

	return p
}

func (s *InlineTableContext) GetAlias() IIdentifierContext { return s.alias }

func (s *InlineTableContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *InlineTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlineTableContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *InlineTableContext) AllRowConstructor() []IRowConstructorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowConstructorContext); ok {
			len++
		}
	}

	tst := make([]IRowConstructorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowConstructorContext); ok {
			tst[i] = t.(IRowConstructorContext)
			i++
		}
	}

	return tst
}

func (s *InlineTableContext) RowConstructor(i int) IRowConstructorContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowConstructorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowConstructorContext)
}

func (s *InlineTableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InlineTableContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *InlineTableContext) ColumnAliases() IColumnAliasesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnAliasesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnAliasesContext)
}

func (s *InlineTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInlineTable(s)
	}
}

func (s *InlineTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInlineTable(s)
	}
}

func (p *StarRocksParser) RelationPrimary() (localctx IRelationPrimaryContext) {
	localctx = NewRelationPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, StarRocksParserRULE_relationPrimary)
	var _la int

	p.SetState(6271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 725, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTableAtomContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6168)
			p.QualifiedName()
		}
		p.SetState(6170)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 700, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6169)
				p.QueryPeriod()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6173)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6172)
				p.PartitionNames()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6176)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 702, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6175)
				p.TabletList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6179)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 703, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6178)
				p.ReplicaList()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6182)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 704, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6181)
				p.SampleClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6188)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 706, p.GetParserRuleContext()) == 1 {
			p.SetState(6185)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6184)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6187)

				var _x = p.Identifier()

				localctx.(*TableAtomContext).alias = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6191)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 707, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6190)
				p.BracketHint()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(6195)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6193)
				p.Match(StarRocksParserBEFORE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6194)

				var _x = p.String_()

				localctx.(*TableAtomContext).ts = _x
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewInlineTableContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6197)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6198)
			p.Match(StarRocksParserVALUES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6199)
			p.RowConstructor()
		}
		p.SetState(6204)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6200)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6201)
				p.RowConstructor()
			}

			p.SetState(6206)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6207)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6215)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 712, p.GetParserRuleContext()) == 1 {
			p.SetState(6209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6208)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6211)

				var _x = p.Identifier()

				localctx.(*InlineTableContext).alias = _x
			}
			p.SetState(6213)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 711, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6212)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSubqueryWithAliasContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6217)
			p.Subquery()
		}
		p.SetState(6225)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 715, p.GetParserRuleContext()) == 1 {
			p.SetState(6219)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6218)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6221)

				var _x = p.Identifier()

				localctx.(*SubqueryWithAliasContext).alias = _x
			}
			p.SetState(6223)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 714, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6222)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 4:
		localctx = NewTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6227)
			p.QualifiedName()
		}
		{
			p.SetState(6228)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6229)
			p.ExpressionList()
		}
		{
			p.SetState(6230)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6238)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 718, p.GetParserRuleContext()) == 1 {
			p.SetState(6232)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6231)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6234)

				var _x = p.Identifier()

				localctx.(*TableFunctionContext).alias = _x
			}
			p.SetState(6236)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 717, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6235)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		localctx = NewNormalizedTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6240)
			p.Match(StarRocksParserTABLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6241)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6242)
			p.QualifiedName()
		}
		{
			p.SetState(6243)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6244)
			p.ArgumentList()
		}
		{
			p.SetState(6245)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6246)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6254)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 721, p.GetParserRuleContext()) == 1 {
			p.SetState(6248)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6247)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6250)

				var _x = p.Identifier()

				localctx.(*NormalizedTableFunctionContext).alias = _x
			}
			p.SetState(6252)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 720, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6251)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		localctx = NewFileTableFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6256)
			p.Match(StarRocksParserFILES)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6257)
			p.PropertyList()
		}
		p.SetState(6265)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 724, p.GetParserRuleContext()) == 1 {
			p.SetState(6259)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(6258)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(6261)

				var _x = p.Identifier()

				localctx.(*FileTableFunctionContext).alias = _x
			}
			p.SetState(6263)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 723, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6262)
					p.ColumnAliases()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		localctx = NewParenthesizedRelationContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6267)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6268)
			p.Relations()
		}
		{
			p.SetState(6269)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotClauseContext is an interface to support dynamic dispatch.
type IPivotClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PIVOT() antlr.TerminalNode
	AllPivotAggregationExpression() []IPivotAggregationExpressionContext
	PivotAggregationExpression(i int) IPivotAggregationExpressionContext
	FOR() antlr.TerminalNode
	IN() antlr.TerminalNode
	AllPivotValue() []IPivotValueContext
	PivotValue(i int) IPivotValueContext
	Identifier() IIdentifierContext
	IdentifierList() IIdentifierListContext

	// IsPivotClauseContext differentiates from other interfaces.
	IsPivotClauseContext()
}

type PivotClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotClauseContext() *PivotClauseContext {
	var p = new(PivotClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotClause
	return p
}

func InitEmptyPivotClauseContext(p *PivotClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotClause
}

func (*PivotClauseContext) IsPivotClauseContext() {}

func NewPivotClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotClauseContext {
	var p = new(PivotClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_pivotClause

	return p
}

func (s *PivotClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotClauseContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIVOT, 0)
}

func (s *PivotClauseContext) AllPivotAggregationExpression() []IPivotAggregationExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotAggregationExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPivotAggregationExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotAggregationExpressionContext); ok {
			tst[i] = t.(IPivotAggregationExpressionContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotAggregationExpression(i int) IPivotAggregationExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotAggregationExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotAggregationExpressionContext)
}

func (s *PivotClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *PivotClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *PivotClauseContext) AllPivotValue() []IPivotValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPivotValueContext); ok {
			len++
		}
	}

	tst := make([]IPivotValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPivotValueContext); ok {
			tst[i] = t.(IPivotValueContext)
			i++
		}
	}

	return tst
}

func (s *PivotClauseContext) PivotValue(i int) IPivotValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPivotValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPivotValueContext)
}

func (s *PivotClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PivotClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPivotClause(s)
	}
}

func (s *PivotClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPivotClause(s)
	}
}

func (p *StarRocksParser) PivotClause() (localctx IPivotClauseContext) {
	localctx = NewPivotClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, StarRocksParserRULE_pivotClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6273)
		p.Match(StarRocksParserPIVOT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6274)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6275)
		p.PivotAggregationExpression()
	}
	p.SetState(6280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6276)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6277)
			p.PivotAggregationExpression()
		}

		p.SetState(6282)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6283)
		p.Match(StarRocksParserFOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6286)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(6284)
			p.Identifier()
		}

	case StarRocksParserT__1:
		{
			p.SetState(6285)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(6288)
		p.Match(StarRocksParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6289)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6290)
		p.PivotValue()
	}
	p.SetState(6295)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6291)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6292)
			p.PivotValue()
		}

		p.SetState(6297)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6298)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6299)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotAggregationExpressionContext is an interface to support dynamic dispatch.
type IPivotAggregationExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FunctionCall() IFunctionCallContext
	Identifier() IIdentifierContext
	String_() IStringContext
	AS() antlr.TerminalNode

	// IsPivotAggregationExpressionContext differentiates from other interfaces.
	IsPivotAggregationExpressionContext()
}

type PivotAggregationExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotAggregationExpressionContext() *PivotAggregationExpressionContext {
	var p = new(PivotAggregationExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotAggregationExpression
	return p
}

func InitEmptyPivotAggregationExpressionContext(p *PivotAggregationExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotAggregationExpression
}

func (*PivotAggregationExpressionContext) IsPivotAggregationExpressionContext() {}

func NewPivotAggregationExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotAggregationExpressionContext {
	var p = new(PivotAggregationExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_pivotAggregationExpression

	return p
}

func (s *PivotAggregationExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotAggregationExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PivotAggregationExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotAggregationExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PivotAggregationExpressionContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *PivotAggregationExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotAggregationExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotAggregationExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPivotAggregationExpression(s)
	}
}

func (s *PivotAggregationExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPivotAggregationExpression(s)
	}
}

func (p *StarRocksParser) PivotAggregationExpression() (localctx IPivotAggregationExpressionContext) {
	localctx = NewPivotAggregationExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, StarRocksParserRULE_pivotAggregationExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6301)
		p.FunctionCall()
	}
	p.SetState(6309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262622484480) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&7557330222697660093) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-4653295000587626501) != 0) || ((int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&-3747053846437727955) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&8790990742223650807) != 0) || ((int64((_la-326)) & ^0x3f) == 0 && ((int64(1)<<(_la-326))&-5479769140411580417) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&3742173942658366679) != 0) || ((int64((_la-454)) & ^0x3f) == 0 && ((int64(1)<<(_la-454))&8856199495341) != 0) || ((int64((_la-519)) & ^0x3f) == 0 && ((int64(1)<<(_la-519))&4211) != 0) {
		p.SetState(6303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS {
			{
				p.SetState(6302)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6307)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(6305)
				p.Identifier()
			}

		case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(6306)
				p.String_()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPivotValueContext is an interface to support dynamic dispatch.
type IPivotValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LiteralExpression() ILiteralExpressionContext
	LiteralExpressionList() ILiteralExpressionListContext
	Identifier() IIdentifierContext
	String_() IStringContext
	AS() antlr.TerminalNode

	// IsPivotValueContext differentiates from other interfaces.
	IsPivotValueContext()
}

type PivotValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPivotValueContext() *PivotValueContext {
	var p = new(PivotValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotValue
	return p
}

func InitEmptyPivotValueContext(p *PivotValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_pivotValue
}

func (*PivotValueContext) IsPivotValueContext() {}

func NewPivotValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PivotValueContext {
	var p = new(PivotValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_pivotValue

	return p
}

func (s *PivotValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PivotValueContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *PivotValueContext) LiteralExpressionList() ILiteralExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionListContext)
}

func (s *PivotValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PivotValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PivotValueContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *PivotValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PivotValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PivotValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPivotValue(s)
	}
}

func (s *PivotValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPivotValue(s)
	}
}

func (p *StarRocksParser) PivotValue() (localctx IPivotValueContext) {
	localctx = NewPivotValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, StarRocksParserRULE_pivotValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCEIL, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserFALSE, StarRocksParserFLOOR, StarRocksParserINTERVAL, StarRocksParserNULL, StarRocksParserPARAMETER, StarRocksParserTRUE, StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT:
		{
			p.SetState(6311)
			p.LiteralExpression()
		}

	case StarRocksParserT__1:
		{
			p.SetState(6312)
			p.LiteralExpressionList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(6322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262622484480) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&7557330222697660093) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-4653295000587626501) != 0) || ((int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&-3747053846437727955) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&8790990742223650807) != 0) || ((int64((_la-326)) & ^0x3f) == 0 && ((int64(1)<<(_la-326))&-5479769140411580417) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&3742173942658366679) != 0) || ((int64((_la-454)) & ^0x3f) == 0 && ((int64(1)<<(_la-454))&8856199495341) != 0) || ((int64((_la-519)) & ^0x3f) == 0 && ((int64(1)<<(_la-519))&4211) != 0) {
		p.SetState(6316)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserAS {
			{
				p.SetState(6315)
				p.Match(StarRocksParserAS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(6320)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(6318)
				p.Identifier()
			}

		case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
			{
				p.SetState(6319)
				p.String_()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISampleClauseContext is an interface to support dynamic dispatch.
type ISampleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAMPLE() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSampleClauseContext differentiates from other interfaces.
	IsSampleClauseContext()
}

type SampleClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySampleClauseContext() *SampleClauseContext {
	var p = new(SampleClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sampleClause
	return p
}

func InitEmptySampleClauseContext(p *SampleClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_sampleClause
}

func (*SampleClauseContext) IsSampleClauseContext() {}

func NewSampleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SampleClauseContext {
	var p = new(SampleClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_sampleClause

	return p
}

func (s *SampleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SampleClauseContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSAMPLE, 0)
}

func (s *SampleClauseContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SampleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SampleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SampleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSampleClause(s)
	}
}

func (s *SampleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSampleClause(s)
	}
}

func (p *StarRocksParser) SampleClause() (localctx ISampleClauseContext) {
	localctx = NewSampleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, StarRocksParserRULE_sampleClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6324)
		p.Match(StarRocksParserSAMPLE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6326)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 736, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6325)
			p.PropertyList()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArgumentListContext is an interface to support dynamic dispatch.
type IArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionList() IExpressionListContext
	NamedArgumentList() INamedArgumentListContext

	// IsArgumentListContext differentiates from other interfaces.
	IsArgumentListContext()
}

type ArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentListContext() *ArgumentListContext {
	var p = new(ArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_argumentList
	return p
}

func InitEmptyArgumentListContext(p *ArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_argumentList
}

func (*ArgumentListContext) IsArgumentListContext() {}

func NewArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentListContext {
	var p = new(ArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_argumentList

	return p
}

func (s *ArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArgumentListContext) NamedArgumentList() INamedArgumentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentListContext)
}

func (s *ArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArgumentList(s)
	}
}

func (s *ArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArgumentList(s)
	}
}

func (p *StarRocksParser) ArgumentList() (localctx IArgumentListContext) {
	localctx = NewArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, StarRocksParserRULE_argumentList)
	p.SetState(6330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 737, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6328)
			p.ExpressionList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6329)
			p.NamedArgumentList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentListContext is an interface to support dynamic dispatch.
type INamedArgumentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllNamedArgument() []INamedArgumentContext
	NamedArgument(i int) INamedArgumentContext

	// IsNamedArgumentListContext differentiates from other interfaces.
	IsNamedArgumentListContext()
}

type NamedArgumentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentListContext() *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_namedArgumentList
	return p
}

func InitEmptyNamedArgumentListContext(p *NamedArgumentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_namedArgumentList
}

func (*NamedArgumentListContext) IsNamedArgumentListContext() {}

func NewNamedArgumentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentListContext {
	var p = new(NamedArgumentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_namedArgumentList

	return p
}

func (s *NamedArgumentListContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentListContext) AllNamedArgument() []INamedArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(INamedArgumentContext); ok {
			len++
		}
	}

	tst := make([]INamedArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(INamedArgumentContext); ok {
			tst[i] = t.(INamedArgumentContext)
			i++
		}
	}

	return tst
}

func (s *NamedArgumentListContext) NamedArgument(i int) INamedArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedArgumentContext)
}

func (s *NamedArgumentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NamedArgumentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNamedArgumentList(s)
	}
}

func (s *NamedArgumentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNamedArgumentList(s)
	}
}

func (p *StarRocksParser) NamedArgumentList() (localctx INamedArgumentListContext) {
	localctx = NewNamedArgumentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, StarRocksParserRULE_namedArgumentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6332)
		p.NamedArgument()
	}
	p.SetState(6337)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6333)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6334)
			p.NamedArgument()
		}

		p.SetState(6339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INamedArgumentContext is an interface to support dynamic dispatch.
type INamedArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNamedArgumentContext differentiates from other interfaces.
	IsNamedArgumentContext()
}

type NamedArgumentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedArgumentContext() *NamedArgumentContext {
	var p = new(NamedArgumentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_namedArgument
	return p
}

func InitEmptyNamedArgumentContext(p *NamedArgumentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_namedArgument
}

func (*NamedArgumentContext) IsNamedArgumentContext() {}

func NewNamedArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedArgumentContext {
	var p = new(NamedArgumentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_namedArgument

	return p
}

func (s *NamedArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedArgumentContext) CopyAll(ctx *NamedArgumentContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NamedArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type NamedArgumentsContext struct {
	NamedArgumentContext
}

func NewNamedArgumentsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NamedArgumentsContext {
	var p = new(NamedArgumentsContext)

	InitEmptyNamedArgumentContext(&p.NamedArgumentContext)
	p.parser = parser
	p.CopyAll(ctx.(*NamedArgumentContext))

	return p
}

func (s *NamedArgumentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedArgumentsContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *NamedArgumentsContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *NamedArgumentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNamedArguments(s)
	}
}

func (s *NamedArgumentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNamedArguments(s)
	}
}

func (p *StarRocksParser) NamedArgument() (localctx INamedArgumentContext) {
	localctx = NewNamedArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, StarRocksParserRULE_namedArgument)
	localctx = NewNamedArgumentsContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6340)
		p.Identifier()
	}
	{
		p.SetState(6341)
		p.Match(StarRocksParserT__4)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6342)
		p.expression(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinRelationContext is an interface to support dynamic dispatch.
type IJoinRelationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetRightRelation returns the rightRelation rule contexts.
	GetRightRelation() IRelationPrimaryContext

	// SetRightRelation sets the rightRelation rule contexts.
	SetRightRelation(IRelationPrimaryContext)

	// Getter signatures
	CrossOrInnerJoinType() ICrossOrInnerJoinTypeContext
	RelationPrimary() IRelationPrimaryContext
	BracketHint() IBracketHintContext
	LATERAL() antlr.TerminalNode
	JoinCriteria() IJoinCriteriaContext
	OuterAndSemiJoinType() IOuterAndSemiJoinTypeContext

	// IsJoinRelationContext differentiates from other interfaces.
	IsJoinRelationContext()
}

type JoinRelationContext struct {
	antlr.BaseParserRuleContext
	parser        antlr.Parser
	rightRelation IRelationPrimaryContext
}

func NewEmptyJoinRelationContext() *JoinRelationContext {
	var p = new(JoinRelationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_joinRelation
	return p
}

func InitEmptyJoinRelationContext(p *JoinRelationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_joinRelation
}

func (*JoinRelationContext) IsJoinRelationContext() {}

func NewJoinRelationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinRelationContext {
	var p = new(JoinRelationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_joinRelation

	return p
}

func (s *JoinRelationContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinRelationContext) GetRightRelation() IRelationPrimaryContext { return s.rightRelation }

func (s *JoinRelationContext) SetRightRelation(v IRelationPrimaryContext) { s.rightRelation = v }

func (s *JoinRelationContext) CrossOrInnerJoinType() ICrossOrInnerJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICrossOrInnerJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICrossOrInnerJoinTypeContext)
}

func (s *JoinRelationContext) RelationPrimary() IRelationPrimaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationPrimaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationPrimaryContext)
}

func (s *JoinRelationContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *JoinRelationContext) LATERAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLATERAL, 0)
}

func (s *JoinRelationContext) JoinCriteria() IJoinCriteriaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinCriteriaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinCriteriaContext)
}

func (s *JoinRelationContext) OuterAndSemiJoinType() IOuterAndSemiJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOuterAndSemiJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOuterAndSemiJoinTypeContext)
}

func (s *JoinRelationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinRelationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinRelationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterJoinRelation(s)
	}
}

func (s *JoinRelationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitJoinRelation(s)
	}
}

func (p *StarRocksParser) JoinRelation() (localctx IJoinRelationContext) {
	localctx = NewJoinRelationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, StarRocksParserRULE_joinRelation)
	var _la int

	p.SetState(6365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCROSS, StarRocksParserINNER, StarRocksParserJOIN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6344)
			p.CrossOrInnerJoinType()
		}
		p.SetState(6346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__5 {
			{
				p.SetState(6345)
				p.BracketHint()
			}

		}
		p.SetState(6349)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLATERAL {
			{
				p.SetState(6348)
				p.Match(StarRocksParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6351)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).rightRelation = _x
		}
		p.SetState(6353)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 741, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6352)
				p.JoinCriteria()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserFULL, StarRocksParserLEFT, StarRocksParserRIGHT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6355)
			p.OuterAndSemiJoinType()
		}
		p.SetState(6357)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__5 {
			{
				p.SetState(6356)
				p.BracketHint()
			}

		}
		p.SetState(6360)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLATERAL {
			{
				p.SetState(6359)
				p.Match(StarRocksParserLATERAL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6362)

			var _x = p.RelationPrimary()

			localctx.(*JoinRelationContext).rightRelation = _x
		}
		{
			p.SetState(6363)
			p.JoinCriteria()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICrossOrInnerJoinTypeContext is an interface to support dynamic dispatch.
type ICrossOrInnerJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JOIN() antlr.TerminalNode
	INNER() antlr.TerminalNode
	CROSS() antlr.TerminalNode

	// IsCrossOrInnerJoinTypeContext differentiates from other interfaces.
	IsCrossOrInnerJoinTypeContext()
}

type CrossOrInnerJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrossOrInnerJoinTypeContext() *CrossOrInnerJoinTypeContext {
	var p = new(CrossOrInnerJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_crossOrInnerJoinType
	return p
}

func InitEmptyCrossOrInnerJoinTypeContext(p *CrossOrInnerJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_crossOrInnerJoinType
}

func (*CrossOrInnerJoinTypeContext) IsCrossOrInnerJoinTypeContext() {}

func NewCrossOrInnerJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrossOrInnerJoinTypeContext {
	var p = new(CrossOrInnerJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_crossOrInnerJoinType

	return p
}

func (s *CrossOrInnerJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CrossOrInnerJoinTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOIN, 0)
}

func (s *CrossOrInnerJoinTypeContext) INNER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINNER, 0)
}

func (s *CrossOrInnerJoinTypeContext) CROSS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCROSS, 0)
}

func (s *CrossOrInnerJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrossOrInnerJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrossOrInnerJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCrossOrInnerJoinType(s)
	}
}

func (s *CrossOrInnerJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCrossOrInnerJoinType(s)
	}
}

func (p *StarRocksParser) CrossOrInnerJoinType() (localctx ICrossOrInnerJoinTypeContext) {
	localctx = NewCrossOrInnerJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, StarRocksParserRULE_crossOrInnerJoinType)
	p.SetState(6373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 745, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6367)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6368)
			p.Match(StarRocksParserINNER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6369)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6370)
			p.Match(StarRocksParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6371)
			p.Match(StarRocksParserCROSS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6372)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOuterAndSemiJoinTypeContext is an interface to support dynamic dispatch.
type IOuterAndSemiJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEFT() antlr.TerminalNode
	JOIN() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	FULL() antlr.TerminalNode
	OUTER() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	ANTI() antlr.TerminalNode

	// IsOuterAndSemiJoinTypeContext differentiates from other interfaces.
	IsOuterAndSemiJoinTypeContext()
}

type OuterAndSemiJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOuterAndSemiJoinTypeContext() *OuterAndSemiJoinTypeContext {
	var p = new(OuterAndSemiJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_outerAndSemiJoinType
	return p
}

func InitEmptyOuterAndSemiJoinTypeContext(p *OuterAndSemiJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_outerAndSemiJoinType
}

func (*OuterAndSemiJoinTypeContext) IsOuterAndSemiJoinTypeContext() {}

func NewOuterAndSemiJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OuterAndSemiJoinTypeContext {
	var p = new(OuterAndSemiJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_outerAndSemiJoinType

	return p
}

func (s *OuterAndSemiJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OuterAndSemiJoinTypeContext) LEFT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEFT, 0)
}

func (s *OuterAndSemiJoinTypeContext) JOIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOIN, 0)
}

func (s *OuterAndSemiJoinTypeContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRIGHT, 0)
}

func (s *OuterAndSemiJoinTypeContext) FULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFULL, 0)
}

func (s *OuterAndSemiJoinTypeContext) OUTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOUTER, 0)
}

func (s *OuterAndSemiJoinTypeContext) SEMI() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEMI, 0)
}

func (s *OuterAndSemiJoinTypeContext) ANTI() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANTI, 0)
}

func (s *OuterAndSemiJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterAndSemiJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OuterAndSemiJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOuterAndSemiJoinType(s)
	}
}

func (s *OuterAndSemiJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOuterAndSemiJoinType(s)
	}
}

func (p *StarRocksParser) OuterAndSemiJoinType() (localctx IOuterAndSemiJoinTypeContext) {
	localctx = NewOuterAndSemiJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, StarRocksParserRULE_outerAndSemiJoinType)
	p.SetState(6402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 746, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6375)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6376)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6377)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6378)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6379)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6380)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6381)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6382)
			p.Match(StarRocksParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6383)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6384)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6385)
			p.Match(StarRocksParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6386)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6387)
			p.Match(StarRocksParserFULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6388)
			p.Match(StarRocksParserOUTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6389)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6390)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6391)
			p.Match(StarRocksParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6392)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6393)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6394)
			p.Match(StarRocksParserSEMI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6395)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6396)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6397)
			p.Match(StarRocksParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6398)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6399)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6400)
			p.Match(StarRocksParserANTI)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6401)
			p.Match(StarRocksParserJOIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBracketHintContext is an interface to support dynamic dispatch.
type IBracketHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	BITOR() antlr.TerminalNode
	PrimaryExpression() IPrimaryExpressionContext
	LiteralExpressionList() ILiteralExpressionListContext

	// IsBracketHintContext differentiates from other interfaces.
	IsBracketHintContext()
}

type BracketHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBracketHintContext() *BracketHintContext {
	var p = new(BracketHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_bracketHint
	return p
}

func InitEmptyBracketHintContext(p *BracketHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_bracketHint
}

func (*BracketHintContext) IsBracketHintContext() {}

func NewBracketHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BracketHintContext {
	var p = new(BracketHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_bracketHint

	return p
}

func (s *BracketHintContext) GetParser() antlr.Parser { return s.parser }

func (s *BracketHintContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *BracketHintContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BracketHintContext) BITOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITOR, 0)
}

func (s *BracketHintContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *BracketHintContext) LiteralExpressionList() ILiteralExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionListContext)
}

func (s *BracketHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BracketHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BracketHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBracketHint(s)
	}
}

func (s *BracketHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBracketHint(s)
	}
}

func (p *StarRocksParser) BracketHint() (localctx IBracketHintContext) {
	localctx = NewBracketHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, StarRocksParserRULE_bracketHint)
	var _la int

	p.SetState(6422)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 748, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6404)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6405)
			p.Identifier()
		}
		p.SetState(6410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6406)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6407)
				p.Identifier()
			}

			p.SetState(6412)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6413)
			p.Match(StarRocksParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6415)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6416)
			p.Identifier()
		}
		{
			p.SetState(6417)
			p.Match(StarRocksParserBITOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6418)
			p.primaryExpression(0)
		}
		{
			p.SetState(6419)
			p.LiteralExpressionList()
		}
		{
			p.SetState(6420)
			p.Match(StarRocksParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHintMapContext is an interface to support dynamic dispatch.
type IHintMapContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetK returns the k rule contexts.
	GetK() IIdentifierOrStringContext

	// GetV returns the v rule contexts.
	GetV() ILiteralExpressionContext

	// SetK sets the k rule contexts.
	SetK(IIdentifierOrStringContext)

	// SetV sets the v rule contexts.
	SetV(ILiteralExpressionContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext
	LiteralExpression() ILiteralExpressionContext

	// IsHintMapContext differentiates from other interfaces.
	IsHintMapContext()
}

type HintMapContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	k      IIdentifierOrStringContext
	v      ILiteralExpressionContext
}

func NewEmptyHintMapContext() *HintMapContext {
	var p = new(HintMapContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_hintMap
	return p
}

func InitEmptyHintMapContext(p *HintMapContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_hintMap
}

func (*HintMapContext) IsHintMapContext() {}

func NewHintMapContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HintMapContext {
	var p = new(HintMapContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_hintMap

	return p
}

func (s *HintMapContext) GetParser() antlr.Parser { return s.parser }

func (s *HintMapContext) GetK() IIdentifierOrStringContext { return s.k }

func (s *HintMapContext) GetV() ILiteralExpressionContext { return s.v }

func (s *HintMapContext) SetK(v IIdentifierOrStringContext) { s.k = v }

func (s *HintMapContext) SetV(v ILiteralExpressionContext) { s.v = v }

func (s *HintMapContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *HintMapContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *HintMapContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *HintMapContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HintMapContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HintMapContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterHintMap(s)
	}
}

func (s *HintMapContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitHintMap(s)
	}
}

func (p *StarRocksParser) HintMap() (localctx IHintMapContext) {
	localctx = NewHintMapContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, StarRocksParserRULE_hintMap)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6424)

		var _x = p.IdentifierOrString()

		localctx.(*HintMapContext).k = _x
	}
	{
		p.SetState(6425)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6426)

		var _x = p.LiteralExpression()

		localctx.(*HintMapContext).v = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinCriteriaContext is an interface to support dynamic dispatch.
type IJoinCriteriaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON() antlr.TerminalNode
	Expression() IExpressionContext
	USING() antlr.TerminalNode
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsJoinCriteriaContext differentiates from other interfaces.
	IsJoinCriteriaContext()
}

type JoinCriteriaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinCriteriaContext() *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_joinCriteria
	return p
}

func InitEmptyJoinCriteriaContext(p *JoinCriteriaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_joinCriteria
}

func (*JoinCriteriaContext) IsJoinCriteriaContext() {}

func NewJoinCriteriaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinCriteriaContext {
	var p = new(JoinCriteriaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_joinCriteria

	return p
}

func (s *JoinCriteriaContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinCriteriaContext) ON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserON, 0)
}

func (s *JoinCriteriaContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *JoinCriteriaContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *JoinCriteriaContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *JoinCriteriaContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JoinCriteriaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinCriteriaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinCriteriaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterJoinCriteria(s)
	}
}

func (s *JoinCriteriaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitJoinCriteria(s)
	}
}

func (p *StarRocksParser) JoinCriteria() (localctx IJoinCriteriaContext) {
	localctx = NewJoinCriteriaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, StarRocksParserRULE_joinCriteria)
	var _la int

	p.SetState(6442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6428)
			p.Match(StarRocksParserON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6429)
			p.expression(0)
		}

	case StarRocksParserUSING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6430)
			p.Match(StarRocksParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6431)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6432)
			p.Identifier()
		}
		p.SetState(6437)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6433)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6434)
				p.Identifier()
			}

			p.SetState(6439)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6440)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnAliasesContext is an interface to support dynamic dispatch.
type IColumnAliasesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsColumnAliasesContext differentiates from other interfaces.
	IsColumnAliasesContext()
}

type ColumnAliasesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnAliasesContext() *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnAliases
	return p
}

func InitEmptyColumnAliasesContext(p *ColumnAliasesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnAliases
}

func (*ColumnAliasesContext) IsColumnAliasesContext() {}

func NewColumnAliasesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnAliasesContext {
	var p = new(ColumnAliasesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnAliases

	return p
}

func (s *ColumnAliasesContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnAliasesContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ColumnAliasesContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnAliasesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnAliasesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnAliasesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnAliases(s)
	}
}

func (s *ColumnAliasesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnAliases(s)
	}
}

func (p *StarRocksParser) ColumnAliases() (localctx IColumnAliasesContext) {
	localctx = NewColumnAliasesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, StarRocksParserRULE_columnAliases)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6444)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6445)
		p.Identifier()
	}
	p.SetState(6450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6446)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6447)
			p.Identifier()
		}

		p.SetState(6452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6453)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionNamesContext is an interface to support dynamic dispatch.
type IPartitionNamesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext
	PARTITION() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	KeyPartitions() IKeyPartitionsContext

	// IsPartitionNamesContext differentiates from other interfaces.
	IsPartitionNamesContext()
}

type PartitionNamesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionNamesContext() *PartitionNamesContext {
	var p = new(PartitionNamesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionNames
	return p
}

func InitEmptyPartitionNamesContext(p *PartitionNamesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionNames
}

func (*PartitionNamesContext) IsPartitionNamesContext() {}

func NewPartitionNamesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionNamesContext {
	var p = new(PartitionNamesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionNames

	return p
}

func (s *PartitionNamesContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionNamesContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *PartitionNamesContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *PartitionNamesContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *PartitionNamesContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *PartitionNamesContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *PartitionNamesContext) KeyPartitions() IKeyPartitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartitionsContext)
}

func (s *PartitionNamesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionNamesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionNamesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionNames(s)
	}
}

func (s *PartitionNamesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionNames(s)
	}
}

func (p *StarRocksParser) PartitionNames() (localctx IPartitionNamesContext) {
	localctx = NewPartitionNamesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, StarRocksParserRULE_partitionNames)
	var _la int

	p.SetState(6476)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 755, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6456)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(6455)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6458)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6459)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6460)
			p.IdentifierOrString()
		}
		p.SetState(6465)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6461)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6462)
				p.IdentifierOrString()
			}

			p.SetState(6467)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(6468)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserTEMPORARY {
			{
				p.SetState(6470)
				p.Match(StarRocksParserTEMPORARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6473)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6474)
			p.IdentifierOrString()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6475)
			p.KeyPartitions()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartitionsContext is an interface to support dynamic dispatch.
type IKeyPartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKeyPartitionsContext differentiates from other interfaces.
	IsKeyPartitionsContext()
}

type KeyPartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartitionsContext() *KeyPartitionsContext {
	var p = new(KeyPartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyPartitions
	return p
}

func InitEmptyKeyPartitionsContext(p *KeyPartitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyPartitions
}

func (*KeyPartitionsContext) IsKeyPartitionsContext() {}

func NewKeyPartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartitionsContext {
	var p = new(KeyPartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_keyPartitions

	return p
}

func (s *KeyPartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartitionsContext) CopyAll(ctx *KeyPartitionsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *KeyPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type KeyPartitionListContext struct {
	KeyPartitionsContext
}

func NewKeyPartitionListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *KeyPartitionListContext {
	var p = new(KeyPartitionListContext)

	InitEmptyKeyPartitionsContext(&p.KeyPartitionsContext)
	p.parser = parser
	p.CopyAll(ctx.(*KeyPartitionsContext))

	return p
}

func (s *KeyPartitionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionListContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *KeyPartitionListContext) AllKeyPartition() []IKeyPartitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyPartitionContext); ok {
			len++
		}
	}

	tst := make([]IKeyPartitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyPartitionContext); ok {
			tst[i] = t.(IKeyPartitionContext)
			i++
		}
	}

	return tst
}

func (s *KeyPartitionListContext) KeyPartition(i int) IKeyPartitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartitionContext)
}

func (s *KeyPartitionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKeyPartitionList(s)
	}
}

func (s *KeyPartitionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKeyPartitionList(s)
	}
}

func (p *StarRocksParser) KeyPartitions() (localctx IKeyPartitionsContext) {
	localctx = NewKeyPartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, StarRocksParserRULE_keyPartitions)
	var _la int

	localctx = NewKeyPartitionListContext(p, localctx)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6478)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6479)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6480)
		p.KeyPartition()
	}
	p.SetState(6485)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6481)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6482)
			p.KeyPartition()
		}

		p.SetState(6487)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6488)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITabletListContext is an interface to support dynamic dispatch.
type ITabletListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLET() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsTabletListContext differentiates from other interfaces.
	IsTabletListContext()
}

type TabletListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTabletListContext() *TabletListContext {
	var p = new(TabletListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tabletList
	return p
}

func InitEmptyTabletListContext(p *TabletListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tabletList
}

func (*TabletListContext) IsTabletListContext() {}

func NewTabletListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TabletListContext {
	var p = new(TabletListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tabletList

	return p
}

func (s *TabletListContext) GetParser() antlr.Parser { return s.parser }

func (s *TabletListContext) TABLET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLET, 0)
}

func (s *TabletListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *TabletListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *TabletListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TabletListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TabletListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTabletList(s)
	}
}

func (s *TabletListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTabletList(s)
	}
}

func (p *StarRocksParser) TabletList() (localctx ITabletListContext) {
	localctx = NewTabletListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, StarRocksParserRULE_tabletList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6490)
		p.Match(StarRocksParserTABLET)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6491)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6492)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6497)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6493)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6494)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6499)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6500)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareStatementContext is an interface to support dynamic dispatch.
type IPrepareStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Identifier() IIdentifierContext
	FROM() antlr.TerminalNode
	PrepareSql() IPrepareSqlContext

	// IsPrepareStatementContext differentiates from other interfaces.
	IsPrepareStatementContext()
}

type PrepareStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepareStatementContext() *PrepareStatementContext {
	var p = new(PrepareStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_prepareStatement
	return p
}

func InitEmptyPrepareStatementContext(p *PrepareStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_prepareStatement
}

func (*PrepareStatementContext) IsPrepareStatementContext() {}

func NewPrepareStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareStatementContext {
	var p = new(PrepareStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_prepareStatement

	return p
}

func (s *PrepareStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPREPARE, 0)
}

func (s *PrepareStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PrepareStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *PrepareStatementContext) PrepareSql() IPrepareSqlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrepareSqlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrepareSqlContext)
}

func (s *PrepareStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrepareStatement(s)
	}
}

func (s *PrepareStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrepareStatement(s)
	}
}

func (p *StarRocksParser) PrepareStatement() (localctx IPrepareStatementContext) {
	localctx = NewPrepareStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, StarRocksParserRULE_prepareStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6502)
		p.Match(StarRocksParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6503)
		p.Identifier()
	}
	{
		p.SetState(6504)
		p.Match(StarRocksParserFROM)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6505)
		p.PrepareSql()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrepareSqlContext is an interface to support dynamic dispatch.
type IPrepareSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Statement() IStatementContext
	SINGLE_QUOTED_TEXT() antlr.TerminalNode

	// IsPrepareSqlContext differentiates from other interfaces.
	IsPrepareSqlContext()
}

type PrepareSqlContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrepareSqlContext() *PrepareSqlContext {
	var p = new(PrepareSqlContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_prepareSql
	return p
}

func InitEmptyPrepareSqlContext(p *PrepareSqlContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_prepareSql
}

func (*PrepareSqlContext) IsPrepareSqlContext() {}

func NewPrepareSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrepareSqlContext {
	var p = new(PrepareSqlContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_prepareSql

	return p
}

func (s *PrepareSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *PrepareSqlContext) Statement() IStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PrepareSqlContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSINGLE_QUOTED_TEXT, 0)
}

func (s *PrepareSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrepareSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrepareSqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPrepareSql(s)
	}
}

func (s *PrepareSqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPrepareSql(s)
	}
}

func (p *StarRocksParser) PrepareSql() (localctx IPrepareSqlContext) {
	localctx = NewPrepareSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, StarRocksParserRULE_prepareSql)
	p.SetState(6509)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserADD, StarRocksParserADMIN, StarRocksParserALTER, StarRocksParserANALYZE, StarRocksParserBACKUP, StarRocksParserBEGIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCOMMIT, StarRocksParserCREATE, StarRocksParserDEALLOCATE, StarRocksParserDELETE, StarRocksParserDESC, StarRocksParserDESCRIBE, StarRocksParserDROP, StarRocksParserEXECUTE, StarRocksParserEXPLAIN, StarRocksParserEXPORT, StarRocksParserGRANT, StarRocksParserHELP, StarRocksParserINSTALL, StarRocksParserINSERT, StarRocksParserKILL, StarRocksParserLOAD, StarRocksParserPAUSE, StarRocksParserPREPARE, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserREVOKE, StarRocksParserROLLBACK, StarRocksParserSELECT, StarRocksParserSET, StarRocksParserSHOW, StarRocksParserSTART, StarRocksParserSTOP, StarRocksParserSUBMIT, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRUNCATE, StarRocksParserUNINSTALL, StarRocksParserUPDATE, StarRocksParserUSE, StarRocksParserWITH, StarRocksParserLOCK, StarRocksParserUNLOCK:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6507)
			p.Statement()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6508)
			p.Match(StarRocksParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE() antlr.TerminalNode
	Identifier() IIdentifierContext
	USING() antlr.TerminalNode
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *ExecuteStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSING, 0)
}

func (s *ExecuteStatementContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserAT)
}

func (s *ExecuteStatementContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, i)
}

func (s *ExecuteStatementContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteStatementContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (p *StarRocksParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, StarRocksParserRULE_executeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6511)
		p.Match(StarRocksParserEXECUTE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6512)
		p.Identifier()
	}
	p.SetState(6524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserUSING {
		{
			p.SetState(6513)
			p.Match(StarRocksParserUSING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6514)
			p.Match(StarRocksParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6515)
			p.IdentifierOrString()
		}
		p.SetState(6521)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(6516)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6517)
				p.Match(StarRocksParserAT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6518)
				p.IdentifierOrString()
			}

			p.SetState(6523)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeallocateStatementContext is an interface to support dynamic dispatch.
type IDeallocateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PREPARE() antlr.TerminalNode
	Identifier() IIdentifierContext
	DEALLOCATE() antlr.TerminalNode
	DROP() antlr.TerminalNode

	// IsDeallocateStatementContext differentiates from other interfaces.
	IsDeallocateStatementContext()
}

type DeallocateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeallocateStatementContext() *DeallocateStatementContext {
	var p = new(DeallocateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_deallocateStatement
	return p
}

func InitEmptyDeallocateStatementContext(p *DeallocateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_deallocateStatement
}

func (*DeallocateStatementContext) IsDeallocateStatementContext() {}

func NewDeallocateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeallocateStatementContext {
	var p = new(DeallocateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_deallocateStatement

	return p
}

func (s *DeallocateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeallocateStatementContext) PREPARE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPREPARE, 0)
}

func (s *DeallocateStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DeallocateStatementContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEALLOCATE, 0)
}

func (s *DeallocateStatementContext) DROP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDROP, 0)
}

func (s *DeallocateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeallocateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeallocateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDeallocateStatement(s)
	}
}

func (s *DeallocateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDeallocateStatement(s)
	}
}

func (p *StarRocksParser) DeallocateStatement() (localctx IDeallocateStatementContext) {
	localctx = NewDeallocateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, StarRocksParserRULE_deallocateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6526)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDEALLOCATE || _la == StarRocksParserDROP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6527)
		p.Match(StarRocksParserPREPARE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6528)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicaListContext is an interface to support dynamic dispatch.
type IReplicaListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLICA() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsReplicaListContext differentiates from other interfaces.
	IsReplicaListContext()
}

type ReplicaListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicaListContext() *ReplicaListContext {
	var p = new(ReplicaListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_replicaList
	return p
}

func InitEmptyReplicaListContext(p *ReplicaListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_replicaList
}

func (*ReplicaListContext) IsReplicaListContext() {}

func NewReplicaListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicaListContext {
	var p = new(ReplicaListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_replicaList

	return p
}

func (s *ReplicaListContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicaListContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *ReplicaListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *ReplicaListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *ReplicaListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicaListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicaListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterReplicaList(s)
	}
}

func (s *ReplicaListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitReplicaList(s)
	}
}

func (p *StarRocksParser) ReplicaList() (localctx IReplicaListContext) {
	localctx = NewReplicaListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, StarRocksParserRULE_replicaList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6530)
		p.Match(StarRocksParserREPLICA)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6531)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6532)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6537)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6533)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6534)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(6539)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6540)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionsWithDefaultContext is an interface to support dynamic dispatch.
type IExpressionsWithDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpressionOrDefault() []IExpressionOrDefaultContext
	ExpressionOrDefault(i int) IExpressionOrDefaultContext

	// IsExpressionsWithDefaultContext differentiates from other interfaces.
	IsExpressionsWithDefaultContext()
}

type ExpressionsWithDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionsWithDefaultContext() *ExpressionsWithDefaultContext {
	var p = new(ExpressionsWithDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionsWithDefault
	return p
}

func InitEmptyExpressionsWithDefaultContext(p *ExpressionsWithDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionsWithDefault
}

func (*ExpressionsWithDefaultContext) IsExpressionsWithDefaultContext() {}

func NewExpressionsWithDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionsWithDefaultContext {
	var p = new(ExpressionsWithDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expressionsWithDefault

	return p
}

func (s *ExpressionsWithDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionsWithDefaultContext) AllExpressionOrDefault() []IExpressionOrDefaultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			len++
		}
	}

	tst := make([]IExpressionOrDefaultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionOrDefaultContext); ok {
			tst[i] = t.(IExpressionOrDefaultContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionsWithDefaultContext) ExpressionOrDefault(i int) IExpressionOrDefaultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *ExpressionsWithDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionsWithDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionsWithDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionsWithDefault(s)
	}
}

func (s *ExpressionsWithDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionsWithDefault(s)
	}
}

func (p *StarRocksParser) ExpressionsWithDefault() (localctx IExpressionsWithDefaultContext) {
	localctx = NewExpressionsWithDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, StarRocksParserRULE_expressionsWithDefault)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6542)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6543)
		p.ExpressionOrDefault()
	}
	p.SetState(6548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6544)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6545)
			p.ExpressionOrDefault()
		}

		p.SetState(6550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6551)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionOrDefaultContext is an interface to support dynamic dispatch.
type IExpressionOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	DEFAULT() antlr.TerminalNode

	// IsExpressionOrDefaultContext differentiates from other interfaces.
	IsExpressionOrDefaultContext()
}

type ExpressionOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionOrDefaultContext() *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionOrDefault
	return p
}

func InitEmptyExpressionOrDefaultContext(p *ExpressionOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionOrDefault
}

func (*ExpressionOrDefaultContext) IsExpressionOrDefaultContext() {}

func NewExpressionOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionOrDefaultContext {
	var p = new(ExpressionOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expressionOrDefault

	return p
}

func (s *ExpressionOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionOrDefaultContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionOrDefaultContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *ExpressionOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionOrDefault(s)
	}
}

func (s *ExpressionOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionOrDefault(s)
	}
}

func (p *StarRocksParser) ExpressionOrDefault() (localctx IExpressionOrDefaultContext) {
	localctx = NewExpressionOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, StarRocksParserRULE_expressionOrDefault)
	p.SetState(6555)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserT__5, StarRocksParserT__8, StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCASE, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHAR, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCONVERT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserCURRENT_DATE, StarRocksParserCURRENT_GROUP, StarRocksParserCURRENT_ROLE, StarRocksParserCURRENT_TIME, StarRocksParserCURRENT_TIMESTAMP, StarRocksParserCURRENT_USER, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATABASE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDENSE_RANK, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserNTILE, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXISTS, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFALSE, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFIRST_VALUE, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUPING, StarRocksParserGROUPING_ID, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIF, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAG, StarRocksParserLAST, StarRocksParserLAST_VALUE, StarRocksParserLEAD, StarRocksParserLEFT, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIKE, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCALTIME, StarRocksParserLOCALTIMESTAMP, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMOD, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNOT, StarRocksParserNULL, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARAMETER, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREGEXP, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserRIGHT, StarRocksParserRLIKE, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserROW_NUMBER, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSCHEMA, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserPLUS_SYMBOL, StarRocksParserMINUS_SYMBOL, StarRocksParserLOGICAL_NOT, StarRocksParserBITNOT, StarRocksParserAT, StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6553)
			p.expression(0)
		}

	case StarRocksParserDEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6554)
			p.Match(StarRocksParserDEFAULT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionListContext is an interface to support dynamic dispatch.
type IMapExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMapExpression() []IMapExpressionContext
	MapExpression(i int) IMapExpressionContext

	// IsMapExpressionListContext differentiates from other interfaces.
	IsMapExpressionListContext()
}

type MapExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapExpressionListContext() *MapExpressionListContext {
	var p = new(MapExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapExpressionList
	return p
}

func InitEmptyMapExpressionListContext(p *MapExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapExpressionList
}

func (*MapExpressionListContext) IsMapExpressionListContext() {}

func NewMapExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionListContext {
	var p = new(MapExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_mapExpressionList

	return p
}

func (s *MapExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionListContext) AllMapExpression() []IMapExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMapExpressionContext); ok {
			len++
		}
	}

	tst := make([]IMapExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMapExpressionContext); ok {
			tst[i] = t.(IMapExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionListContext) MapExpression(i int) IMapExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionContext)
}

func (s *MapExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMapExpressionList(s)
	}
}

func (s *MapExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMapExpressionList(s)
	}
}

func (p *StarRocksParser) MapExpressionList() (localctx IMapExpressionListContext) {
	localctx = NewMapExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, StarRocksParserRULE_mapExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6557)
		p.MapExpression()
	}
	p.SetState(6562)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(6558)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6559)
			p.MapExpression()
		}

		p.SetState(6564)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapExpressionContext is an interface to support dynamic dispatch.
type IMapExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IExpressionContext

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// SetKey sets the key rule contexts.
	SetKey(IExpressionContext)

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsMapExpressionContext differentiates from other interfaces.
	IsMapExpressionContext()
}

type MapExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IExpressionContext
	value  IExpressionContext
}

func NewEmptyMapExpressionContext() *MapExpressionContext {
	var p = new(MapExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapExpression
	return p
}

func InitEmptyMapExpressionContext(p *MapExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapExpression
}

func (*MapExpressionContext) IsMapExpressionContext() {}

func NewMapExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapExpressionContext {
	var p = new(MapExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_mapExpression

	return p
}

func (s *MapExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *MapExpressionContext) GetKey() IExpressionContext { return s.key }

func (s *MapExpressionContext) GetValue() IExpressionContext { return s.value }

func (s *MapExpressionContext) SetKey(v IExpressionContext) { s.key = v }

func (s *MapExpressionContext) SetValue(v IExpressionContext) { s.value = v }

func (s *MapExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MapExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MapExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMapExpression(s)
	}
}

func (s *MapExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMapExpression(s)
	}
}

func (p *StarRocksParser) MapExpression() (localctx IMapExpressionContext) {
	localctx = NewMapExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, StarRocksParserRULE_mapExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6565)

		var _x = p.expression(0)

		localctx.(*MapExpressionContext).key = _x
	}
	{
		p.SetState(6566)
		p.Match(StarRocksParserT__7)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6567)

		var _x = p.expression(0)

		localctx.(*MapExpressionContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionSingletonContext is an interface to support dynamic dispatch.
type IExpressionSingletonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext
	EOF() antlr.TerminalNode

	// IsExpressionSingletonContext differentiates from other interfaces.
	IsExpressionSingletonContext()
}

type ExpressionSingletonContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionSingletonContext() *ExpressionSingletonContext {
	var p = new(ExpressionSingletonContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionSingleton
	return p
}

func InitEmptyExpressionSingletonContext(p *ExpressionSingletonContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionSingleton
}

func (*ExpressionSingletonContext) IsExpressionSingletonContext() {}

func NewExpressionSingletonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionSingletonContext {
	var p = new(ExpressionSingletonContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expressionSingleton

	return p
}

func (s *ExpressionSingletonContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionSingletonContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionSingletonContext) EOF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEOF, 0)
}

func (s *ExpressionSingletonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionSingletonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionSingletonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionSingleton(s)
	}
}

func (s *ExpressionSingletonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionSingleton(s)
	}
}

func (p *StarRocksParser) ExpressionSingleton() (localctx IExpressionSingletonContext) {
	localctx = NewExpressionSingletonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, StarRocksParserRULE_expressionSingleton)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6569)
		p.expression(0)
	}
	{
		p.SetState(6570)
		p.Match(StarRocksParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExpressionDefaultContext struct {
	ExpressionContext
}

func NewExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExpressionDefaultContext {
	var p = new(ExpressionDefaultContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionDefaultContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ExpressionDefaultContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY, 0)
}

func (s *ExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionDefault(s)
	}
}

func (s *ExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionDefault(s)
	}
}

type LogicalNotContext struct {
	ExpressionContext
}

func NewLogicalNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalNotContext {
	var p = new(LogicalNotContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalNotContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *LogicalNotContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLogicalNot(s)
	}
}

func (s *LogicalNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLogicalNot(s)
	}
}

type LogicalBinaryContext struct {
	ExpressionContext
	left     IExpressionContext
	operator antlr.Token
	right    IExpressionContext
}

func NewLogicalBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LogicalBinaryContext {
	var p = new(LogicalBinaryContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *LogicalBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *LogicalBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *LogicalBinaryContext) GetLeft() IExpressionContext { return s.left }

func (s *LogicalBinaryContext) GetRight() IExpressionContext { return s.right }

func (s *LogicalBinaryContext) SetLeft(v IExpressionContext) { s.left = v }

func (s *LogicalBinaryContext) SetRight(v IExpressionContext) { s.right = v }

func (s *LogicalBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogicalBinaryContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LogicalBinaryContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LogicalBinaryContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *LogicalBinaryContext) LOGICAL_AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL_AND, 0)
}

func (s *LogicalBinaryContext) OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOR, 0)
}

func (s *LogicalBinaryContext) LOGICAL_OR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL_OR, 0)
}

func (s *LogicalBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLogicalBinary(s)
	}
}

func (s *LogicalBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLogicalBinary(s)
	}
}

func (p *StarRocksParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *StarRocksParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 842
	p.EnterRecursionRule(localctx, 842, StarRocksParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6579)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserT__1, StarRocksParserT__5, StarRocksParserT__8, StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCASE, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHAR, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCONVERT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserCURRENT_DATE, StarRocksParserCURRENT_GROUP, StarRocksParserCURRENT_ROLE, StarRocksParserCURRENT_TIME, StarRocksParserCURRENT_TIMESTAMP, StarRocksParserCURRENT_USER, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATABASE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDENSE_RANK, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserNTILE, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXISTS, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFALSE, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFIRST_VALUE, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUPING, StarRocksParserGROUPING_ID, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIF, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAG, StarRocksParserLAST, StarRocksParserLAST_VALUE, StarRocksParserLEAD, StarRocksParserLEFT, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIKE, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCALTIME, StarRocksParserLOCALTIMESTAMP, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMOD, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULL, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARAMETER, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREGEXP, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserRIGHT, StarRocksParserRLIKE, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserROW_NUMBER, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSCHEMA, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserPLUS_SYMBOL, StarRocksParserMINUS_SYMBOL, StarRocksParserLOGICAL_NOT, StarRocksParserBITNOT, StarRocksParserAT, StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE, StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT, StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		localctx = NewExpressionDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		p.SetState(6574)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 765, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6573)
				p.Match(StarRocksParserBINARY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(6576)
			p.booleanExpression(0)
		}

	case StarRocksParserNOT:
		localctx = NewLogicalNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6577)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6578)
			p.expression(3)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6589)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 768, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6587)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 767, p.GetParserRuleContext()) {
			case 1:
				localctx = NewLogicalBinaryContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_expression)
				p.SetState(6581)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6582)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserAND || _la == StarRocksParserLOGICAL_AND) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6583)

					var _x = p.expression(3)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case 2:
				localctx = NewLogicalBinaryContext(p, NewExpressionContext(p, _parentctx, _parentState))
				localctx.(*LogicalBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_expression)
				p.SetState(6584)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6585)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*LogicalBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserOR || _la == StarRocksParserLOGICAL_OR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*LogicalBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6586)

					var _x = p.expression(2)

					localctx.(*LogicalBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6591)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 768, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExpressionListContext is an interface to support dynamic dispatch.
type IExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsExpressionListContext differentiates from other interfaces.
	IsExpressionListContext()
}

type ExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionListContext() *ExpressionListContext {
	var p = new(ExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionList
	return p
}

func InitEmptyExpressionListContext(p *ExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_expressionList
}

func (*ExpressionListContext) IsExpressionListContext() {}

func NewExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionListContext {
	var p = new(ExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_expressionList

	return p
}

func (s *ExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ExpressionListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExpressionList(s)
	}
}

func (s *ExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExpressionList(s)
	}
}

func (p *StarRocksParser) ExpressionList() (localctx IExpressionListContext) {
	localctx = NewExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, StarRocksParserRULE_expressionList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6592)
		p.expression(0)
	}
	p.SetState(6597)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 769, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6593)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6594)
				p.expression(0)
			}

		}
		p.SetState(6599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 769, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanExpressionContext is an interface to support dynamic dispatch.
type IBooleanExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBooleanExpressionContext differentiates from other interfaces.
	IsBooleanExpressionContext()
}

type BooleanExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanExpressionContext() *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_booleanExpression
	return p
}

func InitEmptyBooleanExpressionContext(p *BooleanExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_booleanExpression
}

func (*BooleanExpressionContext) IsBooleanExpressionContext() {}

func NewBooleanExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_booleanExpression

	return p
}

func (s *BooleanExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanExpressionContext) CopyAll(ctx *BooleanExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ComparisonContext struct {
	BooleanExpressionContext
	left  IBooleanExpressionContext
	right IPredicateContext
}

func NewComparisonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ComparisonContext {
	var p = new(ComparisonContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ComparisonContext) GetLeft() IBooleanExpressionContext { return s.left }

func (s *ComparisonContext) GetRight() IPredicateContext { return s.right }

func (s *ComparisonContext) SetLeft(v IBooleanExpressionContext) { s.left = v }

func (s *ComparisonContext) SetRight(v IPredicateContext) { s.right = v }

func (s *ComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ComparisonContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ComparisonContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *ComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterComparison(s)
	}
}

func (s *ComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitComparison(s)
	}
}

type BooleanExpressionDefaultContext struct {
	BooleanExpressionContext
}

func NewBooleanExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanExpressionDefaultContext {
	var p = new(BooleanExpressionDefaultContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *BooleanExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionDefaultContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BooleanExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBooleanExpressionDefault(s)
	}
}

func (s *BooleanExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBooleanExpressionDefault(s)
	}
}

type IsNullContext struct {
	BooleanExpressionContext
}

func NewIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IsNullContext {
	var p = new(IsNullContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *IsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsNullContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *IsNullContext) IS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIS, 0)
}

func (s *IsNullContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *IsNullContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *IsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIsNull(s)
	}
}

func (s *IsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIsNull(s)
	}
}

type ScalarSubqueryContext struct {
	BooleanExpressionContext
}

func NewScalarSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ScalarSubqueryContext {
	var p = new(ScalarSubqueryContext)

	InitEmptyBooleanExpressionContext(&p.BooleanExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*BooleanExpressionContext))

	return p
}

func (s *ScalarSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScalarSubqueryContext) BooleanExpression() IBooleanExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanExpressionContext)
}

func (s *ScalarSubqueryContext) ComparisonOperator() IComparisonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComparisonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComparisonOperatorContext)
}

func (s *ScalarSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *ScalarSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterScalarSubquery(s)
	}
}

func (s *ScalarSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitScalarSubquery(s)
	}
}

func (p *StarRocksParser) BooleanExpression() (localctx IBooleanExpressionContext) {
	return p.booleanExpression(0)
}

func (p *StarRocksParser) booleanExpression(_p int) (localctx IBooleanExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBooleanExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBooleanExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 846
	p.EnterRecursionRule(localctx, 846, StarRocksParserRULE_booleanExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewBooleanExpressionDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(6601)
		p.Predicate()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 772, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6619)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 771, p.GetParserRuleContext()) {
			case 1:
				localctx = NewIsNullContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_booleanExpression)
				p.SetState(6603)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(6604)
					p.Match(StarRocksParserIS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6606)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserNOT {
					{
						p.SetState(6605)
						p.Match(StarRocksParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6608)
					p.Match(StarRocksParserNULL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewComparisonContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				localctx.(*ComparisonContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_booleanExpression)
				p.SetState(6609)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6610)
					p.ComparisonOperator()
				}
				{
					p.SetState(6611)

					var _x = p.Predicate()

					localctx.(*ComparisonContext).right = _x
				}

			case 3:
				localctx = NewScalarSubqueryContext(p, NewBooleanExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_booleanExpression)
				p.SetState(6613)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6614)
					p.ComparisonOperator()
				}
				{
					p.SetState(6615)
					p.Match(StarRocksParserT__1)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6616)
					p.QueryRelation()
				}
				{
					p.SetState(6617)
					p.Match(StarRocksParserT__3)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6623)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 772, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_valueExpression returns the _valueExpression rule contexts.
	Get_valueExpression() IValueExpressionContext

	// Set_valueExpression sets the _valueExpression rule contexts.
	Set_valueExpression(IValueExpressionContext)

	// Getter signatures
	ValueExpression() IValueExpressionContext
	PredicateOperations() IPredicateOperationsContext
	TupleInSubquery() ITupleInSubqueryContext

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser           antlr.Parser
	_valueExpression IValueExpressionContext
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) Get_valueExpression() IValueExpressionContext { return s._valueExpression }

func (s *PredicateContext) Set_valueExpression(v IValueExpressionContext) { s._valueExpression = v }

func (s *PredicateContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *PredicateContext) PredicateOperations() IPredicateOperationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateOperationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateOperationsContext)
}

func (s *PredicateContext) TupleInSubquery() ITupleInSubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleInSubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleInSubqueryContext)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (p *StarRocksParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, StarRocksParserRULE_predicate)
	p.SetState(6629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 774, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6624)

			var _x = p.valueExpression(0)

			localctx.(*PredicateContext)._valueExpression = _x
		}
		p.SetState(6626)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 773, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6625)
				p.PredicateOperations(localctx.(*PredicateContext).Get_valueExpression())
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6628)
			p.TupleInSubquery()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITupleInSubqueryContext is an interface to support dynamic dispatch.
type ITupleInSubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	IN() antlr.TerminalNode
	QueryRelation() IQueryRelationContext
	NOT() antlr.TerminalNode

	// IsTupleInSubqueryContext differentiates from other interfaces.
	IsTupleInSubqueryContext()
}

type TupleInSubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleInSubqueryContext() *TupleInSubqueryContext {
	var p = new(TupleInSubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tupleInSubquery
	return p
}

func InitEmptyTupleInSubqueryContext(p *TupleInSubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tupleInSubquery
}

func (*TupleInSubqueryContext) IsTupleInSubqueryContext() {}

func NewTupleInSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleInSubqueryContext {
	var p = new(TupleInSubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tupleInSubquery

	return p
}

func (s *TupleInSubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleInSubqueryContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TupleInSubqueryContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleInSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *TupleInSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *TupleInSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *TupleInSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleInSubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TupleInSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTupleInSubquery(s)
	}
}

func (s *TupleInSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTupleInSubquery(s)
	}
}

func (p *StarRocksParser) TupleInSubquery() (localctx ITupleInSubqueryContext) {
	localctx = NewTupleInSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, StarRocksParserRULE_tupleInSubquery)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6631)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6632)
		p.expression(0)
	}
	p.SetState(6635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == StarRocksParserT__2 {
		{
			p.SetState(6633)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6634)
			p.expression(0)
		}

		p.SetState(6637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(6639)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(6641)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserNOT {
		{
			p.SetState(6640)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(6643)
		p.Match(StarRocksParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6644)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(6645)
		p.QueryRelation()
	}
	{
		p.SetState(6646)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateOperationsContext is an interface to support dynamic dispatch.
type IPredicateOperationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value attribute.
	GetValue() antlr.ParserRuleContext

	// SetValue sets the value attribute.
	SetValue(antlr.ParserRuleContext)

	// IsPredicateOperationsContext differentiates from other interfaces.
	IsPredicateOperationsContext()
}

type PredicateOperationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.ParserRuleContext
}

func NewEmptyPredicateOperationsContext() *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_predicateOperations
	return p
}

func InitEmptyPredicateOperationsContext(p *PredicateOperationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_predicateOperations
}

func (*PredicateOperationsContext) IsPredicateOperationsContext() {}

func NewPredicateOperationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int, value antlr.ParserRuleContext) *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_predicateOperations

	p.value = value

	return p
}

func (s *PredicateOperationsContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateOperationsContext) GetValue() antlr.ParserRuleContext { return s.value }

func (s *PredicateOperationsContext) SetValue(v antlr.ParserRuleContext) { s.value = v }

func (s *PredicateOperationsContext) CopyAll(ctx *PredicateOperationsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
	s.value = ctx.value
}

func (s *PredicateOperationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateOperationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type InIntegerListContext struct {
	PredicateOperationsContext
}

func NewInIntegerListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InIntegerListContext {
	var p = new(InIntegerListContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InIntegerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InIntegerListContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *InIntegerListContext) IntegerList() IIntegerListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerListContext)
}

func (s *InIntegerListContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *InIntegerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInIntegerList(s)
	}
}

func (s *InIntegerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInIntegerList(s)
	}
}

type LikeContext struct {
	PredicateOperationsContext
	pattern IValueExpressionContext
}

func NewLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LikeContext {
	var p = new(LikeContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *LikeContext) GetPattern() IValueExpressionContext { return s.pattern }

func (s *LikeContext) SetPattern(v IValueExpressionContext) { s.pattern = v }

func (s *LikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *LikeContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRLIKE, 0)
}

func (s *LikeContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREGEXP, 0)
}

func (s *LikeContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *LikeContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *LikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLike(s)
	}
}

func (s *LikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLike(s)
	}
}

type InSubqueryContext struct {
	PredicateOperationsContext
}

func NewInSubqueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InSubqueryContext {
	var p = new(InSubqueryContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InSubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSubqueryContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *InSubqueryContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *InSubqueryContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *InSubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInSubquery(s)
	}
}

func (s *InSubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInSubquery(s)
	}
}

type InStringListContext struct {
	PredicateOperationsContext
}

func NewInStringListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InStringListContext {
	var p = new(InStringListContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InStringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InStringListContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *InStringListContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *InStringListContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *InStringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInStringList(s)
	}
}

func (s *InStringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInStringList(s)
	}
}

type InListContext struct {
	PredicateOperationsContext
}

func NewInListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InListContext {
	var p = new(InListContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *InListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InListContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *InListContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *InListContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *InListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInList(s)
	}
}

func (s *InListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInList(s)
	}
}

type BetweenContext struct {
	PredicateOperationsContext
	lower IValueExpressionContext
	upper IPredicateContext
}

func NewBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenContext {
	var p = new(BetweenContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *BetweenContext) GetLower() IValueExpressionContext { return s.lower }

func (s *BetweenContext) GetUpper() IPredicateContext { return s.upper }

func (s *BetweenContext) SetLower(v IValueExpressionContext) { s.lower = v }

func (s *BetweenContext) SetUpper(v IPredicateContext) { s.upper = v }

func (s *BetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBETWEEN, 0)
}

func (s *BetweenContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *BetweenContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *BetweenContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *BetweenContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *BetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBetween(s)
	}
}

func (s *BetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBetween(s)
	}
}

func (p *StarRocksParser) PredicateOperations(value antlr.ParserRuleContext) (localctx IPredicateOperationsContext) {
	localctx = NewPredicateOperationsContext(p, p.GetParserRuleContext(), p.GetState(), value)
	p.EnterRule(localctx, 852, StarRocksParserRULE_predicateOperations)
	var _la int

	p.SetState(6687)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 783, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInIntegerListContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(6649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6648)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6651)
			p.Match(StarRocksParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6652)
			p.IntegerList()
		}

	case 2:
		localctx = NewInStringListContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(6654)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6653)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6656)
			p.Match(StarRocksParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6657)
			p.StringList()
		}

	case 3:
		localctx = NewInSubqueryContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(6659)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6658)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6661)
			p.Match(StarRocksParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6662)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6663)
			p.QueryRelation()
		}
		{
			p.SetState(6664)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewInListContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(6667)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6666)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6669)
			p.Match(StarRocksParserIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6670)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6671)
			p.ExpressionList()
		}
		{
			p.SetState(6672)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		localctx = NewBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(6675)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6674)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6677)
			p.Match(StarRocksParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6678)

			var _x = p.valueExpression(0)

			localctx.(*BetweenContext).lower = _x
		}
		{
			p.SetState(6679)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6680)

			var _x = p.Predicate()

			localctx.(*BetweenContext).upper = _x
		}

	case 6:
		localctx = NewLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		p.SetState(6683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserNOT {
			{
				p.SetState(6682)
				p.Match(StarRocksParserNOT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6685)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserLIKE || _la == StarRocksParserREGEXP || _la == StarRocksParserRLIKE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6686)

			var _x = p.valueExpression(0)

			localctx.(*LikeContext).pattern = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValueExpressionContext is an interface to support dynamic dispatch.
type IValueExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsValueExpressionContext differentiates from other interfaces.
	IsValueExpressionContext()
}

type ValueExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueExpressionContext() *ValueExpressionContext {
	var p = new(ValueExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_valueExpression
	return p
}

func InitEmptyValueExpressionContext(p *ValueExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_valueExpression
}

func (*ValueExpressionContext) IsValueExpressionContext() {}

func NewValueExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueExpressionContext {
	var p = new(ValueExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_valueExpression

	return p
}

func (s *ValueExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueExpressionContext) CopyAll(ctx *ValueExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ValueExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ValueExpressionDefaultContext struct {
	ValueExpressionContext
}

func NewValueExpressionDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ValueExpressionDefaultContext {
	var p = new(ValueExpressionDefaultContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ValueExpressionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueExpressionDefaultContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ValueExpressionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterValueExpressionDefault(s)
	}
}

func (s *ValueExpressionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitValueExpressionDefault(s)
	}
}

type ArithmeticBinaryContext struct {
	ValueExpressionContext
	left     IValueExpressionContext
	operator antlr.Token
	right    IValueExpressionContext
}

func NewArithmeticBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticBinaryContext {
	var p = new(ArithmeticBinaryContext)

	InitEmptyValueExpressionContext(&p.ValueExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ValueExpressionContext))

	return p
}

func (s *ArithmeticBinaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticBinaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticBinaryContext) GetLeft() IValueExpressionContext { return s.left }

func (s *ArithmeticBinaryContext) GetRight() IValueExpressionContext { return s.right }

func (s *ArithmeticBinaryContext) SetLeft(v IValueExpressionContext) { s.left = v }

func (s *ArithmeticBinaryContext) SetRight(v IValueExpressionContext) { s.right = v }

func (s *ArithmeticBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticBinaryContext) AllValueExpression() []IValueExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValueExpressionContext); ok {
			len++
		}
	}

	tst := make([]IValueExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValueExpressionContext); ok {
			tst[i] = t.(IValueExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticBinaryContext) ValueExpression(i int) IValueExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ArithmeticBinaryContext) BITXOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITXOR, 0)
}

func (s *ArithmeticBinaryContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) SLASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSLASH_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) PERCENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENT_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) INT_DIV() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINT_DIV, 0)
}

func (s *ArithmeticBinaryContext) MOD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMOD, 0)
}

func (s *ArithmeticBinaryContext) PLUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUS_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS_SYMBOL, 0)
}

func (s *ArithmeticBinaryContext) BITAND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITAND, 0)
}

func (s *ArithmeticBinaryContext) BITOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITOR, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_LEFT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBIT_SHIFT_LEFT, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_RIGHT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBIT_SHIFT_RIGHT, 0)
}

func (s *ArithmeticBinaryContext) BIT_SHIFT_RIGHT_LOGICAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBIT_SHIFT_RIGHT_LOGICAL, 0)
}

func (s *ArithmeticBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArithmeticBinary(s)
	}
}

func (s *ArithmeticBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArithmeticBinary(s)
	}
}

func (p *StarRocksParser) ValueExpression() (localctx IValueExpressionContext) {
	return p.valueExpression(0)
}

func (p *StarRocksParser) valueExpression(_p int) (localctx IValueExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewValueExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IValueExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 854
	p.EnterRecursionRule(localctx, 854, StarRocksParserRULE_valueExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewValueExpressionDefaultContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(6690)
		p.primaryExpression(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6718)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 785, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6716)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 784, p.GetParserRuleContext()) {
			case 1:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6692)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(6693)

					var _m = p.Match(StarRocksParserBITXOR)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6694)

					var _x = p.valueExpression(9)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 2:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6695)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(6696)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserMOD || ((int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&71) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6697)

					var _x = p.valueExpression(8)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 3:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6698)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(6699)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ArithmeticBinaryContext).operator = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == StarRocksParserPLUS_SYMBOL || _la == StarRocksParserMINUS_SYMBOL) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ArithmeticBinaryContext).operator = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(6700)

					var _x = p.valueExpression(7)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 4:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6701)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(6702)

					var _m = p.Match(StarRocksParserBITAND)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6703)

					var _x = p.valueExpression(6)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 5:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6704)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(6705)

					var _m = p.Match(StarRocksParserBITOR)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6706)

					var _x = p.valueExpression(5)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 6:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6707)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(6708)

					var _m = p.Match(StarRocksParserBIT_SHIFT_LEFT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6709)

					var _x = p.valueExpression(4)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 7:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6710)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(6711)

					var _m = p.Match(StarRocksParserBIT_SHIFT_RIGHT)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6712)

					var _x = p.valueExpression(3)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case 8:
				localctx = NewArithmeticBinaryContext(p, NewValueExpressionContext(p, _parentctx, _parentState))
				localctx.(*ArithmeticBinaryContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_valueExpression)
				p.SetState(6713)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(6714)

					var _m = p.Match(StarRocksParserBIT_SHIFT_RIGHT_LOGICAL)

					localctx.(*ArithmeticBinaryContext).operator = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6715)

					var _x = p.valueExpression(2)

					localctx.(*ArithmeticBinaryContext).right = _x
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6720)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 785, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrimaryExpressionContext is an interface to support dynamic dispatch.
type IPrimaryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPrimaryExpressionContext differentiates from other interfaces.
	IsPrimaryExpressionContext()
}

type PrimaryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryExpressionContext() *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_primaryExpression
	return p
}

func InitEmptyPrimaryExpressionContext(p *PrimaryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_primaryExpression
}

func (*PrimaryExpressionContext) IsPrimaryExpressionContext() {}

func NewPrimaryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryExpressionContext {
	var p = new(PrimaryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_primaryExpression

	return p
}

func (s *PrimaryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryExpressionContext) CopyAll(ctx *PrimaryExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PrimaryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DereferenceContext struct {
	PrimaryExpressionContext
	base      IPrimaryExpressionContext
	fieldName IIdentifierContext
}

func NewDereferenceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DereferenceContext {
	var p = new(DereferenceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DereferenceContext) GetBase() IPrimaryExpressionContext { return s.base }

func (s *DereferenceContext) GetFieldName() IIdentifierContext { return s.fieldName }

func (s *DereferenceContext) SetBase(v IPrimaryExpressionContext) { s.base = v }

func (s *DereferenceContext) SetFieldName(v IIdentifierContext) { s.fieldName = v }

func (s *DereferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DereferenceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *DereferenceContext) DOT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOT_IDENTIFIER, 0)
}

func (s *DereferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DereferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDereference(s)
	}
}

func (s *DereferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDereference(s)
	}
}

type OdbcFunctionCallExpressionContext struct {
	PrimaryExpressionContext
}

func NewOdbcFunctionCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OdbcFunctionCallExpressionContext {
	var p = new(OdbcFunctionCallExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *OdbcFunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OdbcFunctionCallExpressionContext) FN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFN, 0)
}

func (s *OdbcFunctionCallExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *OdbcFunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOdbcFunctionCallExpression(s)
	}
}

func (s *OdbcFunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOdbcFunctionCallExpression(s)
	}
}

type MatchExprContext struct {
	PrimaryExpressionContext
	left  IPrimaryExpressionContext
	right IPrimaryExpressionContext
}

func NewMatchExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MatchExprContext {
	var p = new(MatchExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MatchExprContext) GetLeft() IPrimaryExpressionContext { return s.left }

func (s *MatchExprContext) GetRight() IPrimaryExpressionContext { return s.right }

func (s *MatchExprContext) SetLeft(v IPrimaryExpressionContext) { s.left = v }

func (s *MatchExprContext) SetRight(v IPrimaryExpressionContext) { s.right = v }

func (s *MatchExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MatchExprContext) MATCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATCH, 0)
}

func (s *MatchExprContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MatchExprContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *MatchExprContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *MatchExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMatchExpr(s)
	}
}

func (s *MatchExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMatchExpr(s)
	}
}

type ColumnRefContext struct {
	PrimaryExpressionContext
}

func NewColumnRefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ColumnRefContext {
	var p = new(ColumnRefContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefContext) ColumnReference() IColumnReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnReferenceContext)
}

func (s *ColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnRef(s)
	}
}

func (s *ColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnRef(s)
	}
}

type ConvertContext struct {
	PrimaryExpressionContext
}

func NewConvertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConvertContext {
	var p = new(ConvertContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConvertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConvertContext) CONVERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONVERT, 0)
}

func (s *ConvertContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConvertContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ConvertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterConvert(s)
	}
}

func (s *ConvertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitConvert(s)
	}
}

type CollectionSubscriptContext struct {
	PrimaryExpressionContext
	value IPrimaryExpressionContext
	index IValueExpressionContext
}

func NewCollectionSubscriptContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollectionSubscriptContext {
	var p = new(CollectionSubscriptContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollectionSubscriptContext) GetValue() IPrimaryExpressionContext { return s.value }

func (s *CollectionSubscriptContext) GetIndex() IValueExpressionContext { return s.index }

func (s *CollectionSubscriptContext) SetValue(v IPrimaryExpressionContext) { s.value = v }

func (s *CollectionSubscriptContext) SetIndex(v IValueExpressionContext) { s.index = v }

func (s *CollectionSubscriptContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollectionSubscriptContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollectionSubscriptContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *CollectionSubscriptContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCollectionSubscript(s)
	}
}

func (s *CollectionSubscriptContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCollectionSubscript(s)
	}
}

type LiteralContext struct {
	PrimaryExpressionContext
}

func NewLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralContext {
	var p = new(LiteralContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLiteral(s)
	}
}

type CastContext struct {
	PrimaryExpressionContext
}

func NewCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastContext {
	var p = new(CastContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastContext) CAST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCAST, 0)
}

func (s *CastContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *CastContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *CastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCast(s)
	}
}

func (s *CastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCast(s)
	}
}

type ParenthesizedExpressionContext struct {
	PrimaryExpressionContext
}

func NewParenthesizedExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedExpressionContext {
	var p = new(ParenthesizedExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ParenthesizedExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParenthesizedExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterParenthesizedExpression(s)
	}
}

func (s *ParenthesizedExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitParenthesizedExpression(s)
	}
}

type UserVariableExpressionContext struct {
	PrimaryExpressionContext
}

func NewUserVariableExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserVariableExpressionContext {
	var p = new(UserVariableExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *UserVariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableExpressionContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *UserVariableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserVariableExpression(s)
	}
}

func (s *UserVariableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserVariableExpression(s)
	}
}

type FunctionCallExpressionContext struct {
	PrimaryExpressionContext
}

func NewFunctionCallExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionCallExpressionContext {
	var p = new(FunctionCallExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *FunctionCallExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallExpressionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *FunctionCallExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFunctionCallExpression(s)
	}
}

func (s *FunctionCallExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFunctionCallExpression(s)
	}
}

type SimpleCaseContext struct {
	PrimaryExpressionContext
	caseExpr       IExpressionContext
	elseExpression IExpressionContext
}

func NewSimpleCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleCaseContext {
	var p = new(SimpleCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SimpleCaseContext) GetCaseExpr() IExpressionContext { return s.caseExpr }

func (s *SimpleCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SimpleCaseContext) SetCaseExpr(v IExpressionContext) { s.caseExpr = v }

func (s *SimpleCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SimpleCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCASE, 0)
}

func (s *SimpleCaseContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *SimpleCaseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SimpleCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SimpleCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserELSE, 0)
}

func (s *SimpleCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSimpleCase(s)
	}
}

func (s *SimpleCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSimpleCase(s)
	}
}

type ArrowExpressionContext struct {
	PrimaryExpressionContext
}

func NewArrowExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrowExpressionContext {
	var p = new(ArrowExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrowExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrowExpressionContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArrowExpressionContext) ARROW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARROW, 0)
}

func (s *ArrowExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ArrowExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArrowExpression(s)
	}
}

func (s *ArrowExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArrowExpression(s)
	}
}

type SystemVariableExpressionContext struct {
	PrimaryExpressionContext
}

func NewSystemVariableExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SystemVariableExpressionContext {
	var p = new(SystemVariableExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SystemVariableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableExpressionContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *SystemVariableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSystemVariableExpression(s)
	}
}

func (s *SystemVariableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSystemVariableExpression(s)
	}
}

type ConcatContext struct {
	PrimaryExpressionContext
	left  IPrimaryExpressionContext
	right IPrimaryExpressionContext
}

func NewConcatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcatContext {
	var p = new(ConcatContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ConcatContext) GetLeft() IPrimaryExpressionContext { return s.left }

func (s *ConcatContext) GetRight() IPrimaryExpressionContext { return s.right }

func (s *ConcatContext) SetLeft(v IPrimaryExpressionContext) { s.left = v }

func (s *ConcatContext) SetRight(v IPrimaryExpressionContext) { s.right = v }

func (s *ConcatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcatContext) CONCAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONCAT, 0)
}

func (s *ConcatContext) AllPrimaryExpression() []IPrimaryExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			len++
		}
	}

	tst := make([]IPrimaryExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPrimaryExpressionContext); ok {
			tst[i] = t.(IPrimaryExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ConcatContext) PrimaryExpression(i int) IPrimaryExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ConcatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterConcat(s)
	}
}

func (s *ConcatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitConcat(s)
	}
}

type SubqueryExpressionContext struct {
	PrimaryExpressionContext
}

func NewSubqueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SubqueryExpressionContext {
	var p = new(SubqueryExpressionContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SubqueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryExpressionContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SubqueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubqueryExpression(s)
	}
}

func (s *SubqueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubqueryExpression(s)
	}
}

type LambdaFunctionExprContext struct {
	PrimaryExpressionContext
}

func NewLambdaFunctionExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LambdaFunctionExprContext {
	var p = new(LambdaFunctionExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *LambdaFunctionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LambdaFunctionExprContext) ARROW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARROW, 0)
}

func (s *LambdaFunctionExprContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LambdaFunctionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LambdaFunctionExprContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *LambdaFunctionExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *LambdaFunctionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLambdaFunctionExpr(s)
	}
}

func (s *LambdaFunctionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLambdaFunctionExpr(s)
	}
}

type DictionaryGetExprContext struct {
	PrimaryExpressionContext
}

func NewDictionaryGetExprContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DictionaryGetExprContext {
	var p = new(DictionaryGetExprContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *DictionaryGetExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DictionaryGetExprContext) DICTIONARY_GET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY_GET, 0)
}

func (s *DictionaryGetExprContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *DictionaryGetExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDictionaryGetExpr(s)
	}
}

func (s *DictionaryGetExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDictionaryGetExpr(s)
	}
}

type CollateContext struct {
	PrimaryExpressionContext
}

func NewCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CollateContext {
	var p = new(CollateContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *CollateContext) COLLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATE, 0)
}

func (s *CollateContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CollateContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCollate(s)
	}
}

type ArrayConstructorContext struct {
	PrimaryExpressionContext
}

func NewArrayConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArrayConstructorContext {
	var p = new(ArrayConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArrayConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayConstructorContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *ArrayConstructorContext) ExpressionList() IExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionListContext)
}

func (s *ArrayConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArrayConstructor(s)
	}
}

func (s *ArrayConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArrayConstructor(s)
	}
}

type MapConstructorContext struct {
	PrimaryExpressionContext
}

func NewMapConstructorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MapConstructorContext {
	var p = new(MapConstructorContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *MapConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapConstructorContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *MapConstructorContext) MapExpressionList() IMapExpressionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapExpressionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapExpressionListContext)
}

func (s *MapConstructorContext) MAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAP, 0)
}

func (s *MapConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMapConstructor(s)
	}
}

func (s *MapConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMapConstructor(s)
	}
}

type ArraySliceContext struct {
	PrimaryExpressionContext
	start_ antlr.Token
	end    antlr.Token
}

func NewArraySliceContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArraySliceContext {
	var p = new(ArraySliceContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArraySliceContext) GetStart_() antlr.Token { return s.start_ }

func (s *ArraySliceContext) GetEnd() antlr.Token { return s.end }

func (s *ArraySliceContext) SetStart_(v antlr.Token) { s.start_ = v }

func (s *ArraySliceContext) SetEnd(v antlr.Token) { s.end = v }

func (s *ArraySliceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArraySliceContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArraySliceContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *ArraySliceContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *ArraySliceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArraySlice(s)
	}
}

func (s *ArraySliceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArraySlice(s)
	}
}

type ExistsContext struct {
	PrimaryExpressionContext
}

func NewExistsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistsContext {
	var p = new(ExistsContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistsContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *ExistsContext) QueryRelation() IQueryRelationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryRelationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryRelationContext)
}

func (s *ExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExists(s)
	}
}

func (s *ExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExists(s)
	}
}

type SearchedCaseContext struct {
	PrimaryExpressionContext
	elseExpression IExpressionContext
}

func NewSearchedCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SearchedCaseContext {
	var p = new(SearchedCaseContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *SearchedCaseContext) GetElseExpression() IExpressionContext { return s.elseExpression }

func (s *SearchedCaseContext) SetElseExpression(v IExpressionContext) { s.elseExpression = v }

func (s *SearchedCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchedCaseContext) CASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCASE, 0)
}

func (s *SearchedCaseContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *SearchedCaseContext) AllWhenClause() []IWhenClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenClauseContext); ok {
			len++
		}
	}

	tst := make([]IWhenClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenClauseContext); ok {
			tst[i] = t.(IWhenClauseContext)
			i++
		}
	}

	return tst
}

func (s *SearchedCaseContext) WhenClause(i int) IWhenClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenClauseContext)
}

func (s *SearchedCaseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserELSE, 0)
}

func (s *SearchedCaseContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SearchedCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSearchedCase(s)
	}
}

func (s *SearchedCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSearchedCase(s)
	}
}

type ArithmeticUnaryContext struct {
	PrimaryExpressionContext
	operator antlr.Token
}

func NewArithmeticUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ArithmeticUnaryContext {
	var p = new(ArithmeticUnaryContext)

	InitEmptyPrimaryExpressionContext(&p.PrimaryExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*PrimaryExpressionContext))

	return p
}

func (s *ArithmeticUnaryContext) GetOperator() antlr.Token { return s.operator }

func (s *ArithmeticUnaryContext) SetOperator(v antlr.Token) { s.operator = v }

func (s *ArithmeticUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticUnaryContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *ArithmeticUnaryContext) MINUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS_SYMBOL, 0)
}

func (s *ArithmeticUnaryContext) PLUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUS_SYMBOL, 0)
}

func (s *ArithmeticUnaryContext) BITNOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITNOT, 0)
}

func (s *ArithmeticUnaryContext) LOGICAL_NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL_NOT, 0)
}

func (s *ArithmeticUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArithmeticUnary(s)
	}
}

func (s *ArithmeticUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArithmeticUnary(s)
	}
}

func (p *StarRocksParser) PrimaryExpression() (localctx IPrimaryExpressionContext) {
	return p.primaryExpression(0)
}

func (p *StarRocksParser) primaryExpression(_p int) (localctx IPrimaryExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewPrimaryExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 856
	p.EnterRecursionRule(localctx, 856, StarRocksParserRULE_primaryExpression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6826)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 796, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserVariableExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(6722)
			p.UserVariable()
		}

	case 2:
		localctx = NewSystemVariableExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6723)
			p.SystemVariable()
		}

	case 3:
		localctx = NewDictionaryGetExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6724)
			p.Match(StarRocksParserDICTIONARY_GET)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6725)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6726)
			p.ExpressionList()
		}
		{
			p.SetState(6727)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewFunctionCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6729)
			p.FunctionCall()
		}

	case 5:
		localctx = NewOdbcFunctionCallExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6730)
			p.Match(StarRocksParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6731)
			p.Match(StarRocksParserFN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6732)
			p.FunctionCall()
		}
		{
			p.SetState(6733)
			p.Match(StarRocksParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		localctx = NewLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6735)
			p.LiteralExpression()
		}

	case 7:
		localctx = NewColumnRefContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6736)
			p.ColumnReference()
		}

	case 8:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6737)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ArithmeticUnaryContext).operator = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-498)) & ^0x3f) == 0 && ((int64(1)<<(_la-498))&4099) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ArithmeticUnaryContext).operator = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6738)
			p.primaryExpression(18)
		}

	case 9:
		localctx = NewArithmeticUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6739)

			var _m = p.Match(StarRocksParserLOGICAL_NOT)

			localctx.(*ArithmeticUnaryContext).operator = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6740)
			p.primaryExpression(17)
		}

	case 10:
		localctx = NewParenthesizedExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6741)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6742)
			p.expression(0)
		}
		{
			p.SetState(6743)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 11:
		localctx = NewExistsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6745)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6746)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6747)
			p.QueryRelation()
		}
		{
			p.SetState(6748)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		localctx = NewSubqueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6750)
			p.Subquery()
		}

	case 13:
		localctx = NewCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6751)
			p.Match(StarRocksParserCAST)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6752)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6753)
			p.expression(0)
		}
		{
			p.SetState(6754)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6755)
			p.Type_()
		}
		{
			p.SetState(6756)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		localctx = NewConvertContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6758)
			p.Match(StarRocksParserCONVERT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6759)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6760)
			p.expression(0)
		}
		{
			p.SetState(6761)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6762)
			p.Type_()
		}
		{
			p.SetState(6763)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewSimpleCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6765)
			p.Match(StarRocksParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6766)

			var _x = p.expression(0)

			localctx.(*SimpleCaseContext).caseExpr = _x
		}
		p.SetState(6768)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == StarRocksParserWHEN {
			{
				p.SetState(6767)
				p.WhenClause()
			}

			p.SetState(6770)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6774)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserELSE {
			{
				p.SetState(6772)
				p.Match(StarRocksParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6773)

				var _x = p.expression(0)

				localctx.(*SimpleCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(6776)
			p.Match(StarRocksParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewSearchedCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6778)
			p.Match(StarRocksParserCASE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6780)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == StarRocksParserWHEN {
			{
				p.SetState(6779)
				p.WhenClause()
			}

			p.SetState(6782)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(6786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserELSE {
			{
				p.SetState(6784)
				p.Match(StarRocksParserELSE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(6785)

				var _x = p.expression(0)

				localctx.(*SearchedCaseContext).elseExpression = _x
			}

		}
		{
			p.SetState(6788)
			p.Match(StarRocksParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		localctx = NewArrayConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(6791)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserARRAY {
			{
				p.SetState(6790)
				p.ArrayType()
			}

		}
		{
			p.SetState(6793)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6794)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6797)
			p.Match(StarRocksParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6798)
			p.MapType()
		}
		{
			p.SetState(6799)
			p.Match(StarRocksParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6801)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6800)
				p.MapExpressionList()
			}

		}
		{
			p.SetState(6803)
			p.Match(StarRocksParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewMapConstructorContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6805)
			p.Match(StarRocksParserMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6806)
			p.Match(StarRocksParserT__8)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6808)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6807)
				p.MapExpressionList()
			}

		}
		{
			p.SetState(6810)
			p.Match(StarRocksParserT__9)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewLambdaFunctionExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(6813)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
			{
				p.SetState(6811)
				p.Identifier()
			}

		case StarRocksParserT__1:
			{
				p.SetState(6812)
				p.IdentifierList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(6815)
			p.Match(StarRocksParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6816)
			p.expression(0)
		}

	case 21:
		localctx = NewLambdaFunctionExprContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(6818)
			p.IdentifierList()
		}
		{
			p.SetState(6819)
			p.Match(StarRocksParserARROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6820)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6822)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6821)
				p.ExpressionList()
			}

		}
		{
			p.SetState(6824)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(6869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 803, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(6867)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 802, p.GetParserRuleContext()) {
			case 1:
				localctx = NewConcatContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*ConcatContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6828)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
					goto errorExit
				}
				{
					p.SetState(6829)
					p.Match(StarRocksParserCONCAT)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6830)

					var _x = p.primaryExpression(20)

					localctx.(*ConcatContext).right = _x
				}

			case 2:
				localctx = NewMatchExprContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*MatchExprContext).left = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6831)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				p.SetState(6833)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserNOT {
					{
						p.SetState(6832)
						p.Match(StarRocksParserNOT)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6835)
					p.Match(StarRocksParserMATCH)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6836)

					var _x = p.primaryExpression(2)

					localctx.(*MatchExprContext).right = _x
				}

			case 3:
				localctx = NewCollateContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6837)

				if !(p.Precpred(p.GetParserRuleContext(), 23)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 23)", ""))
					goto errorExit
				}
				{
					p.SetState(6838)
					p.Match(StarRocksParserCOLLATE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6841)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
					{
						p.SetState(6839)
						p.Identifier()
					}

				case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
					{
						p.SetState(6840)
						p.String_()
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 4:
				localctx = NewDereferenceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*DereferenceContext).base = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6843)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				p.SetState(6847)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}

				switch p.GetTokenStream().LA(1) {
				case StarRocksParserDOT_IDENTIFIER:
					{
						p.SetState(6844)
						p.Match(StarRocksParserDOT_IDENTIFIER)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				case StarRocksParserT__0:
					{
						p.SetState(6845)
						p.Match(StarRocksParserT__0)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}
					{
						p.SetState(6846)

						var _x = p.Identifier()

						localctx.(*DereferenceContext).fieldName = _x
					}

				default:
					p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
					goto errorExit
				}

			case 5:
				localctx = NewCollectionSubscriptContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				localctx.(*CollectionSubscriptContext).value = _prevctx

				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6849)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(6850)
					p.Match(StarRocksParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6851)

					var _x = p.valueExpression(0)

					localctx.(*CollectionSubscriptContext).index = _x
				}
				{
					p.SetState(6852)
					p.Match(StarRocksParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 6:
				localctx = NewArraySliceContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6854)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(6855)
					p.Match(StarRocksParserT__5)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6857)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserINTEGER_VALUE {
					{
						p.SetState(6856)

						var _m = p.Match(StarRocksParserINTEGER_VALUE)

						localctx.(*ArraySliceContext).start_ = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6859)
					p.Match(StarRocksParserT__7)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(6861)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == StarRocksParserINTEGER_VALUE {
					{
						p.SetState(6860)

						var _m = p.Match(StarRocksParserINTEGER_VALUE)

						localctx.(*ArraySliceContext).end = _m
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(6863)
					p.Match(StarRocksParserT__6)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 7:
				localctx = NewArrowExpressionContext(p, NewPrimaryExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, StarRocksParserRULE_primaryExpression)
				p.SetState(6864)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(6865)
					p.Match(StarRocksParserARROW)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6866)
					p.String_()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(6871)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 803, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralExpressionContext is an interface to support dynamic dispatch.
type ILiteralExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralExpressionContext differentiates from other interfaces.
	IsLiteralExpressionContext()
}

type LiteralExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralExpressionContext() *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_literalExpression
	return p
}

func InitEmptyLiteralExpressionContext(p *LiteralExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_literalExpression
}

func (*LiteralExpressionContext) IsLiteralExpressionContext() {}

func NewLiteralExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralExpressionContext {
	var p = new(LiteralExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_literalExpression

	return p
}

func (s *LiteralExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralExpressionContext) CopyAll(ctx *LiteralExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BinaryLiteralContext struct {
	LiteralExpressionContext
}

func NewBinaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BinaryLiteralContext {
	var p = new(BinaryLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *BinaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryLiteralContext) Binary() IBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBinaryContext)
}

func (s *BinaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBinaryLiteral(s)
	}
}

func (s *BinaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBinaryLiteral(s)
	}
}

type NullLiteralContext struct {
	LiteralExpressionContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

type StringLiteralContext struct {
	LiteralExpressionContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStringLiteral(s)
	}
}

func (s *StringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStringLiteral(s)
	}
}

type ParameterContext struct {
	LiteralExpressionContext
}

func NewParameterContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParameterContext {
	var p = new(ParameterContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *ParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterContext) PARAMETER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARAMETER, 0)
}

func (s *ParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterParameter(s)
	}
}

func (s *ParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitParameter(s)
	}
}

type DateLiteralContext struct {
	LiteralExpressionContext
}

func NewDateLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateLiteralContext {
	var p = new(DateLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *DateLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateLiteralContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *DateLiteralContext) DATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATE, 0)
}

func (s *DateLiteralContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATETIME, 0)
}

func (s *DateLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDateLiteral(s)
	}
}

func (s *DateLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDateLiteral(s)
	}
}

type NumericLiteralContext struct {
	LiteralExpressionContext
}

func NewNumericLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) Number() INumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumberContext)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

type BooleanLiteralContext struct {
	LiteralExpressionContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) BooleanValue() IBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanValueContext)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

type IntervalLiteralContext struct {
	LiteralExpressionContext
}

func NewIntervalLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalLiteralContext {
	var p = new(IntervalLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *IntervalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalLiteralContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *IntervalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIntervalLiteral(s)
	}
}

func (s *IntervalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIntervalLiteral(s)
	}
}

type UnitBoundaryLiteralContext struct {
	LiteralExpressionContext
}

func NewUnitBoundaryLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnitBoundaryLiteralContext {
	var p = new(UnitBoundaryLiteralContext)

	InitEmptyLiteralExpressionContext(&p.LiteralExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralExpressionContext))

	return p
}

func (s *UnitBoundaryLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitBoundaryLiteralContext) UnitBoundary() IUnitBoundaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitBoundaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitBoundaryContext)
}

func (s *UnitBoundaryLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnitBoundaryLiteral(s)
	}
}

func (s *UnitBoundaryLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnitBoundaryLiteral(s)
	}
}

func (p *StarRocksParser) LiteralExpression() (localctx ILiteralExpressionContext) {
	localctx = NewLiteralExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, StarRocksParserRULE_literalExpression)
	var _la int

	p.SetState(6882)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserINTEGER_VALUE, StarRocksParserDECIMAL_VALUE, StarRocksParserDOUBLE_VALUE:
		localctx = NewNumericLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6872)
			p.Number()
		}

	case StarRocksParserNULL:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6873)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserFALSE, StarRocksParserTRUE:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6874)
			p.BooleanValue()
		}

	case StarRocksParserDATE, StarRocksParserDATETIME:
		localctx = NewDateLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6875)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserDATE || _la == StarRocksParserDATETIME) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(6876)
			p.String_()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6877)
			p.String_()
		}

	case StarRocksParserINTERVAL:
		localctx = NewIntervalLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6878)
			p.Interval()
		}

	case StarRocksParserCEIL, StarRocksParserFLOOR:
		localctx = NewUnitBoundaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6879)
			p.UnitBoundary()
		}

	case StarRocksParserBINARY_SINGLE_QUOTED_TEXT, StarRocksParserBINARY_DOUBLE_QUOTED_TEXT:
		localctx = NewBinaryLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6880)
			p.Binary()
		}

	case StarRocksParserPARAMETER:
		localctx = NewParameterContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6881)
			p.Match(StarRocksParserPARAMETER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) CopyAll(ctx *FunctionCallContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type AggregationFunctionCallContext struct {
	FunctionCallContext
}

func NewAggregationFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregationFunctionCallContext {
	var p = new(AggregationFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *AggregationFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionCallContext) AggregationFunction() IAggregationFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregationFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregationFunctionContext)
}

func (s *AggregationFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *AggregationFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAggregationFunctionCall(s)
	}
}

func (s *AggregationFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAggregationFunctionCall(s)
	}
}

type ExtractContext struct {
	FunctionCallContext
}

func NewExtractContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExtractContext {
	var p = new(ExtractContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *ExtractContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtractContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTRACT, 0)
}

func (s *ExtractContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExtractContext) FROM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFROM, 0)
}

func (s *ExtractContext) ValueExpression() IValueExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueExpressionContext)
}

func (s *ExtractContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExtract(s)
	}
}

func (s *ExtractContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExtract(s)
	}
}

type SpecialFunctionContext struct {
	FunctionCallContext
}

func NewSpecialFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialFunctionContext {
	var p = new(SpecialFunctionContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecialFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionContext) SpecialFunctionExpression() ISpecialFunctionExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialFunctionExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialFunctionExpressionContext)
}

func (s *SpecialFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSpecialFunction(s)
	}
}

func (s *SpecialFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSpecialFunction(s)
	}
}

type SimpleFunctionCallContext struct {
	FunctionCallContext
}

func NewSimpleFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleFunctionCallContext {
	var p = new(SimpleFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SimpleFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleFunctionCallContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *SimpleFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SimpleFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *SimpleFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSimpleFunctionCall(s)
	}
}

func (s *SimpleFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSimpleFunctionCall(s)
	}
}

type SpecialDateTimeContext struct {
	FunctionCallContext
}

func NewSpecialDateTimeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SpecialDateTimeContext {
	var p = new(SpecialDateTimeContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *SpecialDateTimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeContext) SpecialDateTimeExpression() ISpecialDateTimeExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialDateTimeExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialDateTimeExpressionContext)
}

func (s *SpecialDateTimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSpecialDateTime(s)
	}
}

func (s *SpecialDateTimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSpecialDateTime(s)
	}
}

type WindowFunctionCallContext struct {
	FunctionCallContext
}

func NewWindowFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WindowFunctionCallContext {
	var p = new(WindowFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *WindowFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionCallContext) WindowFunction() IWindowFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFunctionContext)
}

func (s *WindowFunctionCallContext) Over() IOverContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOverContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOverContext)
}

func (s *WindowFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWindowFunctionCall(s)
	}
}

type InformationFunctionContext struct {
	FunctionCallContext
}

func NewInformationFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InformationFunctionContext {
	var p = new(InformationFunctionContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *InformationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InformationFunctionContext) InformationFunctionExpression() IInformationFunctionExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInformationFunctionExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInformationFunctionExpressionContext)
}

func (s *InformationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInformationFunction(s)
	}
}

func (s *InformationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInformationFunction(s)
	}
}

type TranslateFunctionCallContext struct {
	FunctionCallContext
}

func NewTranslateFunctionCallContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TranslateFunctionCallContext {
	var p = new(TranslateFunctionCallContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *TranslateFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TranslateFunctionCallContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSLATE, 0)
}

func (s *TranslateFunctionCallContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TranslateFunctionCallContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TranslateFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTranslateFunctionCall(s)
	}
}

func (s *TranslateFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTranslateFunctionCall(s)
	}
}

type GroupingOperationContext struct {
	FunctionCallContext
}

func NewGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	InitEmptyFunctionCallContext(&p.FunctionCallContext)
	p.parser = parser
	p.CopyAll(ctx.(*FunctionCallContext))

	return p
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) GROUPING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPING, 0)
}

func (s *GroupingOperationContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupingOperationContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *GroupingOperationContext) GROUPING_ID() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUPING_ID, 0)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (p *StarRocksParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, StarRocksParserRULE_functionCall)
	var _la int

	p.SetState(6956)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 815, p.GetParserRuleContext()) {
	case 1:
		localctx = NewExtractContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6884)
			p.Match(StarRocksParserEXTRACT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6885)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6886)
			p.Identifier()
		}
		{
			p.SetState(6887)
			p.Match(StarRocksParserFROM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6888)
			p.valueExpression(0)
		}
		{
			p.SetState(6889)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewGroupingOperationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6891)
			p.Match(StarRocksParserGROUPING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6892)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6901)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6893)
				p.expression(0)
			}
			p.SetState(6898)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(6894)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6895)
					p.expression(0)
				}

				p.SetState(6900)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6903)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewGroupingOperationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6904)
			p.Match(StarRocksParserGROUPING_ID)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6905)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6906)
				p.expression(0)
			}
			p.SetState(6911)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(6907)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6908)
					p.expression(0)
				}

				p.SetState(6913)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6916)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewInformationFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6917)
			p.InformationFunctionExpression()
		}

	case 5:
		localctx = NewSpecialDateTimeContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6918)
			p.SpecialDateTimeExpression()
		}

	case 6:
		localctx = NewSpecialFunctionContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6919)
			p.SpecialFunctionExpression()
		}

	case 7:
		localctx = NewAggregationFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6920)
			p.AggregationFunction()
		}
		p.SetState(6922)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 809, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6921)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		localctx = NewWindowFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6924)
			p.WindowFunction()
		}
		{
			p.SetState(6925)
			p.Over()
		}

	case 9:
		localctx = NewTranslateFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6927)
			p.Match(StarRocksParserTRANSLATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6928)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6929)
				p.expression(0)
			}
			p.SetState(6934)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(6930)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6931)
					p.expression(0)
				}

				p.SetState(6936)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6939)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		localctx = NewSimpleFunctionCallContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6940)
			p.QualifiedName()
		}
		{
			p.SetState(6941)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6950)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6942)
				p.expression(0)
			}
			p.SetState(6947)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(6943)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6944)
					p.expression(0)
				}

				p.SetState(6949)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6952)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6954)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 814, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6953)
				p.Over()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAggregationFunctionContext is an interface to support dynamic dispatch.
type IAggregationFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AVG() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	SetQuantifier() ISetQuantifierContext
	COUNT() antlr.TerminalNode
	ASTERISK_SYMBOL() antlr.TerminalNode
	BracketHint() IBracketHintContext
	MAX() antlr.TerminalNode
	MIN() antlr.TerminalNode
	SUM() antlr.TerminalNode
	ARRAY_AGG() antlr.TerminalNode
	ORDER() antlr.TerminalNode
	BY() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	ARRAY_AGG_DISTINCT() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	SEPARATOR() antlr.TerminalNode

	// IsAggregationFunctionContext differentiates from other interfaces.
	IsAggregationFunctionContext()
}

type AggregationFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregationFunctionContext() *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggregationFunction
	return p
}

func InitEmptyAggregationFunctionContext(p *AggregationFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_aggregationFunction
}

func (*AggregationFunctionContext) IsAggregationFunctionContext() {}

func NewAggregationFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregationFunctionContext {
	var p = new(AggregationFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_aggregationFunction

	return p
}

func (s *AggregationFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregationFunctionContext) AVG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAVG, 0)
}

func (s *AggregationFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AggregationFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AggregationFunctionContext) SetQuantifier() ISetQuantifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetQuantifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetQuantifierContext)
}

func (s *AggregationFunctionContext) COUNT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOUNT, 0)
}

func (s *AggregationFunctionContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *AggregationFunctionContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *AggregationFunctionContext) MAX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAX, 0)
}

func (s *AggregationFunctionContext) MIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMIN, 0)
}

func (s *AggregationFunctionContext) SUM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUM, 0)
}

func (s *AggregationFunctionContext) ARRAY_AGG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_AGG, 0)
}

func (s *AggregationFunctionContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *AggregationFunctionContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *AggregationFunctionContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *AggregationFunctionContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *AggregationFunctionContext) ARRAY_AGG_DISTINCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_AGG_DISTINCT, 0)
}

func (s *AggregationFunctionContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP_CONCAT, 0)
}

func (s *AggregationFunctionContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEPARATOR, 0)
}

func (s *AggregationFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregationFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AggregationFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAggregationFunction(s)
	}
}

func (s *AggregationFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAggregationFunction(s)
	}
}

func (p *StarRocksParser) AggregationFunction() (localctx IAggregationFunctionContext) {
	localctx = NewAggregationFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, StarRocksParserRULE_aggregationFunction)
	var _la int

	p.SetState(7083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 835, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6958)
			p.Match(StarRocksParserAVG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6959)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6961)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(6960)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(6963)
			p.expression(0)
		}
		{
			p.SetState(6964)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6966)
			p.Match(StarRocksParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6967)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6969)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserASTERISK_SYMBOL {
			{
				p.SetState(6968)
				p.Match(StarRocksParserASTERISK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(6971)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6972)
			p.Match(StarRocksParserCOUNT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6973)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6978)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(6974)
				p.SetQuantifier()
			}
			p.SetState(6976)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 818, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(6975)
					p.BracketHint()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		}
		p.SetState(6988)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(6980)
				p.expression(0)
			}
			p.SetState(6985)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(6981)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(6982)
					p.expression(0)
				}

				p.SetState(6987)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(6990)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6991)
			p.Match(StarRocksParserMAX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(6992)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(6994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(6993)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(6996)
			p.expression(0)
		}
		{
			p.SetState(6997)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6999)
			p.Match(StarRocksParserMIN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7000)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7001)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7004)
			p.expression(0)
		}
		{
			p.SetState(7005)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7007)
			p.Match(StarRocksParserSUM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7008)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7010)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7009)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7012)
			p.expression(0)
		}
		{
			p.SetState(7013)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7015)
			p.Match(StarRocksParserARRAY_AGG)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7016)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7017)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7020)
			p.expression(0)
		}
		p.SetState(7031)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(7021)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7022)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7023)
				p.SortItem()
			}
			p.SetState(7028)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7024)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7025)
					p.SortItem()
				}

				p.SetState(7030)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7033)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7035)
			p.Match(StarRocksParserARRAY_AGG_DISTINCT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7036)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7037)
			p.expression(0)
		}
		p.SetState(7048)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(7038)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7039)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7040)
				p.SortItem()
			}
			p.SetState(7045)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7041)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7042)
					p.SortItem()
				}

				p.SetState(7047)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7050)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7052)
			p.Match(StarRocksParserGROUP_CONCAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7053)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7055)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserALL || _la == StarRocksParserDISTINCT {
			{
				p.SetState(7054)
				p.SetQuantifier()
			}

		}
		{
			p.SetState(7057)
			p.expression(0)
		}
		p.SetState(7062)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(7058)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7059)
				p.expression(0)
			}

			p.SetState(7064)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(7075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserORDER {
			{
				p.SetState(7065)
				p.Match(StarRocksParserORDER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7066)
				p.Match(StarRocksParserBY)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7067)
				p.SortItem()
			}
			p.SetState(7072)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7068)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7069)
					p.SortItem()
				}

				p.SetState(7074)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(7079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSEPARATOR {
			{
				p.SetState(7077)
				p.Match(StarRocksParserSEPARATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7078)
				p.expression(0)
			}

		}
		{
			p.SetState(7081)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserVariableContext is an interface to support dynamic dispatch.
type IUserVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT() antlr.TerminalNode
	IdentifierOrString() IIdentifierOrStringContext

	// IsUserVariableContext differentiates from other interfaces.
	IsUserVariableContext()
}

type UserVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariableContext() *UserVariableContext {
	var p = new(UserVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_userVariable
	return p
}

func InitEmptyUserVariableContext(p *UserVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_userVariable
}

func (*UserVariableContext) IsUserVariableContext() {}

func NewUserVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariableContext {
	var p = new(UserVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_userVariable

	return p
}

func (s *UserVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariableContext) AT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, 0)
}

func (s *UserVariableContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserVariable(s)
	}
}

func (s *UserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserVariable(s)
	}
}

func (p *StarRocksParser) UserVariable() (localctx IUserVariableContext) {
	localctx = NewUserVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, StarRocksParserRULE_userVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7085)
		p.Match(StarRocksParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7086)
		p.IdentifierOrString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISystemVariableContext is an interface to support dynamic dispatch.
type ISystemVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAT() []antlr.TerminalNode
	AT(i int) antlr.TerminalNode
	Identifier() IIdentifierContext
	VarType() IVarTypeContext

	// IsSystemVariableContext differentiates from other interfaces.
	IsSystemVariableContext()
}

type SystemVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemVariableContext() *SystemVariableContext {
	var p = new(SystemVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_systemVariable
	return p
}

func InitEmptySystemVariableContext(p *SystemVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_systemVariable
}

func (*SystemVariableContext) IsSystemVariableContext() {}

func NewSystemVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemVariableContext {
	var p = new(SystemVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_systemVariable

	return p
}

func (s *SystemVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemVariableContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserAT)
}

func (s *SystemVariableContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, i)
}

func (s *SystemVariableContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SystemVariableContext) VarType() IVarTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarTypeContext)
}

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSystemVariable(s)
	}
}

func (s *SystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSystemVariable(s)
	}
}

func (p *StarRocksParser) SystemVariable() (localctx ISystemVariableContext) {
	localctx = NewSystemVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, StarRocksParserRULE_systemVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7088)
		p.Match(StarRocksParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7089)
		p.Match(StarRocksParserAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7093)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 836, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(7090)
			p.VarType()
		}
		{
			p.SetState(7091)
			p.Match(StarRocksParserT__0)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(7095)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnReferenceContext is an interface to support dynamic dispatch.
type IColumnReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsColumnReferenceContext differentiates from other interfaces.
	IsColumnReferenceContext()
}

type ColumnReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnReferenceContext() *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnReference
	return p
}

func InitEmptyColumnReferenceContext(p *ColumnReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_columnReference
}

func (*ColumnReferenceContext) IsColumnReferenceContext() {}

func NewColumnReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnReferenceContext {
	var p = new(ColumnReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_columnReference

	return p
}

func (s *ColumnReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterColumnReference(s)
	}
}

func (s *ColumnReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitColumnReference(s)
	}
}

func (p *StarRocksParser) ColumnReference() (localctx IColumnReferenceContext) {
	localctx = NewColumnReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, StarRocksParserRULE_columnReference)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7097)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInformationFunctionExpressionContext is an interface to support dynamic dispatch.
type IInformationFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	CATALOG() antlr.TerminalNode
	DATABASE() antlr.TerminalNode
	SCHEMA() antlr.TerminalNode
	USER() antlr.TerminalNode
	CURRENT_USER() antlr.TerminalNode
	CURRENT_ROLE() antlr.TerminalNode
	CURRENT_GROUP() antlr.TerminalNode

	// IsInformationFunctionExpressionContext differentiates from other interfaces.
	IsInformationFunctionExpressionContext()
}

type InformationFunctionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyInformationFunctionExpressionContext() *InformationFunctionExpressionContext {
	var p = new(InformationFunctionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_informationFunctionExpression
	return p
}

func InitEmptyInformationFunctionExpressionContext(p *InformationFunctionExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_informationFunctionExpression
}

func (*InformationFunctionExpressionContext) IsInformationFunctionExpressionContext() {}

func NewInformationFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InformationFunctionExpressionContext {
	var p = new(InformationFunctionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_informationFunctionExpression

	return p
}

func (s *InformationFunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *InformationFunctionExpressionContext) GetName() antlr.Token { return s.name }

func (s *InformationFunctionExpressionContext) SetName(v antlr.Token) { s.name = v }

func (s *InformationFunctionExpressionContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *InformationFunctionExpressionContext) DATABASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATABASE, 0)
}

func (s *InformationFunctionExpressionContext) SCHEMA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEMA, 0)
}

func (s *InformationFunctionExpressionContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_USER, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_ROLE, 0)
}

func (s *InformationFunctionExpressionContext) CURRENT_GROUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_GROUP, 0)
}

func (s *InformationFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InformationFunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InformationFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInformationFunctionExpression(s)
	}
}

func (s *InformationFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInformationFunctionExpression(s)
	}
}

func (p *StarRocksParser) InformationFunctionExpression() (localctx IInformationFunctionExpressionContext) {
	localctx = NewInformationFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, StarRocksParserRULE_informationFunctionExpression)
	p.SetState(7126)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCATALOG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7099)

			var _m = p.Match(StarRocksParserCATALOG)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7100)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7101)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDATABASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7102)

			var _m = p.Match(StarRocksParserDATABASE)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7103)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7104)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSCHEMA:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7105)

			var _m = p.Match(StarRocksParserSCHEMA)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7106)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7107)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserUSER:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7108)

			var _m = p.Match(StarRocksParserUSER)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7109)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7110)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCURRENT_USER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7111)

			var _m = p.Match(StarRocksParserCURRENT_USER)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7114)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 837, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7112)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7113)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserCURRENT_ROLE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7116)

			var _m = p.Match(StarRocksParserCURRENT_ROLE)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7119)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 838, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7117)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7118)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserCURRENT_GROUP:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7121)

			var _m = p.Match(StarRocksParserCURRENT_GROUP)

			localctx.(*InformationFunctionExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7124)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 839, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7122)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7123)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecialDateTimeExpressionContext is an interface to support dynamic dispatch.
type ISpecialDateTimeExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	CURRENT_DATE() antlr.TerminalNode
	CURRENT_TIME() antlr.TerminalNode
	CURRENT_TIMESTAMP() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	LOCALTIME() antlr.TerminalNode
	LOCALTIMESTAMP() antlr.TerminalNode

	// IsSpecialDateTimeExpressionContext differentiates from other interfaces.
	IsSpecialDateTimeExpressionContext()
}

type SpecialDateTimeExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptySpecialDateTimeExpressionContext() *SpecialDateTimeExpressionContext {
	var p = new(SpecialDateTimeExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_specialDateTimeExpression
	return p
}

func InitEmptySpecialDateTimeExpressionContext(p *SpecialDateTimeExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_specialDateTimeExpression
}

func (*SpecialDateTimeExpressionContext) IsSpecialDateTimeExpressionContext() {}

func NewSpecialDateTimeExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialDateTimeExpressionContext {
	var p = new(SpecialDateTimeExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_specialDateTimeExpression

	return p
}

func (s *SpecialDateTimeExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialDateTimeExpressionContext) GetName() antlr.Token { return s.name }

func (s *SpecialDateTimeExpressionContext) SetName(v antlr.Token) { s.name = v }

func (s *SpecialDateTimeExpressionContext) CURRENT_DATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_DATE, 0)
}

func (s *SpecialDateTimeExpressionContext) CURRENT_TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_TIME, 0)
}

func (s *SpecialDateTimeExpressionContext) CURRENT_TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT_TIMESTAMP, 0)
}

func (s *SpecialDateTimeExpressionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *SpecialDateTimeExpressionContext) LOCALTIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCALTIME, 0)
}

func (s *SpecialDateTimeExpressionContext) LOCALTIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCALTIMESTAMP, 0)
}

func (s *SpecialDateTimeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialDateTimeExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialDateTimeExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSpecialDateTimeExpression(s)
	}
}

func (s *SpecialDateTimeExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSpecialDateTimeExpression(s)
	}
}

func (p *StarRocksParser) SpecialDateTimeExpression() (localctx ISpecialDateTimeExpressionContext) {
	localctx = NewSpecialDateTimeExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, StarRocksParserRULE_specialDateTimeExpression)
	var _la int

	p.SetState(7156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCURRENT_DATE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7128)

			var _m = p.Match(StarRocksParserCURRENT_DATE)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7131)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 841, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7129)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7130)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserCURRENT_TIME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7133)

			var _m = p.Match(StarRocksParserCURRENT_TIME)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7136)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 842, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7134)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7135)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserCURRENT_TIMESTAMP:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7138)

			var _m = p.Match(StarRocksParserCURRENT_TIMESTAMP)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7144)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 844, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7139)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(7141)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserINTEGER_VALUE {
				{
					p.SetState(7140)
					p.Match(StarRocksParserINTEGER_VALUE)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(7143)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserLOCALTIME:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7146)

			var _m = p.Match(StarRocksParserLOCALTIME)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7149)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 845, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7147)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7148)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case StarRocksParserLOCALTIMESTAMP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7151)

			var _m = p.Match(StarRocksParserLOCALTIMESTAMP)

			localctx.(*SpecialDateTimeExpressionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7154)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 846, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(7152)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7153)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpecialFunctionExpressionContext is an interface to support dynamic dispatch.
type ISpecialFunctionExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	IF() antlr.TerminalNode
	LEFT() antlr.TerminalNode
	LIKE() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MOD() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	REGEXP() antlr.TerminalNode
	REPLACE() antlr.TerminalNode
	RIGHT() antlr.TerminalNode
	RLIKE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	UnitIdentifier() IUnitIdentifierContext
	TIMESTAMPDIFF() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	String_() IStringContext
	FLOOR() antlr.TerminalNode
	CEIL() antlr.TerminalNode

	// IsSpecialFunctionExpressionContext differentiates from other interfaces.
	IsSpecialFunctionExpressionContext()
}

type SpecialFunctionExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialFunctionExpressionContext() *SpecialFunctionExpressionContext {
	var p = new(SpecialFunctionExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_specialFunctionExpression
	return p
}

func InitEmptySpecialFunctionExpressionContext(p *SpecialFunctionExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_specialFunctionExpression
}

func (*SpecialFunctionExpressionContext) IsSpecialFunctionExpressionContext() {}

func NewSpecialFunctionExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialFunctionExpressionContext {
	var p = new(SpecialFunctionExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_specialFunctionExpression

	return p
}

func (s *SpecialFunctionExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialFunctionExpressionContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *SpecialFunctionExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SpecialFunctionExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SpecialFunctionExpressionContext) DAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAY, 0)
}

func (s *SpecialFunctionExpressionContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOUR, 0)
}

func (s *SpecialFunctionExpressionContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *SpecialFunctionExpressionContext) LEFT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEFT, 0)
}

func (s *SpecialFunctionExpressionContext) LIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIKE, 0)
}

func (s *SpecialFunctionExpressionContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTE, 0)
}

func (s *SpecialFunctionExpressionContext) MOD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMOD, 0)
}

func (s *SpecialFunctionExpressionContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMONTH, 0)
}

func (s *SpecialFunctionExpressionContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUARTER, 0)
}

func (s *SpecialFunctionExpressionContext) REGEXP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREGEXP, 0)
}

func (s *SpecialFunctionExpressionContext) REPLACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE, 0)
}

func (s *SpecialFunctionExpressionContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRIGHT, 0)
}

func (s *SpecialFunctionExpressionContext) RLIKE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRLIKE, 0)
}

func (s *SpecialFunctionExpressionContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECOND, 0)
}

func (s *SpecialFunctionExpressionContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMPADD, 0)
}

func (s *SpecialFunctionExpressionContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *SpecialFunctionExpressionContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMPDIFF, 0)
}

func (s *SpecialFunctionExpressionContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserYEAR, 0)
}

func (s *SpecialFunctionExpressionContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPASSWORD, 0)
}

func (s *SpecialFunctionExpressionContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *SpecialFunctionExpressionContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFLOOR, 0)
}

func (s *SpecialFunctionExpressionContext) CEIL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCEIL, 0)
}

func (s *SpecialFunctionExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialFunctionExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialFunctionExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSpecialFunctionExpression(s)
	}
}

func (s *SpecialFunctionExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSpecialFunctionExpression(s)
	}
}

func (p *StarRocksParser) SpecialFunctionExpression() (localctx ISpecialFunctionExpressionContext) {
	localctx = NewSpecialFunctionExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, StarRocksParserRULE_specialFunctionExpression)
	var _la int

	p.SetState(7299)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7158)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7159)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7160)
			p.expression(0)
		}
		{
			p.SetState(7161)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDAY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7163)
			p.Match(StarRocksParserDAY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7164)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7165)
			p.expression(0)
		}
		{
			p.SetState(7166)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserHOUR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7168)
			p.Match(StarRocksParserHOUR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7169)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7170)
			p.expression(0)
		}
		{
			p.SetState(7171)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserIF:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7173)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7174)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7183)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(7175)
				p.expression(0)
			}
			p.SetState(7180)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7176)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7177)
					p.expression(0)
				}

				p.SetState(7182)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7185)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserLEFT:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7186)
			p.Match(StarRocksParserLEFT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7187)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7188)
			p.expression(0)
		}
		{
			p.SetState(7189)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7190)
			p.expression(0)
		}
		{
			p.SetState(7191)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserLIKE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7193)
			p.Match(StarRocksParserLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7194)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7195)
			p.expression(0)
		}
		{
			p.SetState(7196)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7197)
			p.expression(0)
		}
		{
			p.SetState(7198)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMINUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7200)
			p.Match(StarRocksParserMINUTE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7201)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7202)
			p.expression(0)
		}
		{
			p.SetState(7203)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMOD:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7205)
			p.Match(StarRocksParserMOD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7206)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7207)
			p.expression(0)
		}
		{
			p.SetState(7208)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7209)
			p.expression(0)
		}
		{
			p.SetState(7210)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserMONTH:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7212)
			p.Match(StarRocksParserMONTH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7213)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7214)
			p.expression(0)
		}
		{
			p.SetState(7215)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserQUARTER:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7217)
			p.Match(StarRocksParserQUARTER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7218)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7219)
			p.expression(0)
		}
		{
			p.SetState(7220)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserREGEXP:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(7222)
			p.Match(StarRocksParserREGEXP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7223)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7224)
			p.expression(0)
		}
		{
			p.SetState(7225)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7226)
			p.expression(0)
		}
		{
			p.SetState(7227)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserREPLACE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(7229)
			p.Match(StarRocksParserREPLACE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7230)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(7231)
				p.expression(0)
			}
			p.SetState(7236)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7232)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7233)
					p.expression(0)
				}

				p.SetState(7238)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7241)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRIGHT:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(7242)
			p.Match(StarRocksParserRIGHT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7243)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7244)
			p.expression(0)
		}
		{
			p.SetState(7245)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7246)
			p.expression(0)
		}
		{
			p.SetState(7247)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRLIKE:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(7249)
			p.Match(StarRocksParserRLIKE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7250)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7251)
			p.expression(0)
		}
		{
			p.SetState(7252)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7253)
			p.expression(0)
		}
		{
			p.SetState(7254)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSECOND:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(7256)
			p.Match(StarRocksParserSECOND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7257)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7258)
			p.expression(0)
		}
		{
			p.SetState(7259)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserTIMESTAMPADD:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(7261)
			p.Match(StarRocksParserTIMESTAMPADD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7262)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7263)
			p.UnitIdentifier()
		}
		{
			p.SetState(7264)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7265)
			p.expression(0)
		}
		{
			p.SetState(7266)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7267)
			p.expression(0)
		}
		{
			p.SetState(7268)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserTIMESTAMPDIFF:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(7270)
			p.Match(StarRocksParserTIMESTAMPDIFF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7271)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7272)
			p.UnitIdentifier()
		}
		{
			p.SetState(7273)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7274)
			p.expression(0)
		}
		{
			p.SetState(7275)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7276)
			p.expression(0)
		}
		{
			p.SetState(7277)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserYEAR:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(7279)
			p.Match(StarRocksParserYEAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7280)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7281)
			p.expression(0)
		}
		{
			p.SetState(7282)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPASSWORD:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(7284)
			p.Match(StarRocksParserPASSWORD)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7285)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7286)
			p.String_()
		}
		{
			p.SetState(7287)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserFLOOR:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(7289)
			p.Match(StarRocksParserFLOOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7290)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7291)
			p.expression(0)
		}
		{
			p.SetState(7292)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCEIL:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(7294)
			p.Match(StarRocksParserCEIL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7295)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7296)
			p.expression(0)
		}
		{
			p.SetState(7297)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFunctionContext is an interface to support dynamic dispatch.
type IWindowFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	ROW_NUMBER() antlr.TerminalNode
	RANK() antlr.TerminalNode
	DENSE_RANK() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	NTILE() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	LEAD() antlr.TerminalNode
	AllIgnoreNulls() []IIgnoreNullsContext
	IgnoreNulls(i int) IIgnoreNullsContext
	LAG() antlr.TerminalNode
	FIRST_VALUE() antlr.TerminalNode
	LAST_VALUE() antlr.TerminalNode

	// IsWindowFunctionContext differentiates from other interfaces.
	IsWindowFunctionContext()
}

type WindowFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyWindowFunctionContext() *WindowFunctionContext {
	var p = new(WindowFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_windowFunction
	return p
}

func InitEmptyWindowFunctionContext(p *WindowFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_windowFunction
}

func (*WindowFunctionContext) IsWindowFunctionContext() {}

func NewWindowFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFunctionContext {
	var p = new(WindowFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_windowFunction

	return p
}

func (s *WindowFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFunctionContext) GetName() antlr.Token { return s.name }

func (s *WindowFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *WindowFunctionContext) ROW_NUMBER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROW_NUMBER, 0)
}

func (s *WindowFunctionContext) RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANK, 0)
}

func (s *WindowFunctionContext) DENSE_RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDENSE_RANK, 0)
}

func (s *WindowFunctionContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUME_DIST, 0)
}

func (s *WindowFunctionContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENT_RANK, 0)
}

func (s *WindowFunctionContext) NTILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNTILE, 0)
}

func (s *WindowFunctionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WindowFunctionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WindowFunctionContext) LEAD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEAD, 0)
}

func (s *WindowFunctionContext) AllIgnoreNulls() []IIgnoreNullsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIgnoreNullsContext); ok {
			len++
		}
	}

	tst := make([]IIgnoreNullsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIgnoreNullsContext); ok {
			tst[i] = t.(IIgnoreNullsContext)
			i++
		}
	}

	return tst
}

func (s *WindowFunctionContext) IgnoreNulls(i int) IIgnoreNullsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIgnoreNullsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIgnoreNullsContext)
}

func (s *WindowFunctionContext) LAG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLAG, 0)
}

func (s *WindowFunctionContext) FIRST_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST_VALUE, 0)
}

func (s *WindowFunctionContext) LAST_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLAST_VALUE, 0)
}

func (s *WindowFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWindowFunction(s)
	}
}

func (s *WindowFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWindowFunction(s)
	}
}

func (p *StarRocksParser) WindowFunction() (localctx IWindowFunctionContext) {
	localctx = NewWindowFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, StarRocksParserRULE_windowFunction)
	var _la int

	p.SetState(7398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserROW_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7301)

			var _m = p.Match(StarRocksParserROW_NUMBER)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7302)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7303)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserRANK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7304)

			var _m = p.Match(StarRocksParserRANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7305)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7306)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDENSE_RANK:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7307)

			var _m = p.Match(StarRocksParserDENSE_RANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7308)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7309)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserCUME_DIST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7310)

			var _m = p.Match(StarRocksParserCUME_DIST)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7311)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7312)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserPERCENT_RANK:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7313)

			var _m = p.Match(StarRocksParserPERCENT_RANK)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7314)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7315)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserNTILE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7316)

			var _m = p.Match(StarRocksParserNTILE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7317)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7319)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(7318)
				p.expression(0)
			}

		}
		{
			p.SetState(7321)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserLEAD:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7322)

			var _m = p.Match(StarRocksParserLEAD)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7323)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7335)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(7324)
				p.expression(0)
			}
			p.SetState(7326)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIGNORE {
				{
					p.SetState(7325)
					p.IgnoreNulls()
				}

			}
			p.SetState(7332)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7328)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7329)
					p.expression(0)
				}

				p.SetState(7334)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7337)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIGNORE {
			{
				p.SetState(7338)
				p.IgnoreNulls()
			}

		}

	case StarRocksParserLAG:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(7341)

			var _m = p.Match(StarRocksParserLAG)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7342)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7354)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(7343)
				p.expression(0)
			}
			p.SetState(7345)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIGNORE {
				{
					p.SetState(7344)
					p.IgnoreNulls()
				}

			}
			p.SetState(7351)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7347)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7348)
					p.expression(0)
				}

				p.SetState(7353)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7356)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIGNORE {
			{
				p.SetState(7357)
				p.IgnoreNulls()
			}

		}

	case StarRocksParserFIRST_VALUE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(7360)

			var _m = p.Match(StarRocksParserFIRST_VALUE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7361)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(7362)
				p.expression(0)
			}
			p.SetState(7364)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIGNORE {
				{
					p.SetState(7363)
					p.IgnoreNulls()
				}

			}
			p.SetState(7370)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7366)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7367)
					p.expression(0)
				}

				p.SetState(7372)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7375)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7377)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIGNORE {
			{
				p.SetState(7376)
				p.IgnoreNulls()
			}

		}

	case StarRocksParserLAST_VALUE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(7379)

			var _m = p.Match(StarRocksParserLAST_VALUE)

			localctx.(*WindowFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7380)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-37178886588212668) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&-6366929338696271115) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-652232913500536911) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-353114152744113) != 0) || ((int64((_la-257)) & ^0x3f) == 0 && ((int64(1)<<(_la-257))&4610547043566354425) != 0) || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&-36063982064762897) != 0) || ((int64((_la-386)) & ^0x3f) == 0 && ((int64(1)<<(_la-386))&4606608455443139963) != 0) || ((int64((_la-450)) & ^0x3f) == 0 && ((int64(1)<<(_la-450))&1189936425747868371) != 0) || ((int64((_la-515)) & ^0x3f) == 0 && ((int64(1)<<(_la-515))&67583) != 0) {
			{
				p.SetState(7381)
				p.expression(0)
			}
			p.SetState(7383)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserIGNORE {
				{
					p.SetState(7382)
					p.IgnoreNulls()
				}

			}
			p.SetState(7389)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7385)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7386)
					p.expression(0)
				}

				p.SetState(7391)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7394)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7396)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserIGNORE {
			{
				p.SetState(7395)
				p.IgnoreNulls()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenClauseContext is an interface to support dynamic dispatch.
type IWhenClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetCondition returns the condition rule contexts.
	GetCondition() IExpressionContext

	// GetResult returns the result rule contexts.
	GetResult() IExpressionContext

	// SetCondition sets the condition rule contexts.
	SetCondition(IExpressionContext)

	// SetResult sets the result rule contexts.
	SetResult(IExpressionContext)

	// Getter signatures
	WHEN() antlr.TerminalNode
	THEN() antlr.TerminalNode
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsWhenClauseContext differentiates from other interfaces.
	IsWhenClauseContext()
}

type WhenClauseContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	condition IExpressionContext
	result    IExpressionContext
}

func NewEmptyWhenClauseContext() *WhenClauseContext {
	var p = new(WhenClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_whenClause
	return p
}

func InitEmptyWhenClauseContext(p *WhenClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_whenClause
}

func (*WhenClauseContext) IsWhenClauseContext() {}

func NewWhenClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenClauseContext {
	var p = new(WhenClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_whenClause

	return p
}

func (s *WhenClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenClauseContext) GetCondition() IExpressionContext { return s.condition }

func (s *WhenClauseContext) GetResult() IExpressionContext { return s.result }

func (s *WhenClauseContext) SetCondition(v IExpressionContext) { s.condition = v }

func (s *WhenClauseContext) SetResult(v IExpressionContext) { s.result = v }

func (s *WhenClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHEN, 0)
}

func (s *WhenClauseContext) THEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTHEN, 0)
}

func (s *WhenClauseContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WhenClauseContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhenClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWhenClause(s)
	}
}

func (s *WhenClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWhenClause(s)
	}
}

func (p *StarRocksParser) WhenClause() (localctx IWhenClauseContext) {
	localctx = NewWhenClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, StarRocksParserRULE_whenClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7400)
		p.Match(StarRocksParserWHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7401)

		var _x = p.expression(0)

		localctx.(*WhenClauseContext).condition = _x
	}
	{
		p.SetState(7402)
		p.Match(StarRocksParserTHEN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7403)

		var _x = p.expression(0)

		localctx.(*WhenClauseContext).result = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOverContext is an interface to support dynamic dispatch.
type IOverContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Get_expression returns the _expression rule contexts.
	Get_expression() IExpressionContext

	// Set_expression sets the _expression rule contexts.
	Set_expression(IExpressionContext)

	// GetPartition returns the partition rule context list.
	GetPartition() []IExpressionContext

	// SetPartition sets the partition rule context list.
	SetPartition([]IExpressionContext)

	// Getter signatures
	OVER() antlr.TerminalNode
	PARTITION() antlr.TerminalNode
	AllBY() []antlr.TerminalNode
	BY(i int) antlr.TerminalNode
	ORDER() antlr.TerminalNode
	AllSortItem() []ISortItemContext
	SortItem(i int) ISortItemContext
	WindowFrame() IWindowFrameContext
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	BracketHint() IBracketHintContext

	// IsOverContext differentiates from other interfaces.
	IsOverContext()
}

type OverContext struct {
	antlr.BaseParserRuleContext
	parser      antlr.Parser
	_expression IExpressionContext
	partition   []IExpressionContext
}

func NewEmptyOverContext() *OverContext {
	var p = new(OverContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_over
	return p
}

func InitEmptyOverContext(p *OverContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_over
}

func (*OverContext) IsOverContext() {}

func NewOverContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OverContext {
	var p = new(OverContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_over

	return p
}

func (s *OverContext) GetParser() antlr.Parser { return s.parser }

func (s *OverContext) Get_expression() IExpressionContext { return s._expression }

func (s *OverContext) Set_expression(v IExpressionContext) { s._expression = v }

func (s *OverContext) GetPartition() []IExpressionContext { return s.partition }

func (s *OverContext) SetPartition(v []IExpressionContext) { s.partition = v }

func (s *OverContext) OVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOVER, 0)
}

func (s *OverContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *OverContext) AllBY() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserBY)
}

func (s *OverContext) BY(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, i)
}

func (s *OverContext) ORDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserORDER, 0)
}

func (s *OverContext) AllSortItem() []ISortItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortItemContext); ok {
			len++
		}
	}

	tst := make([]ISortItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortItemContext); ok {
			tst[i] = t.(ISortItemContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) SortItem(i int) ISortItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortItemContext)
}

func (s *OverContext) WindowFrame() IWindowFrameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameContext)
}

func (s *OverContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OverContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *OverContext) BracketHint() IBracketHintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBracketHintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBracketHintContext)
}

func (s *OverContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OverContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOver(s)
	}
}

func (s *OverContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOver(s)
	}
}

func (p *StarRocksParser) Over() (localctx IOverContext) {
	localctx = NewOverContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, StarRocksParserRULE_over)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7405)
		p.Match(StarRocksParserOVER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7406)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7420)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__5 || _la == StarRocksParserPARTITION {
		p.SetState(7408)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__5 {
			{
				p.SetState(7407)
				p.BracketHint()
			}

		}
		{
			p.SetState(7410)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7411)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7412)

			var _x = p.expression(0)

			localctx.(*OverContext)._expression = _x
		}
		localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)
		p.SetState(7417)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(7413)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7414)

				var _x = p.expression(0)

				localctx.(*OverContext)._expression = _x
			}
			localctx.(*OverContext).partition = append(localctx.(*OverContext).partition, localctx.(*OverContext)._expression)

			p.SetState(7419)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(7432)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserORDER {
		{
			p.SetState(7422)
			p.Match(StarRocksParserORDER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7423)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7424)
			p.SortItem()
		}
		p.SetState(7429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == StarRocksParserT__2 {
			{
				p.SetState(7425)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7426)
				p.SortItem()
			}

			p.SetState(7431)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(7435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserRANGE || _la == StarRocksParserROWS {
		{
			p.SetState(7434)
			p.WindowFrame()
		}

	}
	{
		p.SetState(7437)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIgnoreNullsContext is an interface to support dynamic dispatch.
type IIgnoreNullsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IGNORE() antlr.TerminalNode
	NULLS() antlr.TerminalNode

	// IsIgnoreNullsContext differentiates from other interfaces.
	IsIgnoreNullsContext()
}

type IgnoreNullsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIgnoreNullsContext() *IgnoreNullsContext {
	var p = new(IgnoreNullsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_ignoreNulls
	return p
}

func InitEmptyIgnoreNullsContext(p *IgnoreNullsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_ignoreNulls
}

func (*IgnoreNullsContext) IsIgnoreNullsContext() {}

func NewIgnoreNullsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IgnoreNullsContext {
	var p = new(IgnoreNullsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_ignoreNulls

	return p
}

func (s *IgnoreNullsContext) GetParser() antlr.Parser { return s.parser }

func (s *IgnoreNullsContext) IGNORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIGNORE, 0)
}

func (s *IgnoreNullsContext) NULLS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULLS, 0)
}

func (s *IgnoreNullsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IgnoreNullsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IgnoreNullsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIgnoreNulls(s)
	}
}

func (s *IgnoreNullsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIgnoreNulls(s)
	}
}

func (p *StarRocksParser) IgnoreNulls() (localctx IIgnoreNullsContext) {
	localctx = NewIgnoreNullsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, StarRocksParserRULE_ignoreNulls)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7439)
		p.Match(StarRocksParserIGNORE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7440)
		p.Match(StarRocksParserNULLS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameContext is an interface to support dynamic dispatch.
type IWindowFrameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFrameType returns the frameType token.
	GetFrameType() antlr.Token

	// SetFrameType sets the frameType token.
	SetFrameType(antlr.Token)

	// GetStart_ returns the start_ rule contexts.
	GetStart_() IFrameBoundContext

	// GetEnd returns the end rule contexts.
	GetEnd() IFrameBoundContext

	// SetStart_ sets the start_ rule contexts.
	SetStart_(IFrameBoundContext)

	// SetEnd sets the end rule contexts.
	SetEnd(IFrameBoundContext)

	// Getter signatures
	RANGE() antlr.TerminalNode
	AllFrameBound() []IFrameBoundContext
	FrameBound(i int) IFrameBoundContext
	ROWS() antlr.TerminalNode
	BETWEEN() antlr.TerminalNode
	AND() antlr.TerminalNode

	// IsWindowFrameContext differentiates from other interfaces.
	IsWindowFrameContext()
}

type WindowFrameContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	frameType antlr.Token
	start_    IFrameBoundContext
	end       IFrameBoundContext
}

func NewEmptyWindowFrameContext() *WindowFrameContext {
	var p = new(WindowFrameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_windowFrame
	return p
}

func InitEmptyWindowFrameContext(p *WindowFrameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_windowFrame
}

func (*WindowFrameContext) IsWindowFrameContext() {}

func NewWindowFrameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameContext {
	var p = new(WindowFrameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_windowFrame

	return p
}

func (s *WindowFrameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameContext) GetFrameType() antlr.Token { return s.frameType }

func (s *WindowFrameContext) SetFrameType(v antlr.Token) { s.frameType = v }

func (s *WindowFrameContext) GetStart_() IFrameBoundContext { return s.start_ }

func (s *WindowFrameContext) GetEnd() IFrameBoundContext { return s.end }

func (s *WindowFrameContext) SetStart_(v IFrameBoundContext) { s.start_ = v }

func (s *WindowFrameContext) SetEnd(v IFrameBoundContext) { s.end = v }

func (s *WindowFrameContext) RANGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANGE, 0)
}

func (s *WindowFrameContext) AllFrameBound() []IFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFrameBoundContext); ok {
			tst[i] = t.(IFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameContext) FrameBound(i int) IFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFrameBoundContext)
}

func (s *WindowFrameContext) ROWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROWS, 0)
}

func (s *WindowFrameContext) BETWEEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBETWEEN, 0)
}

func (s *WindowFrameContext) AND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAND, 0)
}

func (s *WindowFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWindowFrame(s)
	}
}

func (s *WindowFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWindowFrame(s)
	}
}

func (p *StarRocksParser) WindowFrame() (localctx IWindowFrameContext) {
	localctx = NewWindowFrameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, StarRocksParserRULE_windowFrame)
	p.SetState(7458)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 877, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7442)

			var _m = p.Match(StarRocksParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7443)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7444)

			var _m = p.Match(StarRocksParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7445)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7446)

			var _m = p.Match(StarRocksParserRANGE)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7447)
			p.Match(StarRocksParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7448)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(7449)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7450)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7452)

			var _m = p.Match(StarRocksParserROWS)

			localctx.(*WindowFrameContext).frameType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7453)
			p.Match(StarRocksParserBETWEEN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7454)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).start_ = _x
		}
		{
			p.SetState(7455)
			p.Match(StarRocksParserAND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7456)

			var _x = p.FrameBound()

			localctx.(*WindowFrameContext).end = _x
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFrameBoundContext is an interface to support dynamic dispatch.
type IFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFrameBoundContext differentiates from other interfaces.
	IsFrameBoundContext()
}

type FrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFrameBoundContext() *FrameBoundContext {
	var p = new(FrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_frameBound
	return p
}

func InitEmptyFrameBoundContext(p *FrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_frameBound
}

func (*FrameBoundContext) IsFrameBoundContext() {}

func NewFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FrameBoundContext {
	var p = new(FrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_frameBound

	return p
}

func (s *FrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *FrameBoundContext) CopyAll(ctx *FrameBoundContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *FrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BoundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewBoundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BoundedFrameContext {
	var p = new(BoundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *BoundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *BoundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *BoundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoundedFrameContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BoundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRECEDING, 0)
}

func (s *BoundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWING, 0)
}

func (s *BoundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBoundedFrame(s)
	}
}

func (s *BoundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBoundedFrame(s)
	}
}

type UnboundedFrameContext struct {
	FrameBoundContext
	boundType antlr.Token
}

func NewUnboundedFrameContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnboundedFrameContext {
	var p = new(UnboundedFrameContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *UnboundedFrameContext) GetBoundType() antlr.Token { return s.boundType }

func (s *UnboundedFrameContext) SetBoundType(v antlr.Token) { s.boundType = v }

func (s *UnboundedFrameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnboundedFrameContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNBOUNDED, 0)
}

func (s *UnboundedFrameContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRECEDING, 0)
}

func (s *UnboundedFrameContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWING, 0)
}

func (s *UnboundedFrameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnboundedFrame(s)
	}
}

func (s *UnboundedFrameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnboundedFrame(s)
	}
}

type CurrentRowBoundContext struct {
	FrameBoundContext
}

func NewCurrentRowBoundContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CurrentRowBoundContext {
	var p = new(CurrentRowBoundContext)

	InitEmptyFrameBoundContext(&p.FrameBoundContext)
	p.parser = parser
	p.CopyAll(ctx.(*FrameBoundContext))

	return p
}

func (s *CurrentRowBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrentRowBoundContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT, 0)
}

func (s *CurrentRowBoundContext) ROW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROW, 0)
}

func (s *CurrentRowBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterCurrentRowBound(s)
	}
}

func (s *CurrentRowBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitCurrentRowBound(s)
	}
}

func (p *StarRocksParser) FrameBound() (localctx IFrameBoundContext) {
	localctx = NewFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, StarRocksParserRULE_frameBound)
	var _la int

	p.SetState(7469)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 878, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7460)
			p.Match(StarRocksParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7461)

			var _m = p.Match(StarRocksParserPRECEDING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewUnboundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7462)
			p.Match(StarRocksParserUNBOUNDED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7463)

			var _m = p.Match(StarRocksParserFOLLOWING)

			localctx.(*UnboundedFrameContext).boundType = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewCurrentRowBoundContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7464)
			p.Match(StarRocksParserCURRENT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7465)
			p.Match(StarRocksParserROW)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		localctx = NewBoundedFrameContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7466)
			p.expression(0)
		}
		{
			p.SetState(7467)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*BoundedFrameContext).boundType = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserFOLLOWING || _la == StarRocksParserPRECEDING) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*BoundedFrameContext).boundType = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupRestoreObjectDescContext is an interface to support dynamic dispatch.
type IBackupRestoreObjectDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BackupRestoreTableDesc() IBackupRestoreTableDescContext
	ALL() antlr.TerminalNode
	QualifiedName() IQualifiedNameContext
	FUNCTION() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLE() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode

	// IsBackupRestoreObjectDescContext differentiates from other interfaces.
	IsBackupRestoreObjectDescContext()
}

type BackupRestoreObjectDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackupRestoreObjectDescContext() *BackupRestoreObjectDescContext {
	var p = new(BackupRestoreObjectDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupRestoreObjectDesc
	return p
}

func InitEmptyBackupRestoreObjectDescContext(p *BackupRestoreObjectDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupRestoreObjectDesc
}

func (*BackupRestoreObjectDescContext) IsBackupRestoreObjectDescContext() {}

func NewBackupRestoreObjectDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupRestoreObjectDescContext {
	var p = new(BackupRestoreObjectDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_backupRestoreObjectDesc

	return p
}

func (s *BackupRestoreObjectDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupRestoreObjectDescContext) BackupRestoreTableDesc() IBackupRestoreTableDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBackupRestoreTableDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBackupRestoreTableDescContext)
}

func (s *BackupRestoreObjectDescContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *BackupRestoreObjectDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupRestoreObjectDescContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTION, 0)
}

func (s *BackupRestoreObjectDescContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTIONS, 0)
}

func (s *BackupRestoreObjectDescContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *BackupRestoreObjectDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupRestoreObjectDescContext) TABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLE, 0)
}

func (s *BackupRestoreObjectDescContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *BackupRestoreObjectDescContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *BackupRestoreObjectDescContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *BackupRestoreObjectDescContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEWS, 0)
}

func (s *BackupRestoreObjectDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupRestoreObjectDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupRestoreObjectDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBackupRestoreObjectDesc(s)
	}
}

func (s *BackupRestoreObjectDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBackupRestoreObjectDesc(s)
	}
}

func (p *StarRocksParser) BackupRestoreObjectDesc() (localctx IBackupRestoreObjectDescContext) {
	localctx = NewBackupRestoreObjectDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, StarRocksParserRULE_backupRestoreObjectDesc)
	var _la int

	p.SetState(7510)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 886, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7471)
			p.BackupRestoreTableDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(7480)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserALL:
			{
				p.SetState(7472)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7473)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFUNCTION || _la == StarRocksParserFUNCTIONS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case StarRocksParserFUNCTION, StarRocksParserFUNCTIONS:
			{
				p.SetState(7474)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserFUNCTION || _la == StarRocksParserFUNCTIONS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7475)
				p.QualifiedName()
			}
			p.SetState(7478)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(7476)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7477)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(7486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserALL:
			{
				p.SetState(7482)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7483)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserTABLE || _la == StarRocksParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case StarRocksParserTABLE, StarRocksParserTABLES:
			{
				p.SetState(7484)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserTABLE || _la == StarRocksParserTABLES) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7485)
				p.BackupRestoreTableDesc()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(7498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserALL:
			{
				p.SetState(7488)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7489)
				p.Match(StarRocksParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7490)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserVIEW || _la == StarRocksParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case StarRocksParserMATERIALIZED:
			{
				p.SetState(7491)
				p.Match(StarRocksParserMATERIALIZED)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7492)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserVIEW || _la == StarRocksParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7493)
				p.QualifiedName()
			}
			p.SetState(7496)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(7494)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7495)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(7508)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserALL:
			{
				p.SetState(7500)
				p.Match(StarRocksParserALL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7501)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserVIEW || _la == StarRocksParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case StarRocksParserVIEW, StarRocksParserVIEWS:
			{
				p.SetState(7502)
				_la = p.GetTokenStream().LA(1)

				if !(_la == StarRocksParserVIEW || _la == StarRocksParserVIEWS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}
			{
				p.SetState(7503)
				p.QualifiedName()
			}
			p.SetState(7506)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == StarRocksParserAS {
				{
					p.SetState(7504)
					p.Match(StarRocksParserAS)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7505)
					p.Identifier()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableDescContext is an interface to support dynamic dispatch.
type ITableDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext

	// IsTableDescContext differentiates from other interfaces.
	IsTableDescContext()
}

type TableDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableDescContext() *TableDescContext {
	var p = new(TableDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableDesc
	return p
}

func InitEmptyTableDescContext(p *TableDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableDesc
}

func (*TableDescContext) IsTableDescContext() {}

func NewTableDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableDescContext {
	var p = new(TableDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tableDesc

	return p
}

func (s *TableDescContext) GetParser() antlr.Parser { return s.parser }

func (s *TableDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *TableDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableDesc(s)
	}
}

func (s *TableDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableDesc(s)
	}
}

func (p *StarRocksParser) TableDesc() (localctx ITableDescContext) {
	localctx = NewTableDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, StarRocksParserRULE_tableDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7512)
		p.QualifiedName()
	}
	p.SetState(7514)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(7513)
			p.PartitionNames()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBackupRestoreTableDescContext is an interface to support dynamic dispatch.
type IBackupRestoreTableDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext
	PartitionNames() IPartitionNamesContext
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsBackupRestoreTableDescContext differentiates from other interfaces.
	IsBackupRestoreTableDescContext()
}

type BackupRestoreTableDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBackupRestoreTableDescContext() *BackupRestoreTableDescContext {
	var p = new(BackupRestoreTableDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupRestoreTableDesc
	return p
}

func InitEmptyBackupRestoreTableDescContext(p *BackupRestoreTableDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_backupRestoreTableDesc
}

func (*BackupRestoreTableDescContext) IsBackupRestoreTableDescContext() {}

func NewBackupRestoreTableDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BackupRestoreTableDescContext {
	var p = new(BackupRestoreTableDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_backupRestoreTableDesc

	return p
}

func (s *BackupRestoreTableDescContext) GetParser() antlr.Parser { return s.parser }

func (s *BackupRestoreTableDescContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *BackupRestoreTableDescContext) PartitionNames() IPartitionNamesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionNamesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionNamesContext)
}

func (s *BackupRestoreTableDescContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *BackupRestoreTableDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BackupRestoreTableDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackupRestoreTableDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BackupRestoreTableDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBackupRestoreTableDesc(s)
	}
}

func (s *BackupRestoreTableDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBackupRestoreTableDesc(s)
	}
}

func (p *StarRocksParser) BackupRestoreTableDesc() (localctx IBackupRestoreTableDescContext) {
	localctx = NewBackupRestoreTableDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, StarRocksParserRULE_backupRestoreTableDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7516)
		p.QualifiedName()
	}
	p.SetState(7518)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPARTITION || _la == StarRocksParserPARTITIONS || _la == StarRocksParserTEMPORARY {
		{
			p.SetState(7517)
			p.PartitionNames()
		}

	}
	p.SetState(7522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(7520)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7521)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplainDescContext is an interface to support dynamic dispatch.
type IExplainDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DESC() antlr.TerminalNode
	DESCRIBE() antlr.TerminalNode
	EXPLAIN() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	ANALYZE() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	COSTS() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode

	// IsExplainDescContext differentiates from other interfaces.
	IsExplainDescContext()
}

type ExplainDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplainDescContext() *ExplainDescContext {
	var p = new(ExplainDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_explainDesc
	return p
}

func InitEmptyExplainDescContext(p *ExplainDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_explainDesc
}

func (*ExplainDescContext) IsExplainDescContext() {}

func NewExplainDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplainDescContext {
	var p = new(ExplainDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_explainDesc

	return p
}

func (s *ExplainDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplainDescContext) DESC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESC, 0)
}

func (s *ExplainDescContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDESCRIBE, 0)
}

func (s *ExplainDescContext) EXPLAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPLAIN, 0)
}

func (s *ExplainDescContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL, 0)
}

func (s *ExplainDescContext) ANALYZE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANALYZE, 0)
}

func (s *ExplainDescContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERBOSE, 0)
}

func (s *ExplainDescContext) COSTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOSTS, 0)
}

func (s *ExplainDescContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULER, 0)
}

func (s *ExplainDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplainDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplainDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExplainDesc(s)
	}
}

func (s *ExplainDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExplainDesc(s)
	}
}

func (p *StarRocksParser) ExplainDesc() (localctx IExplainDescContext) {
	localctx = NewExplainDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, StarRocksParserRULE_explainDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7524)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-123)) & ^0x3f) == 0 && ((int64(1)<<(_la-123))&8388611) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(7526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserANALYZE || _la == StarRocksParserCOSTS || _la == StarRocksParserLOGICAL || _la == StarRocksParserSCHEDULER || _la == StarRocksParserVERBOSE {
		{
			p.SetState(7525)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserANALYZE || _la == StarRocksParserCOSTS || _la == StarRocksParserLOGICAL || _la == StarRocksParserSCHEDULER || _la == StarRocksParserVERBOSE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptimizerTraceContext is an interface to support dynamic dispatch.
type IOptimizerTraceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRACE() antlr.TerminalNode
	ALL() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	VALUES() antlr.TerminalNode
	REASON() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsOptimizerTraceContext differentiates from other interfaces.
	IsOptimizerTraceContext()
}

type OptimizerTraceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptimizerTraceContext() *OptimizerTraceContext {
	var p = new(OptimizerTraceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizerTrace
	return p
}

func InitEmptyOptimizerTraceContext(p *OptimizerTraceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_optimizerTrace
}

func (*OptimizerTraceContext) IsOptimizerTraceContext() {}

func NewOptimizerTraceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptimizerTraceContext {
	var p = new(OptimizerTraceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_optimizerTrace

	return p
}

func (s *OptimizerTraceContext) GetParser() antlr.Parser { return s.parser }

func (s *OptimizerTraceContext) TRACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRACE, 0)
}

func (s *OptimizerTraceContext) ALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserALL, 0)
}

func (s *OptimizerTraceContext) LOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGS, 0)
}

func (s *OptimizerTraceContext) TIMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMES, 0)
}

func (s *OptimizerTraceContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *OptimizerTraceContext) REASON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREASON, 0)
}

func (s *OptimizerTraceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *OptimizerTraceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptimizerTraceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptimizerTraceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOptimizerTrace(s)
	}
}

func (s *OptimizerTraceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOptimizerTrace(s)
	}
}

func (p *StarRocksParser) OptimizerTrace() (localctx IOptimizerTraceContext) {
	localctx = NewOptimizerTraceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, StarRocksParserRULE_optimizerTrace)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7528)
		p.Match(StarRocksParserTRACE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7529)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserALL || _la == StarRocksParserLOGS || _la == StarRocksParserREASON || _la == StarRocksParserTIMES || _la == StarRocksParserVALUES) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(7531)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&7557330222697660093) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-4653295000587626501) != 0) || ((int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&-3747053846437727955) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&8790990742223650807) != 0) || ((int64((_la-326)) & ^0x3f) == 0 && ((int64(1)<<(_la-326))&-5479769140411580417) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&3742173942658366679) != 0) || ((int64((_la-454)) & ^0x3f) == 0 && ((int64(1)<<(_la-454))&8856199495341) != 0) || ((int64((_la-523)) & ^0x3f) == 0 && ((int64(1)<<(_la-523))&263) != 0) {
		{
			p.SetState(7530)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionExprContext is an interface to support dynamic dispatch.
type IPartitionExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionCall() IFunctionCallContext

	// IsPartitionExprContext differentiates from other interfaces.
	IsPartitionExprContext()
}

type PartitionExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionExprContext() *PartitionExprContext {
	var p = new(PartitionExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionExpr
	return p
}

func InitEmptyPartitionExprContext(p *PartitionExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionExpr
}

func (*PartitionExprContext) IsPartitionExprContext() {}

func NewPartitionExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionExprContext {
	var p = new(PartitionExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionExpr

	return p
}

func (s *PartitionExprContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionExprContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionExprContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PartitionExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionExpr(s)
	}
}

func (s *PartitionExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionExpr(s)
	}
}

func (p *StarRocksParser) PartitionExpr() (localctx IPartitionExprContext) {
	localctx = NewPartitionExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, StarRocksParserRULE_partitionExpr)
	p.SetState(7535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 892, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7533)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7534)
			p.FunctionCall()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDescContext is an interface to support dynamic dispatch.
type IPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	BY() antlr.TerminalNode
	RANGE() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	AllRangePartitionDesc() []IRangePartitionDescContext
	RangePartitionDesc(i int) IRangePartitionDescContext
	PrimaryExpression() IPrimaryExpressionContext
	LIST() antlr.TerminalNode
	AllListPartitionDesc() []IListPartitionDescContext
	ListPartitionDesc(i int) IListPartitionDescContext
	FunctionCall() IFunctionCallContext
	AllPartitionExpr() []IPartitionExprContext
	PartitionExpr(i int) IPartitionExprContext

	// IsPartitionDescContext differentiates from other interfaces.
	IsPartitionDescContext()
}

type PartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDescContext() *PartitionDescContext {
	var p = new(PartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionDesc
	return p
}

func InitEmptyPartitionDescContext(p *PartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionDesc
}

func (*PartitionDescContext) IsPartitionDescContext() {}

func NewPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDescContext {
	var p = new(PartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionDesc

	return p
}

func (s *PartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *PartitionDescContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *PartitionDescContext) RANGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANGE, 0)
}

func (s *PartitionDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionDescContext) AllRangePartitionDesc() []IRangePartitionDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRangePartitionDescContext); ok {
			len++
		}
	}

	tst := make([]IRangePartitionDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRangePartitionDescContext); ok {
			tst[i] = t.(IRangePartitionDescContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) RangePartitionDesc(i int) IRangePartitionDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRangePartitionDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRangePartitionDescContext)
}

func (s *PartitionDescContext) PrimaryExpression() IPrimaryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrimaryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrimaryExpressionContext)
}

func (s *PartitionDescContext) LIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIST, 0)
}

func (s *PartitionDescContext) AllListPartitionDesc() []IListPartitionDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListPartitionDescContext); ok {
			len++
		}
	}

	tst := make([]IListPartitionDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListPartitionDescContext); ok {
			tst[i] = t.(IListPartitionDescContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) ListPartitionDesc(i int) IListPartitionDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionDescContext)
}

func (s *PartitionDescContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *PartitionDescContext) AllPartitionExpr() []IPartitionExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionExprContext); ok {
			len++
		}
	}

	tst := make([]IPartitionExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionExprContext); ok {
			tst[i] = t.(IPartitionExprContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDescContext) PartitionExpr(i int) IPartitionExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionExprContext)
}

func (s *PartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionDesc(s)
	}
}

func (s *PartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionDesc(s)
	}
}

func (p *StarRocksParser) PartitionDesc() (localctx IPartitionDescContext) {
	localctx = NewPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, StarRocksParserRULE_partitionDesc)
	var _la int

	var _alt int

	p.SetState(7625)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 904, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7537)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7538)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7539)
			p.Match(StarRocksParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7540)
			p.IdentifierList()
		}
		{
			p.SetState(7541)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserSTART {
			{
				p.SetState(7542)
				p.RangePartitionDesc()
			}
			p.SetState(7547)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7543)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7544)
					p.RangePartitionDesc()
				}

				p.SetState(7549)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7552)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7554)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7555)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7556)
			p.Match(StarRocksParserRANGE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7557)
			p.primaryExpression(0)
		}
		{
			p.SetState(7558)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7567)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserSTART {
			{
				p.SetState(7559)
				p.RangePartitionDesc()
			}
			p.SetState(7564)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7560)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7561)
					p.RangePartitionDesc()
				}

				p.SetState(7566)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7569)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7571)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7572)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7574)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIST {
			{
				p.SetState(7573)
				p.Match(StarRocksParserLIST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7576)
			p.IdentifierList()
		}
		{
			p.SetState(7577)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION {
			{
				p.SetState(7578)
				p.ListPartitionDesc()
			}
			p.SetState(7583)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7579)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7580)
					p.ListPartitionDesc()
				}

				p.SetState(7585)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7588)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7590)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7591)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7593)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserLIST {
			{
				p.SetState(7592)
				p.Match(StarRocksParserLIST)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7595)
			p.IdentifierList()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7596)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7597)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7598)
			p.FunctionCall()
		}
		{
			p.SetState(7599)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserPARTITION || _la == StarRocksParserSTART {
			{
				p.SetState(7600)
				p.RangePartitionDesc()
			}
			p.SetState(7605)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == StarRocksParserT__2 {
				{
					p.SetState(7601)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7602)
					p.RangePartitionDesc()
				}

				p.SetState(7607)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(7610)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(7612)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7613)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7614)
			p.FunctionCall()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(7615)
			p.Match(StarRocksParserPARTITION)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7616)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7617)
			p.PartitionExpr()
		}
		p.SetState(7622)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 903, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(7618)
					p.Match(StarRocksParserT__2)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(7619)
					p.PartitionExpr()
				}

			}
			p.SetState(7624)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 903, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionDescContext is an interface to support dynamic dispatch.
type IListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleItemListPartitionDesc() ISingleItemListPartitionDescContext
	MultiItemListPartitionDesc() IMultiItemListPartitionDescContext

	// IsListPartitionDescContext differentiates from other interfaces.
	IsListPartitionDescContext()
}

type ListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionDescContext() *ListPartitionDescContext {
	var p = new(ListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionDesc
	return p
}

func InitEmptyListPartitionDescContext(p *ListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionDesc
}

func (*ListPartitionDescContext) IsListPartitionDescContext() {}

func NewListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionDescContext {
	var p = new(ListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_listPartitionDesc

	return p
}

func (s *ListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionDescContext) SingleItemListPartitionDesc() ISingleItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleItemListPartitionDescContext)
}

func (s *ListPartitionDescContext) MultiItemListPartitionDesc() IMultiItemListPartitionDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiItemListPartitionDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiItemListPartitionDescContext)
}

func (s *ListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterListPartitionDesc(s)
	}
}

func (s *ListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitListPartitionDesc(s)
	}
}

func (p *StarRocksParser) ListPartitionDesc() (localctx IListPartitionDescContext) {
	localctx = NewListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, StarRocksParserRULE_listPartitionDesc)
	p.SetState(7629)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 905, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7627)
			p.SingleItemListPartitionDesc()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7628)
			p.MultiItemListPartitionDesc()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleItemListPartitionDescContext is an interface to support dynamic dispatch.
type ISingleItemListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	SingleListPartitionValues() ISingleListPartitionValuesContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSingleItemListPartitionDescContext differentiates from other interfaces.
	IsSingleItemListPartitionDescContext()
}

type SingleItemListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleItemListPartitionDescContext() *SingleItemListPartitionDescContext {
	var p = new(SingleItemListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleItemListPartitionDesc
	return p
}

func InitEmptySingleItemListPartitionDescContext(p *SingleItemListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleItemListPartitionDesc
}

func (*SingleItemListPartitionDescContext) IsSingleItemListPartitionDescContext() {}

func NewSingleItemListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleItemListPartitionDescContext {
	var p = new(SingleItemListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_singleItemListPartitionDesc

	return p
}

func (s *SingleItemListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleItemListPartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *SingleItemListPartitionDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleItemListPartitionDescContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *SingleItemListPartitionDescContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *SingleItemListPartitionDescContext) SingleListPartitionValues() ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *SingleItemListPartitionDescContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *SingleItemListPartitionDescContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *SingleItemListPartitionDescContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *SingleItemListPartitionDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SingleItemListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleItemListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleItemListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleItemListPartitionDesc(s)
	}
}

func (s *SingleItemListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleItemListPartitionDesc(s)
	}
}

func (p *StarRocksParser) SingleItemListPartitionDesc() (localctx ISingleItemListPartitionDescContext) {
	localctx = NewSingleItemListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, StarRocksParserRULE_singleItemListPartitionDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7631)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7635)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(7632)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7633)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7634)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7637)
		p.Identifier()
	}
	{
		p.SetState(7638)
		p.Match(StarRocksParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7639)
		p.Match(StarRocksParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7640)
		p.SingleListPartitionValues()
	}
	p.SetState(7642)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(7641)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiItemListPartitionDescContext is an interface to support dynamic dispatch.
type IMultiItemListPartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	IN() antlr.TerminalNode
	MultiListPartitionValues() IMultiListPartitionValuesContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsMultiItemListPartitionDescContext differentiates from other interfaces.
	IsMultiItemListPartitionDescContext()
}

type MultiItemListPartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiItemListPartitionDescContext() *MultiItemListPartitionDescContext {
	var p = new(MultiItemListPartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiItemListPartitionDesc
	return p
}

func InitEmptyMultiItemListPartitionDescContext(p *MultiItemListPartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiItemListPartitionDesc
}

func (*MultiItemListPartitionDescContext) IsMultiItemListPartitionDescContext() {}

func NewMultiItemListPartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiItemListPartitionDescContext {
	var p = new(MultiItemListPartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_multiItemListPartitionDesc

	return p
}

func (s *MultiItemListPartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiItemListPartitionDescContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *MultiItemListPartitionDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiItemListPartitionDescContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *MultiItemListPartitionDescContext) IN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIN, 0)
}

func (s *MultiItemListPartitionDescContext) MultiListPartitionValues() IMultiListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiListPartitionValuesContext)
}

func (s *MultiItemListPartitionDescContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *MultiItemListPartitionDescContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *MultiItemListPartitionDescContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *MultiItemListPartitionDescContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *MultiItemListPartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiItemListPartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiItemListPartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultiItemListPartitionDesc(s)
	}
}

func (s *MultiItemListPartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultiItemListPartitionDesc(s)
	}
}

func (p *StarRocksParser) MultiItemListPartitionDesc() (localctx IMultiItemListPartitionDescContext) {
	localctx = NewMultiItemListPartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, StarRocksParserRULE_multiItemListPartitionDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7644)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(7645)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7646)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7647)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7650)
		p.Identifier()
	}
	{
		p.SetState(7651)
		p.Match(StarRocksParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7652)
		p.Match(StarRocksParserIN)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7653)
		p.MultiListPartitionValues()
	}
	p.SetState(7655)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(7654)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiListPartitionValuesContext is an interface to support dynamic dispatch.
type IMultiListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSingleListPartitionValues() []ISingleListPartitionValuesContext
	SingleListPartitionValues(i int) ISingleListPartitionValuesContext

	// IsMultiListPartitionValuesContext differentiates from other interfaces.
	IsMultiListPartitionValuesContext()
}

type MultiListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiListPartitionValuesContext() *MultiListPartitionValuesContext {
	var p = new(MultiListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiListPartitionValues
	return p
}

func InitEmptyMultiListPartitionValuesContext(p *MultiListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiListPartitionValues
}

func (*MultiListPartitionValuesContext) IsMultiListPartitionValuesContext() {}

func NewMultiListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiListPartitionValuesContext {
	var p = new(MultiListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_multiListPartitionValues

	return p
}

func (s *MultiListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiListPartitionValuesContext) AllSingleListPartitionValues() []ISingleListPartitionValuesContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			len++
		}
	}

	tst := make([]ISingleListPartitionValuesContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISingleListPartitionValuesContext); ok {
			tst[i] = t.(ISingleListPartitionValuesContext)
			i++
		}
	}

	return tst
}

func (s *MultiListPartitionValuesContext) SingleListPartitionValues(i int) ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *MultiListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultiListPartitionValues(s)
	}
}

func (s *MultiListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultiListPartitionValues(s)
	}
}

func (p *StarRocksParser) MultiListPartitionValues() (localctx IMultiListPartitionValuesContext) {
	localctx = NewMultiListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, StarRocksParserRULE_multiListPartitionValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7657)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7658)
		p.SingleListPartitionValues()
	}
	p.SetState(7663)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7659)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7660)
			p.SingleListPartitionValues()
		}

		p.SetState(7665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7666)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleListPartitionValuesContext is an interface to support dynamic dispatch.
type ISingleListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllListPartitionValue() []IListPartitionValueContext
	ListPartitionValue(i int) IListPartitionValueContext

	// IsSingleListPartitionValuesContext differentiates from other interfaces.
	IsSingleListPartitionValuesContext()
}

type SingleListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleListPartitionValuesContext() *SingleListPartitionValuesContext {
	var p = new(SingleListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleListPartitionValues
	return p
}

func InitEmptySingleListPartitionValuesContext(p *SingleListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleListPartitionValues
}

func (*SingleListPartitionValuesContext) IsSingleListPartitionValuesContext() {}

func NewSingleListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleListPartitionValuesContext {
	var p = new(SingleListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_singleListPartitionValues

	return p
}

func (s *SingleListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleListPartitionValuesContext) AllListPartitionValue() []IListPartitionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IListPartitionValueContext); ok {
			len++
		}
	}

	tst := make([]IListPartitionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IListPartitionValueContext); ok {
			tst[i] = t.(IListPartitionValueContext)
			i++
		}
	}

	return tst
}

func (s *SingleListPartitionValuesContext) ListPartitionValue(i int) IListPartitionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListPartitionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListPartitionValueContext)
}

func (s *SingleListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleListPartitionValues(s)
	}
}

func (s *SingleListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleListPartitionValues(s)
	}
}

func (p *StarRocksParser) SingleListPartitionValues() (localctx ISingleListPartitionValuesContext) {
	localctx = NewSingleListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, StarRocksParserRULE_singleListPartitionValues)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7668)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7669)
		p.ListPartitionValue()
	}
	p.SetState(7674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7670)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7671)
			p.ListPartitionValue()
		}

		p.SetState(7676)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7677)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionValuesContext is an interface to support dynamic dispatch.
type IListPartitionValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleListPartitionValues() ISingleListPartitionValuesContext
	MultiListPartitionValues() IMultiListPartitionValuesContext

	// IsListPartitionValuesContext differentiates from other interfaces.
	IsListPartitionValuesContext()
}

type ListPartitionValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionValuesContext() *ListPartitionValuesContext {
	var p = new(ListPartitionValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionValues
	return p
}

func InitEmptyListPartitionValuesContext(p *ListPartitionValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionValues
}

func (*ListPartitionValuesContext) IsListPartitionValuesContext() {}

func NewListPartitionValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionValuesContext {
	var p = new(ListPartitionValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_listPartitionValues

	return p
}

func (s *ListPartitionValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionValuesContext) SingleListPartitionValues() ISingleListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleListPartitionValuesContext)
}

func (s *ListPartitionValuesContext) MultiListPartitionValues() IMultiListPartitionValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiListPartitionValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiListPartitionValuesContext)
}

func (s *ListPartitionValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterListPartitionValues(s)
	}
}

func (s *ListPartitionValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitListPartitionValues(s)
	}
}

func (p *StarRocksParser) ListPartitionValues() (localctx IListPartitionValuesContext) {
	localctx = NewListPartitionValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, StarRocksParserRULE_listPartitionValues)
	p.SetState(7681)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 912, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7679)
			p.SingleListPartitionValues()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7680)
			p.MultiListPartitionValues()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IListPartitionValueContext is an interface to support dynamic dispatch.
type IListPartitionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL() antlr.TerminalNode
	String_() IStringContext

	// IsListPartitionValueContext differentiates from other interfaces.
	IsListPartitionValueContext()
}

type ListPartitionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListPartitionValueContext() *ListPartitionValueContext {
	var p = new(ListPartitionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionValue
	return p
}

func InitEmptyListPartitionValueContext(p *ListPartitionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_listPartitionValue
}

func (*ListPartitionValueContext) IsListPartitionValueContext() {}

func NewListPartitionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListPartitionValueContext {
	var p = new(ListPartitionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_listPartitionValue

	return p
}

func (s *ListPartitionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ListPartitionValueContext) NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULL, 0)
}

func (s *ListPartitionValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *ListPartitionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListPartitionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ListPartitionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterListPartitionValue(s)
	}
}

func (s *ListPartitionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitListPartitionValue(s)
	}
}

func (p *StarRocksParser) ListPartitionValue() (localctx IListPartitionValueContext) {
	localctx = NewListPartitionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, StarRocksParserRULE_listPartitionValue)
	p.SetState(7685)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserNULL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7683)
			p.Match(StarRocksParserNULL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7684)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringListContext is an interface to support dynamic dispatch.
type IStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsStringListContext differentiates from other interfaces.
	IsStringListContext()
}

type StringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListContext() *StringListContext {
	var p = new(StringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_stringList
	return p
}

func InitEmptyStringListContext(p *StringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_stringList
}

func (*StringListContext) IsStringListContext() {}

func NewStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListContext {
	var p = new(StringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_stringList

	return p
}

func (s *StringListContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *StringListContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *StringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStringList(s)
	}
}

func (s *StringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStringList(s)
	}
}

func (p *StarRocksParser) StringList() (localctx IStringListContext) {
	localctx = NewStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, StarRocksParserRULE_stringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7687)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7688)
		p.String_()
	}
	p.SetState(7693)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7689)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7690)
			p.String_()
		}

		p.SetState(7695)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7696)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntegerListContext is an interface to support dynamic dispatch.
type IIntegerListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsIntegerListContext differentiates from other interfaces.
	IsIntegerListContext()
}

type IntegerListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerListContext() *IntegerListContext {
	var p = new(IntegerListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_integerList
	return p
}

func InitEmptyIntegerListContext(p *IntegerListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_integerList
}

func (*IntegerListContext) IsIntegerListContext() {}

func NewIntegerListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerListContext {
	var p = new(IntegerListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_integerList

	return p
}

func (s *IntegerListContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerListContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *IntegerListContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *IntegerListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIntegerList(s)
	}
}

func (s *IntegerListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIntegerList(s)
	}
}

func (p *StarRocksParser) IntegerList() (localctx IIntegerListContext) {
	localctx = NewIntegerListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, StarRocksParserRULE_integerList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7698)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7699)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7704)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7700)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7701)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

		p.SetState(7706)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7707)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralExpressionListContext is an interface to support dynamic dispatch.
type ILiteralExpressionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLiteralExpression() []ILiteralExpressionContext
	LiteralExpression(i int) ILiteralExpressionContext

	// IsLiteralExpressionListContext differentiates from other interfaces.
	IsLiteralExpressionListContext()
}

type LiteralExpressionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralExpressionListContext() *LiteralExpressionListContext {
	var p = new(LiteralExpressionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_literalExpressionList
	return p
}

func InitEmptyLiteralExpressionListContext(p *LiteralExpressionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_literalExpressionList
}

func (*LiteralExpressionListContext) IsLiteralExpressionListContext() {}

func NewLiteralExpressionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralExpressionListContext {
	var p = new(LiteralExpressionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_literalExpressionList

	return p
}

func (s *LiteralExpressionListContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralExpressionListContext) AllLiteralExpression() []ILiteralExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			len++
		}
	}

	tst := make([]ILiteralExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralExpressionContext); ok {
			tst[i] = t.(ILiteralExpressionContext)
			i++
		}
	}

	return tst
}

func (s *LiteralExpressionListContext) LiteralExpression(i int) ILiteralExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *LiteralExpressionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralExpressionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralExpressionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterLiteralExpressionList(s)
	}
}

func (s *LiteralExpressionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitLiteralExpressionList(s)
	}
}

func (p *StarRocksParser) LiteralExpressionList() (localctx ILiteralExpressionListContext) {
	localctx = NewLiteralExpressionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, StarRocksParserRULE_literalExpressionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7709)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7710)
		p.LiteralExpression()
	}
	p.SetState(7715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7711)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7712)
			p.LiteralExpression()
		}

		p.SetState(7717)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7718)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRangePartitionDescContext is an interface to support dynamic dispatch.
type IRangePartitionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleRangePartition() ISingleRangePartitionContext
	MultiRangePartition() IMultiRangePartitionContext

	// IsRangePartitionDescContext differentiates from other interfaces.
	IsRangePartitionDescContext()
}

type RangePartitionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRangePartitionDescContext() *RangePartitionDescContext {
	var p = new(RangePartitionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rangePartitionDesc
	return p
}

func InitEmptyRangePartitionDescContext(p *RangePartitionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_rangePartitionDesc
}

func (*RangePartitionDescContext) IsRangePartitionDescContext() {}

func NewRangePartitionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RangePartitionDescContext {
	var p = new(RangePartitionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_rangePartitionDesc

	return p
}

func (s *RangePartitionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RangePartitionDescContext) SingleRangePartition() ISingleRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleRangePartitionContext)
}

func (s *RangePartitionDescContext) MultiRangePartition() IMultiRangePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiRangePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiRangePartitionContext)
}

func (s *RangePartitionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RangePartitionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RangePartitionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRangePartitionDesc(s)
	}
}

func (s *RangePartitionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRangePartitionDesc(s)
	}
}

func (p *StarRocksParser) RangePartitionDesc() (localctx IRangePartitionDescContext) {
	localctx = NewRangePartitionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, StarRocksParserRULE_rangePartitionDesc)
	p.SetState(7722)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserPARTITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7720)
			p.SingleRangePartition()
		}

	case StarRocksParserSTART:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7721)
			p.MultiRangePartition()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleRangePartitionContext is an interface to support dynamic dispatch.
type ISingleRangePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES() antlr.TerminalNode
	PartitionKeyDesc() IPartitionKeyDescContext
	IF() antlr.TerminalNode
	NOT() antlr.TerminalNode
	EXISTS() antlr.TerminalNode
	PropertyList() IPropertyListContext

	// IsSingleRangePartitionContext differentiates from other interfaces.
	IsSingleRangePartitionContext()
}

type SingleRangePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleRangePartitionContext() *SingleRangePartitionContext {
	var p = new(SingleRangePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleRangePartition
	return p
}

func InitEmptySingleRangePartitionContext(p *SingleRangePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_singleRangePartition
}

func (*SingleRangePartitionContext) IsSingleRangePartitionContext() {}

func NewSingleRangePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleRangePartitionContext {
	var p = new(SingleRangePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_singleRangePartition

	return p
}

func (s *SingleRangePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleRangePartitionContext) PARTITION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITION, 0)
}

func (s *SingleRangePartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SingleRangePartitionContext) VALUES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUES, 0)
}

func (s *SingleRangePartitionContext) PartitionKeyDesc() IPartitionKeyDescContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyDescContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyDescContext)
}

func (s *SingleRangePartitionContext) IF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIF, 0)
}

func (s *SingleRangePartitionContext) NOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNOT, 0)
}

func (s *SingleRangePartitionContext) EXISTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXISTS, 0)
}

func (s *SingleRangePartitionContext) PropertyList() IPropertyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyListContext)
}

func (s *SingleRangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleRangePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleRangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSingleRangePartition(s)
	}
}

func (s *SingleRangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSingleRangePartition(s)
	}
}

func (p *StarRocksParser) SingleRangePartition() (localctx ISingleRangePartitionContext) {
	localctx = NewSingleRangePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, StarRocksParserRULE_singleRangePartition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7724)
		p.Match(StarRocksParserPARTITION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7728)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserIF {
		{
			p.SetState(7725)
			p.Match(StarRocksParserIF)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7726)
			p.Match(StarRocksParserNOT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7727)
			p.Match(StarRocksParserEXISTS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(7730)
		p.Identifier()
	}
	{
		p.SetState(7731)
		p.Match(StarRocksParserVALUES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7732)
		p.PartitionKeyDesc()
	}
	p.SetState(7734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(7733)
			p.PropertyList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMultiRangePartitionContext is an interface to support dynamic dispatch.
type IMultiRangePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	END() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	Interval() IIntervalContext
	INTEGER_VALUE() antlr.TerminalNode

	// IsMultiRangePartitionContext differentiates from other interfaces.
	IsMultiRangePartitionContext()
}

type MultiRangePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiRangePartitionContext() *MultiRangePartitionContext {
	var p = new(MultiRangePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiRangePartition
	return p
}

func InitEmptyMultiRangePartitionContext(p *MultiRangePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_multiRangePartition
}

func (*MultiRangePartitionContext) IsMultiRangePartitionContext() {}

func NewMultiRangePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiRangePartitionContext {
	var p = new(MultiRangePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_multiRangePartition

	return p
}

func (s *MultiRangePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiRangePartitionContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *MultiRangePartitionContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *MultiRangePartitionContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *MultiRangePartitionContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *MultiRangePartitionContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVERY, 0)
}

func (s *MultiRangePartitionContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *MultiRangePartitionContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *MultiRangePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiRangePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiRangePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMultiRangePartition(s)
	}
}

func (s *MultiRangePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMultiRangePartition(s)
	}
}

func (p *StarRocksParser) MultiRangePartition() (localctx IMultiRangePartitionContext) {
	localctx = NewMultiRangePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, StarRocksParserRULE_multiRangePartition)
	p.SetState(7762)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 920, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7736)
			p.Match(StarRocksParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7737)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7738)
			p.String_()
		}
		{
			p.SetState(7739)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7740)
			p.Match(StarRocksParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7741)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7742)
			p.String_()
		}
		{
			p.SetState(7743)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7744)
			p.Match(StarRocksParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7745)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7746)
			p.Interval()
		}
		{
			p.SetState(7747)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7749)
			p.Match(StarRocksParserSTART)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7750)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7751)
			p.String_()
		}
		{
			p.SetState(7752)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7753)
			p.Match(StarRocksParserEND)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7754)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7755)
			p.String_()
		}
		{
			p.SetState(7756)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7757)
			p.Match(StarRocksParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7758)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7759)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7760)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionRangeDescContext is an interface to support dynamic dispatch.
type IPartitionRangeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext
	END() antlr.TerminalNode

	// IsPartitionRangeDescContext differentiates from other interfaces.
	IsPartitionRangeDescContext()
}

type PartitionRangeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionRangeDescContext() *PartitionRangeDescContext {
	var p = new(PartitionRangeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionRangeDesc
	return p
}

func InitEmptyPartitionRangeDescContext(p *PartitionRangeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionRangeDesc
}

func (*PartitionRangeDescContext) IsPartitionRangeDescContext() {}

func NewPartitionRangeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionRangeDescContext {
	var p = new(PartitionRangeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionRangeDesc

	return p
}

func (s *PartitionRangeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionRangeDescContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *PartitionRangeDescContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *PartitionRangeDescContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PartitionRangeDescContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *PartitionRangeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionRangeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionRangeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionRangeDesc(s)
	}
}

func (s *PartitionRangeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionRangeDesc(s)
	}
}

func (p *StarRocksParser) PartitionRangeDesc() (localctx IPartitionRangeDescContext) {
	localctx = NewPartitionRangeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, StarRocksParserRULE_partitionRangeDesc)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7764)
		p.Match(StarRocksParserSTART)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7765)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7766)
		p.String_()
	}
	{
		p.SetState(7767)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7768)
		p.Match(StarRocksParserEND)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7769)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7770)
		p.String_()
	}
	{
		p.SetState(7771)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyDescContext is an interface to support dynamic dispatch.
type IPartitionKeyDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LESS() antlr.TerminalNode
	THAN() antlr.TerminalNode
	MAXVALUE() antlr.TerminalNode
	AllPartitionValueList() []IPartitionValueListContext
	PartitionValueList(i int) IPartitionValueListContext

	// IsPartitionKeyDescContext differentiates from other interfaces.
	IsPartitionKeyDescContext()
}

type PartitionKeyDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyDescContext() *PartitionKeyDescContext {
	var p = new(PartitionKeyDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionKeyDesc
	return p
}

func InitEmptyPartitionKeyDescContext(p *PartitionKeyDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionKeyDesc
}

func (*PartitionKeyDescContext) IsPartitionKeyDescContext() {}

func NewPartitionKeyDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyDescContext {
	var p = new(PartitionKeyDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionKeyDesc

	return p
}

func (s *PartitionKeyDescContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyDescContext) LESS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLESS, 0)
}

func (s *PartitionKeyDescContext) THAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTHAN, 0)
}

func (s *PartitionKeyDescContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAXVALUE, 0)
}

func (s *PartitionKeyDescContext) AllPartitionValueList() []IPartitionValueListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueListContext); ok {
			tst[i] = t.(IPartitionValueListContext)
			i++
		}
	}

	return tst
}

func (s *PartitionKeyDescContext) PartitionValueList(i int) IPartitionValueListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueListContext)
}

func (s *PartitionKeyDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionKeyDesc(s)
	}
}

func (s *PartitionKeyDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionKeyDesc(s)
	}
}

func (p *StarRocksParser) PartitionKeyDesc() (localctx IPartitionKeyDescContext) {
	localctx = NewPartitionKeyDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, StarRocksParserRULE_partitionKeyDesc)
	p.SetState(7785)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLESS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7773)
			p.Match(StarRocksParserLESS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7774)
			p.Match(StarRocksParserTHAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7777)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case StarRocksParserMAXVALUE:
			{
				p.SetState(7775)
				p.Match(StarRocksParserMAXVALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case StarRocksParserT__1:
			{
				p.SetState(7776)
				p.PartitionValueList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case StarRocksParserT__5:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7779)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7780)
			p.PartitionValueList()
		}
		{
			p.SetState(7781)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7782)
			p.PartitionValueList()
		}
		{
			p.SetState(7783)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueListContext is an interface to support dynamic dispatch.
type IPartitionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPartitionValue() []IPartitionValueContext
	PartitionValue(i int) IPartitionValueContext

	// IsPartitionValueListContext differentiates from other interfaces.
	IsPartitionValueListContext()
}

type PartitionValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueListContext() *PartitionValueListContext {
	var p = new(PartitionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionValueList
	return p
}

func InitEmptyPartitionValueListContext(p *PartitionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionValueList
}

func (*PartitionValueListContext) IsPartitionValueListContext() {}

func NewPartitionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueListContext {
	var p = new(PartitionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionValueList

	return p
}

func (s *PartitionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueListContext) AllPartitionValue() []IPartitionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueContext); ok {
			tst[i] = t.(IPartitionValueContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueListContext) PartitionValue(i int) IPartitionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueContext)
}

func (s *PartitionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionValueList(s)
	}
}

func (s *PartitionValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionValueList(s)
	}
}

func (p *StarRocksParser) PartitionValueList() (localctx IPartitionValueListContext) {
	localctx = NewPartitionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, StarRocksParserRULE_partitionValueList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7787)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7788)
		p.PartitionValue()
	}
	p.SetState(7793)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7789)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7790)
			p.PartitionValue()
		}

		p.SetState(7795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7796)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartitionContext is an interface to support dynamic dispatch.
type IKeyPartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPartitionColName returns the partitionColName rule contexts.
	GetPartitionColName() IIdentifierContext

	// GetPartitionColValue returns the partitionColValue rule contexts.
	GetPartitionColValue() ILiteralExpressionContext

	// SetPartitionColName sets the partitionColName rule contexts.
	SetPartitionColName(IIdentifierContext)

	// SetPartitionColValue sets the partitionColValue rule contexts.
	SetPartitionColValue(ILiteralExpressionContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext
	LiteralExpression() ILiteralExpressionContext

	// IsKeyPartitionContext differentiates from other interfaces.
	IsKeyPartitionContext()
}

type KeyPartitionContext struct {
	antlr.BaseParserRuleContext
	parser            antlr.Parser
	partitionColName  IIdentifierContext
	partitionColValue ILiteralExpressionContext
}

func NewEmptyKeyPartitionContext() *KeyPartitionContext {
	var p = new(KeyPartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyPartition
	return p
}

func InitEmptyKeyPartitionContext(p *KeyPartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_keyPartition
}

func (*KeyPartitionContext) IsKeyPartitionContext() {}

func NewKeyPartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartitionContext {
	var p = new(KeyPartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_keyPartition

	return p
}

func (s *KeyPartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartitionContext) GetPartitionColName() IIdentifierContext { return s.partitionColName }

func (s *KeyPartitionContext) GetPartitionColValue() ILiteralExpressionContext {
	return s.partitionColValue
}

func (s *KeyPartitionContext) SetPartitionColName(v IIdentifierContext) { s.partitionColName = v }

func (s *KeyPartitionContext) SetPartitionColValue(v ILiteralExpressionContext) {
	s.partitionColValue = v
}

func (s *KeyPartitionContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *KeyPartitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyPartitionContext) LiteralExpression() ILiteralExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralExpressionContext)
}

func (s *KeyPartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterKeyPartition(s)
	}
}

func (s *KeyPartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitKeyPartition(s)
	}
}

func (p *StarRocksParser) KeyPartition() (localctx IKeyPartitionContext) {
	localctx = NewKeyPartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, StarRocksParserRULE_keyPartition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7798)

		var _x = p.Identifier()

		localctx.(*KeyPartitionContext).partitionColName = _x
	}
	{
		p.SetState(7799)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7800)

		var _x = p.LiteralExpression()

		localctx.(*KeyPartitionContext).partitionColValue = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueContext is an interface to support dynamic dispatch.
type IPartitionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAXVALUE() antlr.TerminalNode
	String_() IStringContext

	// IsPartitionValueContext differentiates from other interfaces.
	IsPartitionValueContext()
}

type PartitionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueContext() *PartitionValueContext {
	var p = new(PartitionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionValue
	return p
}

func InitEmptyPartitionValueContext(p *PartitionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_partitionValue
}

func (*PartitionValueContext) IsPartitionValueContext() {}

func NewPartitionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueContext {
	var p = new(PartitionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_partitionValue

	return p
}

func (s *PartitionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueContext) MAXVALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAXVALUE, 0)
}

func (s *PartitionValueContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PartitionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPartitionValue(s)
	}
}

func (s *PartitionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPartitionValue(s)
	}
}

func (p *StarRocksParser) PartitionValue() (localctx IPartitionValueContext) {
	localctx = NewPartitionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, StarRocksParserRULE_partitionValue)
	p.SetState(7804)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserMAXVALUE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7802)
			p.Match(StarRocksParserMAXVALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7803)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributionClauseContext is an interface to support dynamic dispatch.
type IDistributionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	BUCKETS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsDistributionClauseContext differentiates from other interfaces.
	IsDistributionClauseContext()
}

type DistributionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributionClauseContext() *DistributionClauseContext {
	var p = new(DistributionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_distributionClause
	return p
}

func InitEmptyDistributionClauseContext(p *DistributionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_distributionClause
}

func (*DistributionClauseContext) IsDistributionClauseContext() {}

func NewDistributionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributionClauseContext {
	var p = new(DistributionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_distributionClause

	return p
}

func (s *DistributionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributionClauseContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTED, 0)
}

func (s *DistributionClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *DistributionClauseContext) HASH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHASH, 0)
}

func (s *DistributionClauseContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DistributionClauseContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUCKETS, 0)
}

func (s *DistributionClauseContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DistributionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDistributionClause(s)
	}
}

func (s *DistributionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDistributionClause(s)
	}
}

func (p *StarRocksParser) DistributionClause() (localctx IDistributionClauseContext) {
	localctx = NewDistributionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, StarRocksParserRULE_distributionClause)
	var _la int

	p.SetState(7818)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 926, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7806)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7807)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7808)
			p.Match(StarRocksParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7809)
			p.IdentifierList()
		}
		p.SetState(7812)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserBUCKETS {
			{
				p.SetState(7810)
				p.Match(StarRocksParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7811)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7814)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7815)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7816)
			p.Match(StarRocksParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7817)
			p.IdentifierList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDistributionDescContext is an interface to support dynamic dispatch.
type IDistributionDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	BUCKETS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode
	RANDOM() antlr.TerminalNode

	// IsDistributionDescContext differentiates from other interfaces.
	IsDistributionDescContext()
}

type DistributionDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDistributionDescContext() *DistributionDescContext {
	var p = new(DistributionDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_distributionDesc
	return p
}

func InitEmptyDistributionDescContext(p *DistributionDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_distributionDesc
}

func (*DistributionDescContext) IsDistributionDescContext() {}

func NewDistributionDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DistributionDescContext {
	var p = new(DistributionDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_distributionDesc

	return p
}

func (s *DistributionDescContext) GetParser() antlr.Parser { return s.parser }

func (s *DistributionDescContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTED, 0)
}

func (s *DistributionDescContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *DistributionDescContext) HASH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHASH, 0)
}

func (s *DistributionDescContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *DistributionDescContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUCKETS, 0)
}

func (s *DistributionDescContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *DistributionDescContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANDOM, 0)
}

func (s *DistributionDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DistributionDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DistributionDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDistributionDesc(s)
	}
}

func (s *DistributionDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDistributionDesc(s)
	}
}

func (p *StarRocksParser) DistributionDesc() (localctx IDistributionDescContext) {
	localctx = NewDistributionDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, StarRocksParserRULE_distributionDesc)
	var _la int

	p.SetState(7839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 929, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7820)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7821)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7822)
			p.Match(StarRocksParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7823)
			p.IdentifierList()
		}
		p.SetState(7826)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserBUCKETS {
			{
				p.SetState(7824)
				p.Match(StarRocksParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7825)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7828)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7829)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7830)
			p.Match(StarRocksParserHASH)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7831)
			p.IdentifierList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7832)
			p.Match(StarRocksParserDISTRIBUTED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7833)
			p.Match(StarRocksParserBY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7834)
			p.Match(StarRocksParserRANDOM)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7837)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserBUCKETS {
			{
				p.SetState(7835)
				p.Match(StarRocksParserBUCKETS)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7836)
				p.Match(StarRocksParserINTEGER_VALUE)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterModifyDefaultBucketsContext is an interface to support dynamic dispatch.
type IAlterModifyDefaultBucketsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTRIBUTED() antlr.TerminalNode
	BY() antlr.TerminalNode
	HASH() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	DEFAULT() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	INTEGER_VALUE() antlr.TerminalNode

	// IsAlterModifyDefaultBucketsContext differentiates from other interfaces.
	IsAlterModifyDefaultBucketsContext()
}

type AlterModifyDefaultBucketsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterModifyDefaultBucketsContext() *AlterModifyDefaultBucketsContext {
	var p = new(AlterModifyDefaultBucketsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterModifyDefaultBuckets
	return p
}

func InitEmptyAlterModifyDefaultBucketsContext(p *AlterModifyDefaultBucketsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_alterModifyDefaultBuckets
}

func (*AlterModifyDefaultBucketsContext) IsAlterModifyDefaultBucketsContext() {}

func NewAlterModifyDefaultBucketsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterModifyDefaultBucketsContext {
	var p = new(AlterModifyDefaultBucketsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_alterModifyDefaultBuckets

	return p
}

func (s *AlterModifyDefaultBucketsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterModifyDefaultBucketsContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTED, 0)
}

func (s *AlterModifyDefaultBucketsContext) BY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBY, 0)
}

func (s *AlterModifyDefaultBucketsContext) HASH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHASH, 0)
}

func (s *AlterModifyDefaultBucketsContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *AlterModifyDefaultBucketsContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFAULT, 0)
}

func (s *AlterModifyDefaultBucketsContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUCKETS, 0)
}

func (s *AlterModifyDefaultBucketsContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *AlterModifyDefaultBucketsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterModifyDefaultBucketsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterModifyDefaultBucketsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAlterModifyDefaultBuckets(s)
	}
}

func (s *AlterModifyDefaultBucketsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAlterModifyDefaultBuckets(s)
	}
}

func (p *StarRocksParser) AlterModifyDefaultBuckets() (localctx IAlterModifyDefaultBucketsContext) {
	localctx = NewAlterModifyDefaultBucketsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, StarRocksParserRULE_alterModifyDefaultBuckets)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7841)
		p.Match(StarRocksParserDISTRIBUTED)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7842)
		p.Match(StarRocksParserBY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7843)
		p.Match(StarRocksParserHASH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7844)
		p.IdentifierList()
	}
	{
		p.SetState(7845)
		p.Match(StarRocksParserDEFAULT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7846)
		p.Match(StarRocksParserBUCKETS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7847)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRefreshSchemeDescContext is an interface to support dynamic dispatch.
type IRefreshSchemeDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REFRESH() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	Interval() IIntervalContext
	INCREMENTAL() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	IMMEDIATE() antlr.TerminalNode
	DEFERRED() antlr.TerminalNode
	START() antlr.TerminalNode
	String_() IStringContext

	// IsRefreshSchemeDescContext differentiates from other interfaces.
	IsRefreshSchemeDescContext()
}

type RefreshSchemeDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRefreshSchemeDescContext() *RefreshSchemeDescContext {
	var p = new(RefreshSchemeDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshSchemeDesc
	return p
}

func InitEmptyRefreshSchemeDescContext(p *RefreshSchemeDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_refreshSchemeDesc
}

func (*RefreshSchemeDescContext) IsRefreshSchemeDescContext() {}

func NewRefreshSchemeDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RefreshSchemeDescContext {
	var p = new(RefreshSchemeDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_refreshSchemeDesc

	return p
}

func (s *RefreshSchemeDescContext) GetParser() antlr.Parser { return s.parser }

func (s *RefreshSchemeDescContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *RefreshSchemeDescContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *RefreshSchemeDescContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVERY, 0)
}

func (s *RefreshSchemeDescContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *RefreshSchemeDescContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINCREMENTAL, 0)
}

func (s *RefreshSchemeDescContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMANUAL, 0)
}

func (s *RefreshSchemeDescContext) IMMEDIATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMMEDIATE, 0)
}

func (s *RefreshSchemeDescContext) DEFERRED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEFERRED, 0)
}

func (s *RefreshSchemeDescContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *RefreshSchemeDescContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *RefreshSchemeDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RefreshSchemeDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RefreshSchemeDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterRefreshSchemeDesc(s)
	}
}

func (s *RefreshSchemeDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitRefreshSchemeDesc(s)
	}
}

func (p *StarRocksParser) RefreshSchemeDesc() (localctx IRefreshSchemeDescContext) {
	localctx = NewRefreshSchemeDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, StarRocksParserRULE_refreshSchemeDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7849)
		p.Match(StarRocksParserREFRESH)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7851)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserDEFERRED || _la == StarRocksParserIMMEDIATE {
		{
			p.SetState(7850)
			_la = p.GetTokenStream().LA(1)

			if !(_la == StarRocksParserDEFERRED || _la == StarRocksParserIMMEDIATE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(7869)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 932, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7853)
			p.Match(StarRocksParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(7854)
			p.Match(StarRocksParserASYNC)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(7860)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserSTART {
			{
				p.SetState(7855)
				p.Match(StarRocksParserSTART)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7856)
				p.Match(StarRocksParserT__1)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(7857)
				p.String_()
			}
			{
				p.SetState(7858)
				p.Match(StarRocksParserT__3)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(7862)
			p.Match(StarRocksParserEVERY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7863)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7864)
			p.Interval()
		}
		{
			p.SetState(7865)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		{
			p.SetState(7867)
			p.Match(StarRocksParserINCREMENTAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		{
			p.SetState(7868)
			p.Match(StarRocksParserMANUAL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStatusDescContext is an interface to support dynamic dispatch.
type IStatusDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTIVE() antlr.TerminalNode
	INACTIVE() antlr.TerminalNode

	// IsStatusDescContext differentiates from other interfaces.
	IsStatusDescContext()
}

type StatusDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatusDescContext() *StatusDescContext {
	var p = new(StatusDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_statusDesc
	return p
}

func InitEmptyStatusDescContext(p *StatusDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_statusDesc
}

func (*StatusDescContext) IsStatusDescContext() {}

func NewStatusDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatusDescContext {
	var p = new(StatusDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_statusDesc

	return p
}

func (s *StatusDescContext) GetParser() antlr.Parser { return s.parser }

func (s *StatusDescContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserACTIVE, 0)
}

func (s *StatusDescContext) INACTIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINACTIVE, 0)
}

func (s *StatusDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatusDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatusDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStatusDesc(s)
	}
}

func (s *StatusDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStatusDesc(s)
	}
}

func (p *StarRocksParser) StatusDesc() (localctx IStatusDescContext) {
	localctx = NewStatusDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, StarRocksParserRULE_statusDesc)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7871)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserACTIVE || _la == StarRocksParserINACTIVE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertiesContext is an interface to support dynamic dispatch.
type IPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROPERTIES() antlr.TerminalNode
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsPropertiesContext differentiates from other interfaces.
	IsPropertiesContext()
}

type PropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertiesContext() *PropertiesContext {
	var p = new(PropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_properties
	return p
}

func InitEmptyPropertiesContext(p *PropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_properties
}

func (*PropertiesContext) IsPropertiesContext() {}

func NewPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertiesContext {
	var p = new(PropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_properties

	return p
}

func (s *PropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertiesContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *PropertiesContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertiesContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterProperties(s)
	}
}

func (s *PropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitProperties(s)
	}
}

func (p *StarRocksParser) Properties() (localctx IPropertiesContext) {
	localctx = NewPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, StarRocksParserRULE_properties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7873)
		p.Match(StarRocksParserPROPERTIES)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7874)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7875)
		p.Property()
	}
	p.SetState(7880)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7876)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7877)
			p.Property()
		}

		p.SetState(7882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7883)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExtPropertiesContext is an interface to support dynamic dispatch.
type IExtPropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BROKER() antlr.TerminalNode
	Properties() IPropertiesContext

	// IsExtPropertiesContext differentiates from other interfaces.
	IsExtPropertiesContext()
}

type ExtPropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExtPropertiesContext() *ExtPropertiesContext {
	var p = new(ExtPropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_extProperties
	return p
}

func InitEmptyExtPropertiesContext(p *ExtPropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_extProperties
}

func (*ExtPropertiesContext) IsExtPropertiesContext() {}

func NewExtPropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExtPropertiesContext {
	var p = new(ExtPropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_extProperties

	return p
}

func (s *ExtPropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExtPropertiesContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *ExtPropertiesContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *ExtPropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExtPropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExtPropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterExtProperties(s)
	}
}

func (s *ExtPropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitExtProperties(s)
	}
}

func (p *StarRocksParser) ExtProperties() (localctx IExtPropertiesContext) {
	localctx = NewExtPropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, StarRocksParserRULE_extProperties)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7885)
		p.Match(StarRocksParserBROKER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7886)
		p.Properties()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyListContext is an interface to support dynamic dispatch.
type IPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsPropertyListContext differentiates from other interfaces.
	IsPropertyListContext()
}

type PropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPropertyListContext() *PropertyListContext {
	var p = new(PropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_propertyList
	return p
}

func InitEmptyPropertyListContext(p *PropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_propertyList
}

func (*PropertyListContext) IsPropertyListContext() {}

func NewPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyListContext {
	var p = new(PropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_propertyList

	return p
}

func (s *PropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *PropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *PropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterPropertyList(s)
	}
}

func (s *PropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitPropertyList(s)
	}
}

func (p *StarRocksParser) PropertyList() (localctx IPropertyListContext) {
	localctx = NewPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, StarRocksParserRULE_propertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7888)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7889)
		p.Property()
	}
	p.SetState(7894)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7890)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7891)
			p.Property()
		}

		p.SetState(7896)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(7897)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserPropertyListContext is an interface to support dynamic dispatch.
type IUserPropertyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllProperty() []IPropertyContext
	Property(i int) IPropertyContext

	// IsUserPropertyListContext differentiates from other interfaces.
	IsUserPropertyListContext()
}

type UserPropertyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserPropertyListContext() *UserPropertyListContext {
	var p = new(UserPropertyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_userPropertyList
	return p
}

func InitEmptyUserPropertyListContext(p *UserPropertyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_userPropertyList
}

func (*UserPropertyListContext) IsUserPropertyListContext() {}

func NewUserPropertyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserPropertyListContext {
	var p = new(UserPropertyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_userPropertyList

	return p
}

func (s *UserPropertyListContext) GetParser() antlr.Parser { return s.parser }

func (s *UserPropertyListContext) AllProperty() []IPropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPropertyContext); ok {
			len++
		}
	}

	tst := make([]IPropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPropertyContext); ok {
			tst[i] = t.(IPropertyContext)
			i++
		}
	}

	return tst
}

func (s *UserPropertyListContext) Property(i int) IPropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertyContext)
}

func (s *UserPropertyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserPropertyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserPropertyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserPropertyList(s)
	}
}

func (s *UserPropertyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserPropertyList(s)
	}
}

func (p *StarRocksParser) UserPropertyList() (localctx IUserPropertyListContext) {
	localctx = NewUserPropertyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, StarRocksParserRULE_userPropertyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7899)
		p.Property()
	}
	p.SetState(7904)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7900)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7901)
			p.Property()
		}

		p.SetState(7906)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPropertyContext is an interface to support dynamic dispatch.
type IPropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IStringContext

	// GetValue returns the value rule contexts.
	GetValue() IStringContext

	// SetKey sets the key rule contexts.
	SetKey(IStringContext)

	// SetValue sets the value rule contexts.
	SetValue(IStringContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	AllString_() []IStringContext
	String_(i int) IStringContext

	// IsPropertyContext differentiates from other interfaces.
	IsPropertyContext()
}

type PropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IStringContext
	value  IStringContext
}

func NewEmptyPropertyContext() *PropertyContext {
	var p = new(PropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_property
	return p
}

func InitEmptyPropertyContext(p *PropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_property
}

func (*PropertyContext) IsPropertyContext() {}

func NewPropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PropertyContext {
	var p = new(PropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_property

	return p
}

func (s *PropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *PropertyContext) GetKey() IStringContext { return s.key }

func (s *PropertyContext) GetValue() IStringContext { return s.value }

func (s *PropertyContext) SetKey(v IStringContext) { s.key = v }

func (s *PropertyContext) SetValue(v IStringContext) { s.value = v }

func (s *PropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *PropertyContext) AllString_() []IStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringContext); ok {
			len++
		}
	}

	tst := make([]IStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringContext); ok {
			tst[i] = t.(IStringContext)
			i++
		}
	}

	return tst
}

func (s *PropertyContext) String_(i int) IStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *PropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterProperty(s)
	}
}

func (s *PropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitProperty(s)
	}
}

func (p *StarRocksParser) Property() (localctx IPropertyContext) {
	localctx = NewPropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, StarRocksParserRULE_property)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7907)

		var _x = p.String_()

		localctx.(*PropertyContext).key = _x
	}
	{
		p.SetState(7908)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7909)

		var _x = p.String_()

		localctx.(*PropertyContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlinePropertiesContext is an interface to support dynamic dispatch.
type IInlinePropertiesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllInlineProperty() []IInlinePropertyContext
	InlineProperty(i int) IInlinePropertyContext

	// IsInlinePropertiesContext differentiates from other interfaces.
	IsInlinePropertiesContext()
}

type InlinePropertiesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInlinePropertiesContext() *InlinePropertiesContext {
	var p = new(InlinePropertiesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineProperties
	return p
}

func InitEmptyInlinePropertiesContext(p *InlinePropertiesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineProperties
}

func (*InlinePropertiesContext) IsInlinePropertiesContext() {}

func NewInlinePropertiesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlinePropertiesContext {
	var p = new(InlinePropertiesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_inlineProperties

	return p
}

func (s *InlinePropertiesContext) GetParser() antlr.Parser { return s.parser }

func (s *InlinePropertiesContext) AllInlineProperty() []IInlinePropertyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInlinePropertyContext); ok {
			len++
		}
	}

	tst := make([]IInlinePropertyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInlinePropertyContext); ok {
			tst[i] = t.(IInlinePropertyContext)
			i++
		}
	}

	return tst
}

func (s *InlinePropertiesContext) InlineProperty(i int) IInlinePropertyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInlinePropertyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInlinePropertyContext)
}

func (s *InlinePropertiesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlinePropertiesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlinePropertiesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInlineProperties(s)
	}
}

func (s *InlinePropertiesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInlineProperties(s)
	}
}

func (p *StarRocksParser) InlineProperties() (localctx IInlinePropertiesContext) {
	localctx = NewInlinePropertiesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, StarRocksParserRULE_inlineProperties)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7911)
		p.InlineProperty()
	}
	p.SetState(7915)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&7557330222697660093) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-4653295000587626501) != 0) || ((int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&-3747053846437727955) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&8790990742223650807) != 0) || ((int64((_la-326)) & ^0x3f) == 0 && ((int64(1)<<(_la-326))&-5479769140411580417) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&3742173942658366679) != 0) || ((int64((_la-454)) & ^0x3f) == 0 && ((int64(1)<<(_la-454))&8856199495341) != 0) || ((int64((_la-523)) & ^0x3f) == 0 && ((int64(1)<<(_la-523))&263) != 0) {
		{
			p.SetState(7912)
			p.InlineProperty()
		}

		p.SetState(7917)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInlinePropertyContext is an interface to support dynamic dispatch.
type IInlinePropertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetKey returns the key rule contexts.
	GetKey() IIdentifierContext

	// GetValue returns the value rule contexts.
	GetValue() IStringContext

	// SetKey sets the key rule contexts.
	SetKey(IIdentifierContext)

	// SetValue sets the value rule contexts.
	SetValue(IStringContext)

	// Getter signatures
	EQ() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsInlinePropertyContext differentiates from other interfaces.
	IsInlinePropertyContext()
}

type InlinePropertyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	key    IIdentifierContext
	value  IStringContext
}

func NewEmptyInlinePropertyContext() *InlinePropertyContext {
	var p = new(InlinePropertyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineProperty
	return p
}

func InitEmptyInlinePropertyContext(p *InlinePropertyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_inlineProperty
}

func (*InlinePropertyContext) IsInlinePropertyContext() {}

func NewInlinePropertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InlinePropertyContext {
	var p = new(InlinePropertyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_inlineProperty

	return p
}

func (s *InlinePropertyContext) GetParser() antlr.Parser { return s.parser }

func (s *InlinePropertyContext) GetKey() IIdentifierContext { return s.key }

func (s *InlinePropertyContext) GetValue() IStringContext { return s.value }

func (s *InlinePropertyContext) SetKey(v IIdentifierContext) { s.key = v }

func (s *InlinePropertyContext) SetValue(v IStringContext) { s.value = v }

func (s *InlinePropertyContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *InlinePropertyContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InlinePropertyContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *InlinePropertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InlinePropertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InlinePropertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInlineProperty(s)
	}
}

func (s *InlinePropertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInlineProperty(s)
	}
}

func (p *StarRocksParser) InlineProperty() (localctx IInlinePropertyContext) {
	localctx = NewInlinePropertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, StarRocksParserRULE_inlineProperty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7918)

		var _x = p.Identifier()

		localctx.(*InlinePropertyContext).key = _x
	}
	{
		p.SetState(7919)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7920)

		var _x = p.String_()

		localctx.(*InlinePropertyContext).value = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarTypeContext is an interface to support dynamic dispatch.
type IVarTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode

	// IsVarTypeContext differentiates from other interfaces.
	IsVarTypeContext()
}

type VarTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarTypeContext() *VarTypeContext {
	var p = new(VarTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_varType
	return p
}

func InitEmptyVarTypeContext(p *VarTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_varType
}

func (*VarTypeContext) IsVarTypeContext() {}

func NewVarTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarTypeContext {
	var p = new(VarTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_varType

	return p
}

func (s *VarTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VarTypeContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *VarTypeContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCAL, 0)
}

func (s *VarTypeContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSESSION, 0)
}

func (s *VarTypeContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERBOSE, 0)
}

func (s *VarTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterVarType(s)
	}
}

func (s *VarTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitVarType(s)
	}
}

func (p *StarRocksParser) VarType() (localctx IVarTypeContext) {
	localctx = NewVarTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, StarRocksParserRULE_varType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7922)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserGLOBAL || _la == StarRocksParserLOCAL || _la == StarRocksParserSESSION || _la == StarRocksParserVERBOSE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COMMENT() antlr.TerminalNode
	String_() IStringContext

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_comment
	return p
}

func InitEmptyCommentContext(p *CommentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_comment
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *CommentContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitComment(s)
	}
}

func (p *StarRocksParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, StarRocksParserRULE_comment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7924)
		p.Match(StarRocksParserCOMMENT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7925)
		p.String_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOutfileContext is an interface to support dynamic dispatch.
type IOutfileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetFile returns the file rule contexts.
	GetFile() IStringContext

	// SetFile sets the file rule contexts.
	SetFile(IStringContext)

	// Getter signatures
	INTO() antlr.TerminalNode
	OUTFILE() antlr.TerminalNode
	String_() IStringContext
	FileFormat() IFileFormatContext
	Properties() IPropertiesContext

	// IsOutfileContext differentiates from other interfaces.
	IsOutfileContext()
}

type OutfileContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	file   IStringContext
}

func NewEmptyOutfileContext() *OutfileContext {
	var p = new(OutfileContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_outfile
	return p
}

func InitEmptyOutfileContext(p *OutfileContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_outfile
}

func (*OutfileContext) IsOutfileContext() {}

func NewOutfileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OutfileContext {
	var p = new(OutfileContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_outfile

	return p
}

func (s *OutfileContext) GetParser() antlr.Parser { return s.parser }

func (s *OutfileContext) GetFile() IStringContext { return s.file }

func (s *OutfileContext) SetFile(v IStringContext) { s.file = v }

func (s *OutfileContext) INTO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTO, 0)
}

func (s *OutfileContext) OUTFILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOUTFILE, 0)
}

func (s *OutfileContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *OutfileContext) FileFormat() IFileFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileFormatContext)
}

func (s *OutfileContext) Properties() IPropertiesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPropertiesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPropertiesContext)
}

func (s *OutfileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OutfileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OutfileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterOutfile(s)
	}
}

func (s *OutfileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitOutfile(s)
	}
}

func (p *StarRocksParser) Outfile() (localctx IOutfileContext) {
	localctx = NewOutfileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, StarRocksParserRULE_outfile)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7927)
		p.Match(StarRocksParserINTO)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7928)
		p.Match(StarRocksParserOUTFILE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7929)

		var _x = p.String_()

		localctx.(*OutfileContext).file = _x
	}
	p.SetState(7931)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFORMAT {
		{
			p.SetState(7930)
			p.FileFormat()
		}

	}
	p.SetState(7934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserPROPERTIES {
		{
			p.SetState(7933)
			p.Properties()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFileFormatContext is an interface to support dynamic dispatch.
type IFileFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORMAT() antlr.TerminalNode
	AS() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsFileFormatContext differentiates from other interfaces.
	IsFileFormatContext()
}

type FileFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileFormatContext() *FileFormatContext {
	var p = new(FileFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fileFormat
	return p
}

func InitEmptyFileFormatContext(p *FileFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_fileFormat
}

func (*FileFormatContext) IsFileFormatContext() {}

func NewFileFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileFormatContext {
	var p = new(FileFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_fileFormat

	return p
}

func (s *FileFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *FileFormatContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORMAT, 0)
}

func (s *FileFormatContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *FileFormatContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FileFormatContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *FileFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterFileFormat(s)
	}
}

func (s *FileFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitFileFormat(s)
	}
}

func (p *StarRocksParser) FileFormat() (localctx IFileFormatContext) {
	localctx = NewFileFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, StarRocksParserRULE_fileFormat)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7936)
		p.Match(StarRocksParserFORMAT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7937)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(7940)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		{
			p.SetState(7938)
			p.Identifier()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		{
			p.SetState(7939)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringContext is an interface to support dynamic dispatch.
type IStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SINGLE_QUOTED_TEXT() antlr.TerminalNode
	DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsStringContext differentiates from other interfaces.
	IsStringContext()
}

type StringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringContext() *StringContext {
	var p = new(StringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_string
	return p
}

func InitEmptyStringContext(p *StringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_string
}

func (*StringContext) IsStringContext() {}

func NewStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringContext {
	var p = new(StringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_string

	return p
}

func (s *StringContext) GetParser() antlr.Parser { return s.parser }

func (s *StringContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSINGLE_QUOTED_TEXT, 0)
}

func (s *StringContext) DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOUBLE_QUOTED_TEXT, 0)
}

func (s *StringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterString(s)
	}
}

func (s *StringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitString(s)
	}
}

func (p *StarRocksParser) String_() (localctx IStringContext) {
	localctx = NewStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, StarRocksParserRULE_string)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7942)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserSINGLE_QUOTED_TEXT || _la == StarRocksParserDOUBLE_QUOTED_TEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBinaryContext is an interface to support dynamic dispatch.
type IBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY_SINGLE_QUOTED_TEXT() antlr.TerminalNode
	BINARY_DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsBinaryContext differentiates from other interfaces.
	IsBinaryContext()
}

type BinaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBinaryContext() *BinaryContext {
	var p = new(BinaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_binary
	return p
}

func InitEmptyBinaryContext(p *BinaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_binary
}

func (*BinaryContext) IsBinaryContext() {}

func NewBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BinaryContext {
	var p = new(BinaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_binary

	return p
}

func (s *BinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *BinaryContext) BINARY_SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY_SINGLE_QUOTED_TEXT, 0)
}

func (s *BinaryContext) BINARY_DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY_DOUBLE_QUOTED_TEXT, 0)
}

func (s *BinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBinary(s)
	}
}

func (s *BinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBinary(s)
	}
}

func (p *StarRocksParser) Binary() (localctx IBinaryContext) {
	localctx = NewBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, StarRocksParserRULE_binary)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7944)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserBINARY_SINGLE_QUOTED_TEXT || _la == StarRocksParserBINARY_DOUBLE_QUOTED_TEXT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComparisonOperatorContext is an interface to support dynamic dispatch.
type IComparisonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQ() antlr.TerminalNode
	NEQ() antlr.TerminalNode
	LT() antlr.TerminalNode
	LTE() antlr.TerminalNode
	GT() antlr.TerminalNode
	GTE() antlr.TerminalNode
	EQ_FOR_NULL() antlr.TerminalNode

	// IsComparisonOperatorContext differentiates from other interfaces.
	IsComparisonOperatorContext()
}

type ComparisonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComparisonOperatorContext() *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_comparisonOperator
	return p
}

func InitEmptyComparisonOperatorContext(p *ComparisonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_comparisonOperator
}

func (*ComparisonOperatorContext) IsComparisonOperatorContext() {}

func NewComparisonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComparisonOperatorContext {
	var p = new(ComparisonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_comparisonOperator

	return p
}

func (s *ComparisonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *ComparisonOperatorContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *ComparisonOperatorContext) NEQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNEQ, 0)
}

func (s *ComparisonOperatorContext) LT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLT, 0)
}

func (s *ComparisonOperatorContext) LTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLTE, 0)
}

func (s *ComparisonOperatorContext) GT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGT, 0)
}

func (s *ComparisonOperatorContext) GTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGTE, 0)
}

func (s *ComparisonOperatorContext) EQ_FOR_NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ_FOR_NULL, 0)
}

func (s *ComparisonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComparisonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComparisonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterComparisonOperator(s)
	}
}

func (s *ComparisonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitComparisonOperator(s)
	}
}

func (p *StarRocksParser) ComparisonOperator() (localctx IComparisonOperatorContext) {
	localctx = NewComparisonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, StarRocksParserRULE_comparisonOperator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7946)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-490)) & ^0x3f) == 0 && ((int64(1)<<(_la-490))&127) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBooleanValueContext is an interface to support dynamic dispatch.
type IBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE() antlr.TerminalNode
	FALSE() antlr.TerminalNode

	// IsBooleanValueContext differentiates from other interfaces.
	IsBooleanValueContext()
}

type BooleanValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanValueContext() *BooleanValueContext {
	var p = new(BooleanValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_booleanValue
	return p
}

func InitEmptyBooleanValueContext(p *BooleanValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_booleanValue
}

func (*BooleanValueContext) IsBooleanValueContext() {}

func NewBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanValueContext {
	var p = new(BooleanValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_booleanValue

	return p
}

func (s *BooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanValueContext) TRUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUE, 0)
}

func (s *BooleanValueContext) FALSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFALSE, 0)
}

func (s *BooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBooleanValue(s)
	}
}

func (s *BooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBooleanValue(s)
	}
}

func (p *StarRocksParser) BooleanValue() (localctx IBooleanValueContext) {
	localctx = NewBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, StarRocksParserRULE_booleanValue)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7948)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserFALSE || _la == StarRocksParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetFrom returns the from rule contexts.
	GetFrom() IUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetFrom sets the from rule contexts.
	SetFrom(IUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	UnitIdentifier() IUnitIdentifierContext

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	from   IUnitIdentifierContext
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) GetValue() IExpressionContext { return s.value }

func (s *IntervalContext) GetFrom() IUnitIdentifierContext { return s.from }

func (s *IntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *IntervalContext) SetFrom(v IUnitIdentifierContext) { s.from = v }

func (s *IntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERVAL, 0)
}

func (s *IntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalContext) UnitIdentifier() IUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitIdentifierContext)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (p *StarRocksParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, StarRocksParserRULE_interval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7950)
		p.Match(StarRocksParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7951)

		var _x = p.expression(0)

		localctx.(*IntervalContext).value = _x
	}
	{
		p.SetState(7952)

		var _x = p.UnitIdentifier()

		localctx.(*IntervalContext).from = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskIntervalContext is an interface to support dynamic dispatch.
type ITaskIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value rule contexts.
	GetValue() IExpressionContext

	// GetFrom returns the from rule contexts.
	GetFrom() ITaskUnitIdentifierContext

	// SetValue sets the value rule contexts.
	SetValue(IExpressionContext)

	// SetFrom sets the from rule contexts.
	SetFrom(ITaskUnitIdentifierContext)

	// Getter signatures
	INTERVAL() antlr.TerminalNode
	Expression() IExpressionContext
	TaskUnitIdentifier() ITaskUnitIdentifierContext

	// IsTaskIntervalContext differentiates from other interfaces.
	IsTaskIntervalContext()
}

type TaskIntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  IExpressionContext
	from   ITaskUnitIdentifierContext
}

func NewEmptyTaskIntervalContext() *TaskIntervalContext {
	var p = new(TaskIntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskInterval
	return p
}

func InitEmptyTaskIntervalContext(p *TaskIntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskInterval
}

func (*TaskIntervalContext) IsTaskIntervalContext() {}

func NewTaskIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskIntervalContext {
	var p = new(TaskIntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_taskInterval

	return p
}

func (s *TaskIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskIntervalContext) GetValue() IExpressionContext { return s.value }

func (s *TaskIntervalContext) GetFrom() ITaskUnitIdentifierContext { return s.from }

func (s *TaskIntervalContext) SetValue(v IExpressionContext) { s.value = v }

func (s *TaskIntervalContext) SetFrom(v ITaskUnitIdentifierContext) { s.from = v }

func (s *TaskIntervalContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERVAL, 0)
}

func (s *TaskIntervalContext) Expression() IExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TaskIntervalContext) TaskUnitIdentifier() ITaskUnitIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITaskUnitIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITaskUnitIdentifierContext)
}

func (s *TaskIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTaskInterval(s)
	}
}

func (s *TaskIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTaskInterval(s)
	}
}

func (p *StarRocksParser) TaskInterval() (localctx ITaskIntervalContext) {
	localctx = NewTaskIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, StarRocksParserRULE_taskInterval)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7954)
		p.Match(StarRocksParserINTERVAL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7955)

		var _x = p.expression(0)

		localctx.(*TaskIntervalContext).value = _x
	}
	{
		p.SetState(7956)

		var _x = p.TaskUnitIdentifier()

		localctx.(*TaskIntervalContext).from = _x
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITaskUnitIdentifierContext is an interface to support dynamic dispatch.
type ITaskUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode

	// IsTaskUnitIdentifierContext differentiates from other interfaces.
	IsTaskUnitIdentifierContext()
}

type TaskUnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTaskUnitIdentifierContext() *TaskUnitIdentifierContext {
	var p = new(TaskUnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskUnitIdentifier
	return p
}

func InitEmptyTaskUnitIdentifierContext(p *TaskUnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_taskUnitIdentifier
}

func (*TaskUnitIdentifierContext) IsTaskUnitIdentifierContext() {}

func NewTaskUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TaskUnitIdentifierContext {
	var p = new(TaskUnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_taskUnitIdentifier

	return p
}

func (s *TaskUnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TaskUnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAY, 0)
}

func (s *TaskUnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOUR, 0)
}

func (s *TaskUnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTE, 0)
}

func (s *TaskUnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECOND, 0)
}

func (s *TaskUnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TaskUnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TaskUnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTaskUnitIdentifier(s)
	}
}

func (s *TaskUnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTaskUnitIdentifier(s)
	}
}

func (p *StarRocksParser) TaskUnitIdentifier() (localctx ITaskUnitIdentifierContext) {
	localctx = NewTaskUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, StarRocksParserRULE_taskUnitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7958)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDAY || _la == StarRocksParserHOUR || _la == StarRocksParserMINUTE || _la == StarRocksParserSECOND) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitIdentifierContext is an interface to support dynamic dispatch.
type IUnitIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	YEAR() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	DAY() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	MILLISECOND() antlr.TerminalNode
	MICROSECOND() antlr.TerminalNode

	// IsUnitIdentifierContext differentiates from other interfaces.
	IsUnitIdentifierContext()
}

type UnitIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitIdentifierContext() *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unitIdentifier
	return p
}

func InitEmptyUnitIdentifierContext(p *UnitIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unitIdentifier
}

func (*UnitIdentifierContext) IsUnitIdentifierContext() {}

func NewUnitIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitIdentifierContext {
	var p = new(UnitIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_unitIdentifier

	return p
}

func (s *UnitIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitIdentifierContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserYEAR, 0)
}

func (s *UnitIdentifierContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMONTH, 0)
}

func (s *UnitIdentifierContext) WEEK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWEEK, 0)
}

func (s *UnitIdentifierContext) DAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAY, 0)
}

func (s *UnitIdentifierContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOUR, 0)
}

func (s *UnitIdentifierContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTE, 0)
}

func (s *UnitIdentifierContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECOND, 0)
}

func (s *UnitIdentifierContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUARTER, 0)
}

func (s *UnitIdentifierContext) MILLISECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMILLISECOND, 0)
}

func (s *UnitIdentifierContext) MICROSECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMICROSECOND, 0)
}

func (s *UnitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnitIdentifier(s)
	}
}

func (s *UnitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnitIdentifier(s)
	}
}

func (p *StarRocksParser) UnitIdentifier() (localctx IUnitIdentifierContext) {
	localctx = NewUnitIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, StarRocksParserRULE_unitIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7960)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserDAY || _la == StarRocksParserHOUR || ((int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&1035) != 0) || _la == StarRocksParserQUARTER || _la == StarRocksParserSECOND || _la == StarRocksParserWEEK || _la == StarRocksParserYEAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnitBoundaryContext is an interface to support dynamic dispatch.
type IUnitBoundaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FLOOR() antlr.TerminalNode
	CEIL() antlr.TerminalNode

	// IsUnitBoundaryContext differentiates from other interfaces.
	IsUnitBoundaryContext()
}

type UnitBoundaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitBoundaryContext() *UnitBoundaryContext {
	var p = new(UnitBoundaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unitBoundary
	return p
}

func InitEmptyUnitBoundaryContext(p *UnitBoundaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_unitBoundary
}

func (*UnitBoundaryContext) IsUnitBoundaryContext() {}

func NewUnitBoundaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitBoundaryContext {
	var p = new(UnitBoundaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_unitBoundary

	return p
}

func (s *UnitBoundaryContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitBoundaryContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFLOOR, 0)
}

func (s *UnitBoundaryContext) CEIL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCEIL, 0)
}

func (s *UnitBoundaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitBoundaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnitBoundaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnitBoundary(s)
	}
}

func (s *UnitBoundaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnitBoundary(s)
	}
}

func (p *StarRocksParser) UnitBoundary() (localctx IUnitBoundaryContext) {
	localctx = NewUnitBoundaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, StarRocksParserRULE_unitBoundary)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7962)
		_la = p.GetTokenStream().LA(1)

		if !(_la == StarRocksParserCEIL || _la == StarRocksParserFLOOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeContext is an interface to support dynamic dispatch.
type ITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BaseType() IBaseTypeContext
	DecimalType() IDecimalTypeContext
	ArrayType() IArrayTypeContext
	StructType() IStructTypeContext
	MapType() IMapTypeContext

	// IsTypeContext differentiates from other interfaces.
	IsTypeContext()
}

type TypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeContext() *TypeContext {
	var p = new(TypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_type
	return p
}

func InitEmptyTypeContext(p *TypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_type
}

func (*TypeContext) IsTypeContext() {}

func NewTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeContext {
	var p = new(TypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_type

	return p
}

func (s *TypeContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeContext) BaseType() IBaseTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBaseTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBaseTypeContext)
}

func (s *TypeContext) DecimalType() IDecimalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalTypeContext)
}

func (s *TypeContext) ArrayType() IArrayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayTypeContext)
}

func (s *TypeContext) StructType() IStructTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStructTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStructTypeContext)
}

func (s *TypeContext) MapType() IMapTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMapTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMapTypeContext)
}

func (s *TypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterType(s)
	}
}

func (s *TypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitType(s)
	}
}

func (p *StarRocksParser) Type_() (localctx ITypeContext) {
	localctx = NewTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, StarRocksParserRULE_type)
	p.SetState(7969)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserBIGINT, StarRocksParserBINARY, StarRocksParserBITMAP, StarRocksParserBOOLEAN, StarRocksParserCHAR, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDOUBLE, StarRocksParserFLOAT, StarRocksParserHLL, StarRocksParserINT, StarRocksParserINTEGER, StarRocksParserJSON, StarRocksParserLARGEINT, StarRocksParserPERCENTILE, StarRocksParserSIGNED, StarRocksParserSMALLINT, StarRocksParserSTRING, StarRocksParserTEXT, StarRocksParserTIME, StarRocksParserTINYINT, StarRocksParserUNSIGNED, StarRocksParserVARBINARY, StarRocksParserVARCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(7964)
			p.BaseType()
		}

	case StarRocksParserDECIMAL, StarRocksParserDECIMALV2, StarRocksParserDECIMAL32, StarRocksParserDECIMAL64, StarRocksParserDECIMAL128, StarRocksParserNUMBER, StarRocksParserNUMERIC:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(7965)
			p.DecimalType()
		}

	case StarRocksParserARRAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(7966)
			p.ArrayType()
		}

	case StarRocksParserSTRUCT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(7967)
			p.StructType()
		}

	case StarRocksParserMAP:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(7968)
			p.MapType()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayTypeContext is an interface to support dynamic dispatch.
type IArrayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY() antlr.TerminalNode
	LT() antlr.TerminalNode
	Type_() ITypeContext
	GT() antlr.TerminalNode

	// IsArrayTypeContext differentiates from other interfaces.
	IsArrayTypeContext()
}

type ArrayTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayTypeContext() *ArrayTypeContext {
	var p = new(ArrayTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_arrayType
	return p
}

func InitEmptyArrayTypeContext(p *ArrayTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_arrayType
}

func (*ArrayTypeContext) IsArrayTypeContext() {}

func NewArrayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayTypeContext {
	var p = new(ArrayTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_arrayType

	return p
}

func (s *ArrayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayTypeContext) ARRAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY, 0)
}

func (s *ArrayTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLT, 0)
}

func (s *ArrayTypeContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *ArrayTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGT, 0)
}

func (s *ArrayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterArrayType(s)
	}
}

func (s *ArrayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitArrayType(s)
	}
}

func (p *StarRocksParser) ArrayType() (localctx IArrayTypeContext) {
	localctx = NewArrayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, StarRocksParserRULE_arrayType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7971)
		p.Match(StarRocksParserARRAY)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7972)
		p.Match(StarRocksParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7973)
		p.Type_()
	}
	{
		p.SetState(7974)
		p.Match(StarRocksParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMapTypeContext is an interface to support dynamic dispatch.
type IMapTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MAP() antlr.TerminalNode
	LT() antlr.TerminalNode
	AllType_() []ITypeContext
	Type_(i int) ITypeContext
	GT() antlr.TerminalNode

	// IsMapTypeContext differentiates from other interfaces.
	IsMapTypeContext()
}

type MapTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMapTypeContext() *MapTypeContext {
	var p = new(MapTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapType
	return p
}

func InitEmptyMapTypeContext(p *MapTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_mapType
}

func (*MapTypeContext) IsMapTypeContext() {}

func NewMapTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MapTypeContext {
	var p = new(MapTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_mapType

	return p
}

func (s *MapTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *MapTypeContext) MAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAP, 0)
}

func (s *MapTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLT, 0)
}

func (s *MapTypeContext) AllType_() []ITypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeContext); ok {
			len++
		}
	}

	tst := make([]ITypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeContext); ok {
			tst[i] = t.(ITypeContext)
			i++
		}
	}

	return tst
}

func (s *MapTypeContext) Type_(i int) ITypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *MapTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGT, 0)
}

func (s *MapTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MapTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MapTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterMapType(s)
	}
}

func (s *MapTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitMapType(s)
	}
}

func (p *StarRocksParser) MapType() (localctx IMapTypeContext) {
	localctx = NewMapTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, StarRocksParserRULE_mapType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7976)
		p.Match(StarRocksParserMAP)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7977)
		p.Match(StarRocksParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7978)
		p.Type_()
	}
	{
		p.SetState(7979)
		p.Match(StarRocksParserT__2)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7980)
		p.Type_()
	}
	{
		p.SetState(7981)
		p.Match(StarRocksParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldDescContext is an interface to support dynamic dispatch.
type ISubfieldDescContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Type_() ITypeContext
	Identifier() IIdentifierContext
	NestedFieldName() INestedFieldNameContext

	// IsSubfieldDescContext differentiates from other interfaces.
	IsSubfieldDescContext()
}

type SubfieldDescContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldDescContext() *SubfieldDescContext {
	var p = new(SubfieldDescContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldDesc
	return p
}

func InitEmptySubfieldDescContext(p *SubfieldDescContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldDesc
}

func (*SubfieldDescContext) IsSubfieldDescContext() {}

func NewSubfieldDescContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldDescContext {
	var p = new(SubfieldDescContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_subfieldDesc

	return p
}

func (s *SubfieldDescContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldDescContext) Type_() ITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeContext)
}

func (s *SubfieldDescContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubfieldDescContext) NestedFieldName() INestedFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INestedFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INestedFieldNameContext)
}

func (s *SubfieldDescContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldDescContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldDescContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubfieldDesc(s)
	}
}

func (s *SubfieldDescContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubfieldDesc(s)
	}
}

func (p *StarRocksParser) SubfieldDesc() (localctx ISubfieldDescContext) {
	localctx = NewSubfieldDescContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, StarRocksParserRULE_subfieldDesc)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(7985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 941, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(7983)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(7984)
			p.NestedFieldName()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(7987)
		p.Type_()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubfieldDescsContext is an interface to support dynamic dispatch.
type ISubfieldDescsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSubfieldDesc() []ISubfieldDescContext
	SubfieldDesc(i int) ISubfieldDescContext

	// IsSubfieldDescsContext differentiates from other interfaces.
	IsSubfieldDescsContext()
}

type SubfieldDescsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubfieldDescsContext() *SubfieldDescsContext {
	var p = new(SubfieldDescsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldDescs
	return p
}

func InitEmptySubfieldDescsContext(p *SubfieldDescsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_subfieldDescs
}

func (*SubfieldDescsContext) IsSubfieldDescsContext() {}

func NewSubfieldDescsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubfieldDescsContext {
	var p = new(SubfieldDescsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_subfieldDescs

	return p
}

func (s *SubfieldDescsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubfieldDescsContext) AllSubfieldDesc() []ISubfieldDescContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			len++
		}
	}

	tst := make([]ISubfieldDescContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubfieldDescContext); ok {
			tst[i] = t.(ISubfieldDescContext)
			i++
		}
	}

	return tst
}

func (s *SubfieldDescsContext) SubfieldDesc(i int) ISubfieldDescContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescContext)
}

func (s *SubfieldDescsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubfieldDescsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubfieldDescsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterSubfieldDescs(s)
	}
}

func (s *SubfieldDescsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitSubfieldDescs(s)
	}
}

func (p *StarRocksParser) SubfieldDescs() (localctx ISubfieldDescsContext) {
	localctx = NewSubfieldDescsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, StarRocksParserRULE_subfieldDescs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7989)
		p.SubfieldDesc()
	}
	p.SetState(7994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(7990)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(7991)
			p.SubfieldDesc()
		}

		p.SetState(7996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStructTypeContext is an interface to support dynamic dispatch.
type IStructTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRUCT() antlr.TerminalNode
	LT() antlr.TerminalNode
	SubfieldDescs() ISubfieldDescsContext
	GT() antlr.TerminalNode

	// IsStructTypeContext differentiates from other interfaces.
	IsStructTypeContext()
}

type StructTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStructTypeContext() *StructTypeContext {
	var p = new(StructTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_structType
	return p
}

func InitEmptyStructTypeContext(p *StructTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_structType
}

func (*StructTypeContext) IsStructTypeContext() {}

func NewStructTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StructTypeContext {
	var p = new(StructTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_structType

	return p
}

func (s *StructTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StructTypeContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTRUCT, 0)
}

func (s *StructTypeContext) LT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLT, 0)
}

func (s *StructTypeContext) SubfieldDescs() ISubfieldDescsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubfieldDescsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubfieldDescsContext)
}

func (s *StructTypeContext) GT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGT, 0)
}

func (s *StructTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StructTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StructTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterStructType(s)
	}
}

func (s *StructTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitStructType(s)
	}
}

func (p *StarRocksParser) StructType() (localctx IStructTypeContext) {
	localctx = NewStructTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, StarRocksParserRULE_structType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(7997)
		p.Match(StarRocksParserSTRUCT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7998)
		p.Match(StarRocksParserLT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(7999)
		p.SubfieldDescs()
	}
	{
		p.SetState(8000)
		p.Match(StarRocksParserGT)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeParameterContext is an interface to support dynamic dispatch.
type ITypeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTEGER_VALUE() antlr.TerminalNode

	// IsTypeParameterContext differentiates from other interfaces.
	IsTypeParameterContext()
}

type TypeParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeParameterContext() *TypeParameterContext {
	var p = new(TypeParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeParameter
	return p
}

func InitEmptyTypeParameterContext(p *TypeParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_typeParameter
}

func (*TypeParameterContext) IsTypeParameterContext() {}

func NewTypeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeParameterContext {
	var p = new(TypeParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_typeParameter

	return p
}

func (s *TypeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeParameterContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *TypeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTypeParameter(s)
	}
}

func (s *TypeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTypeParameter(s)
	}
}

func (p *StarRocksParser) TypeParameter() (localctx ITypeParameterContext) {
	localctx = NewTypeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, StarRocksParserRULE_typeParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8002)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8003)
		p.Match(StarRocksParserINTEGER_VALUE)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8004)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBaseTypeContext is an interface to support dynamic dispatch.
type IBaseTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BOOLEAN() antlr.TerminalNode
	TINYINT() antlr.TerminalNode
	TypeParameter() ITypeParameterContext
	SMALLINT() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	INT() antlr.TerminalNode
	INTEGER() antlr.TerminalNode
	UNSIGNED() antlr.TerminalNode
	BIGINT() antlr.TerminalNode
	LARGEINT() antlr.TerminalNode
	FLOAT() antlr.TerminalNode
	DOUBLE() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	TIME() antlr.TerminalNode
	CHAR() antlr.TerminalNode
	VARCHAR() antlr.TerminalNode
	STRING() antlr.TerminalNode
	TEXT() antlr.TerminalNode
	BITMAP() antlr.TerminalNode
	HLL() antlr.TerminalNode
	PERCENTILE() antlr.TerminalNode
	JSON() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	BINARY() antlr.TerminalNode

	// IsBaseTypeContext differentiates from other interfaces.
	IsBaseTypeContext()
}

type BaseTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBaseTypeContext() *BaseTypeContext {
	var p = new(BaseTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_baseType
	return p
}

func InitEmptyBaseTypeContext(p *BaseTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_baseType
}

func (*BaseTypeContext) IsBaseTypeContext() {}

func NewBaseTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BaseTypeContext {
	var p = new(BaseTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_baseType

	return p
}

func (s *BaseTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *BaseTypeContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBOOLEAN, 0)
}

func (s *BaseTypeContext) TINYINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTINYINT, 0)
}

func (s *BaseTypeContext) TypeParameter() ITypeParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeParameterContext)
}

func (s *BaseTypeContext) SMALLINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSMALLINT, 0)
}

func (s *BaseTypeContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSIGNED, 0)
}

func (s *BaseTypeContext) INT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINT, 0)
}

func (s *BaseTypeContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER, 0)
}

func (s *BaseTypeContext) UNSIGNED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNSIGNED, 0)
}

func (s *BaseTypeContext) BIGINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBIGINT, 0)
}

func (s *BaseTypeContext) LARGEINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLARGEINT, 0)
}

func (s *BaseTypeContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFLOAT, 0)
}

func (s *BaseTypeContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOUBLE, 0)
}

func (s *BaseTypeContext) DATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATE, 0)
}

func (s *BaseTypeContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATETIME, 0)
}

func (s *BaseTypeContext) TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIME, 0)
}

func (s *BaseTypeContext) CHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAR, 0)
}

func (s *BaseTypeContext) VARCHAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARCHAR, 0)
}

func (s *BaseTypeContext) STRING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTRING, 0)
}

func (s *BaseTypeContext) TEXT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEXT, 0)
}

func (s *BaseTypeContext) BITMAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITMAP, 0)
}

func (s *BaseTypeContext) HLL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHLL, 0)
}

func (s *BaseTypeContext) PERCENTILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENTILE, 0)
}

func (s *BaseTypeContext) JSON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJSON, 0)
}

func (s *BaseTypeContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARBINARY, 0)
}

func (s *BaseTypeContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY, 0)
}

func (s *BaseTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BaseTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BaseTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBaseType(s)
	}
}

func (s *BaseTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBaseType(s)
	}
}

func (p *StarRocksParser) BaseType() (localctx IBaseTypeContext) {
	localctx = NewBaseTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, StarRocksParserRULE_baseType)
	var _la int

	p.SetState(8074)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 957, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8006)
			p.Match(StarRocksParserBOOLEAN)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8007)
			p.Match(StarRocksParserTINYINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8008)
				p.TypeParameter()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8011)
			p.Match(StarRocksParserSMALLINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8013)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8012)
				p.TypeParameter()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8015)
			p.Match(StarRocksParserSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8017)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserINT {
			{
				p.SetState(8016)
				p.Match(StarRocksParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(8019)
			p.Match(StarRocksParserSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8021)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserINTEGER {
			{
				p.SetState(8020)
				p.Match(StarRocksParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(8023)
			p.Match(StarRocksParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserINT {
			{
				p.SetState(8024)
				p.Match(StarRocksParserINT)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(8027)
			p.Match(StarRocksParserUNSIGNED)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8029)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserINTEGER {
			{
				p.SetState(8028)
				p.Match(StarRocksParserINTEGER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(8031)
			p.Match(StarRocksParserINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8033)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8032)
				p.TypeParameter()
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(8035)
			p.Match(StarRocksParserINTEGER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8036)
				p.TypeParameter()
			}

		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(8039)
			p.Match(StarRocksParserBIGINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8040)
				p.TypeParameter()
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(8043)
			p.Match(StarRocksParserLARGEINT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8045)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8044)
				p.TypeParameter()
			}

		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(8047)
			p.Match(StarRocksParserFLOAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(8048)
			p.Match(StarRocksParserDOUBLE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(8049)
			p.Match(StarRocksParserDATE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(8050)
			p.Match(StarRocksParserDATETIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(8051)
			p.Match(StarRocksParserTIME)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(8052)
			p.Match(StarRocksParserCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8054)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8053)
				p.TypeParameter()
			}

		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(8056)
			p.Match(StarRocksParserVARCHAR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8057)
				p.TypeParameter()
			}

		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(8060)
			p.Match(StarRocksParserSTRING)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(8061)
			p.Match(StarRocksParserTEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(8062)
			p.Match(StarRocksParserBITMAP)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(8063)
			p.Match(StarRocksParserHLL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(8064)
			p.Match(StarRocksParserPERCENTILE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(8065)
			p.Match(StarRocksParserJSON)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(8066)
			p.Match(StarRocksParserVARBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8067)
				p.TypeParameter()
			}

		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(8070)
			p.Match(StarRocksParserBINARY)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8072)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__1 {
			{
				p.SetState(8071)
				p.TypeParameter()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDecimalTypeContext is an interface to support dynamic dispatch.
type IDecimalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetPrecision returns the precision token.
	GetPrecision() antlr.Token

	// GetScale returns the scale token.
	GetScale() antlr.Token

	// SetPrecision sets the precision token.
	SetPrecision(antlr.Token)

	// SetScale sets the scale token.
	SetScale(antlr.Token)

	// Getter signatures
	DECIMAL() antlr.TerminalNode
	DECIMALV2() antlr.TerminalNode
	DECIMAL32() antlr.TerminalNode
	DECIMAL64() antlr.TerminalNode
	DECIMAL128() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	AllINTEGER_VALUE() []antlr.TerminalNode
	INTEGER_VALUE(i int) antlr.TerminalNode

	// IsDecimalTypeContext differentiates from other interfaces.
	IsDecimalTypeContext()
}

type DecimalTypeContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	precision antlr.Token
	scale     antlr.Token
}

func NewEmptyDecimalTypeContext() *DecimalTypeContext {
	var p = new(DecimalTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decimalType
	return p
}

func InitEmptyDecimalTypeContext(p *DecimalTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_decimalType
}

func (*DecimalTypeContext) IsDecimalTypeContext() {}

func NewDecimalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalTypeContext {
	var p = new(DecimalTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_decimalType

	return p
}

func (s *DecimalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalTypeContext) GetPrecision() antlr.Token { return s.precision }

func (s *DecimalTypeContext) GetScale() antlr.Token { return s.scale }

func (s *DecimalTypeContext) SetPrecision(v antlr.Token) { s.precision = v }

func (s *DecimalTypeContext) SetScale(v antlr.Token) { s.scale = v }

func (s *DecimalTypeContext) DECIMAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL, 0)
}

func (s *DecimalTypeContext) DECIMALV2() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMALV2, 0)
}

func (s *DecimalTypeContext) DECIMAL32() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL32, 0)
}

func (s *DecimalTypeContext) DECIMAL64() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL64, 0)
}

func (s *DecimalTypeContext) DECIMAL128() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL128, 0)
}

func (s *DecimalTypeContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNUMERIC, 0)
}

func (s *DecimalTypeContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNUMBER, 0)
}

func (s *DecimalTypeContext) AllINTEGER_VALUE() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserINTEGER_VALUE)
}

func (s *DecimalTypeContext) INTEGER_VALUE(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, i)
}

func (s *DecimalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDecimalType(s)
	}
}

func (s *DecimalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDecimalType(s)
	}
}

func (p *StarRocksParser) DecimalType() (localctx IDecimalTypeContext) {
	localctx = NewDecimalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, StarRocksParserRULE_decimalType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8076)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la-109)) & ^0x3f) == 0 && ((int64(1)<<(_la-109))&31) != 0) || _la == StarRocksParserNUMBER || _la == StarRocksParserNUMERIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(8084)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserT__1 {
		{
			p.SetState(8077)
			p.Match(StarRocksParserT__1)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8078)

			var _m = p.Match(StarRocksParserINTEGER_VALUE)

			localctx.(*DecimalTypeContext).precision = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(8081)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == StarRocksParserT__2 {
			{
				p.SetState(8079)
				p.Match(StarRocksParserT__2)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(8080)

				var _m = p.Match(StarRocksParserINTEGER_VALUE)

				localctx.(*DecimalTypeContext).scale = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(8083)
			p.Match(StarRocksParserT__3)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedNameContext is an interface to support dynamic dispatch.
type IQualifiedNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT_IDENTIFIER() []antlr.TerminalNode
	DOT_IDENTIFIER(i int) antlr.TerminalNode

	// IsQualifiedNameContext differentiates from other interfaces.
	IsQualifiedNameContext()
}

type QualifiedNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedNameContext() *QualifiedNameContext {
	var p = new(QualifiedNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_qualifiedName
	return p
}

func InitEmptyQualifiedNameContext(p *QualifiedNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_qualifiedName
}

func (*QualifiedNameContext) IsQualifiedNameContext() {}

func NewQualifiedNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedNameContext {
	var p = new(QualifiedNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_qualifiedName

	return p
}

func (s *QualifiedNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedNameContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedNameContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedNameContext) AllDOT_IDENTIFIER() []antlr.TerminalNode {
	return s.GetTokens(StarRocksParserDOT_IDENTIFIER)
}

func (s *QualifiedNameContext) DOT_IDENTIFIER(i int) antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOT_IDENTIFIER, i)
}

func (s *QualifiedNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterQualifiedName(s)
	}
}

func (s *QualifiedNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitQualifiedName(s)
	}
}

func (p *StarRocksParser) QualifiedName() (localctx IQualifiedNameContext) {
	localctx = NewQualifiedNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, StarRocksParserRULE_qualifiedName)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8086)
		p.Identifier()
	}
	p.SetState(8092)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 961, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(8090)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case StarRocksParserDOT_IDENTIFIER:
				{
					p.SetState(8087)
					p.Match(StarRocksParserDOT_IDENTIFIER)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case StarRocksParserT__0:
				{
					p.SetState(8088)
					p.Match(StarRocksParserT__0)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(8089)
					p.Identifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		}
		p.SetState(8094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 961, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedName() IQualifiedNameContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) QualifiedName() IQualifiedNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedNameContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (p *StarRocksParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, StarRocksParserRULE_tableName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8095)
		p.QualifiedName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWriteBranchContext is an interface to support dynamic dispatch.
type IWriteBranchContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VERSION() antlr.TerminalNode
	AS() antlr.TerminalNode
	OF() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR() antlr.TerminalNode

	// IsWriteBranchContext differentiates from other interfaces.
	IsWriteBranchContext()
}

type WriteBranchContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteBranchContext() *WriteBranchContext {
	var p = new(WriteBranchContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_writeBranch
	return p
}

func InitEmptyWriteBranchContext(p *WriteBranchContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_writeBranch
}

func (*WriteBranchContext) IsWriteBranchContext() {}

func NewWriteBranchContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteBranchContext {
	var p = new(WriteBranchContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_writeBranch

	return p
}

func (s *WriteBranchContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteBranchContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *WriteBranchContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *WriteBranchContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *WriteBranchContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteBranchContext) FOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOR, 0)
}

func (s *WriteBranchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteBranchContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteBranchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterWriteBranch(s)
	}
}

func (s *WriteBranchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitWriteBranch(s)
	}
}

func (p *StarRocksParser) WriteBranch() (localctx IWriteBranchContext) {
	localctx = NewWriteBranchContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, StarRocksParserRULE_writeBranch)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(8098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserFOR {
		{
			p.SetState(8097)
			p.Match(StarRocksParserFOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(8100)
		p.Match(StarRocksParserVERSION)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8101)
		p.Match(StarRocksParserAS)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8102)
		p.Match(StarRocksParserOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8103)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) CopyAll(ctx *IdentifierContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type BackQuotedIdentifierContext struct {
	IdentifierContext
}

func NewBackQuotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BackQuotedIdentifierContext {
	var p = new(BackQuotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *BackQuotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BackQuotedIdentifierContext) BACKQUOTED_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKQUOTED_IDENTIFIER, 0)
}

func (s *BackQuotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterBackQuotedIdentifier(s)
	}
}

func (s *BackQuotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitBackQuotedIdentifier(s)
	}
}

type DigitIdentifierContext struct {
	IdentifierContext
}

func NewDigitIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DigitIdentifierContext {
	var p = new(DigitIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *DigitIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitIdentifierContext) DIGIT_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDIGIT_IDENTIFIER, 0)
}

func (s *DigitIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDigitIdentifier(s)
	}
}

func (s *DigitIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDigitIdentifier(s)
	}
}

type UnquotedIdentifierContext struct {
	IdentifierContext
}

func NewUnquotedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UnquotedIdentifierContext {
	var p = new(UnquotedIdentifierContext)

	InitEmptyIdentifierContext(&p.IdentifierContext)
	p.parser = parser
	p.CopyAll(ctx.(*IdentifierContext))

	return p
}

func (s *UnquotedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnquotedIdentifierContext) LETTER_IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLETTER_IDENTIFIER, 0)
}

func (s *UnquotedIdentifierContext) NonReserved() INonReservedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonReservedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonReservedContext)
}

func (s *UnquotedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUnquotedIdentifier(s)
	}
}

func (s *UnquotedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUnquotedIdentifier(s)
	}
}

func (p *StarRocksParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, StarRocksParserRULE_identifier)
	p.SetState(8109)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserLETTER_IDENTIFIER:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8105)
			p.Match(StarRocksParserLETTER_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserDOTDOTDOT:
		localctx = NewUnquotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8106)
			p.NonReserved()
		}

	case StarRocksParserDIGIT_IDENTIFIER:
		localctx = NewDigitIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8107)
			p.Match(StarRocksParserDIGIT_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserBACKQUOTED_IDENTIFIER:
		localctx = NewBackQuotedIdentifierContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(8108)
			p.Match(StarRocksParserBACKQUOTED_IDENTIFIER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierWithAliasContext is an interface to support dynamic dispatch.
type IIdentifierWithAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOriginalName returns the originalName rule contexts.
	GetOriginalName() IIdentifierContext

	// GetAlias returns the alias rule contexts.
	GetAlias() IIdentifierContext

	// SetOriginalName sets the originalName rule contexts.
	SetOriginalName(IIdentifierContext)

	// SetAlias sets the alias rule contexts.
	SetAlias(IIdentifierContext)

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AS() antlr.TerminalNode

	// IsIdentifierWithAliasContext differentiates from other interfaces.
	IsIdentifierWithAliasContext()
}

type IdentifierWithAliasContext struct {
	antlr.BaseParserRuleContext
	parser       antlr.Parser
	originalName IIdentifierContext
	alias        IIdentifierContext
}

func NewEmptyIdentifierWithAliasContext() *IdentifierWithAliasContext {
	var p = new(IdentifierWithAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierWithAlias
	return p
}

func InitEmptyIdentifierWithAliasContext(p *IdentifierWithAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierWithAlias
}

func (*IdentifierWithAliasContext) IsIdentifierWithAliasContext() {}

func NewIdentifierWithAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierWithAliasContext {
	var p = new(IdentifierWithAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierWithAlias

	return p
}

func (s *IdentifierWithAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierWithAliasContext) GetOriginalName() IIdentifierContext { return s.originalName }

func (s *IdentifierWithAliasContext) GetAlias() IIdentifierContext { return s.alias }

func (s *IdentifierWithAliasContext) SetOriginalName(v IIdentifierContext) { s.originalName = v }

func (s *IdentifierWithAliasContext) SetAlias(v IIdentifierContext) { s.alias = v }

func (s *IdentifierWithAliasContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierWithAliasContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierWithAliasContext) AS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAS, 0)
}

func (s *IdentifierWithAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierWithAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierWithAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierWithAlias(s)
	}
}

func (s *IdentifierWithAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierWithAlias(s)
	}
}

func (p *StarRocksParser) IdentifierWithAlias() (localctx IIdentifierWithAliasContext) {
	localctx = NewIdentifierWithAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1014, StarRocksParserRULE_identifierWithAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8111)

		var _x = p.Identifier()

		localctx.(*IdentifierWithAliasContext).originalName = _x
	}
	p.SetState(8114)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == StarRocksParserAS {
		{
			p.SetState(8112)
			p.Match(StarRocksParserAS)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8113)

			var _x = p.Identifier()

			localctx.(*IdentifierWithAliasContext).alias = _x
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierWithAliasListContext is an interface to support dynamic dispatch.
type IIdentifierWithAliasListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierWithAlias() []IIdentifierWithAliasContext
	IdentifierWithAlias(i int) IIdentifierWithAliasContext

	// IsIdentifierWithAliasListContext differentiates from other interfaces.
	IsIdentifierWithAliasListContext()
}

type IdentifierWithAliasListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierWithAliasListContext() *IdentifierWithAliasListContext {
	var p = new(IdentifierWithAliasListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierWithAliasList
	return p
}

func InitEmptyIdentifierWithAliasListContext(p *IdentifierWithAliasListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierWithAliasList
}

func (*IdentifierWithAliasListContext) IsIdentifierWithAliasListContext() {}

func NewIdentifierWithAliasListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierWithAliasListContext {
	var p = new(IdentifierWithAliasListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierWithAliasList

	return p
}

func (s *IdentifierWithAliasListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierWithAliasListContext) AllIdentifierWithAlias() []IIdentifierWithAliasContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierWithAliasContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierWithAliasContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierWithAliasContext); ok {
			tst[i] = t.(IIdentifierWithAliasContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierWithAliasListContext) IdentifierWithAlias(i int) IIdentifierWithAliasContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierWithAliasContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierWithAliasContext)
}

func (s *IdentifierWithAliasListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierWithAliasListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierWithAliasListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierWithAliasList(s)
	}
}

func (s *IdentifierWithAliasListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierWithAliasList(s)
	}
}

func (p *StarRocksParser) IdentifierWithAliasList() (localctx IIdentifierWithAliasListContext) {
	localctx = NewIdentifierWithAliasListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, StarRocksParserRULE_identifierWithAliasList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8116)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8117)
		p.IdentifierWithAlias()
	}
	p.SetState(8122)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(8118)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8119)
			p.IdentifierWithAlias()
		}

		p.SetState(8124)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8125)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (p *StarRocksParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, StarRocksParserRULE_identifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8127)
		p.Match(StarRocksParserT__1)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8128)
		p.Identifier()
	}
	p.SetState(8133)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(8129)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8130)
			p.Identifier()
		}

		p.SetState(8135)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(8136)
		p.Match(StarRocksParserT__3)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringContext is an interface to support dynamic dispatch.
type IIdentifierOrStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsIdentifierOrStringContext differentiates from other interfaces.
	IsIdentifierOrStringContext()
}

type IdentifierOrStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringContext() *IdentifierOrStringContext {
	var p = new(IdentifierOrStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrString
	return p
}

func InitEmptyIdentifierOrStringContext(p *IdentifierOrStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrString
}

func (*IdentifierOrStringContext) IsIdentifierOrStringContext() {}

func NewIdentifierOrStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringContext {
	var p = new(IdentifierOrStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierOrString

	return p
}

func (s *IdentifierOrStringContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrStringContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *IdentifierOrStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierOrString(s)
	}
}

func (s *IdentifierOrStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierOrString(s)
	}
}

func (p *StarRocksParser) IdentifierOrString() (localctx IIdentifierOrStringContext) {
	localctx = NewIdentifierOrStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, StarRocksParserRULE_identifierOrString)
	p.SetState(8140)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8138)
			p.Identifier()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8139)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringListContext is an interface to support dynamic dispatch.
type IIdentifierOrStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifierOrString() []IIdentifierOrStringContext
	IdentifierOrString(i int) IIdentifierOrStringContext

	// IsIdentifierOrStringListContext differentiates from other interfaces.
	IsIdentifierOrStringListContext()
}

type IdentifierOrStringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringListContext() *IdentifierOrStringListContext {
	var p = new(IdentifierOrStringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrStringList
	return p
}

func InitEmptyIdentifierOrStringListContext(p *IdentifierOrStringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrStringList
}

func (*IdentifierOrStringListContext) IsIdentifierOrStringListContext() {}

func NewIdentifierOrStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringListContext {
	var p = new(IdentifierOrStringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierOrStringList

	return p
}

func (s *IdentifierOrStringListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringListContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierOrStringListContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *IdentifierOrStringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierOrStringList(s)
	}
}

func (s *IdentifierOrStringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierOrStringList(s)
	}
}

func (p *StarRocksParser) IdentifierOrStringList() (localctx IIdentifierOrStringListContext) {
	localctx = NewIdentifierOrStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, StarRocksParserRULE_identifierOrStringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8142)
		p.IdentifierOrString()
	}
	p.SetState(8147)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(8143)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8144)
			p.IdentifierOrString()
		}

		p.SetState(8149)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierOrStringOrStarContext is an interface to support dynamic dispatch.
type IIdentifierOrStringOrStarContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASTERISK_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	String_() IStringContext

	// IsIdentifierOrStringOrStarContext differentiates from other interfaces.
	IsIdentifierOrStringOrStarContext()
}

type IdentifierOrStringOrStarContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrStringOrStarContext() *IdentifierOrStringOrStarContext {
	var p = new(IdentifierOrStringOrStarContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrStringOrStar
	return p
}

func InitEmptyIdentifierOrStringOrStarContext(p *IdentifierOrStringOrStarContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_identifierOrStringOrStar
}

func (*IdentifierOrStringOrStarContext) IsIdentifierOrStringOrStarContext() {}

func NewIdentifierOrStringOrStarContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrStringOrStarContext {
	var p = new(IdentifierOrStringOrStarContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_identifierOrStringOrStar

	return p
}

func (s *IdentifierOrStringOrStarContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrStringOrStarContext) ASTERISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASTERISK_SYMBOL, 0)
}

func (s *IdentifierOrStringOrStarContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrStringOrStarContext) String_() IStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringContext)
}

func (s *IdentifierOrStringOrStarContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrStringOrStarContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierOrStringOrStarContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIdentifierOrStringOrStar(s)
	}
}

func (s *IdentifierOrStringOrStarContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIdentifierOrStringOrStar(s)
	}
}

func (p *StarRocksParser) IdentifierOrStringOrStar() (localctx IIdentifierOrStringOrStarContext) {
	localctx = NewIdentifierOrStringOrStarContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, StarRocksParserRULE_identifierOrStringOrStar)
	p.SetState(8153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserASTERISK_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8150)
			p.Match(StarRocksParserASTERISK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserACCESS, StarRocksParserACTIVE, StarRocksParserADMIN, StarRocksParserADVISOR, StarRocksParserAFTER, StarRocksParserAGGREGATE, StarRocksParserANTI, StarRocksParserAPPLY, StarRocksParserARRAY_AGG, StarRocksParserARRAY_AGG_DISTINCT, StarRocksParserASYNC, StarRocksParserAUTHORS, StarRocksParserAUTHENTICATION, StarRocksParserAUTOMATED, StarRocksParserAUTO_INCREMENT, StarRocksParserAVG, StarRocksParserBACKEND, StarRocksParserBACKENDS, StarRocksParserBACKUP, StarRocksParserBASE, StarRocksParserBASELINE, StarRocksParserBEGIN, StarRocksParserBINARY, StarRocksParserBITMAP_UNION, StarRocksParserBLACKHOLE, StarRocksParserBLACKLIST, StarRocksParserBODY, StarRocksParserBOOLEAN, StarRocksParserBRANCH, StarRocksParserBROKER, StarRocksParserBUCKETS, StarRocksParserBUILTIN, StarRocksParserCACHE, StarRocksParserCANCEL, StarRocksParserCAST, StarRocksParserCATALOG, StarRocksParserCATALOGS, StarRocksParserCEIL, StarRocksParserCHAIN, StarRocksParserCHARSET, StarRocksParserCLEAN, StarRocksParserCLEAR, StarRocksParserCLUSTER, StarRocksParserCLUSTERS, StarRocksParserCOLLATION, StarRocksParserCOLUMNS, StarRocksParserCOMMENT, StarRocksParserCOMMIT, StarRocksParserCOMMITTED, StarRocksParserCOMPACT, StarRocksParserCOMPUTE, StarRocksParserCONFIG, StarRocksParserCONNECTION, StarRocksParserCONSISTENT, StarRocksParserCOSTS, StarRocksParserCOUNT, StarRocksParserCUME_DIST, StarRocksParserCUMULATIVE, StarRocksParserCURRENT, StarRocksParserDATA, StarRocksParserDATACACHE, StarRocksParserDATE, StarRocksParserDATETIME, StarRocksParserDAY, StarRocksParserDAYS, StarRocksParserDEALLOCATE, StarRocksParserDECOMMISSION, StarRocksParserDIALECT, StarRocksParserDICTIONARY, StarRocksParserDICTIONARY_GET, StarRocksParserDISABLE, StarRocksParserDISTRIBUTED, StarRocksParserDISTRIBUTION, StarRocksParserDUPLICATE, StarRocksParserDYNAMIC, StarRocksParserENABLE, StarRocksParserENCLOSE, StarRocksParserEND, StarRocksParserENGINE, StarRocksParserENGINES, StarRocksParserERRORS, StarRocksParserESCAPE, StarRocksParserEVENTS, StarRocksParserEXECUTE, StarRocksParserEXPORT, StarRocksParserEXTERNAL, StarRocksParserEXTRACT, StarRocksParserEVERY, StarRocksParserFAILPOINT, StarRocksParserFAILPOINTS, StarRocksParserFIELDS, StarRocksParserFILE, StarRocksParserFILTER, StarRocksParserFIRST, StarRocksParserFLOOR, StarRocksParserFN, StarRocksParserFOLLOWING, StarRocksParserFOLLOWER, StarRocksParserFORMAT, StarRocksParserFREE, StarRocksParserFRONTEND, StarRocksParserFRONTENDS, StarRocksParserFUNCTIONS, StarRocksParserGLOBAL, StarRocksParserGRANTS, StarRocksParserGROUP_CONCAT, StarRocksParserHASH, StarRocksParserHELP, StarRocksParserHISTOGRAM, StarRocksParserHLL_UNION, StarRocksParserHOST, StarRocksParserHOUR, StarRocksParserHOURS, StarRocksParserHUB, StarRocksParserIDENTIFIED, StarRocksParserIMPERSONATE, StarRocksParserIMAGE, StarRocksParserINACTIVE, StarRocksParserINCREMENTAL, StarRocksParserINDEXES, StarRocksParserINSTALL, StarRocksParserINTEGRATION, StarRocksParserINTEGRATIONS, StarRocksParserINTERMEDIATE, StarRocksParserINTERVAL, StarRocksParserOVERWRITE, StarRocksParserISOLATION, StarRocksParserJOB, StarRocksParserLABEL, StarRocksParserLAST, StarRocksParserLESS, StarRocksParserLEVEL, StarRocksParserLIST, StarRocksParserLOCAL, StarRocksParserLOCATION, StarRocksParserLOCATIONS, StarRocksParserLOGS, StarRocksParserLOGICAL, StarRocksParserMANUAL, StarRocksParserMAP, StarRocksParserMAPPING, StarRocksParserMAPPINGS, StarRocksParserMASKING, StarRocksParserMATCH, StarRocksParserMATERIALIZED, StarRocksParserMAX, StarRocksParserMERGE, StarRocksParserMIN, StarRocksParserMINUTE, StarRocksParserMINUTES, StarRocksParserMINUS, StarRocksParserMETA, StarRocksParserMODE, StarRocksParserMODIFY, StarRocksParserMONTH, StarRocksParserMULTIPLE, StarRocksParserNAME, StarRocksParserNAMES, StarRocksParserNEGATIVE, StarRocksParserNGRAMBF, StarRocksParserNO, StarRocksParserNODE, StarRocksParserNODES, StarRocksParserNONE, StarRocksParserNULLS, StarRocksParserNUMBER, StarRocksParserNUMERIC, StarRocksParserOBSERVER, StarRocksParserOF, StarRocksParserOFF, StarRocksParserOFFSET, StarRocksParserONLY, StarRocksParserOPEN, StarRocksParserOPERATE, StarRocksParserOPTIMIZER, StarRocksParserOPTION, StarRocksParserPARTITIONS, StarRocksParserPASSWORD, StarRocksParserPATH, StarRocksParserPAUSE, StarRocksParserPENDING, StarRocksParserPERCENT_RANK, StarRocksParserPERCENTILE_UNION, StarRocksParserPLAN, StarRocksParserPLUGIN, StarRocksParserPLUGINS, StarRocksParserPIPE, StarRocksParserPIPES, StarRocksParserPIVOT, StarRocksParserPOLICY, StarRocksParserPOLICIES, StarRocksParserPRECEDING, StarRocksParserPREDICATE, StarRocksParserPRIORITY, StarRocksParserPRIVILEGES, StarRocksParserPROBABILITY, StarRocksParserPROC, StarRocksParserPROCESSLIST, StarRocksParserPROFILE, StarRocksParserPROFILELIST, StarRocksParserPROPERTIES, StarRocksParserPROPERTY, StarRocksParserPROVIDER, StarRocksParserPROVIDERS, StarRocksParserQUALIFY, StarRocksParserQUARTER, StarRocksParserQUERY, StarRocksParserQUERIES, StarRocksParserQUEUE, StarRocksParserQUOTA, StarRocksParserRANDOM, StarRocksParserRANK, StarRocksParserREASON, StarRocksParserRECOVER, StarRocksParserREFRESH, StarRocksParserREWRITE, StarRocksParserREMOVE, StarRocksParserREPAIR, StarRocksParserREPEATABLE, StarRocksParserREPLACE_IF_NOT_NULL, StarRocksParserREPLICA, StarRocksParserREPOSITORY, StarRocksParserREPOSITORIES, StarRocksParserRESOURCE, StarRocksParserRESOURCES, StarRocksParserRESTORE, StarRocksParserRESUME, StarRocksParserRETAIN, StarRocksParserRETENTION, StarRocksParserRETURNS, StarRocksParserRETRY, StarRocksParserREVERT, StarRocksParserROLE, StarRocksParserROLES, StarRocksParserROLLBACK, StarRocksParserROLLUP, StarRocksParserROUTINE, StarRocksParserROW, StarRocksParserRULE, StarRocksParserRULES, StarRocksParserRUNNING, StarRocksParserSAMPLE, StarRocksParserSCHEDULE, StarRocksParserSCHEDULER, StarRocksParserSECOND, StarRocksParserSECURITY, StarRocksParserSEMI, StarRocksParserSEPARATOR, StarRocksParserSERIALIZABLE, StarRocksParserSESSION, StarRocksParserSETS, StarRocksParserSIGNED, StarRocksParserSKIP_HEADER, StarRocksParserSNAPSHOT, StarRocksParserSNAPSHOTS, StarRocksParserSQLBLACKLIST, StarRocksParserSTARROCKS, StarRocksParserSTART, StarRocksParserSTATS, StarRocksParserSTATUS, StarRocksParserSTOP, StarRocksParserSTORAGE, StarRocksParserSTREAM, StarRocksParserSTRING, StarRocksParserSUBMIT, StarRocksParserSUM, StarRocksParserSUSPEND, StarRocksParserSYNC, StarRocksParserSYSTEM_TIME, StarRocksParserSWAP, StarRocksParserSTRUCT, StarRocksParserTABLES, StarRocksParserTABLET, StarRocksParserTABLETS, StarRocksParserTAG, StarRocksParserTASK, StarRocksParserTEMPORARY, StarRocksParserTHAN, StarRocksParserTIME, StarRocksParserTIMES, StarRocksParserTIMESTAMP, StarRocksParserTIMESTAMPADD, StarRocksParserTIMESTAMPDIFF, StarRocksParserTRANSACTION, StarRocksParserTRANSLATE, StarRocksParserTRACE, StarRocksParserTRIGGERS, StarRocksParserTRIM_SPACE, StarRocksParserTRUNCATE, StarRocksParserTYPE, StarRocksParserTYPES, StarRocksParserUNBOUNDED, StarRocksParserUNCOMMITTED, StarRocksParserUNINSTALL, StarRocksParserUNSET, StarRocksParserUSAGE, StarRocksParserUSER, StarRocksParserUSERS, StarRocksParserVALUE, StarRocksParserVARBINARY, StarRocksParserVARIABLES, StarRocksParserVECTOR, StarRocksParserVERBOSE, StarRocksParserVERSION, StarRocksParserVIEW, StarRocksParserVIEWS, StarRocksParserVOLUME, StarRocksParserVOLUMES, StarRocksParserWAREHOUSE, StarRocksParserWAREHOUSES, StarRocksParserWARNINGS, StarRocksParserWEEK, StarRocksParserWHITELIST, StarRocksParserWORK, StarRocksParserWRITE, StarRocksParserYEAR, StarRocksParserLOCK, StarRocksParserUNLOCK, StarRocksParserLOW_PRIORITY, StarRocksParserDISK, StarRocksParserBEFORE, StarRocksParserFIELD, StarRocksParserPERSISTENT, StarRocksParserARRAY_ELEMENT, StarRocksParserLETTER_IDENTIFIER, StarRocksParserDIGIT_IDENTIFIER, StarRocksParserBACKQUOTED_IDENTIFIER, StarRocksParserDOTDOTDOT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8151)
			p.Identifier()
		}

	case StarRocksParserSINGLE_QUOTED_TEXT, StarRocksParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8152)
			p.String_()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_user
	return p
}

func InitEmptyUserContext(p *UserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_user
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) CopyAll(ctx *UserContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type UserWithHostAndBlanketContext struct {
	UserContext
}

func NewUserWithHostAndBlanketContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithHostAndBlanketContext {
	var p = new(UserWithHostAndBlanketContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithHostAndBlanketContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithHostAndBlanketContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *UserWithHostAndBlanketContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithHostAndBlanketContext) AT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, 0)
}

func (s *UserWithHostAndBlanketContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserWithHostAndBlanket(s)
	}
}

func (s *UserWithHostAndBlanketContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserWithHostAndBlanket(s)
	}
}

type UserWithHostContext struct {
	UserContext
}

func NewUserWithHostContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithHostContext {
	var p = new(UserWithHostContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithHostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithHostContext) AllIdentifierOrString() []IIdentifierOrStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierOrStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierOrStringContext); ok {
			tst[i] = t.(IIdentifierOrStringContext)
			i++
		}
	}

	return tst
}

func (s *UserWithHostContext) IdentifierOrString(i int) IIdentifierOrStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithHostContext) AT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAT, 0)
}

func (s *UserWithHostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserWithHost(s)
	}
}

func (s *UserWithHostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserWithHost(s)
	}
}

type UserWithoutHostContext struct {
	UserContext
}

func NewUserWithoutHostContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *UserWithoutHostContext {
	var p = new(UserWithoutHostContext)

	InitEmptyUserContext(&p.UserContext)
	p.parser = parser
	p.CopyAll(ctx.(*UserContext))

	return p
}

func (s *UserWithoutHostContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserWithoutHostContext) IdentifierOrString() IIdentifierOrStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrStringContext)
}

func (s *UserWithoutHostContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterUserWithoutHost(s)
	}
}

func (s *UserWithoutHostContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitUserWithoutHost(s)
	}
}

func (p *StarRocksParser) User() (localctx IUserContext) {
	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, StarRocksParserRULE_user)
	p.SetState(8166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 970, p.GetParserRuleContext()) {
	case 1:
		localctx = NewUserWithoutHostContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8155)
			p.IdentifierOrString()
		}

	case 2:
		localctx = NewUserWithHostContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8156)
			p.IdentifierOrString()
		}
		{
			p.SetState(8157)
			p.Match(StarRocksParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8158)
			p.IdentifierOrString()
		}

	case 3:
		localctx = NewUserWithHostAndBlanketContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8160)
			p.IdentifierOrString()
		}
		{
			p.SetState(8161)
			p.Match(StarRocksParserAT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8162)
			p.Match(StarRocksParserT__5)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8163)
			p.IdentifierOrString()
		}
		{
			p.SetState(8164)
			p.Match(StarRocksParserT__6)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentContext is an interface to support dynamic dispatch.
type IAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	EQ() antlr.TerminalNode
	ExpressionOrDefault() IExpressionOrDefaultContext

	// IsAssignmentContext differentiates from other interfaces.
	IsAssignmentContext()
}

type AssignmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentContext() *AssignmentContext {
	var p = new(AssignmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_assignment
	return p
}

func InitEmptyAssignmentContext(p *AssignmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_assignment
}

func (*AssignmentContext) IsAssignmentContext() {}

func NewAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentContext {
	var p = new(AssignmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_assignment

	return p
}

func (s *AssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AssignmentContext) EQ() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEQ, 0)
}

func (s *AssignmentContext) ExpressionOrDefault() IExpressionOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionOrDefaultContext)
}

func (s *AssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAssignment(s)
	}
}

func (s *AssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAssignment(s)
	}
}

func (p *StarRocksParser) Assignment() (localctx IAssignmentContext) {
	localctx = NewAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, StarRocksParserRULE_assignment)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8168)
		p.Identifier()
	}
	{
		p.SetState(8169)
		p.Match(StarRocksParserEQ)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(8170)
		p.ExpressionOrDefault()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAssignmentListContext is an interface to support dynamic dispatch.
type IAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAssignment() []IAssignmentContext
	Assignment(i int) IAssignmentContext

	// IsAssignmentListContext differentiates from other interfaces.
	IsAssignmentListContext()
}

type AssignmentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentListContext() *AssignmentListContext {
	var p = new(AssignmentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_assignmentList
	return p
}

func InitEmptyAssignmentListContext(p *AssignmentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_assignmentList
}

func (*AssignmentListContext) IsAssignmentListContext() {}

func NewAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentListContext {
	var p = new(AssignmentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_assignmentList

	return p
}

func (s *AssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentListContext) AllAssignment() []IAssignmentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAssignmentContext); ok {
			len++
		}
	}

	tst := make([]IAssignmentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAssignmentContext); ok {
			tst[i] = t.(IAssignmentContext)
			i++
		}
	}

	return tst
}

func (s *AssignmentListContext) Assignment(i int) IAssignmentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentContext)
}

func (s *AssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterAssignmentList(s)
	}
}

func (s *AssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitAssignmentList(s)
	}
}

func (p *StarRocksParser) AssignmentList() (localctx IAssignmentListContext) {
	localctx = NewAssignmentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1030, StarRocksParserRULE_assignmentList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8172)
		p.Assignment()
	}
	p.SetState(8177)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == StarRocksParserT__2 {
		{
			p.SetState(8173)
			p.Match(StarRocksParserT__2)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(8174)
			p.Assignment()
		}

		p.SetState(8179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumberContext is an interface to support dynamic dispatch.
type INumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsNumberContext differentiates from other interfaces.
	IsNumberContext()
}

type NumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumberContext() *NumberContext {
	var p = new(NumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_number
	return p
}

func InitEmptyNumberContext(p *NumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_number
}

func (*NumberContext) IsNumberContext() {}

func NewNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumberContext {
	var p = new(NumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_number

	return p
}

func (s *NumberContext) GetParser() antlr.Parser { return s.parser }

func (s *NumberContext) CopyAll(ctx *NumberContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *NumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type DecimalValueContext struct {
	NumberContext
}

func NewDecimalValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DecimalValueContext {
	var p = new(DecimalValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DecimalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalValueContext) DECIMAL_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECIMAL_VALUE, 0)
}

func (s *DecimalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDecimalValue(s)
	}
}

func (s *DecimalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDecimalValue(s)
	}
}

type IntegerValueContext struct {
	NumberContext
}

func NewIntegerValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntegerValueContext {
	var p = new(IntegerValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *IntegerValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerValueContext) INTEGER_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGER_VALUE, 0)
}

func (s *IntegerValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterIntegerValue(s)
	}
}

func (s *IntegerValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitIntegerValue(s)
	}
}

type DoubleValueContext struct {
	NumberContext
}

func NewDoubleValueContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DoubleValueContext {
	var p = new(DoubleValueContext)

	InitEmptyNumberContext(&p.NumberContext)
	p.parser = parser
	p.CopyAll(ctx.(*NumberContext))

	return p
}

func (s *DoubleValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DoubleValueContext) DOUBLE_VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOUBLE_VALUE, 0)
}

func (s *DoubleValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterDoubleValue(s)
	}
}

func (s *DoubleValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitDoubleValue(s)
	}
}

func (p *StarRocksParser) Number() (localctx INumberContext) {
	localctx = NewNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, StarRocksParserRULE_number)
	p.SetState(8183)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case StarRocksParserINTEGER_VALUE:
		localctx = NewIntegerValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(8180)
			p.Match(StarRocksParserINTEGER_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDECIMAL_VALUE:
		localctx = NewDecimalValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(8181)
			p.Match(StarRocksParserDECIMAL_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case StarRocksParserDOUBLE_VALUE:
		localctx = NewDoubleValueContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(8182)
			p.Match(StarRocksParserDOUBLE_VALUE)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonReservedContext is an interface to support dynamic dispatch.
type INonReservedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCESS() antlr.TerminalNode
	ACTIVE() antlr.TerminalNode
	ADVISOR() antlr.TerminalNode
	AFTER() antlr.TerminalNode
	AGGREGATE() antlr.TerminalNode
	APPLY() antlr.TerminalNode
	ASYNC() antlr.TerminalNode
	AUTHORS() antlr.TerminalNode
	AVG() antlr.TerminalNode
	ADMIN() antlr.TerminalNode
	ANTI() antlr.TerminalNode
	AUTHENTICATION() antlr.TerminalNode
	AUTO_INCREMENT() antlr.TerminalNode
	AUTOMATED() antlr.TerminalNode
	ARRAY_AGG() antlr.TerminalNode
	ARRAY_AGG_DISTINCT() antlr.TerminalNode
	BACKEND() antlr.TerminalNode
	BACKENDS() antlr.TerminalNode
	BACKUP() antlr.TerminalNode
	BEGIN() antlr.TerminalNode
	BITMAP_UNION() antlr.TerminalNode
	BLACKLIST() antlr.TerminalNode
	BLACKHOLE() antlr.TerminalNode
	BINARY() antlr.TerminalNode
	BODY() antlr.TerminalNode
	BOOLEAN() antlr.TerminalNode
	BRANCH() antlr.TerminalNode
	BROKER() antlr.TerminalNode
	BUCKETS() antlr.TerminalNode
	BUILTIN() antlr.TerminalNode
	BASE() antlr.TerminalNode
	BEFORE() antlr.TerminalNode
	BASELINE() antlr.TerminalNode
	CACHE() antlr.TerminalNode
	CAST() antlr.TerminalNode
	CANCEL() antlr.TerminalNode
	CATALOG() antlr.TerminalNode
	CATALOGS() antlr.TerminalNode
	CEIL() antlr.TerminalNode
	CHAIN() antlr.TerminalNode
	CHARSET() antlr.TerminalNode
	CLEAN() antlr.TerminalNode
	CLEAR() antlr.TerminalNode
	CLUSTER() antlr.TerminalNode
	CLUSTERS() antlr.TerminalNode
	CURRENT() antlr.TerminalNode
	COLLATION() antlr.TerminalNode
	COLUMNS() antlr.TerminalNode
	CUME_DIST() antlr.TerminalNode
	CUMULATIVE() antlr.TerminalNode
	COMMENT() antlr.TerminalNode
	COMMIT() antlr.TerminalNode
	COMMITTED() antlr.TerminalNode
	COMPUTE() antlr.TerminalNode
	CONNECTION() antlr.TerminalNode
	CONSISTENT() antlr.TerminalNode
	COSTS() antlr.TerminalNode
	COUNT() antlr.TerminalNode
	CONFIG() antlr.TerminalNode
	COMPACT() antlr.TerminalNode
	DATA() antlr.TerminalNode
	DATE() antlr.TerminalNode
	DATACACHE() antlr.TerminalNode
	DATETIME() antlr.TerminalNode
	DAY() antlr.TerminalNode
	DAYS() antlr.TerminalNode
	DECOMMISSION() antlr.TerminalNode
	DIALECT() antlr.TerminalNode
	DISABLE() antlr.TerminalNode
	DISK() antlr.TerminalNode
	DISTRIBUTION() antlr.TerminalNode
	DUPLICATE() antlr.TerminalNode
	DYNAMIC() antlr.TerminalNode
	DISTRIBUTED() antlr.TerminalNode
	DICTIONARY() antlr.TerminalNode
	DICTIONARY_GET() antlr.TerminalNode
	DEALLOCATE() antlr.TerminalNode
	ENABLE() antlr.TerminalNode
	END() antlr.TerminalNode
	ENGINE() antlr.TerminalNode
	ENGINES() antlr.TerminalNode
	ERRORS() antlr.TerminalNode
	EVENTS() antlr.TerminalNode
	EXECUTE() antlr.TerminalNode
	EXTERNAL() antlr.TerminalNode
	EXTRACT() antlr.TerminalNode
	EVERY() antlr.TerminalNode
	ENCLOSE() antlr.TerminalNode
	ESCAPE() antlr.TerminalNode
	EXPORT() antlr.TerminalNode
	FAILPOINT() antlr.TerminalNode
	FAILPOINTS() antlr.TerminalNode
	FIELDS() antlr.TerminalNode
	FILE() antlr.TerminalNode
	FILTER() antlr.TerminalNode
	FIRST() antlr.TerminalNode
	FLOOR() antlr.TerminalNode
	FOLLOWING() antlr.TerminalNode
	FORMAT() antlr.TerminalNode
	FN() antlr.TerminalNode
	FRONTEND() antlr.TerminalNode
	FRONTENDS() antlr.TerminalNode
	FOLLOWER() antlr.TerminalNode
	FREE() antlr.TerminalNode
	FUNCTIONS() antlr.TerminalNode
	GLOBAL() antlr.TerminalNode
	GRANTS() antlr.TerminalNode
	GROUP_CONCAT() antlr.TerminalNode
	HASH() antlr.TerminalNode
	HISTOGRAM() antlr.TerminalNode
	HELP() antlr.TerminalNode
	HLL_UNION() antlr.TerminalNode
	HOST() antlr.TerminalNode
	HOUR() antlr.TerminalNode
	HOURS() antlr.TerminalNode
	HUB() antlr.TerminalNode
	IDENTIFIED() antlr.TerminalNode
	IMAGE() antlr.TerminalNode
	IMPERSONATE() antlr.TerminalNode
	INACTIVE() antlr.TerminalNode
	INCREMENTAL() antlr.TerminalNode
	INDEXES() antlr.TerminalNode
	INSTALL() antlr.TerminalNode
	INTEGRATION() antlr.TerminalNode
	INTEGRATIONS() antlr.TerminalNode
	INTERMEDIATE() antlr.TerminalNode
	INTERVAL() antlr.TerminalNode
	ISOLATION() antlr.TerminalNode
	JOB() antlr.TerminalNode
	LABEL() antlr.TerminalNode
	LAST() antlr.TerminalNode
	LESS() antlr.TerminalNode
	LEVEL() antlr.TerminalNode
	LIST() antlr.TerminalNode
	LOCAL() antlr.TerminalNode
	LOCATION() antlr.TerminalNode
	LOGS() antlr.TerminalNode
	LOGICAL() antlr.TerminalNode
	LOW_PRIORITY() antlr.TerminalNode
	LOCK() antlr.TerminalNode
	LOCATIONS() antlr.TerminalNode
	MANUAL() antlr.TerminalNode
	MAP() antlr.TerminalNode
	MAPPING() antlr.TerminalNode
	MAPPINGS() antlr.TerminalNode
	MASKING() antlr.TerminalNode
	MATCH() antlr.TerminalNode
	MATERIALIZED() antlr.TerminalNode
	MAX() antlr.TerminalNode
	META() antlr.TerminalNode
	MIN() antlr.TerminalNode
	MINUTE() antlr.TerminalNode
	MINUTES() antlr.TerminalNode
	MODE() antlr.TerminalNode
	MODIFY() antlr.TerminalNode
	MONTH() antlr.TerminalNode
	MERGE() antlr.TerminalNode
	MINUS() antlr.TerminalNode
	MULTIPLE() antlr.TerminalNode
	NAME() antlr.TerminalNode
	NAMES() antlr.TerminalNode
	NEGATIVE() antlr.TerminalNode
	NO() antlr.TerminalNode
	NODE() antlr.TerminalNode
	NODES() antlr.TerminalNode
	NONE() antlr.TerminalNode
	NULLS() antlr.TerminalNode
	NUMBER() antlr.TerminalNode
	NUMERIC() antlr.TerminalNode
	OBSERVER() antlr.TerminalNode
	OF() antlr.TerminalNode
	OFFSET() antlr.TerminalNode
	ONLY() antlr.TerminalNode
	OPTIMIZER() antlr.TerminalNode
	OPEN() antlr.TerminalNode
	OPERATE() antlr.TerminalNode
	OPTION() antlr.TerminalNode
	OVERWRITE() antlr.TerminalNode
	OFF() antlr.TerminalNode
	PARTITIONS() antlr.TerminalNode
	PASSWORD() antlr.TerminalNode
	PATH() antlr.TerminalNode
	PAUSE() antlr.TerminalNode
	PENDING() antlr.TerminalNode
	PERCENTILE_UNION() antlr.TerminalNode
	PIVOT() antlr.TerminalNode
	PLAN() antlr.TerminalNode
	PLUGIN() antlr.TerminalNode
	PLUGINS() antlr.TerminalNode
	POLICY() antlr.TerminalNode
	POLICIES() antlr.TerminalNode
	PERCENT_RANK() antlr.TerminalNode
	PREDICATE() antlr.TerminalNode
	PRECEDING() antlr.TerminalNode
	PRIORITY() antlr.TerminalNode
	PROC() antlr.TerminalNode
	PROCESSLIST() antlr.TerminalNode
	PROFILE() antlr.TerminalNode
	PROFILELIST() antlr.TerminalNode
	PROVIDER() antlr.TerminalNode
	PROVIDERS() antlr.TerminalNode
	PRIVILEGES() antlr.TerminalNode
	PROBABILITY() antlr.TerminalNode
	PROPERTIES() antlr.TerminalNode
	PROPERTY() antlr.TerminalNode
	PIPE() antlr.TerminalNode
	PIPES() antlr.TerminalNode
	QUARTER() antlr.TerminalNode
	QUERY() antlr.TerminalNode
	QUERIES() antlr.TerminalNode
	QUEUE() antlr.TerminalNode
	QUOTA() antlr.TerminalNode
	QUALIFY() antlr.TerminalNode
	REASON() antlr.TerminalNode
	REMOVE() antlr.TerminalNode
	REWRITE() antlr.TerminalNode
	RANDOM() antlr.TerminalNode
	RANK() antlr.TerminalNode
	RECOVER() antlr.TerminalNode
	REFRESH() antlr.TerminalNode
	REPAIR() antlr.TerminalNode
	REPEATABLE() antlr.TerminalNode
	REPLACE_IF_NOT_NULL() antlr.TerminalNode
	REPLICA() antlr.TerminalNode
	REPOSITORY() antlr.TerminalNode
	REPOSITORIES() antlr.TerminalNode
	RESOURCE() antlr.TerminalNode
	RESOURCES() antlr.TerminalNode
	RESTORE() antlr.TerminalNode
	RESUME() antlr.TerminalNode
	RETAIN() antlr.TerminalNode
	RETENTION() antlr.TerminalNode
	RETURNS() antlr.TerminalNode
	RETRY() antlr.TerminalNode
	REVERT() antlr.TerminalNode
	ROLE() antlr.TerminalNode
	ROLES() antlr.TerminalNode
	ROLLUP() antlr.TerminalNode
	ROLLBACK() antlr.TerminalNode
	ROUTINE() antlr.TerminalNode
	ROW() antlr.TerminalNode
	RUNNING() antlr.TerminalNode
	RULE() antlr.TerminalNode
	RULES() antlr.TerminalNode
	SAMPLE() antlr.TerminalNode
	SCHEDULE() antlr.TerminalNode
	SCHEDULER() antlr.TerminalNode
	SECOND() antlr.TerminalNode
	SECURITY() antlr.TerminalNode
	SEPARATOR() antlr.TerminalNode
	SERIALIZABLE() antlr.TerminalNode
	SEMI() antlr.TerminalNode
	SESSION() antlr.TerminalNode
	SETS() antlr.TerminalNode
	SIGNED() antlr.TerminalNode
	SNAPSHOT() antlr.TerminalNode
	SNAPSHOTS() antlr.TerminalNode
	SQLBLACKLIST() antlr.TerminalNode
	START() antlr.TerminalNode
	STARROCKS() antlr.TerminalNode
	STREAM() antlr.TerminalNode
	SUM() antlr.TerminalNode
	STATUS() antlr.TerminalNode
	STOP() antlr.TerminalNode
	SKIP_HEADER() antlr.TerminalNode
	SWAP() antlr.TerminalNode
	STORAGE() antlr.TerminalNode
	STRING() antlr.TerminalNode
	STRUCT() antlr.TerminalNode
	STATS() antlr.TerminalNode
	SUBMIT() antlr.TerminalNode
	SUSPEND() antlr.TerminalNode
	SYNC() antlr.TerminalNode
	SYSTEM_TIME() antlr.TerminalNode
	TABLES() antlr.TerminalNode
	TABLET() antlr.TerminalNode
	TABLETS() antlr.TerminalNode
	TAG() antlr.TerminalNode
	TASK() antlr.TerminalNode
	TEMPORARY() antlr.TerminalNode
	TIMESTAMP() antlr.TerminalNode
	TIMESTAMPADD() antlr.TerminalNode
	TIMESTAMPDIFF() antlr.TerminalNode
	THAN() antlr.TerminalNode
	TIME() antlr.TerminalNode
	TIMES() antlr.TerminalNode
	TRANSACTION() antlr.TerminalNode
	TRACE() antlr.TerminalNode
	TRANSLATE() antlr.TerminalNode
	TRIM_SPACE() antlr.TerminalNode
	TRIGGERS() antlr.TerminalNode
	TRUNCATE() antlr.TerminalNode
	TYPE() antlr.TerminalNode
	TYPES() antlr.TerminalNode
	UNBOUNDED() antlr.TerminalNode
	UNCOMMITTED() antlr.TerminalNode
	UNSET() antlr.TerminalNode
	UNINSTALL() antlr.TerminalNode
	USAGE() antlr.TerminalNode
	USER() antlr.TerminalNode
	USERS() antlr.TerminalNode
	UNLOCK() antlr.TerminalNode
	VALUE() antlr.TerminalNode
	VARBINARY() antlr.TerminalNode
	VARIABLES() antlr.TerminalNode
	VIEW() antlr.TerminalNode
	VIEWS() antlr.TerminalNode
	VERBOSE() antlr.TerminalNode
	VERSION() antlr.TerminalNode
	VOLUME() antlr.TerminalNode
	VOLUMES() antlr.TerminalNode
	WARNINGS() antlr.TerminalNode
	WEEK() antlr.TerminalNode
	WHITELIST() antlr.TerminalNode
	WORK() antlr.TerminalNode
	WRITE() antlr.TerminalNode
	WAREHOUSE() antlr.TerminalNode
	WAREHOUSES() antlr.TerminalNode
	YEAR() antlr.TerminalNode
	DOTDOTDOT() antlr.TerminalNode
	NGRAMBF() antlr.TerminalNode
	VECTOR() antlr.TerminalNode
	FIELD() antlr.TerminalNode
	ARRAY_ELEMENT() antlr.TerminalNode
	PERSISTENT() antlr.TerminalNode

	// IsNonReservedContext differentiates from other interfaces.
	IsNonReservedContext()
}

type NonReservedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonReservedContext() *NonReservedContext {
	var p = new(NonReservedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_nonReserved
	return p
}

func InitEmptyNonReservedContext(p *NonReservedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = StarRocksParserRULE_nonReserved
}

func (*NonReservedContext) IsNonReservedContext() {}

func NewNonReservedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonReservedContext {
	var p = new(NonReservedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = StarRocksParserRULE_nonReserved

	return p
}

func (s *NonReservedContext) GetParser() antlr.Parser { return s.parser }

func (s *NonReservedContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserACCESS, 0)
}

func (s *NonReservedContext) ACTIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserACTIVE, 0)
}

func (s *NonReservedContext) ADVISOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADVISOR, 0)
}

func (s *NonReservedContext) AFTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAFTER, 0)
}

func (s *NonReservedContext) AGGREGATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAGGREGATE, 0)
}

func (s *NonReservedContext) APPLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAPPLY, 0)
}

func (s *NonReservedContext) ASYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserASYNC, 0)
}

func (s *NonReservedContext) AUTHORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHORS, 0)
}

func (s *NonReservedContext) AVG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAVG, 0)
}

func (s *NonReservedContext) ADMIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserADMIN, 0)
}

func (s *NonReservedContext) ANTI() antlr.TerminalNode {
	return s.GetToken(StarRocksParserANTI, 0)
}

func (s *NonReservedContext) AUTHENTICATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTHENTICATION, 0)
}

func (s *NonReservedContext) AUTO_INCREMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTO_INCREMENT, 0)
}

func (s *NonReservedContext) AUTOMATED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserAUTOMATED, 0)
}

func (s *NonReservedContext) ARRAY_AGG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_AGG, 0)
}

func (s *NonReservedContext) ARRAY_AGG_DISTINCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_AGG_DISTINCT, 0)
}

func (s *NonReservedContext) BACKEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKEND, 0)
}

func (s *NonReservedContext) BACKENDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKENDS, 0)
}

func (s *NonReservedContext) BACKUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBACKUP, 0)
}

func (s *NonReservedContext) BEGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBEGIN, 0)
}

func (s *NonReservedContext) BITMAP_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBITMAP_UNION, 0)
}

func (s *NonReservedContext) BLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKLIST, 0)
}

func (s *NonReservedContext) BLACKHOLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBLACKHOLE, 0)
}

func (s *NonReservedContext) BINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBINARY, 0)
}

func (s *NonReservedContext) BODY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBODY, 0)
}

func (s *NonReservedContext) BOOLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBOOLEAN, 0)
}

func (s *NonReservedContext) BRANCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBRANCH, 0)
}

func (s *NonReservedContext) BROKER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBROKER, 0)
}

func (s *NonReservedContext) BUCKETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUCKETS, 0)
}

func (s *NonReservedContext) BUILTIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBUILTIN, 0)
}

func (s *NonReservedContext) BASE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASE, 0)
}

func (s *NonReservedContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBEFORE, 0)
}

func (s *NonReservedContext) BASELINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserBASELINE, 0)
}

func (s *NonReservedContext) CACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCACHE, 0)
}

func (s *NonReservedContext) CAST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCAST, 0)
}

func (s *NonReservedContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCANCEL, 0)
}

func (s *NonReservedContext) CATALOG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOG, 0)
}

func (s *NonReservedContext) CATALOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCATALOGS, 0)
}

func (s *NonReservedContext) CEIL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCEIL, 0)
}

func (s *NonReservedContext) CHAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHAIN, 0)
}

func (s *NonReservedContext) CHARSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCHARSET, 0)
}

func (s *NonReservedContext) CLEAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAN, 0)
}

func (s *NonReservedContext) CLEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLEAR, 0)
}

func (s *NonReservedContext) CLUSTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTER, 0)
}

func (s *NonReservedContext) CLUSTERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCLUSTERS, 0)
}

func (s *NonReservedContext) CURRENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCURRENT, 0)
}

func (s *NonReservedContext) COLLATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLLATION, 0)
}

func (s *NonReservedContext) COLUMNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOLUMNS, 0)
}

func (s *NonReservedContext) CUME_DIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUME_DIST, 0)
}

func (s *NonReservedContext) CUMULATIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCUMULATIVE, 0)
}

func (s *NonReservedContext) COMMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMENT, 0)
}

func (s *NonReservedContext) COMMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMIT, 0)
}

func (s *NonReservedContext) COMMITTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMMITTED, 0)
}

func (s *NonReservedContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPUTE, 0)
}

func (s *NonReservedContext) CONNECTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONNECTION, 0)
}

func (s *NonReservedContext) CONSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONSISTENT, 0)
}

func (s *NonReservedContext) COSTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOSTS, 0)
}

func (s *NonReservedContext) COUNT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOUNT, 0)
}

func (s *NonReservedContext) CONFIG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCONFIG, 0)
}

func (s *NonReservedContext) COMPACT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserCOMPACT, 0)
}

func (s *NonReservedContext) DATA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATA, 0)
}

func (s *NonReservedContext) DATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATE, 0)
}

func (s *NonReservedContext) DATACACHE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATACACHE, 0)
}

func (s *NonReservedContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDATETIME, 0)
}

func (s *NonReservedContext) DAY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAY, 0)
}

func (s *NonReservedContext) DAYS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDAYS, 0)
}

func (s *NonReservedContext) DECOMMISSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDECOMMISSION, 0)
}

func (s *NonReservedContext) DIALECT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDIALECT, 0)
}

func (s *NonReservedContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISABLE, 0)
}

func (s *NonReservedContext) DISK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISK, 0)
}

func (s *NonReservedContext) DISTRIBUTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTION, 0)
}

func (s *NonReservedContext) DUPLICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDUPLICATE, 0)
}

func (s *NonReservedContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDYNAMIC, 0)
}

func (s *NonReservedContext) DISTRIBUTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDISTRIBUTED, 0)
}

func (s *NonReservedContext) DICTIONARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY, 0)
}

func (s *NonReservedContext) DICTIONARY_GET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDICTIONARY_GET, 0)
}

func (s *NonReservedContext) DEALLOCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDEALLOCATE, 0)
}

func (s *NonReservedContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENABLE, 0)
}

func (s *NonReservedContext) END() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEND, 0)
}

func (s *NonReservedContext) ENGINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENGINE, 0)
}

func (s *NonReservedContext) ENGINES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENGINES, 0)
}

func (s *NonReservedContext) ERRORS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserERRORS, 0)
}

func (s *NonReservedContext) EVENTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVENTS, 0)
}

func (s *NonReservedContext) EXECUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXECUTE, 0)
}

func (s *NonReservedContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTERNAL, 0)
}

func (s *NonReservedContext) EXTRACT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXTRACT, 0)
}

func (s *NonReservedContext) EVERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEVERY, 0)
}

func (s *NonReservedContext) ENCLOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserENCLOSE, 0)
}

func (s *NonReservedContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserESCAPE, 0)
}

func (s *NonReservedContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserEXPORT, 0)
}

func (s *NonReservedContext) FAILPOINT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFAILPOINT, 0)
}

func (s *NonReservedContext) FAILPOINTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFAILPOINTS, 0)
}

func (s *NonReservedContext) FIELDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELDS, 0)
}

func (s *NonReservedContext) FILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILE, 0)
}

func (s *NonReservedContext) FILTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFILTER, 0)
}

func (s *NonReservedContext) FIRST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIRST, 0)
}

func (s *NonReservedContext) FLOOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFLOOR, 0)
}

func (s *NonReservedContext) FOLLOWING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWING, 0)
}

func (s *NonReservedContext) FORMAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFORMAT, 0)
}

func (s *NonReservedContext) FN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFN, 0)
}

func (s *NonReservedContext) FRONTEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTEND, 0)
}

func (s *NonReservedContext) FRONTENDS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFRONTENDS, 0)
}

func (s *NonReservedContext) FOLLOWER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFOLLOWER, 0)
}

func (s *NonReservedContext) FREE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFREE, 0)
}

func (s *NonReservedContext) FUNCTIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFUNCTIONS, 0)
}

func (s *NonReservedContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGLOBAL, 0)
}

func (s *NonReservedContext) GRANTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGRANTS, 0)
}

func (s *NonReservedContext) GROUP_CONCAT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserGROUP_CONCAT, 0)
}

func (s *NonReservedContext) HASH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHASH, 0)
}

func (s *NonReservedContext) HISTOGRAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHISTOGRAM, 0)
}

func (s *NonReservedContext) HELP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHELP, 0)
}

func (s *NonReservedContext) HLL_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHLL_UNION, 0)
}

func (s *NonReservedContext) HOST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOST, 0)
}

func (s *NonReservedContext) HOUR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOUR, 0)
}

func (s *NonReservedContext) HOURS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHOURS, 0)
}

func (s *NonReservedContext) HUB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserHUB, 0)
}

func (s *NonReservedContext) IDENTIFIED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIDENTIFIED, 0)
}

func (s *NonReservedContext) IMAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMAGE, 0)
}

func (s *NonReservedContext) IMPERSONATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserIMPERSONATE, 0)
}

func (s *NonReservedContext) INACTIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINACTIVE, 0)
}

func (s *NonReservedContext) INCREMENTAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINCREMENTAL, 0)
}

func (s *NonReservedContext) INDEXES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINDEXES, 0)
}

func (s *NonReservedContext) INSTALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINSTALL, 0)
}

func (s *NonReservedContext) INTEGRATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATION, 0)
}

func (s *NonReservedContext) INTEGRATIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTEGRATIONS, 0)
}

func (s *NonReservedContext) INTERMEDIATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERMEDIATE, 0)
}

func (s *NonReservedContext) INTERVAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserINTERVAL, 0)
}

func (s *NonReservedContext) ISOLATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserISOLATION, 0)
}

func (s *NonReservedContext) JOB() antlr.TerminalNode {
	return s.GetToken(StarRocksParserJOB, 0)
}

func (s *NonReservedContext) LABEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLABEL, 0)
}

func (s *NonReservedContext) LAST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLAST, 0)
}

func (s *NonReservedContext) LESS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLESS, 0)
}

func (s *NonReservedContext) LEVEL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLEVEL, 0)
}

func (s *NonReservedContext) LIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLIST, 0)
}

func (s *NonReservedContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCAL, 0)
}

func (s *NonReservedContext) LOCATION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCATION, 0)
}

func (s *NonReservedContext) LOGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGS, 0)
}

func (s *NonReservedContext) LOGICAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOGICAL, 0)
}

func (s *NonReservedContext) LOW_PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOW_PRIORITY, 0)
}

func (s *NonReservedContext) LOCK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCK, 0)
}

func (s *NonReservedContext) LOCATIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserLOCATIONS, 0)
}

func (s *NonReservedContext) MANUAL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMANUAL, 0)
}

func (s *NonReservedContext) MAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAP, 0)
}

func (s *NonReservedContext) MAPPING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAPPING, 0)
}

func (s *NonReservedContext) MAPPINGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAPPINGS, 0)
}

func (s *NonReservedContext) MASKING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMASKING, 0)
}

func (s *NonReservedContext) MATCH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATCH, 0)
}

func (s *NonReservedContext) MATERIALIZED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMATERIALIZED, 0)
}

func (s *NonReservedContext) MAX() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMAX, 0)
}

func (s *NonReservedContext) META() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMETA, 0)
}

func (s *NonReservedContext) MIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMIN, 0)
}

func (s *NonReservedContext) MINUTE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTE, 0)
}

func (s *NonReservedContext) MINUTES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUTES, 0)
}

func (s *NonReservedContext) MODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODE, 0)
}

func (s *NonReservedContext) MODIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMODIFY, 0)
}

func (s *NonReservedContext) MONTH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMONTH, 0)
}

func (s *NonReservedContext) MERGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMERGE, 0)
}

func (s *NonReservedContext) MINUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMINUS, 0)
}

func (s *NonReservedContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserMULTIPLE, 0)
}

func (s *NonReservedContext) NAME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNAME, 0)
}

func (s *NonReservedContext) NAMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNAMES, 0)
}

func (s *NonReservedContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNEGATIVE, 0)
}

func (s *NonReservedContext) NO() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNO, 0)
}

func (s *NonReservedContext) NODE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODE, 0)
}

func (s *NonReservedContext) NODES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNODES, 0)
}

func (s *NonReservedContext) NONE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNONE, 0)
}

func (s *NonReservedContext) NULLS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNULLS, 0)
}

func (s *NonReservedContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNUMBER, 0)
}

func (s *NonReservedContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNUMERIC, 0)
}

func (s *NonReservedContext) OBSERVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOBSERVER, 0)
}

func (s *NonReservedContext) OF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOF, 0)
}

func (s *NonReservedContext) OFFSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOFFSET, 0)
}

func (s *NonReservedContext) ONLY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserONLY, 0)
}

func (s *NonReservedContext) OPTIMIZER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTIMIZER, 0)
}

func (s *NonReservedContext) OPEN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPEN, 0)
}

func (s *NonReservedContext) OPERATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPERATE, 0)
}

func (s *NonReservedContext) OPTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOPTION, 0)
}

func (s *NonReservedContext) OVERWRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOVERWRITE, 0)
}

func (s *NonReservedContext) OFF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserOFF, 0)
}

func (s *NonReservedContext) PARTITIONS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPARTITIONS, 0)
}

func (s *NonReservedContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPASSWORD, 0)
}

func (s *NonReservedContext) PATH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPATH, 0)
}

func (s *NonReservedContext) PAUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPAUSE, 0)
}

func (s *NonReservedContext) PENDING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPENDING, 0)
}

func (s *NonReservedContext) PERCENTILE_UNION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENTILE_UNION, 0)
}

func (s *NonReservedContext) PIVOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIVOT, 0)
}

func (s *NonReservedContext) PLAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLAN, 0)
}

func (s *NonReservedContext) PLUGIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGIN, 0)
}

func (s *NonReservedContext) PLUGINS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPLUGINS, 0)
}

func (s *NonReservedContext) POLICY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPOLICY, 0)
}

func (s *NonReservedContext) POLICIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPOLICIES, 0)
}

func (s *NonReservedContext) PERCENT_RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERCENT_RANK, 0)
}

func (s *NonReservedContext) PREDICATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPREDICATE, 0)
}

func (s *NonReservedContext) PRECEDING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRECEDING, 0)
}

func (s *NonReservedContext) PRIORITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIORITY, 0)
}

func (s *NonReservedContext) PROC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROC, 0)
}

func (s *NonReservedContext) PROCESSLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROCESSLIST, 0)
}

func (s *NonReservedContext) PROFILE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROFILE, 0)
}

func (s *NonReservedContext) PROFILELIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROFILELIST, 0)
}

func (s *NonReservedContext) PROVIDER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDER, 0)
}

func (s *NonReservedContext) PROVIDERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROVIDERS, 0)
}

func (s *NonReservedContext) PRIVILEGES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPRIVILEGES, 0)
}

func (s *NonReservedContext) PROBABILITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROBABILITY, 0)
}

func (s *NonReservedContext) PROPERTIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTIES, 0)
}

func (s *NonReservedContext) PROPERTY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPROPERTY, 0)
}

func (s *NonReservedContext) PIPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPE, 0)
}

func (s *NonReservedContext) PIPES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPIPES, 0)
}

func (s *NonReservedContext) QUARTER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUARTER, 0)
}

func (s *NonReservedContext) QUERY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUERY, 0)
}

func (s *NonReservedContext) QUERIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUERIES, 0)
}

func (s *NonReservedContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUEUE, 0)
}

func (s *NonReservedContext) QUOTA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUOTA, 0)
}

func (s *NonReservedContext) QUALIFY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserQUALIFY, 0)
}

func (s *NonReservedContext) REASON() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREASON, 0)
}

func (s *NonReservedContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREMOVE, 0)
}

func (s *NonReservedContext) REWRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREWRITE, 0)
}

func (s *NonReservedContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANDOM, 0)
}

func (s *NonReservedContext) RANK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRANK, 0)
}

func (s *NonReservedContext) RECOVER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRECOVER, 0)
}

func (s *NonReservedContext) REFRESH() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREFRESH, 0)
}

func (s *NonReservedContext) REPAIR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPAIR, 0)
}

func (s *NonReservedContext) REPEATABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPEATABLE, 0)
}

func (s *NonReservedContext) REPLACE_IF_NOT_NULL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLACE_IF_NOT_NULL, 0)
}

func (s *NonReservedContext) REPLICA() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPLICA, 0)
}

func (s *NonReservedContext) REPOSITORY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORY, 0)
}

func (s *NonReservedContext) REPOSITORIES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREPOSITORIES, 0)
}

func (s *NonReservedContext) RESOURCE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCE, 0)
}

func (s *NonReservedContext) RESOURCES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESOURCES, 0)
}

func (s *NonReservedContext) RESTORE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESTORE, 0)
}

func (s *NonReservedContext) RESUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRESUME, 0)
}

func (s *NonReservedContext) RETAIN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETAIN, 0)
}

func (s *NonReservedContext) RETENTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETENTION, 0)
}

func (s *NonReservedContext) RETURNS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETURNS, 0)
}

func (s *NonReservedContext) RETRY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRETRY, 0)
}

func (s *NonReservedContext) REVERT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserREVERT, 0)
}

func (s *NonReservedContext) ROLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLE, 0)
}

func (s *NonReservedContext) ROLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLES, 0)
}

func (s *NonReservedContext) ROLLUP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLUP, 0)
}

func (s *NonReservedContext) ROLLBACK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROLLBACK, 0)
}

func (s *NonReservedContext) ROUTINE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROUTINE, 0)
}

func (s *NonReservedContext) ROW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserROW, 0)
}

func (s *NonReservedContext) RUNNING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRUNNING, 0)
}

func (s *NonReservedContext) RULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULE, 0)
}

func (s *NonReservedContext) RULES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserRULES, 0)
}

func (s *NonReservedContext) SAMPLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSAMPLE, 0)
}

func (s *NonReservedContext) SCHEDULE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULE, 0)
}

func (s *NonReservedContext) SCHEDULER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSCHEDULER, 0)
}

func (s *NonReservedContext) SECOND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECOND, 0)
}

func (s *NonReservedContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSECURITY, 0)
}

func (s *NonReservedContext) SEPARATOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEPARATOR, 0)
}

func (s *NonReservedContext) SERIALIZABLE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSERIALIZABLE, 0)
}

func (s *NonReservedContext) SEMI() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSEMI, 0)
}

func (s *NonReservedContext) SESSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSESSION, 0)
}

func (s *NonReservedContext) SETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSETS, 0)
}

func (s *NonReservedContext) SIGNED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSIGNED, 0)
}

func (s *NonReservedContext) SNAPSHOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOT, 0)
}

func (s *NonReservedContext) SNAPSHOTS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSNAPSHOTS, 0)
}

func (s *NonReservedContext) SQLBLACKLIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSQLBLACKLIST, 0)
}

func (s *NonReservedContext) START() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTART, 0)
}

func (s *NonReservedContext) STARROCKS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTARROCKS, 0)
}

func (s *NonReservedContext) STREAM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTREAM, 0)
}

func (s *NonReservedContext) SUM() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUM, 0)
}

func (s *NonReservedContext) STATUS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATUS, 0)
}

func (s *NonReservedContext) STOP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTOP, 0)
}

func (s *NonReservedContext) SKIP_HEADER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSKIP_HEADER, 0)
}

func (s *NonReservedContext) SWAP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSWAP, 0)
}

func (s *NonReservedContext) STORAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTORAGE, 0)
}

func (s *NonReservedContext) STRING() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTRING, 0)
}

func (s *NonReservedContext) STRUCT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTRUCT, 0)
}

func (s *NonReservedContext) STATS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSTATS, 0)
}

func (s *NonReservedContext) SUBMIT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUBMIT, 0)
}

func (s *NonReservedContext) SUSPEND() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSUSPEND, 0)
}

func (s *NonReservedContext) SYNC() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYNC, 0)
}

func (s *NonReservedContext) SYSTEM_TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserSYSTEM_TIME, 0)
}

func (s *NonReservedContext) TABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLES, 0)
}

func (s *NonReservedContext) TABLET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLET, 0)
}

func (s *NonReservedContext) TABLETS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTABLETS, 0)
}

func (s *NonReservedContext) TAG() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTAG, 0)
}

func (s *NonReservedContext) TASK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTASK, 0)
}

func (s *NonReservedContext) TEMPORARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTEMPORARY, 0)
}

func (s *NonReservedContext) TIMESTAMP() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMP, 0)
}

func (s *NonReservedContext) TIMESTAMPADD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMPADD, 0)
}

func (s *NonReservedContext) TIMESTAMPDIFF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMESTAMPDIFF, 0)
}

func (s *NonReservedContext) THAN() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTHAN, 0)
}

func (s *NonReservedContext) TIME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIME, 0)
}

func (s *NonReservedContext) TIMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTIMES, 0)
}

func (s *NonReservedContext) TRANSACTION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSACTION, 0)
}

func (s *NonReservedContext) TRACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRACE, 0)
}

func (s *NonReservedContext) TRANSLATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRANSLATE, 0)
}

func (s *NonReservedContext) TRIM_SPACE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRIM_SPACE, 0)
}

func (s *NonReservedContext) TRIGGERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRIGGERS, 0)
}

func (s *NonReservedContext) TRUNCATE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTRUNCATE, 0)
}

func (s *NonReservedContext) TYPE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTYPE, 0)
}

func (s *NonReservedContext) TYPES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserTYPES, 0)
}

func (s *NonReservedContext) UNBOUNDED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNBOUNDED, 0)
}

func (s *NonReservedContext) UNCOMMITTED() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNCOMMITTED, 0)
}

func (s *NonReservedContext) UNSET() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNSET, 0)
}

func (s *NonReservedContext) UNINSTALL() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNINSTALL, 0)
}

func (s *NonReservedContext) USAGE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSAGE, 0)
}

func (s *NonReservedContext) USER() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSER, 0)
}

func (s *NonReservedContext) USERS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUSERS, 0)
}

func (s *NonReservedContext) UNLOCK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserUNLOCK, 0)
}

func (s *NonReservedContext) VALUE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVALUE, 0)
}

func (s *NonReservedContext) VARBINARY() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARBINARY, 0)
}

func (s *NonReservedContext) VARIABLES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVARIABLES, 0)
}

func (s *NonReservedContext) VIEW() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEW, 0)
}

func (s *NonReservedContext) VIEWS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVIEWS, 0)
}

func (s *NonReservedContext) VERBOSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERBOSE, 0)
}

func (s *NonReservedContext) VERSION() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVERSION, 0)
}

func (s *NonReservedContext) VOLUME() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUME, 0)
}

func (s *NonReservedContext) VOLUMES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVOLUMES, 0)
}

func (s *NonReservedContext) WARNINGS() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWARNINGS, 0)
}

func (s *NonReservedContext) WEEK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWEEK, 0)
}

func (s *NonReservedContext) WHITELIST() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWHITELIST, 0)
}

func (s *NonReservedContext) WORK() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWORK, 0)
}

func (s *NonReservedContext) WRITE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWRITE, 0)
}

func (s *NonReservedContext) WAREHOUSE() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSE, 0)
}

func (s *NonReservedContext) WAREHOUSES() antlr.TerminalNode {
	return s.GetToken(StarRocksParserWAREHOUSES, 0)
}

func (s *NonReservedContext) YEAR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserYEAR, 0)
}

func (s *NonReservedContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserDOTDOTDOT, 0)
}

func (s *NonReservedContext) NGRAMBF() antlr.TerminalNode {
	return s.GetToken(StarRocksParserNGRAMBF, 0)
}

func (s *NonReservedContext) VECTOR() antlr.TerminalNode {
	return s.GetToken(StarRocksParserVECTOR, 0)
}

func (s *NonReservedContext) FIELD() antlr.TerminalNode {
	return s.GetToken(StarRocksParserFIELD, 0)
}

func (s *NonReservedContext) ARRAY_ELEMENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserARRAY_ELEMENT, 0)
}

func (s *NonReservedContext) PERSISTENT() antlr.TerminalNode {
	return s.GetToken(StarRocksParserPERSISTENT, 0)
}

func (s *NonReservedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonReservedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonReservedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.EnterNonReserved(s)
	}
}

func (s *NonReservedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(StarRocksListener); ok {
		listenerT.ExitNonReserved(s)
	}
}

func (p *StarRocksParser) NonReserved() (localctx INonReservedContext) {
	localctx = NewNonReservedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, StarRocksParserRULE_nonReserved)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(8185)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-325409262756702208) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&7557330222697660093) != 0) || ((int64((_la-132)) & ^0x3f) == 0 && ((int64(1)<<(_la-132))&-4653295000587626501) != 0) || ((int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&-3747053846437727955) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&8790990742223650807) != 0) || ((int64((_la-326)) & ^0x3f) == 0 && ((int64(1)<<(_la-326))&-5479769140411580417) != 0) || ((int64((_la-390)) & ^0x3f) == 0 && ((int64(1)<<(_la-390))&3742173942658366679) != 0) || ((int64((_la-454)) & ^0x3f) == 0 && ((int64(1)<<(_la-454))&8856199495341) != 0) || _la == StarRocksParserDOTDOTDOT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *StarRocksParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 378:
		var t *QueryPrimaryContext = nil
		if localctx != nil {
			t = localctx.(*QueryPrimaryContext)
		}
		return p.QueryPrimary_Sempred(t, predIndex)

	case 421:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 423:
		var t *BooleanExpressionContext = nil
		if localctx != nil {
			t = localctx.(*BooleanExpressionContext)
		}
		return p.BooleanExpression_Sempred(t, predIndex)

	case 427:
		var t *ValueExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ValueExpressionContext)
		}
		return p.ValueExpression_Sempred(t, predIndex)

	case 428:
		var t *PrimaryExpressionContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryExpressionContext)
		}
		return p.PrimaryExpression_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *StarRocksParser) QueryPrimary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StarRocksParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StarRocksParser) BooleanExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StarRocksParser) ValueExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *StarRocksParser) PrimaryExpression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 15:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 23)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
